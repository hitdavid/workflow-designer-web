/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 54);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARAAAAAkCAYAAABBlmUaAAAL8klEQVR42u2dC1RVZRbHvxSMp4T4ADX1kqKW2lTq5KzJsKysaTRbyxmZWdNItUYX2ghaVq7BlDHTmkmbXkDMKOrFyEcNmvhABQR5P8wJUx4XeSmJPES4PMT/nH2uB69wH+fcewVufXutva5wzv8+zuH73f+3z/m2jPEwGmvXrkVv6n/un9/e9Tx48ODBgwf/BuMO4qd9/jZs2ABzabMXC2YT3b9wSvWIdq/jlODBw0aRHTEVlFnhjyDjs4eQ/ukv0FN6AgQQAV10f7QZRFazRfft9ClfXPgERqiHX+mTJ6Km9QYuaTt6nP70jWMuuf7O6e3ZgdDAvz2OiJm8+X5Yom9rvy6mXP0tgBhOcXt2hOUQWcCGsFCXL55KmILtjQGYGuvXwd5mc43un5GRgatXr/aKhato7sCbRW1Irb2OngYI39572+3ZeRTGhwj5ooEMwbH3x+HIe76IXz8a34bdi/3rRuCbNd7oDo8oAwmzeiUOpKsTcXrVScUC2DCTH3CJ13SXTcO+X/adPxLaXsHsbx8GW8n+YlITExOD2NhYlJWV2eSkJyQkYOPGjbKeq+RaB0amaDE5Qwt1VbtNXn/fpTYEFrSiqsn48xn4A0cvD7Cf1evbqwOhKYfS2LN6MAoKCnC7PspEdtefPn0ahhxIV1gYciOSzmfzmObBm0bnsee9Rhj4aI5s8dAgn09VzZ9U/R75HYvxzMHpYMvd1pg9KASQK1euIDo6GhqNBtbCw8/PT0w5+5+/el0EyNcX2zA5XYsYKyGyq6JVfD7KC9c4QOwFIPYSVK/QDc4omRmBXW94IDs7G7f0QrR8LC+F5yB9amoq5DoQYwAZ99Gk6kW5T8Az1DeFzWCDOj/UojETBgSP2j077lH8t34ZcjuCMf/wY+i37N4PZR0UAohYj6ipQXh4OGpra2ENPAICAmQD5OxNgOTUtmMfQURwIml1lk1n1DfhEaZpFx81jbIAAgPZub3rY0/rrX3/ffXzG3s/5h7vtAMx95j2yYMm6w+GckeIK7KysnAq0kdRliW9AFxeL+pTUlJkOZCuTkQfIAODRoe9lbsQoWf+BI/XxycKv7rLIWDiU4NC7y9bmjEPKdp3kH79Lfzx+BNwCvKLFV2JEoBQVFdX49133xUdiaXwUASQhlsAya9rx/5q3eDPv6qssLpLDx4SQEobuQPhDsS2kfqvybrBKdtBRGDbX506ASLPvUTg/Illuv3Prhf1hgGizIHcPVc1ftL7j2rT2j7Da0kLbzgvGVcx+f1Hmj67EIRM7WacaFqNl5Oehfvi++PZ+MHusg+KtQ6kKzyUAOTcTQdC8PjmUjumCA4kXaEDoZqHPjwkgJTzKczPBiA9VQOhKyXi4KzbJC+Fff+zbEB3gJiZtmjrN4n7d3wfLOpt4UCE6O+xaHLk2uwg5LVsxetZf8COilU41fAxDtavxtJTv8WQJdPymf+UkYoOnrU1ECqYSnUPKeUWUYsadQDZL8CDpi9fXlReA6GCqVT3kJJ+d6lZEUD4du5AzEbiPyfoBmfFO/JS2DcqyEEECOk7IWIWPGpkbFOhbP+Tot4iB2LgUu6g52bMmf7hYzf217yHkw2f4GD1Ruz98U0EZ86F95KZGuY/Y6zig2LrqzBKoqxJdxVmSroWsRctK6DS1RYqmFLNg6Yt5DwIHnUt100ChN/H0XfuA7EXB0KXWcXBWfiGvBT2jVzSrztAyIWYBI8aZw/5I2+7n6hX7ECyDToQcSYzapF/wls5AYitWo3oqqVYkT0PY4NmXXZ58vFpllWWe/E+kOoW3X0gmfXX+WImHn0+6B4NcfD+b7m8FPaNWHxX51WY2yBiBj71FauFacxwUa/oKky2cQdCMWb2nJAnw+dgy8XfYUX+c5jw2lON986a9YxdnpCGthuobb3B4dHLYe03eFhYGOz5/SvR69/gte9vQ7H7bS98ueoeqFe6i1dMqOhJdQuaetDgT0xMxJkzZ24DCO3bNXeucMP2YJfb9OQ+4uPjkZOTY9CB6E9Xuj0aAciI6fO9HvzzC6ULkx/DI6uebVX9et5LfATw4NGDQUCgaYmc1IeHFAQEmpbISX14SABRkobe/5SnF26Y9NKCtokzF77JzyYPu/oG5++fBw8ePHjw4N9ifefz854gPHjw4MGDOxDuQLj+pxp/Z2ziHl/f7JOBr2Cbp+e3CxjzkLY9zZjrFje3vfGBgfj8gQfOLmdsGicDDx42jJHz10JJUvQV/SYBHl9PfviHuvPn0FFZjKpT6Ygc7J1E4BA2O37o6Xmo+NhxtJcWolZTjIhfPV4aZE8Qoe5kNT10Xwi/m5R3JbNET4OyqOismGVlxUKWoLKyDJcuVaKmphp1dTVoaKhDY2ODOIDp0dZ6ne5WkpaytvaymKQxpN/t53e6/pwAj6j10E4Yio6je1CZlYOPvbyOfeDickCTfBKNSYeRN2wILqxZiR8vlGLzA5OKZR1AuhuV7krtLXhQVzK6K5W6lPUFy8638/UwpgBibvA3NV0TBzBts7VeDjyam5u66VNefhUdF4sFeAxEvQ/D5TGO0MbvRunJVBQdO4aG44eQN9QN6U4MiY790PhdHuJWrDB/HmkdDK2H0V/aryRo8RytyrX0pFA3MlpMR+tiqEuZEi2thaHFc7Qq10qA8BW5vQgQe3Igcga/VtsMaV+lelW0Ci0tWjP6Yty3ww+j1L4Yu9NXfPTdOVZMgocEEH19tI/P4UrBZZDzuDzmblQJENEMd0TdgT24cjxegIcrMlwZkpzvQsXWSFzIycG60aPTTB4QWoFLK3FpRa6lAJFW4VoCEepCRt3IqCsZAYS6lCnR00I6aRUu9QXhALFPgNiTA5EDj9bWFhMAMA0POQAhrWqnSgSHavtNeKhHif8meLS3t3XTr2RscKS3d1Jl3mm0HPwKJQI8znsxFIx2xulRbsh0E+AhuI+yLz5HhTDVWadSZb0ovKTRg0G9P6gHCPUCEQezFQCR+oAogQh1HyPnQd3IqKkQQeCsQoDQKlz9TmRqIxAx0eVKVlcva/UmBliP6Hv781vbdcxWU1JrX58GpRx4GBrAXfUECkPwoDSll6YtkgMhkBBApJ9Ja0w/lzH3jwYOPKI5mYK6uK8EeLghV4BIpidDitcAaLb9G8XZOVgzZEjKDKbX+rBrkOOg7mPUhazTDVgJECUQoa5jYi+Qal03sk6ANCgDSKkeQCSIyHEi3IFwB2KpA5EDD3MAIL0EC0PwMKenegdBQ3Ig0jSGIGJKL0DB+R/OznFFxxNx5cgB5I3yQOY9AjwGMhwf5ARNbAwK0zOwysMjYbwAG5MHw9YORClEqPsYdSGjbmQEERr85xQ6kPJr7QY7kpmriXCA8K5kltZA5MCDwhgAJL0+NLrCw5ReKpjqT10IINIUxpie3Addqi1NTtEVTL1dkSFMW1IGOeCE5wAc7s8QN8ABRTt3oCg3F68L0x1/Ydpzx2sg1nQloy5kNI2hrmQ08KlLmZLXpuZBxrqS8asg/CrMnXAgcuBhCgCmpi1y9NLVFn3nIU1j6HfG9FsGDdlbfPQorp6IR/4wV13Nw5lBszVKcB67EOfogL3CF0mMoyPOqdUoSE5GyPDhx+74VRhrg7qRUVcyGvjUpUyJljqPEUTIidB0hmoiVFg19f/CSH/g/D4O3pXMEgciBx6mAKCvp2KpIXiY0utfqpUKpnL08YEvo034OXewB9LupoJpP5RFRaBEcBvn09JQGKPGLgcHbBMgEtG/P8qF36tDQuQd196+D4S6ktF9INSljPHg0YcdiBx4mAOABA9KS/Tm4GFIHzlxYmFtiQaloSuR5O6Giq0RKC8owDsjR2a+4eV1oigrS3Qe4a6uOBoYiHJhdhI6fXqF3Zwc6k5GXcr4n2nPB+8JIt+BKElDAOgtfQhjU8NnztRcLtWgMT8XF/LyEKZSZVGdw4cxF6p5FKSeQnl2DspLSrBhzpyqhYz589HBg4eNgr7ZyQHQlZCut5Qby76kX8rYLzdPmvRDXHAI1nl7Jz/PWOd/dbmIsXuCPT0PqZcvR+hDD5X+hrFZ/Izz4A7EDt4/Dx48ePxk4//JK0wifr6tzgAAAABJRU5ErkJggg=="

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap) {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
  var base64 = new Buffer(JSON.stringify(sourceMap)).toString('base64');
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

  return '/*# ' + data + ' */';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56).Buffer))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(67);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAdElEQVR42u2WwQqAMAxD9/8/7W5SQyZpu52WBx4U8kirqGMYYwzhCeC1Ha6TmY4DRW8YzzsuNRdnyGaqjk9hCJeG6GRJh0pGd2AolE4P8eNKL0AdQOm+dLDC7FDvBHN1FqAsQe2fWsI1T4DfAf4K+D/AmAuZqsR9n40tCbAAAAAASUVORK5CYII="

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAAAhklEQVR42u2YSw6AIAwFuRP3P5vGnQs/yHtQamYSNyQ0nVDM01IAwEqtdTue1vVlBc7NXq2lkVCaD5V2NR8moTTgOsGQEbrb21xDLRB+iV0CaV+jAADwjzyv5pGwPIPAS+0pAkoDT+LK/k9pdISAI1JPOwHH6HSP7ioC3RHc+UGT7m8EQEJ2pYwVYPqWzYQAAAAASUVORK5CYII="

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAQCAYAAACBSfjBAAABmUlEQVR42mNgGAWjgFbAyVLfbDQUKABetuYfPews1rnp6SkSrcnY2Pg/COOSI8ch+Mykhnpi3EiKmaCU52VttsXH1vxvoIvdf28bs28e1ialFDmeXE/B9JETgJTYR6773e3NirzsLf9E+3mf9ba3/O3naP0/Nyn20NGDe+3IdgC5HkLWR24AUmInqQHoYW9m6Wdv+be9rnrFjx8/vFIjQy7s3rq5+fv373YFaWmS3naWx0BqSApAagXCQOklJQADXeyPpUSGXPn8+bMOiA8MRPcnT54Ig9jbtm1jjwv2OwtSQ3QAkusRbPooDUBK7CY2AANc7b42VhRPwiUPkgOpGQ1AHCDI1eFbXkpCPS55kFygq8OP0SyMAySG+t+KCfA4gEseJAdSM1qJ4AALZ8+sCnaz/+vrYJ2MLgcSA8mB1Iw2Y3CA169fSzZXla8P93L9H+jisCXA0TYThEFskBhIDqRmtCGNB3z9+tVw/cplPSnhQSdD3J1egzCIDRIDyY32z4gAoFQGbMJ4/Pz5MwaEQWyCKW8UjIIBAQD4J7dDvQaolAAAAABJRU5ErkJggg=="

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAuklEQVR42u2VQQ6EIAxFvRJwJ27NyrWzHBaYKDU2KZ0glVk4E/qTvyFFfl8KTpNKpfpFee836iEBoIYFEEI4/BgA51zMFh8+v9IG9cTRWlusQY107CkAyXXgdTVLm4fAbwzeCSFRAFfN87EHIQCqFoCWRAAwcA5fNNABIUmb52NfcwvAN/uL5sHGmMhG+haEDG+VNs/PBmNoaQZeV/Nl6MJLWj/WhM0c3zv3/+0jOPxf4En1Xj2VSnVLOxoBpd2hrKpZAAAAAElFTkSuQmCC"

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAfElEQVR42u1XQQ4AEAzzp/3/bVzFAVvLSNrbwtYS2aoU4WWYWZ3Fx8l7wjHeyfGuQ+SrvVfI4RoM8jHXVQMVsMrfqscWEapz+iauikDeEdyIIHJBkAdgeICUBkRpRF+3YsowioqgjGO2NQvPA6YvTDn5U47YbcnSPiNCBhooZuWBYSK0YAAAAABJRU5ErkJggg=="

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = "data:image/gif;base64,R0lGODlhEAAQAPYAAOfn5xhFjMPL15CiwGWBrkttok5vo3GLs5urxcvR2p2txjRbmDhemT5inENnn0psoW2Isa+7zi5WlXSNtNfa39nc4LXA0YecvFh3p2SArbK9z8HJ1kZpoClTk4mdvaGwyGJ/rHyTt8/U3ISZuyJNkGyGsJanw2qFr6u4zFBwpCBLj6e1ypGkwSpTkxxIjdTX3t3f4nmRtoOZu9/h44GXuqCvx+Pk5eXl5rO+0LvF0+Hi5MXM2KWzytvd4cLJ1tHW3czR2r/I1bnD0rC7zs3T28fO2N3f4snP2XqRtqm3y6i1ylV1p1p4qGB9q2eDrk1vo0hqoLfB0XePtUBkndXZ3zpfmoufvl99qzthmzBXlpmqxFZ1pyZQkoabvGiDrkJlnrrD0r3G1NPX3q26zX6UuI6hv5ipw117qoyfvlRzplJypTJZl56txiROkSBLj6OyyRpGjJWnwzZcmShRkkRnn3aOtTxhmx5JjnKLszFZl1x6qW+Jsn+WuQAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAAACwAAAAAEAAQAAAHjYAAgoOEhYUbIykthoUIHCQqLoI2OjeFCgsdJSsvgjcwPTaDAgYSHoY2FBSWAAMLE4wAPT89ggQMEbEzQD+CBQ0UsQA7RYIGDhWxN0E+ggcPFrEUQjuCCAYXsT5DRIIJEBgfhjsrFkaDERkgJhswMwk4CDzdhBohJwcxNB4sPAmMIlCwkOGhRo5gwhIGAgAh+QQJCgAAACwAAAAAEAAQAAAHjIAAgoOEhYU7A1dYDFtdG4YAPBhVC1ktXCRfJoVKT1NIERRUSl4qXIRHBFCbhTKFCgYjkII3g0hLUbMAOjaCBEw9ukZGgidNxLMUFYIXTkGzOmLLAEkQCLNUQMEAPxdSGoYvAkS9gjkyNEkJOjovRWAb04NBJlYsWh9KQ2FUkFQ5SWqsEJIAhq6DAAIBACH5BAkKAAAALAAAAAAQABAAAAeJgACCg4SFhQkKE2kGXiwChgBDB0sGDw4NDGpshTheZ2hRFRVDUmsMCIMiZE48hmgtUBuCYxBmkAAQbV2CLBM+t0puaoIySDC3VC4tgh40M7eFNRdH0IRgZUO3NjqDFB9mv4U6Pc+DRzUfQVQ3NzAULxU2hUBDKENCQTtAL9yGRgkbcvggEq9atUAAIfkECQoAAAAsAAAAABAAEAAAB4+AAIKDhIWFPygeEE4hbEeGADkXBycZZ1tqTkqFQSNIbBtGPUJdD088g1QmMjiGZl9MO4I5ViiQAEgMA4JKLAm3EWtXgmxmOrcUElWCb2zHkFQdcoIWPGK3Sm1LgkcoPrdOKiOCRmA4IpBwDUGDL2A5IjCCN/QAcYUURQIJIlQ9MzZu6aAgRgwFGAFvKRwUCAAh+QQJCgAAACwAAAAAEAAQAAAHjIAAgoOEhYUUYW9lHiYRP4YACStxZRc0SBMyFoVEPAoWQDMzAgolEBqDRjg8O4ZKIBNAgkBjG5AAZVtsgj44VLdCanWCYUI3txUPS7xBx5AVDgazAjC3Q3ZeghUJv5B1cgOCNmI/1YUeWSkCgzNUFDODKydzCwqFNkYwOoIubnQIt244MzDC1q2DggIBACH5BAkKAAAALAAAAAAQABAAAAeJgACCg4SFhTBAOSgrEUEUhgBUQThjSh8IcQo+hRUbYEdUNjoiGlZWQYM2QD4vhkI0ZWKCPQmtkG9SEYJURDOQAD4HaLuyv0ZeB4IVj8ZNJ4IwRje/QkxkgjYz05BdamyDN9uFJg9OR4YEK1RUYzFTT0qGdnduXC1Zchg8kEEjaQsMzpTZ8avgoEAAIfkECQoAAAAsAAAAABAAEAAAB4iAAIKDhIWFNz0/Oz47IjCGADpURAkCQUI4USKFNhUvFTMANxU7KElAhDA9OoZHH0oVgjczrJBRZkGyNpCCRCw8vIUzHmXBhDM0HoIGLsCQAjEmgjIqXrxaBxGCGw5cF4Y8TnybglprLXhjFBUWVnpeOIUIT3lydg4PantDz2UZDwYOIEhgzFggACH5BAkKAAAALAAAAAAQABAAAAeLgACCg4SFhjc6RhUVRjaGgzYzRhRiREQ9hSaGOhRFOxSDQQ0uj1RBPjOCIypOjwAJFkSCSyQrrhRDOYILXFSuNkpjggwtvo86H7YAZ1korkRaEYJlC3WuESxBggJLWHGGFhcIxgBvUHQyUT1GQWwhFxuFKyBPakxNXgceYY9HCDEZTlxA8cOVwUGBAAA7AAAAAAAAAAAA"

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAAgCAYAAADaInAlAAAXq0lEQVR42r1bCVhV1dremlqZf6lZhtPVssEGFb3WLdPqeiu1HHK6lZXzHJlDpjliDgmiIiKBU4qAgOKAGDKoTDKKzMosHEEmK0VxKHn/9X17r8PmcI4j3fM877PX2Xuds3l4h28N+yjKHV7Z2QUoLCpFclYRcgrLUV5eYRaGskqk5JYgPOo0YuNSodTTK6+gCLm5hUjJLkJBcTkMJRUoKy+vA7pGfVLSs5CVlcdQ6vFlOBSA8gUL8ceYsagaMRLVw4ej+uOPGZf/+xkufjsbF3btRk52fr3e19Kr4FwGykp3/r33OnEyGSlnc3H1aiX++OM33LhehVvV1WZB1+T1yj+r4X0o4oGEQKQT+UQsEXzpj99xufIKLlfdxF+3quse6ZpA2W+V/Jn41BycSkx9YCGUrViFqj59UN2vH6onTgTmzAFsbVUsWsTv6TwJ4tZbvVH12mswjJuAtOi4v40cw/lwVN96UkBBVVVfnD2TW7/3ys4vZtdLUs0RHxweh70HjrE49OeJfL0QPA9G4H5cn2PQES9IlkTfCdTvt8tVLAT6jsjYFBYCCepe/oZiT++6xK9dC7i5Ae7uKqhN50gI06cDo0dzIpAQKtu2Rfzc71D/zs9HZaWCG1UKC4AQF/ccNqw/+uD3OpdvwGkR9SUXLrDjTcmV6Dt8vrjZ24yG7f9rViCXqv5kUDswKh2HQ+/sCBn1hvNFTD45+m5IN4eyK7dYBFQygmMzEBQWf9dpQFF/69VXmUwmlgh2cqoh3lQAlAYkEBMR3OrcGcnimHgqqd6EUFH2mYh+lXigi1EEnwwfguXLDz3YfaiGGwwGFoAkzxRxKRQ3/aG0/VHAHspDE/Gt3WGzfSkBaGxA7fic3+DpG4y7JZ9cbIncmLRSLHONx6x1UVjgFIHtfqfY7ebS4Hz5ZS4Joaey4ecfJOIy+7b/pIqp043ks/OJfCKZBCAhXa+VAEk+99cEQMmBnj1ZBIkCx0KOo37qvsLANSshgKlA9WMsgJNRT6FFy4WICE++v/uQ84n84pLyOuQTkQRqE6HKI+OhdN+KwavEgKebO1z90oz9yq7W9JVJkFt6hY97I7NZBDnZ5+r8kUQ+JRA51tT5l2+qRxLFF9/7QHl+GV4e5olXRu6B0m4ulKe/xBOv2mDZ5mPcV/aXIsgvUcvBwYh0+PgetJgEJUttVfKJPEEkEyuJ1rncOACk8kCgtjhnJF8nABoTVHXsiOBnn0XYicgHEkF5ySQUFSi4VCYEcKudEIC1wLPGcjBgwAhMmLT93u+RdKYQ2Tl5XPf15EviCXReErtyWzTaDPDBJysNmLA6thb5esj+1CYRVNwElmw6gIDAKNS+v4FJ4QGfiG098XpMs/WD0nIyWvXZgLhs4eyLf6HHcGconeZA6fyDEMMMLHeP5L5UAqQQqJ1ZdAnJ+RVw2xuK4KBQFpvpKJ+Ioujm6CcyaXAncG3MGJV0jdTqNm1qgVxO55lwMW6g75DvSVBlgvzz7dph87/eRHxc4n2LoNSggHDjSiMeBJL7Ud0Z1VdVARwPegaPPfE94mLTcU91n2I9N/ecMa4lobKOU5vI0ztb9jFHvuFyDWQfEgDhZGY5bH5wwemkDMjopxE7xz+5/6YJ+TQAFEciu1UvMfZ4eRUnwLd2IdyPXE/EN+i+idOABEF9DZfBkN+XXVHNAqBSsGbjdkHEqVr/pPJerxvdb3SxwCJREpbPmKGS3KqV+J8/hr+aNEFlw4ZG0DkCDfymjB2L9UI81F+CBJBpZYW0li35++5Uhsy6v3giu/+yEIBKvBr9lAQ8I7hakwJTp3vhntyfmpYFGvkTeTK2iXB6L496svUCMJJ+E0bSC36HETmXYBRQSuFlfv/VnM3Y5LaXSwG5n+buPOrX3F+hOVgeCUTqQ12+R4NX1rII3hrjyddd/VM5AVgAIgWe/XAjpwN9Jk/ciyC/J7ngMvaFp2Pr/jD4+vgZS0GhoxOTxI6lwRtN54ST3WbNQkhmJmPztGlGwksVBQYBeaRz2Q0aYO6oUXALCcGWsDDsEanBghEJQe4nAWQ//TTWP9Ec7rs87kkA+fn5kO6vvqQYCY8IbKiKQZQBKYDD+9uj1TNL7z4FjglH0FyfFnlk3JtGuRTCNFsvdHhjJl4ZsALWQ1biyZ42UFoMwU9bQ9UBn0Y+kZx9sdoIOk+fTy6+xSI4cDIPX8yw53UCcqRRACakm2LqqhB0HuaL3jPiMX9zPLvbwSOuRgAiGV4a7MpEE/HkeoIUQVLxnzgYlQnfY8nY7LINMdHxqgC6dmMBUALI2N4h6v6hs2dRLYROOFFQwCLQEy/bRP6szz5j8mV/z4wMHJ89G1XNm6NACIHcf0ogUiTF5E+GI+n03a+RlBm+QXFOjfu9PFvQZzU8AkPhc6ooLqkiePfdTzFz1l2mwJHwBLUEaDVaH+GyLQWwekcMGr1qC+WxReoMoKMDlKY2+MH5BAvAlHhCapkKgyYAKgEhKUV4o78NDwgDo1K4BFCN1pMvI1wPIjM4vRKROVXcpv5jFu3l6H/4zS0sgs8XBxn7ElJLa0RA7bD0UhaA0/a98Bd1/1xYFDuTBaCL7YyvvkJ4Xh6uCH9JUuk9pQIRXqqRnyLaP4wZi93C9bKfRM7IUdxHCoDIJxGMb9P2nlKgNFvcK7vG/UQ6oanSXRyt8cWgrmop0ARwaE9HtGy1DKmpWbgrAUTFpyOruLJO/ZYxrq/nhH986ATlhY08E6Dp4MItsbUEIEnXg66R+4l8Qgfr0bDb6ImAsAREJGayAEyJp9gn4uTRVBAU9W36/sRlgVLh8x+TjOIgsvWgc5QAwUlFXAacdvlhvaMz8hYtRoaIZ4ppGgQSKLapzhcMGoS48+driSC+tBTuCxeyCIj8NWJm4BsfX4f834YM4YQobNYMmYL4+KZNWQCEDeK7Z8ywuatlY3J/UVrt2q86/ylYNXhfHP+NoW+/oq0MioHhRVUo773zGebN97s7AYTGZDA5JAB97aYjEUrtnEswimDQ17vUdQCdACgh9OST2+VRtuPOVyMw8TwLoE3XT/Gj/U5eoKEyQAM0IlUSLl0r26agayvcU6D8Yymsx4djfcA1xJ+vS/ypEjCoTdf1Ali6bCW7lNzJKSAGcZUSjz+uOrx/f6SWl9cSQebFiwheuRL7VqzgVDAln4RD4iCREPnJgnwSQIhoEzwbN8YH73+AyIjoOwvgbDN2//WiRsbl3+ZNm4jPtcdTSl8WgM3IZ9UBoZgRsADEeMBjywto237VnVNALwBJtGmMS2JzuJYC743fYlYA1Ef+w4l02WYCyihCb7IACFIAlAC0UkcC0NdtU0gX68ntMGArmvXeCpdfL9Q6T0TL++rblA7+cYUsgJ+c3TH/h8VI+mcvjmUSAUV12ZNPMsi5Bq2+J779dh0RUFv/3hj7YhYR/9BDLAAiXiJCDBSJ/MOPPAJ/cc36hRdELfe+LTll55ao7s8S5F79P+PI//PBzcTnuqLDIwM5BTzWPWmcEdAC0Z9Fagp06z4eS5fvv70AvI/E8FItrdRZqt8SPKCzIABZ4+kfTU6P0/7x+nZkViUOJxjgc7IQVq+OZAHs+TWOxwFxWRW3JdsUNBagmj9+dYyxvkvCLSEi5zoLYFtAImYvXMUCiG7XngVADiW3EvESMuYJCe+9xyIwJVwviLwBA5hoEoAUAX0vtek8kb9PuJ+OXazaYIvbttsLIK0BC0C6n91NI333BiyANzpNRZ8Xh6AoXnU9i0TMCFCiCmDHpi53TgH3kFRep6dYJgLNES8jnJB/o64AvtscwwLQEx5ZWPd4+HQ5zwCcjpw1JsB2/2gcOJ7I0Uw12hLhtdJEvPc/fRkdB3vCbm8ei0WSHFlQczTFkZSL8InIxlrPcEz5ejbs7R3YlZFajZYikEjRCYAQ1f8DFN+4YZZ8WvPXk68HnQ/SBOAtUoXazzVvAaeNzhaJKc1bwsSSCKrLHlXJLVEFkBRCY4BnMfTdjfiP9WDV/UIcdJ1T4EpLUTsV3BDo0X0MVv10mxSgBPAOjsXByHR2qCTaUoyTAPqOqysAOi+JNoejZ6rY+bQc/ImNM55+aRjsnfYw+bv8I3iZNjLr9zqEm8a5BL0Pya1N/O1AiUH3J/d/5+CFyZOnYY+XD46JwZ9RBESYLrb15BOJfnZ2KLt2zWwCxDg5cR9LoNjfJ8h3b9SIU4AEsH69o0ViSlJasQA4/onQssaAFu1E9IutO2Pa6CBMHNpDdT+RX6SlgBDBzTxVFM5rXsPzr6y0vGVMc3GvExksgsOx+UyinnjpaBnjNA4wJwA6L8kOLVTbwbm3uE3HvbEX+D4bD6ehU58Z6PnvSTwNpBnAJu9QLgUUz1Sn9cTrSZfuJmzYn43pdsd5IEhC0JN9vAAMOi+PPvHl+CX4DNbuS8Dob37E3LnzeEk4zLoHO5NcaRSBgF4AdI1WA2lByFIJyL5yBbttbbmvWfIF6R6aALaL923EOMOSAEpz16nup2gvUt1PbmaCtRT49D8dxGcXwcfxaTUBCjQUN1anhCI1rmer5zq/OAnr1h20nAIbPMPgeTSeQTWayJPkS1KlAGqVgJddoDyzBNMcwrgESPKJcALHfuZf8Ikuwfaj6dgSfBajFnmhabsBmDhTXQii1TiXfVG8Ru8emGAUgSVn09+wxD2JN4CU1v/l4wAbXyPxRLYpVPLPYqNfLOY6H8HHg4fBeZMLPycQI2YBsi5L8mTdluR/N3YsfKKiLJKvnyJuEtNC+T1BGkgAFP1EPMFOtFu3bo3Nm382S0pF6hOq+9PJxS1U90uCi1QBrF3YXnx2OhL9mqgJUKQTAe0UCtzIaMCCkSmQk3POvAhoKXjFruNw9QvHbuFEciuN2M0J4MjZS3im7xooXbegaV9PPrbr58Dn9QKgoyT/5yOpcDp4CnPcTuDxzsPQte9EuGzbb9wVpIc2lrkd5iSQIjB1td7d//zUldf/eV+g0xw8ar0Y3qeu1hJAQNYtBpG/NVjUfe8oLNwRjv4jx3H8Hz8WxuJLXracp2UkAn+NcFnLqf3NqFFmF3loZnBm6FDjGECep3WD9TY2xu+i2Cfydwq4aiKwEejQoQO2bq27c1fL/QVN1PjPVVRoBFMZOOnbDA8rH3E/rv8FSk0/SgHaJKLP56pCeuXV8di48VfLKUBP7tj7RMJ5XwTcDsVzvTx69qpRAKmV4NE+rfwpL7qhzeBQdPkqgUHtht3XY9meLGP07025CffIIo58In/+Lyc5+qn22yxwqvW4GG0I+QZEsAg2eoVwnab7U93Wx7iM9n7T1dW/J97ZibYDfXk6uDe5qhbx+1JuYHe0cGTAWSZ/0dYQDJu6FMOGjYC7u6dxHyBHzMUpllkEgiA9cZacTzMC6keIE3N+in/TxSJKAm+NfA+NfEdNAG8K9Or1Og7sr/sAR0VSG5REK6hMUd3PJSBXqQ3hdnJ3++b91PclSt0++hQQ/Tcss0a3XmsspwCXgh1HsHBrKNwOqCKg2CYSD6VdZUcfSLuObWGX2Nkep8U/OK6KQde8km/B69Q17rP7ZAk2B2Yz8QQbp2A83282Wjz3MUZPWVFnO5hetEPm6uGPBZsPw8EjBC4HYjm2fWIuwD+l0kgsCWBH5B/o8akH3vv2JGz9rmHNoRImn0hn4mMq8HPwOUF+Go/457mGYtiMVRz9VHdTU2pvlPh1fp5FwAM0TQQO8+fDw8wKHxEu+0gcGziwjgjSrl/nhaKdGunO4kgrgA7i2EIIbMSIkXW2hktz7Jh8dn9+MzX+icxMDfokEKQe39GyJvpzdX0ytfRAF8DwKKrT1fMvdZkIZ+dA3HZr2NHVDxNW+RrTYKNfAkc41W8pBhIApQMRL0HEbw9THW+/N56xwjsOo5buRfMXR7DzR05YDm+/ULMPhHApEsT8vMMb39h7cRoQeVS3acePYnxXuIEjndxOILKlMKgEbA8vhrMQ3lq/ZKPrJ9vvw8DPv2bn07SPNoBMnw/0F6Lw1+rzTs213t264URCQi1Syfmm5MvRfUC/frxCqBfL/h49mHhyvp12HKHV/yVLltX5H5RFN8aFKAXXkhoCFa2YPCP5ehFcVIwrfuz+EqW2UCQuW6mrgymqSLav6YLnX1t9+xQgcrZ7BPBu3QT7Qzw2IDEQ6GELIpXIXXsolQmnqPc8VcmOJ7HQNer3hd1Rdn2zTkPQqedoTPtuPQ4GhPODJ7db/KAkoKd2Zi53gY29D5O48hcV9L0rvRN4JE/RToSTCLwSr7Dj6Tz1oc/YOB7GMJs16D/0M3zx1Xhs27aDB32mD4LIl+9znVkArlq9Jvh26WIUADmfzu3TQZIvY/5I//5G8ilVHHTkE2wFmgm83bsP9vvVHpWXZNrj/DEFFScFsdlNBaktjESygyWpguzYPbQU3FKgMV606qheL1Bq9Vc/00gVQH5TFsHVRAVdXxuPNQ4H7rxHcDQ0BvNtf0b/savR54tVGLPEncuDBAtDkL01soJhtz+No/6d8evw0kcL8bDV+7zhM3j0Qt70CYtIuOvdL6rPNEijzZpxM23x1XwnFsMCl0AuEXQkksnpW8LLGNSmqP9y6S9MfL8PPmLXr1yxinf9aMv5dvcM9/JhEqVjXTVQvEcOH87i8JDpYAIP3SAvaswY+L/1lpH0lRrx1H5Dc/+8776v81BIRVwHFJ9QcClWEGdoLhzdxEhkDaGqADpbye1gK94NXPBlJ3UnML0uUCqS5Le2uJGgimTF3NfRtcdqZGeduzMfNDugR7/nLXXh+KangV/oMxnWA+di1gZ/owB2xV3FMo9EWPWawHWeRvnUn1b6AoOi+IGT+3lCmUgjIfyyYxdv3NjMs8WkmQsxbcEaFgK53TnEwAKgZBg5ZQE+/mgQj/KJ+MBfg7je3+3TwDtn2PA4wFETgbPuKMuDOcjkoH4OOscT+Uu0NkX/o48+ig8/7I8jAbXrcFH2AXZ/mRDAX8kPC6KaqeSlKLWPWgkg51MCWLcZhw6PzcTi8V+qJSG9pr8RlAJ/tBfnG7MILokS85TVN3B1Dbh7TohACYrxdwfNRK+hS7gMbDpWzAPARXvOcNRP+taOF3joF0L3Q7w5IZBbiMjok7HsZlrBo/18EsBa/ywWAK0NjBg9ief31I/63+tvAei1fuDHTKiDRqaDTgSuFuBsQr50vSR/tMBDYlpJI39zc//y5LEoDFQFQEQRaWbdrCXAoLee4e3g1o0n4NghIHDbEHUwmGkhBVhQjXE1Ru3z6eDB6P3eT/fPDcV5t39PwSTHY3AMOsczglk70/Fyn0n8qBc9X/h3/CKGxCB/9kX1nOb1K32SsPlEKebsTGYBkEDuh3j9PX4aMpRJ17vZzkQQjrr3dmaIt9UwRCO/62td4bB2HTLP5tT524qjuiDvsIKiINWhV6M1xGjQ2jfipKsV/DitE74fNwr+Ln34HF0z7a8Hfe/vJ9TPr53XE02emIXgoIT752nP3iAmnAZ7OxMq8c3ODDz/r3FwdPH9n/w2jogKCInGdMdAToFZv5xmAdDy7oP+HCxXjJJXTpqC+SIJHHXkWoKtCfF0brb4bHct9sn59nYOOJNhPhFLE6cifZ+CrAMKCyHvkGWc04RChP8lpouXwhROjzt9hvqQAG6JgeDQDz9Bi9YzxazoAbmi+Xz/zxfj212pmO2Tj3+8Pg5rnbzuONKvrxcRvd37CGa4hBsTgOp+ff0wlOJ6fM9/Yq5Gqp0J4aZuJ9Aq3zsCTR9qhLZt22G4GIjSip855+tf58P7sADiPRri1G6l3pHho4rBdsbraNZyDtp3nHZv4wCLPyhJyhCDsk3oPX4TJwIJwNI8/+94yQWkcba76i0BapW7E5FYvGgJBr35FgY1bYovtaVcEsVcjXA6975AR83xtMxLT/wst13Bg9i7vZen1xH0/tfXsO42lrdx6wvW3ceiV48veQr4eKvZaNN+OoaPWI3MzHr6JbNcO/hhxVaeNfwvBSBFQMuqtMpnbqHnQV9UEkKCj/P3TxalgcilWO/WrTvXdjrSezo/ZfJUrvVHj4YgJ+fe/8HR0RnY/PNRhptbUL2DXO+xO9Q4Dfx/KJgtqxjgVL0AAAAASUVORK5CYII="

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(60);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../node_modules/css-loader/index.js!./easyui.css", function() {
			var newContent = require("!!../../../../node_modules/css-loader/index.js!./easyui.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 11 */
/***/ (function(module, exports) {

/**
 * jQuery EasyUI 1.4.1
 * 
 * Copyright (c) 2009-2014 www.jeasyui.com. All rights reserved.
 *
 * Licensed under the GPL license: http://www.gnu.org/licenses/gpl.txt
 * To use it on other terms please contact us at info@jeasyui.com
 *
 */
(function($){
$.parser={auto:true,onComplete:function(_1){
},plugins:["draggable","droppable","resizable","pagination","tooltip","linkbutton","menu","menubutton","splitbutton","progressbar","tree","textbox","filebox","combo","combobox","combotree","combogrid","numberbox","validatebox","searchbox","spinner","numberspinner","timespinner","datetimespinner","calendar","datebox","datetimebox","slider","layout","panel","datagrid","propertygrid","treegrid","tabs","accordion","window","dialog","form"],parse:function(_2){
var aa=[];
for(var i=0;i<$.parser.plugins.length;i++){
var _3=$.parser.plugins[i];
var r=$(".easyui-"+_3,_2);
if(r.length){
if(r[_3]){
r[_3]();
}else{
aa.push({name:_3,jq:r});
}
}
}
if(aa.length&&window.easyloader){
var _4=[];
for(var i=0;i<aa.length;i++){
_4.push(aa[i].name);
}
easyloader.load(_4,function(){
for(var i=0;i<aa.length;i++){
var _5=aa[i].name;
var jq=aa[i].jq;
jq[_5]();
}
$.parser.onComplete.call($.parser,_2);
});
}else{
$.parser.onComplete.call($.parser,_2);
}
},parseValue:function(_6,_7,_8,_9){
_9=_9||0;
var v=$.trim(String(_7||""));
var _a=v.substr(v.length-1,1);
if(_a=="%"){
v=parseInt(v.substr(0,v.length-1));
if(_6.toLowerCase().indexOf("width")>=0){
v=Math.floor((_8.width()-_9)*v/100);
}else{
v=Math.floor((_8.height()-_9)*v/100);
}
}else{
v=parseInt(v)||undefined;
}
return v;
},parseOptions:function(_b,_c){
var t=$(_b);
var _d={};
var s=$.trim(t.attr("data-options"));
if(s){
if(s.substring(0,1)!="{"){
s="{"+s+"}";
}
_d=(new Function("return "+s))();
}
$.map(["width","height","left","top","minWidth","maxWidth","minHeight","maxHeight"],function(p){
var pv=$.trim(_b.style[p]||"");
if(pv){
if(pv.indexOf("%")==-1){
pv=parseInt(pv)||undefined;
}
_d[p]=pv;
}
});
if(_c){
var _e={};
for(var i=0;i<_c.length;i++){
var pp=_c[i];
if(typeof pp=="string"){
_e[pp]=t.attr(pp);
}else{
for(var _f in pp){
var _10=pp[_f];
if(_10=="boolean"){
_e[_f]=t.attr(_f)?(t.attr(_f)=="true"):undefined;
}else{
if(_10=="number"){
_e[_f]=t.attr(_f)=="0"?0:parseFloat(t.attr(_f))||undefined;
}
}
}
}
}
$.extend(_d,_e);
}
return _d;
}};
$(function(){
var d=$("<div style=\"position:absolute;top:-1000px;width:100px;height:100px;padding:5px\"></div>").appendTo("body");
$._boxModel=d.outerWidth()!=100;
d.remove();
if(!window.easyloader&&$.parser.auto){
$.parser.parse();
}
});
$.fn._outerWidth=function(_11){
if(_11==undefined){
if(this[0]==window){
return this.width()||document.body.clientWidth;
}
return this.outerWidth()||0;
}
return this._size("width",_11);
};
$.fn._outerHeight=function(_12){
if(_12==undefined){
if(this[0]==window){
return this.height()||document.body.clientHeight;
}
return this.outerHeight()||0;
}
return this._size("height",_12);
};
$.fn._scrollLeft=function(_13){
if(_13==undefined){
return this.scrollLeft();
}else{
return this.each(function(){
$(this).scrollLeft(_13);
});
}
};
$.fn._propAttr=$.fn.prop||$.fn.attr;
$.fn._size=function(_14,_15){
if(typeof _14=="string"){
if(_14=="clear"){
return this.each(function(){
$(this).css({width:"",minWidth:"",maxWidth:"",height:"",minHeight:"",maxHeight:""});
});
}else{
if(_14=="fit"){
return this.each(function(){
_16(this,this.tagName=="BODY"?$("body"):$(this).parent(),true);
});
}else{
if(_14=="unfit"){
return this.each(function(){
_16(this,$(this).parent(),false);
});
}else{
if(_15==undefined){
return _17(this[0],_14);
}else{
return this.each(function(){
_17(this,_14,_15);
});
}
}
}
}
}else{
return this.each(function(){
_15=_15||$(this).parent();
$.extend(_14,_16(this,_15,_14.fit)||{});
var r1=_18(this,"width",_15,_14);
var r2=_18(this,"height",_15,_14);
if(r1||r2){
$(this).addClass("easyui-fluid");
}else{
$(this).removeClass("easyui-fluid");
}
});
}
function _16(_19,_1a,fit){
if(!_1a.length){
return false;
}
var t=$(_19)[0];
var p=_1a[0];
var _1b=p.fcount||0;
if(fit){
if(!t.fitted){
t.fitted=true;
p.fcount=_1b+1;
$(p).addClass("panel-noscroll");
if(p.tagName=="BODY"){
$("html").addClass("panel-fit");
}
}
return {width:($(p).width()||1),height:($(p).height()||1)};
}else{
if(t.fitted){
t.fitted=false;
p.fcount=_1b-1;
if(p.fcount==0){
$(p).removeClass("panel-noscroll");
if(p.tagName=="BODY"){
$("html").removeClass("panel-fit");
}
}
}
return false;
}
};
function _18(_1c,_1d,_1e,_1f){
var t=$(_1c);
var p=_1d;
var p1=p.substr(0,1).toUpperCase()+p.substr(1);
var min=$.parser.parseValue("min"+p1,_1f["min"+p1],_1e);
var max=$.parser.parseValue("max"+p1,_1f["max"+p1],_1e);
var val=$.parser.parseValue(p,_1f[p],_1e);
var _20=(String(_1f[p]||"").indexOf("%")>=0?true:false);
if(!isNaN(val)){
var v=Math.min(Math.max(val,min||0),max||99999);
if(!_20){
_1f[p]=v;
}
t._size("min"+p1,"");
t._size("max"+p1,"");
t._size(p,v);
}else{
t._size(p,"");
t._size("min"+p1,min);
t._size("max"+p1,max);
}
return _20||_1f.fit;
};
function _17(_21,_22,_23){
var t=$(_21);
if(_23==undefined){
_23=parseInt(_21.style[_22]);
if(isNaN(_23)){
return undefined;
}
if($._boxModel){
_23+=_24();
}
return _23;
}else{
if(_23===""){
t.css(_22,"");
}else{
if($._boxModel){
_23-=_24();
if(_23<0){
_23=0;
}
}
t.css(_22,_23+"px");
}
}
function _24(){
if(_22.toLowerCase().indexOf("width")>=0){
return t.outerWidth()-t.width();
}else{
return t.outerHeight()-t.height();
}
};
};
};
})(jQuery);
(function($){
var _25=null;
var _26=null;
var _27=false;
function _28(e){
if(e.touches.length!=1){
return;
}
if(!_27){
_27=true;
dblClickTimer=setTimeout(function(){
_27=false;
},500);
}else{
clearTimeout(dblClickTimer);
_27=false;
_29(e,"dblclick");
}
_25=setTimeout(function(){
_29(e,"contextmenu",3);
},1000);
_29(e,"mousedown");
if($.fn.draggable.isDragging||$.fn.resizable.isResizing){
e.preventDefault();
}
};
function _2a(e){
if(e.touches.length!=1){
return;
}
if(_25){
clearTimeout(_25);
}
_29(e,"mousemove");
if($.fn.draggable.isDragging||$.fn.resizable.isResizing){
e.preventDefault();
}
};
function _2b(e){
if(_25){
clearTimeout(_25);
}
_29(e,"mouseup");
if($.fn.draggable.isDragging||$.fn.resizable.isResizing){
e.preventDefault();
}
};
function _29(e,_2c,_2d){
var _2e=new $.Event(_2c);
_2e.pageX=e.changedTouches[0].pageX;
_2e.pageY=e.changedTouches[0].pageY;
_2e.which=_2d||1;
$(e.target).trigger(_2e);
};
if(document.addEventListener){
document.addEventListener("touchstart",_28,true);
document.addEventListener("touchmove",_2a,true);
document.addEventListener("touchend",_2b,true);
}
})(jQuery);
(function($){
function _2f(e){
var _30=$.data(e.data.target,"draggable");
var _31=_30.options;
var _32=_30.proxy;
var _33=e.data;
var _34=_33.startLeft+e.pageX-_33.startX;
var top=_33.startTop+e.pageY-_33.startY;
if(_32){
if(_32.parent()[0]==document.body){
if(_31.deltaX!=null&&_31.deltaX!=undefined){
_34=e.pageX+_31.deltaX;
}else{
_34=e.pageX-e.data.offsetWidth;
}
if(_31.deltaY!=null&&_31.deltaY!=undefined){
top=e.pageY+_31.deltaY;
}else{
top=e.pageY-e.data.offsetHeight;
}
}else{
if(_31.deltaX!=null&&_31.deltaX!=undefined){
_34+=e.data.offsetWidth+_31.deltaX;
}
if(_31.deltaY!=null&&_31.deltaY!=undefined){
top+=e.data.offsetHeight+_31.deltaY;
}
}
}
if(e.data.parent!=document.body){
_34+=$(e.data.parent).scrollLeft();
top+=$(e.data.parent).scrollTop();
}
if(_31.axis=="h"){
_33.left=_34;
}else{
if(_31.axis=="v"){
_33.top=top;
}else{
_33.left=_34;
_33.top=top;
}
}
};
function _35(e){
var _36=$.data(e.data.target,"draggable");
var _37=_36.options;
var _38=_36.proxy;
if(!_38){
_38=$(e.data.target);
}
_38.css({left:e.data.left,top:e.data.top});
$("body").css("cursor",_37.cursor);
};
function _39(e){
$.fn.draggable.isDragging=true;
var _3a=$.data(e.data.target,"draggable");
var _3b=_3a.options;
var _3c=$(".droppable").filter(function(){
return e.data.target!=this;
}).filter(function(){
var _3d=$.data(this,"droppable").options.accept;
if(_3d){
return $(_3d).filter(function(){
return this==e.data.target;
}).length>0;
}else{
return true;
}
});
_3a.droppables=_3c;
var _3e=_3a.proxy;
if(!_3e){
if(_3b.proxy){
if(_3b.proxy=="clone"){
_3e=$(e.data.target).clone().insertAfter(e.data.target);
}else{
_3e=_3b.proxy.call(e.data.target,e.data.target);
}
_3a.proxy=_3e;
}else{
_3e=$(e.data.target);
}
}
_3e.css("position","absolute");
_2f(e);
_35(e);
_3b.onStartDrag.call(e.data.target,e);
return false;
};
function _3f(e){
var _40=$.data(e.data.target,"draggable");
_2f(e);
if(_40.options.onDrag.call(e.data.target,e)!=false){
_35(e);
}
var _41=e.data.target;
_40.droppables.each(function(){
var _42=$(this);
if(_42.droppable("options").disabled){
return;
}
var p2=_42.offset();
if(e.pageX>p2.left&&e.pageX<p2.left+_42.outerWidth()&&e.pageY>p2.top&&e.pageY<p2.top+_42.outerHeight()){
if(!this.entered){
$(this).trigger("_dragenter",[_41]);
this.entered=true;
}
$(this).trigger("_dragover",[_41]);
}else{
if(this.entered){
$(this).trigger("_dragleave",[_41]);
this.entered=false;
}
}
});
return false;
};
function _43(e){
$.fn.draggable.isDragging=false;
_3f(e);
var _44=$.data(e.data.target,"draggable");
var _45=_44.proxy;
var _46=_44.options;
if(_46.revert){
if(_47()==true){
$(e.data.target).css({position:e.data.startPosition,left:e.data.startLeft,top:e.data.startTop});
}else{
if(_45){
var _48,top;
if(_45.parent()[0]==document.body){
_48=e.data.startX-e.data.offsetWidth;
top=e.data.startY-e.data.offsetHeight;
}else{
_48=e.data.startLeft;
top=e.data.startTop;
}
_45.animate({left:_48,top:top},function(){
_49();
});
}else{
$(e.data.target).animate({left:e.data.startLeft,top:e.data.startTop},function(){
$(e.data.target).css("position",e.data.startPosition);
});
}
}
}else{
$(e.data.target).css({position:"absolute",left:e.data.left,top:e.data.top});
_47();
}
_46.onStopDrag.call(e.data.target,e);
$(document).unbind(".draggable");
setTimeout(function(){
$("body").css("cursor","");
},100);
function _49(){
if(_45){
_45.remove();
}
_44.proxy=null;
};
function _47(){
var _4a=false;
_44.droppables.each(function(){
var _4b=$(this);
if(_4b.droppable("options").disabled){
return;
}
var p2=_4b.offset();
if(e.pageX>p2.left&&e.pageX<p2.left+_4b.outerWidth()&&e.pageY>p2.top&&e.pageY<p2.top+_4b.outerHeight()){
if(_46.revert){
$(e.data.target).css({position:e.data.startPosition,left:e.data.startLeft,top:e.data.startTop});
}
$(this).trigger("_drop",[e.data.target]);
_49();
_4a=true;
this.entered=false;
return false;
}
});
if(!_4a&&!_46.revert){
_49();
}
return _4a;
};
return false;
};
$.fn.draggable=function(_4c,_4d){
if(typeof _4c=="string"){
return $.fn.draggable.methods[_4c](this,_4d);
}
return this.each(function(){
var _4e;
var _4f=$.data(this,"draggable");
if(_4f){
_4f.handle.unbind(".draggable");
_4e=$.extend(_4f.options,_4c);
}else{
_4e=$.extend({},$.fn.draggable.defaults,$.fn.draggable.parseOptions(this),_4c||{});
}
var _50=_4e.handle?(typeof _4e.handle=="string"?$(_4e.handle,this):_4e.handle):$(this);
$.data(this,"draggable",{options:_4e,handle:_50});
if(_4e.disabled){
$(this).css("cursor","");
return;
}
_50.unbind(".draggable").bind("mousemove.draggable",{target:this},function(e){
if($.fn.draggable.isDragging){
return;
}
var _51=$.data(e.data.target,"draggable").options;
if(_52(e)){
$(this).css("cursor",_51.cursor);
}else{
$(this).css("cursor","");
}
}).bind("mouseleave.draggable",{target:this},function(e){
$(this).css("cursor","");
}).bind("mousedown.draggable",{target:this},function(e){
if(_52(e)==false){
return;
}
$(this).css("cursor","");
var _53=$(e.data.target).position();
var _54=$(e.data.target).offset();
var _55={startPosition:$(e.data.target).css("position"),startLeft:_53.left,startTop:_53.top,left:_53.left,top:_53.top,startX:e.pageX,startY:e.pageY,offsetWidth:(e.pageX-_54.left),offsetHeight:(e.pageY-_54.top),target:e.data.target,parent:$(e.data.target).parent()[0]};
$.extend(e.data,_55);
var _56=$.data(e.data.target,"draggable").options;
if(_56.onBeforeDrag.call(e.data.target,e)==false){
return;
}
$(document).bind("mousedown.draggable",e.data,_39);
$(document).bind("mousemove.draggable",e.data,_3f);
$(document).bind("mouseup.draggable",e.data,_43);
});
function _52(e){
var _57=$.data(e.data.target,"draggable");
var _58=_57.handle;
var _59=$(_58).offset();
var _5a=$(_58).outerWidth();
var _5b=$(_58).outerHeight();
var t=e.pageY-_59.top;
var r=_59.left+_5a-e.pageX;
var b=_59.top+_5b-e.pageY;
var l=e.pageX-_59.left;
return Math.min(t,r,b,l)>_57.options.edge;
};
});
};
$.fn.draggable.methods={options:function(jq){
return $.data(jq[0],"draggable").options;
},proxy:function(jq){
return $.data(jq[0],"draggable").proxy;
},enable:function(jq){
return jq.each(function(){
$(this).draggable({disabled:false});
});
},disable:function(jq){
return jq.each(function(){
$(this).draggable({disabled:true});
});
}};
$.fn.draggable.parseOptions=function(_5c){
var t=$(_5c);
return $.extend({},$.parser.parseOptions(_5c,["cursor","handle","axis",{"revert":"boolean","deltaX":"number","deltaY":"number","edge":"number"}]),{disabled:(t.attr("disabled")?true:undefined)});
};
$.fn.draggable.defaults={proxy:null,revert:false,cursor:"move",deltaX:null,deltaY:null,handle:null,disabled:false,edge:0,axis:null,onBeforeDrag:function(e){
},onStartDrag:function(e){
},onDrag:function(e){
},onStopDrag:function(e){
}};
$.fn.draggable.isDragging=false;
})(jQuery);
(function($){
function _5d(_5e){
$(_5e).addClass("droppable");
$(_5e).bind("_dragenter",function(e,_5f){
$.data(_5e,"droppable").options.onDragEnter.apply(_5e,[e,_5f]);
});
$(_5e).bind("_dragleave",function(e,_60){
$.data(_5e,"droppable").options.onDragLeave.apply(_5e,[e,_60]);
});
$(_5e).bind("_dragover",function(e,_61){
$.data(_5e,"droppable").options.onDragOver.apply(_5e,[e,_61]);
});
$(_5e).bind("_drop",function(e,_62){
$.data(_5e,"droppable").options.onDrop.apply(_5e,[e,_62]);
});
};
$.fn.droppable=function(_63,_64){
if(typeof _63=="string"){
return $.fn.droppable.methods[_63](this,_64);
}
_63=_63||{};
return this.each(function(){
var _65=$.data(this,"droppable");
if(_65){
$.extend(_65.options,_63);
}else{
_5d(this);
$.data(this,"droppable",{options:$.extend({},$.fn.droppable.defaults,$.fn.droppable.parseOptions(this),_63)});
}
});
};
$.fn.droppable.methods={options:function(jq){
return $.data(jq[0],"droppable").options;
},enable:function(jq){
return jq.each(function(){
$(this).droppable({disabled:false});
});
},disable:function(jq){
return jq.each(function(){
$(this).droppable({disabled:true});
});
}};
$.fn.droppable.parseOptions=function(_66){
var t=$(_66);
return $.extend({},$.parser.parseOptions(_66,["accept"]),{disabled:(t.attr("disabled")?true:undefined)});
};
$.fn.droppable.defaults={accept:null,disabled:false,onDragEnter:function(e,_67){
},onDragOver:function(e,_68){
},onDragLeave:function(e,_69){
},onDrop:function(e,_6a){
}};
})(jQuery);
(function($){
$.fn.resizable=function(_6b,_6c){
if(typeof _6b=="string"){
return $.fn.resizable.methods[_6b](this,_6c);
}
function _6d(e){
var _6e=e.data;
var _6f=$.data(_6e.target,"resizable").options;
if(_6e.dir.indexOf("e")!=-1){
var _70=_6e.startWidth+e.pageX-_6e.startX;
_70=Math.min(Math.max(_70,_6f.minWidth),_6f.maxWidth);
_6e.width=_70;
}
if(_6e.dir.indexOf("s")!=-1){
var _71=_6e.startHeight+e.pageY-_6e.startY;
_71=Math.min(Math.max(_71,_6f.minHeight),_6f.maxHeight);
_6e.height=_71;
}
if(_6e.dir.indexOf("w")!=-1){
var _70=_6e.startWidth-e.pageX+_6e.startX;
_70=Math.min(Math.max(_70,_6f.minWidth),_6f.maxWidth);
_6e.width=_70;
_6e.left=_6e.startLeft+_6e.startWidth-_6e.width;
}
if(_6e.dir.indexOf("n")!=-1){
var _71=_6e.startHeight-e.pageY+_6e.startY;
_71=Math.min(Math.max(_71,_6f.minHeight),_6f.maxHeight);
_6e.height=_71;
_6e.top=_6e.startTop+_6e.startHeight-_6e.height;
}
};
function _72(e){
var _73=e.data;
var t=$(_73.target);
t.css({left:_73.left,top:_73.top});
if(t.outerWidth()!=_73.width){
t._outerWidth(_73.width);
}
if(t.outerHeight()!=_73.height){
t._outerHeight(_73.height);
}
};
function _74(e){
$.fn.resizable.isResizing=true;
$.data(e.data.target,"resizable").options.onStartResize.call(e.data.target,e);
return false;
};
function _75(e){
_6d(e);
if($.data(e.data.target,"resizable").options.onResize.call(e.data.target,e)!=false){
_72(e);
}
return false;
};
function _76(e){
$.fn.resizable.isResizing=false;
_6d(e,true);
_72(e);
$.data(e.data.target,"resizable").options.onStopResize.call(e.data.target,e);
$(document).unbind(".resizable");
$("body").css("cursor","");
return false;
};
return this.each(function(){
var _77=null;
var _78=$.data(this,"resizable");
if(_78){
$(this).unbind(".resizable");
_77=$.extend(_78.options,_6b||{});
}else{
_77=$.extend({},$.fn.resizable.defaults,$.fn.resizable.parseOptions(this),_6b||{});
$.data(this,"resizable",{options:_77});
}
if(_77.disabled==true){
return;
}
$(this).bind("mousemove.resizable",{target:this},function(e){
if($.fn.resizable.isResizing){
return;
}
var dir=_79(e);
if(dir==""){
$(e.data.target).css("cursor","");
}else{
$(e.data.target).css("cursor",dir+"-resize");
}
}).bind("mouseleave.resizable",{target:this},function(e){
$(e.data.target).css("cursor","");
}).bind("mousedown.resizable",{target:this},function(e){
var dir=_79(e);
if(dir==""){
return;
}
function _7a(css){
var val=parseInt($(e.data.target).css(css));
if(isNaN(val)){
return 0;
}else{
return val;
}
};
var _7b={target:e.data.target,dir:dir,startLeft:_7a("left"),startTop:_7a("top"),left:_7a("left"),top:_7a("top"),startX:e.pageX,startY:e.pageY,startWidth:$(e.data.target).outerWidth(),startHeight:$(e.data.target).outerHeight(),width:$(e.data.target).outerWidth(),height:$(e.data.target).outerHeight(),deltaWidth:$(e.data.target).outerWidth()-$(e.data.target).width(),deltaHeight:$(e.data.target).outerHeight()-$(e.data.target).height()};
$(document).bind("mousedown.resizable",_7b,_74);
$(document).bind("mousemove.resizable",_7b,_75);
$(document).bind("mouseup.resizable",_7b,_76);
$("body").css("cursor",dir+"-resize");
});
function _79(e){
var tt=$(e.data.target);
var dir="";
var _7c=tt.offset();
var _7d=tt.outerWidth();
var _7e=tt.outerHeight();
var _7f=_77.edge;
if(e.pageY>_7c.top&&e.pageY<_7c.top+_7f){
dir+="n";
}else{
if(e.pageY<_7c.top+_7e&&e.pageY>_7c.top+_7e-_7f){
dir+="s";
}
}
if(e.pageX>_7c.left&&e.pageX<_7c.left+_7f){
dir+="w";
}else{
if(e.pageX<_7c.left+_7d&&e.pageX>_7c.left+_7d-_7f){
dir+="e";
}
}
var _80=_77.handles.split(",");
for(var i=0;i<_80.length;i++){
var _81=_80[i].replace(/(^\s*)|(\s*$)/g,"");
if(_81=="all"||_81==dir){
return dir;
}
}
return "";
};
});
};
$.fn.resizable.methods={options:function(jq){
return $.data(jq[0],"resizable").options;
},enable:function(jq){
return jq.each(function(){
$(this).resizable({disabled:false});
});
},disable:function(jq){
return jq.each(function(){
$(this).resizable({disabled:true});
});
}};
$.fn.resizable.parseOptions=function(_82){
var t=$(_82);
return $.extend({},$.parser.parseOptions(_82,["handles",{minWidth:"number",minHeight:"number",maxWidth:"number",maxHeight:"number",edge:"number"}]),{disabled:(t.attr("disabled")?true:undefined)});
};
$.fn.resizable.defaults={disabled:false,handles:"n, e, s, w, ne, se, sw, nw, all",minWidth:10,minHeight:10,maxWidth:10000,maxHeight:10000,edge:5,onStartResize:function(e){
},onResize:function(e){
},onStopResize:function(e){
}};
$.fn.resizable.isResizing=false;
})(jQuery);
(function($){
function _83(_84,_85){
var _86=$.data(_84,"linkbutton").options;
if(_85){
$.extend(_86,_85);
}
if(_86.width||_86.height||_86.fit){
var btn=$(_84);
var _87=btn.parent();
var _88=btn.is(":visible");
if(!_88){
var _89=$("<div style=\"display:none\"></div>").insertBefore(_84);
var _8a={position:btn.css("position"),display:btn.css("display"),left:btn.css("left")};
btn.appendTo("body");
btn.css({position:"absolute",display:"inline-block",left:-20000});
}
btn._size(_86,_87);
var _8b=btn.find(".l-btn-left");
_8b.css("margin-top",0);
_8b.css("margin-top",parseInt((btn.height()-_8b.height())/2)+"px");
if(!_88){
btn.insertAfter(_89);
btn.css(_8a);
_89.remove();
}
}
};
function _8c(_8d){
var _8e=$.data(_8d,"linkbutton").options;
var t=$(_8d).empty();
t.addClass("l-btn").removeClass("l-btn-plain l-btn-selected l-btn-plain-selected");
t.removeClass("l-btn-small l-btn-medium l-btn-large").addClass("l-btn-"+_8e.size);
if(_8e.plain){
t.addClass("l-btn-plain");
}
if(_8e.selected){
t.addClass(_8e.plain?"l-btn-selected l-btn-plain-selected":"l-btn-selected");
}
t.attr("group",_8e.group||"");
t.attr("id",_8e.id||"");
var _8f=$("<span class=\"l-btn-left\"></span>").appendTo(t);
if(_8e.text){
$("<span class=\"l-btn-text\"></span>").html(_8e.text).appendTo(_8f);
}else{
$("<span class=\"l-btn-text l-btn-empty\">&nbsp;</span>").appendTo(_8f);
}
if(_8e.iconCls){
$("<span class=\"l-btn-icon\">&nbsp;</span>").addClass(_8e.iconCls).appendTo(_8f);
_8f.addClass("l-btn-icon-"+_8e.iconAlign);
}
t.unbind(".linkbutton").bind("focus.linkbutton",function(){
if(!_8e.disabled){
$(this).addClass("l-btn-focus");
}
}).bind("blur.linkbutton",function(){
$(this).removeClass("l-btn-focus");
}).bind("click.linkbutton",function(){
if(!_8e.disabled){
if(_8e.toggle){
if(_8e.selected){
$(this).linkbutton("unselect");
}else{
$(this).linkbutton("select");
}
}
_8e.onClick.call(this);
}
});
_90(_8d,_8e.selected);
_91(_8d,_8e.disabled);
};
function _90(_92,_93){
var _94=$.data(_92,"linkbutton").options;
if(_93){
if(_94.group){
$("a.l-btn[group=\""+_94.group+"\"]").each(function(){
var o=$(this).linkbutton("options");
if(o.toggle){
$(this).removeClass("l-btn-selected l-btn-plain-selected");
o.selected=false;
}
});
}
$(_92).addClass(_94.plain?"l-btn-selected l-btn-plain-selected":"l-btn-selected");
_94.selected=true;
}else{
if(!_94.group){
$(_92).removeClass("l-btn-selected l-btn-plain-selected");
_94.selected=false;
}
}
};
function _91(_95,_96){
var _97=$.data(_95,"linkbutton");
var _98=_97.options;
$(_95).removeClass("l-btn-disabled l-btn-plain-disabled");
if(_96){
_98.disabled=true;
var _99=$(_95).attr("href");
if(_99){
_97.href=_99;
$(_95).attr("href","javascript:void(0)");
}
if(_95.onclick){
_97.onclick=_95.onclick;
_95.onclick=null;
}
_98.plain?$(_95).addClass("l-btn-disabled l-btn-plain-disabled"):$(_95).addClass("l-btn-disabled");
}else{
_98.disabled=false;
if(_97.href){
$(_95).attr("href",_97.href);
}
if(_97.onclick){
_95.onclick=_97.onclick;
}
}
};
$.fn.linkbutton=function(_9a,_9b){
if(typeof _9a=="string"){
return $.fn.linkbutton.methods[_9a](this,_9b);
}
_9a=_9a||{};
return this.each(function(){
var _9c=$.data(this,"linkbutton");
if(_9c){
$.extend(_9c.options,_9a);
}else{
$.data(this,"linkbutton",{options:$.extend({},$.fn.linkbutton.defaults,$.fn.linkbutton.parseOptions(this),_9a)});
$(this).removeAttr("disabled");
$(this).bind("_resize",function(e,_9d){
if($(this).hasClass("easyui-fluid")||_9d){
_83(this);
}
return false;
});
}
_8c(this);
_83(this);
});
};
$.fn.linkbutton.methods={options:function(jq){
return $.data(jq[0],"linkbutton").options;
},resize:function(jq,_9e){
return jq.each(function(){
_83(this,_9e);
});
},enable:function(jq){
return jq.each(function(){
_91(this,false);
});
},disable:function(jq){
return jq.each(function(){
_91(this,true);
});
},select:function(jq){
return jq.each(function(){
_90(this,true);
});
},unselect:function(jq){
return jq.each(function(){
_90(this,false);
});
}};
$.fn.linkbutton.parseOptions=function(_9f){
var t=$(_9f);
return $.extend({},$.parser.parseOptions(_9f,["id","iconCls","iconAlign","group","size",{plain:"boolean",toggle:"boolean",selected:"boolean"}]),{disabled:(t.attr("disabled")?true:undefined),text:$.trim(t.html()),iconCls:(t.attr("icon")||t.attr("iconCls"))});
};
$.fn.linkbutton.defaults={id:null,disabled:false,toggle:false,selected:false,group:null,plain:false,text:"",iconCls:null,iconAlign:"left",size:"small",onClick:function(){
}};
})(jQuery);
(function($){
function _a0(_a1){
var _a2=$.data(_a1,"pagination");
var _a3=_a2.options;
var bb=_a2.bb={};
var _a4=$(_a1).addClass("pagination").html("<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tr></tr></table>");
var tr=_a4.find("tr");
var aa=$.extend([],_a3.layout);
if(!_a3.showPageList){
_a5(aa,"list");
}
if(!_a3.showRefresh){
_a5(aa,"refresh");
}
if(aa[0]=="sep"){
aa.shift();
}
if(aa[aa.length-1]=="sep"){
aa.pop();
}
for(var _a6=0;_a6<aa.length;_a6++){
var _a7=aa[_a6];
if(_a7=="list"){
var ps=$("<select class=\"pagination-page-list\"></select>");
ps.bind("change",function(){
_a3.pageSize=parseInt($(this).val());
_a3.onChangePageSize.call(_a1,_a3.pageSize);
_ad(_a1,_a3.pageNumber);
});
for(var i=0;i<_a3.pageList.length;i++){
$("<option></option>").text(_a3.pageList[i]).appendTo(ps);
}
$("<td></td>").append(ps).appendTo(tr);
}else{
if(_a7=="sep"){
$("<td><div class=\"pagination-btn-separator\"></div></td>").appendTo(tr);
}else{
if(_a7=="first"){
bb.first=_a8("first");
}else{
if(_a7=="prev"){
bb.prev=_a8("prev");
}else{
if(_a7=="next"){
bb.next=_a8("next");
}else{
if(_a7=="last"){
bb.last=_a8("last");
}else{
if(_a7=="manual"){
$("<span style=\"padding-left:6px;\"></span>").html(_a3.beforePageText).appendTo(tr).wrap("<td></td>");
bb.num=$("<input class=\"pagination-num\" type=\"text\" value=\"1\" size=\"2\">").appendTo(tr).wrap("<td></td>");
bb.num.unbind(".pagination").bind("keydown.pagination",function(e){
if(e.keyCode==13){
var _a9=parseInt($(this).val())||1;
_ad(_a1,_a9);
return false;
}
});
bb.after=$("<span style=\"padding-right:6px;\"></span>").appendTo(tr).wrap("<td></td>");
}else{
if(_a7=="refresh"){
bb.refresh=_a8("refresh");
}else{
if(_a7=="links"){
$("<td class=\"pagination-links\"></td>").appendTo(tr);
}
}
}
}
}
}
}
}
}
}
if(_a3.buttons){
$("<td><div class=\"pagination-btn-separator\"></div></td>").appendTo(tr);
if($.isArray(_a3.buttons)){
for(var i=0;i<_a3.buttons.length;i++){
var btn=_a3.buttons[i];
if(btn=="-"){
$("<td><div class=\"pagination-btn-separator\"></div></td>").appendTo(tr);
}else{
var td=$("<td></td>").appendTo(tr);
var a=$("<a href=\"javascript:void(0)\"></a>").appendTo(td);
a[0].onclick=eval(btn.handler||function(){
});
a.linkbutton($.extend({},btn,{plain:true}));
}
}
}else{
var td=$("<td></td>").appendTo(tr);
$(_a3.buttons).appendTo(td).show();
}
}
$("<div class=\"pagination-info\"></div>").appendTo(_a4);
$("<div style=\"clear:both;\"></div>").appendTo(_a4);
function _a8(_aa){
var btn=_a3.nav[_aa];
var a=$("<a href=\"javascript:void(0)\"></a>").appendTo(tr);
a.wrap("<td></td>");
a.linkbutton({iconCls:btn.iconCls,plain:true}).unbind(".pagination").bind("click.pagination",function(){
btn.handler.call(_a1);
});
return a;
};
function _a5(aa,_ab){
var _ac=$.inArray(_ab,aa);
if(_ac>=0){
aa.splice(_ac,1);
}
return aa;
};
};
function _ad(_ae,_af){
var _b0=$.data(_ae,"pagination").options;
_b1(_ae,{pageNumber:_af});
_b0.onSelectPage.call(_ae,_b0.pageNumber,_b0.pageSize);
};
function _b1(_b2,_b3){
var _b4=$.data(_b2,"pagination");
var _b5=_b4.options;
var bb=_b4.bb;
$.extend(_b5,_b3||{});
var ps=$(_b2).find("select.pagination-page-list");
if(ps.length){
ps.val(_b5.pageSize+"");
_b5.pageSize=parseInt(ps.val());
}
var _b6=Math.ceil(_b5.total/_b5.pageSize)||1;
if(_b5.pageNumber<1){
_b5.pageNumber=1;
}
if(_b5.pageNumber>_b6){
_b5.pageNumber=_b6;
}
if(_b5.total==0){
_b5.pageNumber=0;
_b6=0;
}
if(bb.num){
bb.num.val(_b5.pageNumber);
}
if(bb.after){
bb.after.html(_b5.afterPageText.replace(/{pages}/,_b6));
}
var td=$(_b2).find("td.pagination-links");
if(td.length){
td.empty();
var _b7=_b5.pageNumber-Math.floor(_b5.links/2);
if(_b7<1){
_b7=1;
}
var _b8=_b7+_b5.links-1;
if(_b8>_b6){
_b8=_b6;
}
_b7=_b8-_b5.links+1;
if(_b7<1){
_b7=1;
}
for(var i=_b7;i<=_b8;i++){
var a=$("<a class=\"pagination-link\" href=\"javascript:void(0)\"></a>").appendTo(td);
a.linkbutton({plain:true,text:i});
if(i==_b5.pageNumber){
a.linkbutton("select");
}else{
a.unbind(".pagination").bind("click.pagination",{pageNumber:i},function(e){
_ad(_b2,e.data.pageNumber);
});
}
}
}
var _b9=_b5.displayMsg;
_b9=_b9.replace(/{from}/,_b5.total==0?0:_b5.pageSize*(_b5.pageNumber-1)+1);
_b9=_b9.replace(/{to}/,Math.min(_b5.pageSize*(_b5.pageNumber),_b5.total));
_b9=_b9.replace(/{total}/,_b5.total);
$(_b2).find("div.pagination-info").html(_b9);
if(bb.first){
bb.first.linkbutton({disabled:((!_b5.total)||_b5.pageNumber==1)});
}
if(bb.prev){
bb.prev.linkbutton({disabled:((!_b5.total)||_b5.pageNumber==1)});
}
if(bb.next){
bb.next.linkbutton({disabled:(_b5.pageNumber==_b6)});
}
if(bb.last){
bb.last.linkbutton({disabled:(_b5.pageNumber==_b6)});
}
_ba(_b2,_b5.loading);
};
function _ba(_bb,_bc){
var _bd=$.data(_bb,"pagination");
var _be=_bd.options;
_be.loading=_bc;
if(_be.showRefresh&&_bd.bb.refresh){
_bd.bb.refresh.linkbutton({iconCls:(_be.loading?"pagination-loading":"pagination-load")});
}
};
$.fn.pagination=function(_bf,_c0){
if(typeof _bf=="string"){
return $.fn.pagination.methods[_bf](this,_c0);
}
_bf=_bf||{};
return this.each(function(){
var _c1;
var _c2=$.data(this,"pagination");
if(_c2){
_c1=$.extend(_c2.options,_bf);
}else{
_c1=$.extend({},$.fn.pagination.defaults,$.fn.pagination.parseOptions(this),_bf);
$.data(this,"pagination",{options:_c1});
}
_a0(this);
_b1(this);
});
};
$.fn.pagination.methods={options:function(jq){
return $.data(jq[0],"pagination").options;
},loading:function(jq){
return jq.each(function(){
_ba(this,true);
});
},loaded:function(jq){
return jq.each(function(){
_ba(this,false);
});
},refresh:function(jq,_c3){
return jq.each(function(){
_b1(this,_c3);
});
},select:function(jq,_c4){
return jq.each(function(){
_ad(this,_c4);
});
}};
$.fn.pagination.parseOptions=function(_c5){
var t=$(_c5);
return $.extend({},$.parser.parseOptions(_c5,[{total:"number",pageSize:"number",pageNumber:"number",links:"number"},{loading:"boolean",showPageList:"boolean",showRefresh:"boolean"}]),{pageList:(t.attr("pageList")?eval(t.attr("pageList")):undefined)});
};
$.fn.pagination.defaults={total:1,pageSize:10,pageNumber:1,pageList:[10,20,30,50],loading:false,buttons:null,showPageList:true,showRefresh:true,links:10,layout:["list","sep","first","prev","sep","manual","sep","next","last","sep","refresh"],onSelectPage:function(_c6,_c7){
},onBeforeRefresh:function(_c8,_c9){
},onRefresh:function(_ca,_cb){
},onChangePageSize:function(_cc){
},beforePageText:"Page",afterPageText:"of {pages}",displayMsg:"Displaying {from} to {to} of {total} items",nav:{first:{iconCls:"pagination-first",handler:function(){
var _cd=$(this).pagination("options");
if(_cd.pageNumber>1){
$(this).pagination("select",1);
}
}},prev:{iconCls:"pagination-prev",handler:function(){
var _ce=$(this).pagination("options");
if(_ce.pageNumber>1){
$(this).pagination("select",_ce.pageNumber-1);
}
}},next:{iconCls:"pagination-next",handler:function(){
var _cf=$(this).pagination("options");
var _d0=Math.ceil(_cf.total/_cf.pageSize);
if(_cf.pageNumber<_d0){
$(this).pagination("select",_cf.pageNumber+1);
}
}},last:{iconCls:"pagination-last",handler:function(){
var _d1=$(this).pagination("options");
var _d2=Math.ceil(_d1.total/_d1.pageSize);
if(_d1.pageNumber<_d2){
$(this).pagination("select",_d2);
}
}},refresh:{iconCls:"pagination-refresh",handler:function(){
var _d3=$(this).pagination("options");
if(_d3.onBeforeRefresh.call(this,_d3.pageNumber,_d3.pageSize)!=false){
$(this).pagination("select",_d3.pageNumber);
_d3.onRefresh.call(this,_d3.pageNumber,_d3.pageSize);
}
}}}};
})(jQuery);
(function($){
function _d4(_d5){
var _d6=$(_d5);
_d6.addClass("tree");
return _d6;
};
function _d7(_d8){
var _d9=$.data(_d8,"tree").options;
$(_d8).unbind().bind("mouseover",function(e){
var tt=$(e.target);
var _da=tt.closest("div.tree-node");
if(!_da.length){
return;
}
_da.addClass("tree-node-hover");
if(tt.hasClass("tree-hit")){
if(tt.hasClass("tree-expanded")){
tt.addClass("tree-expanded-hover");
}else{
tt.addClass("tree-collapsed-hover");
}
}
e.stopPropagation();
}).bind("mouseout",function(e){
var tt=$(e.target);
var _db=tt.closest("div.tree-node");
if(!_db.length){
return;
}
_db.removeClass("tree-node-hover");
if(tt.hasClass("tree-hit")){
if(tt.hasClass("tree-expanded")){
tt.removeClass("tree-expanded-hover");
}else{
tt.removeClass("tree-collapsed-hover");
}
}
e.stopPropagation();
}).bind("click",function(e){
var tt=$(e.target);
var _dc=tt.closest("div.tree-node");
if(!_dc.length){
return;
}
if(tt.hasClass("tree-hit")){
_13b(_d8,_dc[0]);
return false;
}else{
if(tt.hasClass("tree-checkbox")){
_104(_d8,_dc[0],!tt.hasClass("tree-checkbox1"));
return false;
}else{
_181(_d8,_dc[0]);
_d9.onClick.call(_d8,_df(_d8,_dc[0]));
}
}
e.stopPropagation();
}).bind("dblclick",function(e){
var _dd=$(e.target).closest("div.tree-node");
if(!_dd.length){
return;
}
_181(_d8,_dd[0]);
_d9.onDblClick.call(_d8,_df(_d8,_dd[0]));
e.stopPropagation();
}).bind("contextmenu",function(e){
var _de=$(e.target).closest("div.tree-node");
if(!_de.length){
return;
}
_d9.onContextMenu.call(_d8,e,_df(_d8,_de[0]));
e.stopPropagation();
});
};
function _e0(_e1){
var _e2=$.data(_e1,"tree").options;
_e2.dnd=false;
var _e3=$(_e1).find("div.tree-node");
_e3.draggable("disable");
_e3.css("cursor","pointer");
};
function _e4(_e5){
var _e6=$.data(_e5,"tree");
var _e7=_e6.options;
var _e8=_e6.tree;
_e6.disabledNodes=[];
_e7.dnd=true;
_e8.find("div.tree-node").draggable({disabled:false,revert:true,cursor:"pointer",proxy:function(_e9){
var p=$("<div class=\"tree-node-proxy\"></div>").appendTo("body");
p.html("<span class=\"tree-dnd-icon tree-dnd-no\">&nbsp;</span>"+$(_e9).find(".tree-title").html());
p.hide();
return p;
},deltaX:15,deltaY:15,onBeforeDrag:function(e){
if(_e7.onBeforeDrag.call(_e5,_df(_e5,this))==false){
return false;
}
if($(e.target).hasClass("tree-hit")||$(e.target).hasClass("tree-checkbox")){
return false;
}
if(e.which!=1){
return false;
}
$(this).next("ul").find("div.tree-node").droppable({accept:"no-accept"});
var _ea=$(this).find("span.tree-indent");
if(_ea.length){
e.data.offsetWidth-=_ea.length*_ea.width();
}
},onStartDrag:function(){
$(this).draggable("proxy").css({left:-10000,top:-10000});
_e7.onStartDrag.call(_e5,_df(_e5,this));
var _eb=_df(_e5,this);
if(_eb.id==undefined){
_eb.id="easyui_tree_node_id_temp";
_11e(_e5,_eb);
}
_e6.draggingNodeId=_eb.id;
},onDrag:function(e){
var x1=e.pageX,y1=e.pageY,x2=e.data.startX,y2=e.data.startY;
var d=Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
if(d>3){
$(this).draggable("proxy").show();
}
this.pageY=e.pageY;
},onStopDrag:function(){
$(this).next("ul").find("div.tree-node").droppable({accept:"div.tree-node"});
for(var i=0;i<_e6.disabledNodes.length;i++){
$(_e6.disabledNodes[i]).droppable("enable");
}
_e6.disabledNodes=[];
var _ec=_179(_e5,_e6.draggingNodeId);
if(_ec&&_ec.id=="easyui_tree_node_id_temp"){
_ec.id="";
_11e(_e5,_ec);
}
_e7.onStopDrag.call(_e5,_ec);
}}).droppable({accept:"div.tree-node",onDragEnter:function(e,_ed){
if(_e7.onDragEnter.call(_e5,this,_ee(_ed))==false){
_ef(_ed,false);
$(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
$(this).droppable("disable");
_e6.disabledNodes.push(this);
}
},onDragOver:function(e,_f0){
if($(this).droppable("options").disabled){
return;
}
var _f1=_f0.pageY;
var top=$(this).offset().top;
var _f2=top+$(this).outerHeight();
_ef(_f0,true);
$(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
if(_f1>top+(_f2-top)/2){
if(_f2-_f1<5){
$(this).addClass("tree-node-bottom");
}else{
$(this).addClass("tree-node-append");
}
}else{
if(_f1-top<5){
$(this).addClass("tree-node-top");
}else{
$(this).addClass("tree-node-append");
}
}
if(_e7.onDragOver.call(_e5,this,_ee(_f0))==false){
_ef(_f0,false);
$(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
$(this).droppable("disable");
_e6.disabledNodes.push(this);
}
},onDragLeave:function(e,_f3){
_ef(_f3,false);
$(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
_e7.onDragLeave.call(_e5,this,_ee(_f3));
},onDrop:function(e,_f4){
var _f5=this;
var _f6,_f7;
if($(this).hasClass("tree-node-append")){
_f6=_f8;
_f7="append";
}else{
_f6=_f9;
_f7=$(this).hasClass("tree-node-top")?"top":"bottom";
}
if(_e7.onBeforeDrop.call(_e5,_f5,_ee(_f4),_f7)==false){
$(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
return;
}
_f6(_f4,_f5,_f7);
$(this).removeClass("tree-node-append tree-node-top tree-node-bottom");
}});
function _ee(_fa,pop){
return $(_fa).closest("ul.tree").tree(pop?"pop":"getData",_fa);
};
function _ef(_fb,_fc){
var _fd=$(_fb).draggable("proxy").find("span.tree-dnd-icon");
_fd.removeClass("tree-dnd-yes tree-dnd-no").addClass(_fc?"tree-dnd-yes":"tree-dnd-no");
};
function _f8(_fe,_ff){
if(_df(_e5,_ff).state=="closed"){
_133(_e5,_ff,function(){
_100();
});
}else{
_100();
}
function _100(){
var node=_ee(_fe,true);
$(_e5).tree("append",{parent:_ff,data:[node]});
_e7.onDrop.call(_e5,_ff,node,"append");
};
};
function _f9(_101,dest,_102){
var _103={};
if(_102=="top"){
_103.before=dest;
}else{
_103.after=dest;
}
var node=_ee(_101,true);
_103.data=node;
$(_e5).tree("insert",_103);
_e7.onDrop.call(_e5,dest,node,_102);
};
};
function _104(_105,_106,_107){
var opts=$.data(_105,"tree").options;
if(!opts.checkbox){
return;
}
var _108=_df(_105,_106);
if(opts.onBeforeCheck.call(_105,_108,_107)==false){
return;
}
var node=$(_106);
var ck=node.find(".tree-checkbox");
ck.removeClass("tree-checkbox0 tree-checkbox1 tree-checkbox2");
if(_107){
ck.addClass("tree-checkbox1");
}else{
ck.addClass("tree-checkbox0");
}
if(opts.cascadeCheck){
_109(node);
_10a(node);
}
opts.onCheck.call(_105,_108,_107);
function _10a(node){
var _10b=node.next().find(".tree-checkbox");
_10b.removeClass("tree-checkbox0 tree-checkbox1 tree-checkbox2");
if(node.find(".tree-checkbox").hasClass("tree-checkbox1")){
_10b.addClass("tree-checkbox1");
}else{
_10b.addClass("tree-checkbox0");
}
};
function _109(node){
var _10c=_146(_105,node[0]);
if(_10c){
var ck=$(_10c.target).find(".tree-checkbox");
ck.removeClass("tree-checkbox0 tree-checkbox1 tree-checkbox2");
if(_10d(node)){
ck.addClass("tree-checkbox1");
}else{
if(_10e(node)){
ck.addClass("tree-checkbox0");
}else{
ck.addClass("tree-checkbox2");
}
}
_109($(_10c.target));
}
function _10d(n){
var ck=n.find(".tree-checkbox");
if(ck.hasClass("tree-checkbox0")||ck.hasClass("tree-checkbox2")){
return false;
}
var b=true;
n.parent().siblings().each(function(){
if(!$(this).children("div.tree-node").children(".tree-checkbox").hasClass("tree-checkbox1")){
b=false;
}
});
return b;
};
function _10e(n){
var ck=n.find(".tree-checkbox");
if(ck.hasClass("tree-checkbox1")||ck.hasClass("tree-checkbox2")){
return false;
}
var b=true;
n.parent().siblings().each(function(){
if(!$(this).children("div.tree-node").children(".tree-checkbox").hasClass("tree-checkbox0")){
b=false;
}
});
return b;
};
};
};
function _10f(_110,_111){
var opts=$.data(_110,"tree").options;
if(!opts.checkbox){
return;
}
var node=$(_111);
if(_112(_110,_111)){
var ck=node.find(".tree-checkbox");
if(ck.length){
if(ck.hasClass("tree-checkbox1")){
_104(_110,_111,true);
}else{
_104(_110,_111,false);
}
}else{
if(opts.onlyLeafCheck){
$("<span class=\"tree-checkbox tree-checkbox0\"></span>").insertBefore(node.find(".tree-title"));
}
}
}else{
var ck=node.find(".tree-checkbox");
if(opts.onlyLeafCheck){
ck.remove();
}else{
if(ck.hasClass("tree-checkbox1")){
_104(_110,_111,true);
}else{
if(ck.hasClass("tree-checkbox2")){
var _113=true;
var _114=true;
var _115=_116(_110,_111);
for(var i=0;i<_115.length;i++){
if(_115[i].checked){
_114=false;
}else{
_113=false;
}
}
if(_113){
_104(_110,_111,true);
}
if(_114){
_104(_110,_111,false);
}
}
}
}
}
};
function _117(_118,ul,data,_119){
var _11a=$.data(_118,"tree");
var opts=_11a.options;
var _11b=$(ul).prevAll("div.tree-node:first");
data=opts.loadFilter.call(_118,data,_11b[0]);
var _11c=_11d(_118,"domId",_11b.attr("id"));
if(!_119){
_11c?_11c.children=data:_11a.data=data;
$(ul).empty();
}else{
if(_11c){
_11c.children?_11c.children=_11c.children.concat(data):_11c.children=data;
}else{
_11a.data=_11a.data.concat(data);
}
}
opts.view.render.call(opts.view,_118,ul,data);
if(opts.dnd){
_e4(_118);
}
if(_11c){
_11e(_118,_11c);
}
var _11f=[];
var _120=[];
for(var i=0;i<data.length;i++){
var node=data[i];
if(!node.checked){
_11f.push(node);
}
}
_121(data,function(node){
if(node.checked){
_120.push(node);
}
});
var _122=opts.onCheck;
opts.onCheck=function(){
};
if(_11f.length){
_104(_118,$("#"+_11f[0].domId)[0],false);
}
for(var i=0;i<_120.length;i++){
_104(_118,$("#"+_120[i].domId)[0],true);
}
opts.onCheck=_122;
setTimeout(function(){
_123(_118,_118);
},0);
opts.onLoadSuccess.call(_118,_11c,data);
};
function _123(_124,ul,_125){
var opts=$.data(_124,"tree").options;
if(opts.lines){
$(_124).addClass("tree-lines");
}else{
$(_124).removeClass("tree-lines");
return;
}
if(!_125){
_125=true;
$(_124).find("span.tree-indent").removeClass("tree-line tree-join tree-joinbottom");
$(_124).find("div.tree-node").removeClass("tree-node-last tree-root-first tree-root-one");
var _126=$(_124).tree("getRoots");
if(_126.length>1){
$(_126[0].target).addClass("tree-root-first");
}else{
if(_126.length==1){
$(_126[0].target).addClass("tree-root-one");
}
}
}
$(ul).children("li").each(function(){
var node=$(this).children("div.tree-node");
var ul=node.next("ul");
if(ul.length){
if($(this).next().length){
_127(node);
}
_123(_124,ul,_125);
}else{
_128(node);
}
});
var _129=$(ul).children("li:last").children("div.tree-node").addClass("tree-node-last");
_129.children("span.tree-join").removeClass("tree-join").addClass("tree-joinbottom");
function _128(node,_12a){
var icon=node.find("span.tree-icon");
icon.prev("span.tree-indent").addClass("tree-join");
};
function _127(node){
var _12b=node.find("span.tree-indent, span.tree-hit").length;
node.next().find("div.tree-node").each(function(){
$(this).children("span:eq("+(_12b-1)+")").addClass("tree-line");
});
};
};
function _12c(_12d,ul,_12e,_12f){
var opts=$.data(_12d,"tree").options;
_12e=$.extend({},opts.queryParams,_12e||{});
var _130=null;
if(_12d!=ul){
var node=$(ul).prev();
_130=_df(_12d,node[0]);
}
if(opts.onBeforeLoad.call(_12d,_130,_12e)==false){
return;
}
var _131=$(ul).prev().children("span.tree-folder");
_131.addClass("tree-loading");
var _132=opts.loader.call(_12d,_12e,function(data){
_131.removeClass("tree-loading");
_117(_12d,ul,data);
if(_12f){
_12f();
}
},function(){
_131.removeClass("tree-loading");
opts.onLoadError.apply(_12d,arguments);
if(_12f){
_12f();
}
});
if(_132==false){
_131.removeClass("tree-loading");
}
};
function _133(_134,_135,_136){
var opts=$.data(_134,"tree").options;
var hit=$(_135).children("span.tree-hit");
if(hit.length==0){
return;
}
if(hit.hasClass("tree-expanded")){
return;
}
var node=_df(_134,_135);
if(opts.onBeforeExpand.call(_134,node)==false){
return;
}
hit.removeClass("tree-collapsed tree-collapsed-hover").addClass("tree-expanded");
hit.next().addClass("tree-folder-open");
var ul=$(_135).next();
if(ul.length){
if(opts.animate){
ul.slideDown("normal",function(){
node.state="open";
opts.onExpand.call(_134,node);
if(_136){
_136();
}
});
}else{
ul.css("display","block");
node.state="open";
opts.onExpand.call(_134,node);
if(_136){
_136();
}
}
}else{
var _137=$("<ul style=\"display:none\"></ul>").insertAfter(_135);
_12c(_134,_137[0],{id:node.id},function(){
if(_137.is(":empty")){
_137.remove();
}
if(opts.animate){
_137.slideDown("normal",function(){
node.state="open";
opts.onExpand.call(_134,node);
if(_136){
_136();
}
});
}else{
_137.css("display","block");
node.state="open";
opts.onExpand.call(_134,node);
if(_136){
_136();
}
}
});
}
};
function _138(_139,_13a){
var opts=$.data(_139,"tree").options;
var hit=$(_13a).children("span.tree-hit");
if(hit.length==0){
return;
}
if(hit.hasClass("tree-collapsed")){
return;
}
var node=_df(_139,_13a);
if(opts.onBeforeCollapse.call(_139,node)==false){
return;
}
hit.removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed");
hit.next().removeClass("tree-folder-open");
var ul=$(_13a).next();
if(opts.animate){
ul.slideUp("normal",function(){
node.state="closed";
opts.onCollapse.call(_139,node);
});
}else{
ul.css("display","none");
node.state="closed";
opts.onCollapse.call(_139,node);
}
};
function _13b(_13c,_13d){
var hit=$(_13d).children("span.tree-hit");
if(hit.length==0){
return;
}
if(hit.hasClass("tree-expanded")){
_138(_13c,_13d);
}else{
_133(_13c,_13d);
}
};
function _13e(_13f,_140){
var _141=_116(_13f,_140);
if(_140){
_141.unshift(_df(_13f,_140));
}
for(var i=0;i<_141.length;i++){
_133(_13f,_141[i].target);
}
};
function _142(_143,_144){
var _145=[];
var p=_146(_143,_144);
while(p){
_145.unshift(p);
p=_146(_143,p.target);
}
for(var i=0;i<_145.length;i++){
_133(_143,_145[i].target);
}
};
function _147(_148,_149){
var c=$(_148).parent();
while(c[0].tagName!="BODY"&&c.css("overflow-y")!="auto"){
c=c.parent();
}
var n=$(_149);
var ntop=n.offset().top;
if(c[0].tagName!="BODY"){
var ctop=c.offset().top;
if(ntop<ctop){
c.scrollTop(c.scrollTop()+ntop-ctop);
}else{
if(ntop+n.outerHeight()>ctop+c.outerHeight()-18){
c.scrollTop(c.scrollTop()+ntop+n.outerHeight()-ctop-c.outerHeight()+18);
}
}
}else{
c.scrollTop(ntop);
}
};
function _14a(_14b,_14c){
var _14d=_116(_14b,_14c);
if(_14c){
_14d.unshift(_df(_14b,_14c));
}
for(var i=0;i<_14d.length;i++){
_138(_14b,_14d[i].target);
}
};
function _14e(_14f,_150){
var node=$(_150.parent);
var data=_150.data;
if(!data){
return;
}
data=$.isArray(data)?data:[data];
if(!data.length){
return;
}
var ul;
if(node.length==0){
ul=$(_14f);
}else{
if(_112(_14f,node[0])){
var _151=node.find("span.tree-icon");
_151.removeClass("tree-file").addClass("tree-folder tree-folder-open");
var hit=$("<span class=\"tree-hit tree-expanded\"></span>").insertBefore(_151);
if(hit.prev().length){
hit.prev().remove();
}
}
ul=node.next();
if(!ul.length){
ul=$("<ul></ul>").insertAfter(node);
}
}
_117(_14f,ul[0],data,true);
_10f(_14f,ul.prev());
};
function _152(_153,_154){
var ref=_154.before||_154.after;
var _155=_146(_153,ref);
var data=_154.data;
if(!data){
return;
}
data=$.isArray(data)?data:[data];
if(!data.length){
return;
}
_14e(_153,{parent:(_155?_155.target:null),data:data});
var _156=_155?_155.children:$(_153).tree("getRoots");
for(var i=0;i<_156.length;i++){
if(_156[i].domId==$(ref).attr("id")){
for(var j=data.length-1;j>=0;j--){
_156.splice((_154.before?i:(i+1)),0,data[j]);
}
_156.splice(_156.length-data.length,data.length);
break;
}
}
var li=$();
for(var i=0;i<data.length;i++){
li=li.add($("#"+data[i].domId).parent());
}
if(_154.before){
li.insertBefore($(ref).parent());
}else{
li.insertAfter($(ref).parent());
}
};
function _157(_158,_159){
var _15a=del(_159);
$(_159).parent().remove();
if(_15a){
if(!_15a.children||!_15a.children.length){
var node=$(_15a.target);
node.find(".tree-icon").removeClass("tree-folder").addClass("tree-file");
node.find(".tree-hit").remove();
$("<span class=\"tree-indent\"></span>").prependTo(node);
node.next().remove();
}
_11e(_158,_15a);
_10f(_158,_15a.target);
}
_123(_158,_158);
function del(_15b){
var id=$(_15b).attr("id");
var _15c=_146(_158,_15b);
var cc=_15c?_15c.children:$.data(_158,"tree").data;
for(var i=0;i<cc.length;i++){
if(cc[i].domId==id){
cc.splice(i,1);
break;
}
}
return _15c;
};
};
function _11e(_15d,_15e){
var opts=$.data(_15d,"tree").options;
var node=$(_15e.target);
var data=_df(_15d,_15e.target);
var _15f=data.checked;
if(data.iconCls){
node.find(".tree-icon").removeClass(data.iconCls);
}
$.extend(data,_15e);
node.find(".tree-title").html(opts.formatter.call(_15d,data));
if(data.iconCls){
node.find(".tree-icon").addClass(data.iconCls);
}
if(_15f!=data.checked){
_104(_15d,_15e.target,data.checked);
}
};
function _160(_161,_162){
if(_162){
var p=_146(_161,_162);
while(p){
_162=p.target;
p=_146(_161,_162);
}
return _df(_161,_162);
}else{
var _163=_164(_161);
return _163.length?_163[0]:null;
}
};
function _164(_165){
var _166=$.data(_165,"tree").data;
for(var i=0;i<_166.length;i++){
_167(_166[i]);
}
return _166;
};
function _116(_168,_169){
var _16a=[];
var n=_df(_168,_169);
var data=n?(n.children||[]):$.data(_168,"tree").data;
_121(data,function(node){
_16a.push(_167(node));
});
return _16a;
};
function _146(_16b,_16c){
var p=$(_16c).closest("ul").prevAll("div.tree-node:first");
return _df(_16b,p[0]);
};
function _16d(_16e,_16f){
_16f=_16f||"checked";
if(!$.isArray(_16f)){
_16f=[_16f];
}
var _170=[];
for(var i=0;i<_16f.length;i++){
var s=_16f[i];
if(s=="checked"){
_170.push("span.tree-checkbox1");
}else{
if(s=="unchecked"){
_170.push("span.tree-checkbox0");
}else{
if(s=="indeterminate"){
_170.push("span.tree-checkbox2");
}
}
}
}
var _171=[];
$(_16e).find(_170.join(",")).each(function(){
var node=$(this).parent();
_171.push(_df(_16e,node[0]));
});
return _171;
};
function _172(_173){
var node=$(_173).find("div.tree-node-selected");
return node.length?_df(_173,node[0]):null;
};
function _174(_175,_176){
var data=_df(_175,_176);
if(data&&data.children){
_121(data.children,function(node){
_167(node);
});
}
return data;
};
function _df(_177,_178){
return _11d(_177,"domId",$(_178).attr("id"));
};
function _179(_17a,id){
return _11d(_17a,"id",id);
};
function _11d(_17b,_17c,_17d){
var data=$.data(_17b,"tree").data;
var _17e=null;
_121(data,function(node){
if(node[_17c]==_17d){
_17e=_167(node);
return false;
}
});
return _17e;
};
function _167(node){
var d=$("#"+node.domId);
node.target=d[0];
node.checked=d.find(".tree-checkbox").hasClass("tree-checkbox1");
return node;
};
function _121(data,_17f){
var _180=[];
for(var i=0;i<data.length;i++){
_180.push(data[i]);
}
while(_180.length){
var node=_180.shift();
if(_17f(node)==false){
return;
}
if(node.children){
for(var i=node.children.length-1;i>=0;i--){
_180.unshift(node.children[i]);
}
}
}
};
function _181(_182,_183){
var opts=$.data(_182,"tree").options;
var node=_df(_182,_183);
if(opts.onBeforeSelect.call(_182,node)==false){
return;
}
$(_182).find("div.tree-node-selected").removeClass("tree-node-selected");
$(_183).addClass("tree-node-selected");
opts.onSelect.call(_182,node);
};
function _112(_184,_185){
return $(_185).children("span.tree-hit").length==0;
};
function _186(_187,_188){
var opts=$.data(_187,"tree").options;
var node=_df(_187,_188);
if(opts.onBeforeEdit.call(_187,node)==false){
return;
}
$(_188).css("position","relative");
var nt=$(_188).find(".tree-title");
var _189=nt.outerWidth();
nt.empty();
var _18a=$("<input class=\"tree-editor\">").appendTo(nt);
_18a.val(node.text).focus();
_18a.width(_189+20);
_18a.height(document.compatMode=="CSS1Compat"?(18-(_18a.outerHeight()-_18a.height())):18);
_18a.bind("click",function(e){
return false;
}).bind("mousedown",function(e){
e.stopPropagation();
}).bind("mousemove",function(e){
e.stopPropagation();
}).bind("keydown",function(e){
if(e.keyCode==13){
_18b(_187,_188);
return false;
}else{
if(e.keyCode==27){
_18f(_187,_188);
return false;
}
}
}).bind("blur",function(e){
e.stopPropagation();
_18b(_187,_188);
});
};
function _18b(_18c,_18d){
var opts=$.data(_18c,"tree").options;
$(_18d).css("position","");
var _18e=$(_18d).find("input.tree-editor");
var val=_18e.val();
_18e.remove();
var node=_df(_18c,_18d);
node.text=val;
_11e(_18c,node);
opts.onAfterEdit.call(_18c,node);
};
function _18f(_190,_191){
var opts=$.data(_190,"tree").options;
$(_191).css("position","");
$(_191).find("input.tree-editor").remove();
var node=_df(_190,_191);
_11e(_190,node);
opts.onCancelEdit.call(_190,node);
};
$.fn.tree=function(_192,_193){
if(typeof _192=="string"){
return $.fn.tree.methods[_192](this,_193);
}
var _192=_192||{};
return this.each(function(){
var _194=$.data(this,"tree");
var opts;
if(_194){
opts=$.extend(_194.options,_192);
_194.options=opts;
}else{
opts=$.extend({},$.fn.tree.defaults,$.fn.tree.parseOptions(this),_192);
$.data(this,"tree",{options:opts,tree:_d4(this),data:[]});
var data=$.fn.tree.parseData(this);
if(data.length){
_117(this,this,data);
}
}
_d7(this);
if(opts.data){
_117(this,this,$.extend(true,[],opts.data));
}
_12c(this,this);
});
};
$.fn.tree.methods={options:function(jq){
return $.data(jq[0],"tree").options;
},loadData:function(jq,data){
return jq.each(function(){
_117(this,this,data);
});
},getNode:function(jq,_195){
return _df(jq[0],_195);
},getData:function(jq,_196){
return _174(jq[0],_196);
},reload:function(jq,_197){
return jq.each(function(){
if(_197){
var node=$(_197);
var hit=node.children("span.tree-hit");
hit.removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed");
node.next().remove();
_133(this,_197);
}else{
$(this).empty();
_12c(this,this);
}
});
},getRoot:function(jq,_198){
return _160(jq[0],_198);
},getRoots:function(jq){
return _164(jq[0]);
},getParent:function(jq,_199){
return _146(jq[0],_199);
},getChildren:function(jq,_19a){
return _116(jq[0],_19a);
},getChecked:function(jq,_19b){
return _16d(jq[0],_19b);
},getSelected:function(jq){
return _172(jq[0]);
},isLeaf:function(jq,_19c){
return _112(jq[0],_19c);
},find:function(jq,id){
return _179(jq[0],id);
},select:function(jq,_19d){
return jq.each(function(){
_181(this,_19d);
});
},check:function(jq,_19e){
return jq.each(function(){
_104(this,_19e,true);
});
},uncheck:function(jq,_19f){
return jq.each(function(){
_104(this,_19f,false);
});
},collapse:function(jq,_1a0){
return jq.each(function(){
_138(this,_1a0);
});
},expand:function(jq,_1a1){
return jq.each(function(){
_133(this,_1a1);
});
},collapseAll:function(jq,_1a2){
return jq.each(function(){
_14a(this,_1a2);
});
},expandAll:function(jq,_1a3){
return jq.each(function(){
_13e(this,_1a3);
});
},expandTo:function(jq,_1a4){
return jq.each(function(){
_142(this,_1a4);
});
},scrollTo:function(jq,_1a5){
return jq.each(function(){
_147(this,_1a5);
});
},toggle:function(jq,_1a6){
return jq.each(function(){
_13b(this,_1a6);
});
},append:function(jq,_1a7){
return jq.each(function(){
_14e(this,_1a7);
});
},insert:function(jq,_1a8){
return jq.each(function(){
_152(this,_1a8);
});
},remove:function(jq,_1a9){
return jq.each(function(){
_157(this,_1a9);
});
},pop:function(jq,_1aa){
var node=jq.tree("getData",_1aa);
jq.tree("remove",_1aa);
return node;
},update:function(jq,_1ab){
return jq.each(function(){
_11e(this,_1ab);
});
},enableDnd:function(jq){
return jq.each(function(){
_e4(this);
});
},disableDnd:function(jq){
return jq.each(function(){
_e0(this);
});
},beginEdit:function(jq,_1ac){
return jq.each(function(){
_186(this,_1ac);
});
},endEdit:function(jq,_1ad){
return jq.each(function(){
_18b(this,_1ad);
});
},cancelEdit:function(jq,_1ae){
return jq.each(function(){
_18f(this,_1ae);
});
}};
$.fn.tree.parseOptions=function(_1af){
var t=$(_1af);
return $.extend({},$.parser.parseOptions(_1af,["url","method",{checkbox:"boolean",cascadeCheck:"boolean",onlyLeafCheck:"boolean"},{animate:"boolean",lines:"boolean",dnd:"boolean"}]));
};
$.fn.tree.parseData=function(_1b0){
var data=[];
_1b1(data,$(_1b0));
return data;
function _1b1(aa,tree){
tree.children("li").each(function(){
var node=$(this);
var item=$.extend({},$.parser.parseOptions(this,["id","iconCls","state"]),{checked:(node.attr("checked")?true:undefined)});
item.text=node.children("span").html();
if(!item.text){
item.text=node.html();
}
var _1b2=node.children("ul");
if(_1b2.length){
item.children=[];
_1b1(item.children,_1b2);
}
aa.push(item);
});
};
};
var _1b3=1;
var _1b4={render:function(_1b5,ul,data){
var opts=$.data(_1b5,"tree").options;
var _1b6=$(ul).prev("div.tree-node").find("span.tree-indent, span.tree-hit").length;
var cc=_1b7(_1b6,data);
$(ul).append(cc.join(""));
function _1b7(_1b8,_1b9){
var cc=[];
for(var i=0;i<_1b9.length;i++){
var item=_1b9[i];
if(item.state!="open"&&item.state!="closed"){
item.state="open";
}
item.domId="_easyui_tree_"+_1b3++;
cc.push("<li>");
cc.push("<div id=\""+item.domId+"\" class=\"tree-node\">");
for(var j=0;j<_1b8;j++){
cc.push("<span class=\"tree-indent\"></span>");
}
var _1ba=false;
if(item.state=="closed"){
cc.push("<span class=\"tree-hit tree-collapsed\"></span>");
cc.push("<span class=\"tree-icon tree-folder "+(item.iconCls?item.iconCls:"")+"\"></span>");
}else{
if(item.children&&item.children.length){
cc.push("<span class=\"tree-hit tree-expanded\"></span>");
cc.push("<span class=\"tree-icon tree-folder tree-folder-open "+(item.iconCls?item.iconCls:"")+"\"></span>");
}else{
cc.push("<span class=\"tree-indent\"></span>");
cc.push("<span class=\"tree-icon tree-file "+(item.iconCls?item.iconCls:"")+"\"></span>");
_1ba=true;
}
}
if(opts.checkbox){
if((!opts.onlyLeafCheck)||_1ba){
cc.push("<span class=\"tree-checkbox tree-checkbox0\"></span>");
}
}
cc.push("<span class=\"tree-title\">"+opts.formatter.call(_1b5,item)+"</span>");
cc.push("</div>");
if(item.children&&item.children.length){
var tmp=_1b7(_1b8+1,item.children);
cc.push("<ul style=\"display:"+(item.state=="closed"?"none":"block")+"\">");
cc=cc.concat(tmp);
cc.push("</ul>");
}
cc.push("</li>");
}
return cc;
};
}};
$.fn.tree.defaults={url:null,method:"post",animate:false,checkbox:false,cascadeCheck:true,onlyLeafCheck:false,lines:false,dnd:false,data:null,queryParams:{},formatter:function(node){
return node.text;
},loader:function(_1bb,_1bc,_1bd){
var opts=$(this).tree("options");
if(!opts.url){
return false;
}
$.ajax({type:opts.method,url:opts.url,data:_1bb,dataType:"json",success:function(data){
_1bc(data);
},error:function(){
_1bd.apply(this,arguments);
}});
},loadFilter:function(data,_1be){
return data;
},view:_1b4,onBeforeLoad:function(node,_1bf){
},onLoadSuccess:function(node,data){
},onLoadError:function(){
},onClick:function(node){
},onDblClick:function(node){
},onBeforeExpand:function(node){
},onExpand:function(node){
},onBeforeCollapse:function(node){
},onCollapse:function(node){
},onBeforeCheck:function(node,_1c0){
},onCheck:function(node,_1c1){
},onBeforeSelect:function(node){
},onSelect:function(node){
},onContextMenu:function(e,node){
},onBeforeDrag:function(node){
},onStartDrag:function(node){
},onStopDrag:function(node){
},onDragEnter:function(_1c2,_1c3){
},onDragOver:function(_1c4,_1c5){
},onDragLeave:function(_1c6,_1c7){
},onBeforeDrop:function(_1c8,_1c9,_1ca){
},onDrop:function(_1cb,_1cc,_1cd){
},onBeforeEdit:function(node){
},onAfterEdit:function(node){
},onCancelEdit:function(node){
}};
})(jQuery);
(function($){
function init(_1ce){
$(_1ce).addClass("progressbar");
$(_1ce).html("<div class=\"progressbar-text\"></div><div class=\"progressbar-value\"><div class=\"progressbar-text\"></div></div>");
$(_1ce).bind("_resize",function(e,_1cf){
if($(this).hasClass("easyui-fluid")||_1cf){
_1d0(_1ce);
}
return false;
});
return $(_1ce);
};
function _1d0(_1d1,_1d2){
var opts=$.data(_1d1,"progressbar").options;
var bar=$.data(_1d1,"progressbar").bar;
if(_1d2){
opts.width=_1d2;
}
bar._size(opts);
bar.find("div.progressbar-text").css("width",bar.width());
bar.find("div.progressbar-text,div.progressbar-value").css({height:bar.height()+"px",lineHeight:bar.height()+"px"});
};
$.fn.progressbar=function(_1d3,_1d4){
if(typeof _1d3=="string"){
var _1d5=$.fn.progressbar.methods[_1d3];
if(_1d5){
return _1d5(this,_1d4);
}
}
_1d3=_1d3||{};
return this.each(function(){
var _1d6=$.data(this,"progressbar");
if(_1d6){
$.extend(_1d6.options,_1d3);
}else{
_1d6=$.data(this,"progressbar",{options:$.extend({},$.fn.progressbar.defaults,$.fn.progressbar.parseOptions(this),_1d3),bar:init(this)});
}
$(this).progressbar("setValue",_1d6.options.value);
_1d0(this);
});
};
$.fn.progressbar.methods={options:function(jq){
return $.data(jq[0],"progressbar").options;
},resize:function(jq,_1d7){
return jq.each(function(){
_1d0(this,_1d7);
});
},getValue:function(jq){
return $.data(jq[0],"progressbar").options.value;
},setValue:function(jq,_1d8){
if(_1d8<0){
_1d8=0;
}
if(_1d8>100){
_1d8=100;
}
return jq.each(function(){
var opts=$.data(this,"progressbar").options;
var text=opts.text.replace(/{value}/,_1d8);
var _1d9=opts.value;
opts.value=_1d8;
$(this).find("div.progressbar-value").width(_1d8+"%");
$(this).find("div.progressbar-text").html(text);
if(_1d9!=_1d8){
opts.onChange.call(this,_1d8,_1d9);
}
});
}};
$.fn.progressbar.parseOptions=function(_1da){
return $.extend({},$.parser.parseOptions(_1da,["width","height","text",{value:"number"}]));
};
$.fn.progressbar.defaults={width:"auto",height:22,value:0,text:"{value}%",onChange:function(_1db,_1dc){
}};
})(jQuery);
(function($){
function init(_1dd){
$(_1dd).addClass("tooltip-f");
};
function _1de(_1df){
var opts=$.data(_1df,"tooltip").options;
$(_1df).unbind(".tooltip").bind(opts.showEvent+".tooltip",function(e){
$(_1df).tooltip("show",e);
}).bind(opts.hideEvent+".tooltip",function(e){
$(_1df).tooltip("hide",e);
}).bind("mousemove.tooltip",function(e){
if(opts.trackMouse){
opts.trackMouseX=e.pageX;
opts.trackMouseY=e.pageY;
$(_1df).tooltip("reposition");
}
});
};
function _1e0(_1e1){
var _1e2=$.data(_1e1,"tooltip");
if(_1e2.showTimer){
clearTimeout(_1e2.showTimer);
_1e2.showTimer=null;
}
if(_1e2.hideTimer){
clearTimeout(_1e2.hideTimer);
_1e2.hideTimer=null;
}
};
function _1e3(_1e4){
var _1e5=$.data(_1e4,"tooltip");
if(!_1e5||!_1e5.tip){
return;
}
var opts=_1e5.options;
var tip=_1e5.tip;
var pos={left:-100000,top:-100000};
if($(_1e4).is(":visible")){
pos=_1e6(opts.position);
if(opts.position=="top"&&pos.top<0){
pos=_1e6("bottom");
}else{
if((opts.position=="bottom")&&(pos.top+tip._outerHeight()>$(window)._outerHeight()+$(document).scrollTop())){
pos=_1e6("top");
}
}
if(pos.left<0){
if(opts.position=="left"){
pos=_1e6("right");
}else{
$(_1e4).tooltip("arrow").css("left",tip._outerWidth()/2+pos.left);
pos.left=0;
}
}else{
if(pos.left+tip._outerWidth()>$(window)._outerWidth()+$(document)._scrollLeft()){
if(opts.position=="right"){
pos=_1e6("left");
}else{
var left=pos.left;
pos.left=$(window)._outerWidth()+$(document)._scrollLeft()-tip._outerWidth();
$(_1e4).tooltip("arrow").css("left",tip._outerWidth()/2-(pos.left-left));
}
}
}
}
tip.css({left:pos.left,top:pos.top,zIndex:(opts.zIndex!=undefined?opts.zIndex:($.fn.window?$.fn.window.defaults.zIndex++:""))});
opts.onPosition.call(_1e4,pos.left,pos.top);
function _1e6(_1e7){
opts.position=_1e7||"bottom";
tip.removeClass("tooltip-top tooltip-bottom tooltip-left tooltip-right").addClass("tooltip-"+opts.position);
var left,top;
if(opts.trackMouse){
t=$();
left=opts.trackMouseX+opts.deltaX;
top=opts.trackMouseY+opts.deltaY;
}else{
var t=$(_1e4);
left=t.offset().left+opts.deltaX;
top=t.offset().top+opts.deltaY;
}
switch(opts.position){
case "right":
left+=t._outerWidth()+12+(opts.trackMouse?12:0);
top-=(tip._outerHeight()-t._outerHeight())/2;
break;
case "left":
left-=tip._outerWidth()+12+(opts.trackMouse?12:0);
top-=(tip._outerHeight()-t._outerHeight())/2;
break;
case "top":
left-=(tip._outerWidth()-t._outerWidth())/2;
top-=tip._outerHeight()+12+(opts.trackMouse?12:0);
break;
case "bottom":
left-=(tip._outerWidth()-t._outerWidth())/2;
top+=t._outerHeight()+12+(opts.trackMouse?12:0);
break;
}
return {left:left,top:top};
};
};
function _1e8(_1e9,e){
var _1ea=$.data(_1e9,"tooltip");
var opts=_1ea.options;
var tip=_1ea.tip;
if(!tip){
tip=$("<div tabindex=\"-1\" class=\"tooltip\">"+"<div class=\"tooltip-content\"></div>"+"<div class=\"tooltip-arrow-outer\"></div>"+"<div class=\"tooltip-arrow\"></div>"+"</div>").appendTo("body");
_1ea.tip=tip;
_1eb(_1e9);
}
_1e0(_1e9);
_1ea.showTimer=setTimeout(function(){
$(_1e9).tooltip("reposition");
tip.show();
opts.onShow.call(_1e9,e);
var _1ec=tip.children(".tooltip-arrow-outer");
var _1ed=tip.children(".tooltip-arrow");
var bc="border-"+opts.position+"-color";
_1ec.add(_1ed).css({borderTopColor:"",borderBottomColor:"",borderLeftColor:"",borderRightColor:""});
_1ec.css(bc,tip.css(bc));
_1ed.css(bc,tip.css("backgroundColor"));
},opts.showDelay);
};
function _1ee(_1ef,e){
var _1f0=$.data(_1ef,"tooltip");
if(_1f0&&_1f0.tip){
_1e0(_1ef);
_1f0.hideTimer=setTimeout(function(){
_1f0.tip.hide();
_1f0.options.onHide.call(_1ef,e);
},_1f0.options.hideDelay);
}
};
function _1eb(_1f1,_1f2){
var _1f3=$.data(_1f1,"tooltip");
var opts=_1f3.options;
if(_1f2){
opts.content=_1f2;
}
if(!_1f3.tip){
return;
}
var cc=typeof opts.content=="function"?opts.content.call(_1f1):opts.content;
_1f3.tip.children(".tooltip-content").html(cc);
opts.onUpdate.call(_1f1,cc);
};
function _1f4(_1f5){
var _1f6=$.data(_1f5,"tooltip");
if(_1f6){
_1e0(_1f5);
var opts=_1f6.options;
if(_1f6.tip){
_1f6.tip.remove();
}
if(opts._title){
$(_1f5).attr("title",opts._title);
}
$.removeData(_1f5,"tooltip");
$(_1f5).unbind(".tooltip").removeClass("tooltip-f");
opts.onDestroy.call(_1f5);
}
};
$.fn.tooltip=function(_1f7,_1f8){
if(typeof _1f7=="string"){
return $.fn.tooltip.methods[_1f7](this,_1f8);
}
_1f7=_1f7||{};
return this.each(function(){
var _1f9=$.data(this,"tooltip");
if(_1f9){
$.extend(_1f9.options,_1f7);
}else{
$.data(this,"tooltip",{options:$.extend({},$.fn.tooltip.defaults,$.fn.tooltip.parseOptions(this),_1f7)});
init(this);
}
_1de(this);
_1eb(this);
});
};
$.fn.tooltip.methods={options:function(jq){
return $.data(jq[0],"tooltip").options;
},tip:function(jq){
return $.data(jq[0],"tooltip").tip;
},arrow:function(jq){
return jq.tooltip("tip").children(".tooltip-arrow-outer,.tooltip-arrow");
},show:function(jq,e){
return jq.each(function(){
_1e8(this,e);
});
},hide:function(jq,e){
return jq.each(function(){
_1ee(this,e);
});
},update:function(jq,_1fa){
return jq.each(function(){
_1eb(this,_1fa);
});
},reposition:function(jq){
return jq.each(function(){
_1e3(this);
});
},destroy:function(jq){
return jq.each(function(){
_1f4(this);
});
}};
$.fn.tooltip.parseOptions=function(_1fb){
var t=$(_1fb);
var opts=$.extend({},$.parser.parseOptions(_1fb,["position","showEvent","hideEvent","content",{trackMouse:"boolean",deltaX:"number",deltaY:"number",showDelay:"number",hideDelay:"number"}]),{_title:t.attr("title")});
t.attr("title","");
if(!opts.content){
opts.content=opts._title;
}
return opts;
};
$.fn.tooltip.defaults={position:"bottom",content:null,trackMouse:false,deltaX:0,deltaY:0,showEvent:"mouseenter",hideEvent:"mouseleave",showDelay:200,hideDelay:100,onShow:function(e){
},onHide:function(e){
},onUpdate:function(_1fc){
},onPosition:function(left,top){
},onDestroy:function(){
}};
})(jQuery);
(function($){
$.fn._remove=function(){
return this.each(function(){
$(this).remove();
try{
this.outerHTML="";
}
catch(err){
}
});
};
function _1fd(node){
node._remove();
};
function _1fe(_1ff,_200){
var _201=$.data(_1ff,"panel");
var opts=_201.options;
var _202=_201.panel;
var _203=_202.children("div.panel-header");
var _204=_202.children("div.panel-body");
var _205=_202.children("div.panel-footer");
if(_200){
$.extend(opts,{width:_200.width,height:_200.height,minWidth:_200.minWidth,maxWidth:_200.maxWidth,minHeight:_200.minHeight,maxHeight:_200.maxHeight,left:_200.left,top:_200.top});
}
_202._size(opts);
_203.add(_204)._outerWidth(_202.width());
if(!isNaN(parseInt(opts.height))){
_204._outerHeight(_202.height()-_203._outerHeight()-_205._outerHeight());
}else{
_204.css("height","");
var min=$.parser.parseValue("minHeight",opts.minHeight,_202.parent());
var max=$.parser.parseValue("maxHeight",opts.maxHeight,_202.parent());
var _206=_203._outerHeight()+_205._outerHeight()+_202._outerHeight()-_202.height();
_204._size("minHeight",min?(min-_206):"");
_204._size("maxHeight",max?(max-_206):"");
}
_202.css({height:"",minHeight:"",maxHeight:"",left:opts.left,top:opts.top});
opts.onResize.apply(_1ff,[opts.width,opts.height]);
$(_1ff).panel("doLayout");
};
function _207(_208,_209){
var opts=$.data(_208,"panel").options;
var _20a=$.data(_208,"panel").panel;
if(_209){
if(_209.left!=null){
opts.left=_209.left;
}
if(_209.top!=null){
opts.top=_209.top;
}
}
_20a.css({left:opts.left,top:opts.top});
opts.onMove.apply(_208,[opts.left,opts.top]);
};
function _20b(_20c){
$(_20c).addClass("panel-body")._size("clear");
var _20d=$("<div class=\"panel\"></div>").insertBefore(_20c);
_20d[0].appendChild(_20c);
_20d.bind("_resize",function(e,_20e){
if($(this).hasClass("easyui-fluid")||_20e){
_1fe(_20c);
}
return false;
});
return _20d;
};
function _20f(_210){
var _211=$.data(_210,"panel");
var opts=_211.options;
var _212=_211.panel;
_212.css(opts.style);
_212.addClass(opts.cls);
_213();
_214();
var _215=$(_210).panel("header");
var body=$(_210).panel("body");
var _216=$(_210).siblings("div.panel-footer");
if(opts.border){
_215.removeClass("panel-header-noborder");
body.removeClass("panel-body-noborder");
_216.removeClass("panel-footer-noborder");
}else{
_215.addClass("panel-header-noborder");
body.addClass("panel-body-noborder");
_216.addClass("panel-footer-noborder");
}
_215.addClass(opts.headerCls);
body.addClass(opts.bodyCls);
$(_210).attr("id",opts.id||"");
if(opts.content){
$(_210).panel("clear");
$(_210).html(opts.content);
$.parser.parse($(_210));
}
function _213(){
if(opts.tools&&typeof opts.tools=="string"){
_212.find(">div.panel-header>div.panel-tool .panel-tool-a").appendTo(opts.tools);
}
_1fd(_212.children("div.panel-header"));
if(opts.title&&!opts.noheader){
var _217=$("<div class=\"panel-header\"></div>").prependTo(_212);
var _218=$("<div class=\"panel-title\"></div>").html(opts.title).appendTo(_217);
if(opts.iconCls){
_218.addClass("panel-with-icon");
$("<div class=\"panel-icon\"></div>").addClass(opts.iconCls).appendTo(_217);
}
var tool=$("<div class=\"panel-tool\"></div>").appendTo(_217);
tool.bind("click",function(e){
e.stopPropagation();
});
if(opts.tools){
if($.isArray(opts.tools)){
for(var i=0;i<opts.tools.length;i++){
var t=$("<a href=\"javascript:void(0)\"></a>").addClass(opts.tools[i].iconCls).appendTo(tool);
if(opts.tools[i].handler){
t.bind("click",eval(opts.tools[i].handler));
}
}
}else{
$(opts.tools).children().each(function(){
$(this).addClass($(this).attr("iconCls")).addClass("panel-tool-a").appendTo(tool);
});
}
}
if(opts.collapsible){
$("<a class=\"panel-tool-collapse\" href=\"javascript:void(0)\"></a>").appendTo(tool).bind("click",function(){
if(opts.collapsed==true){
_235(_210,true);
}else{
_228(_210,true);
}
return false;
});
}
if(opts.minimizable){
$("<a class=\"panel-tool-min\" href=\"javascript:void(0)\"></a>").appendTo(tool).bind("click",function(){
_23b(_210);
return false;
});
}
if(opts.maximizable){
$("<a class=\"panel-tool-max\" href=\"javascript:void(0)\"></a>").appendTo(tool).bind("click",function(){
if(opts.maximized==true){
_23e(_210);
}else{
_227(_210);
}
return false;
});
}
if(opts.closable){
$("<a class=\"panel-tool-close\" href=\"javascript:void(0)\"></a>").appendTo(tool).bind("click",function(){
_229(_210);
return false;
});
}
_212.children("div.panel-body").removeClass("panel-body-noheader");
}else{
_212.children("div.panel-body").addClass("panel-body-noheader");
}
};
function _214(){
if(opts.footer){
$(opts.footer).addClass("panel-footer").appendTo(_212);
$(_210).addClass("panel-body-nobottom");
}else{
_212.children("div.panel-footer").remove();
$(_210).removeClass("panel-body-nobottom");
}
};
};
function _219(_21a,_21b){
var _21c=$.data(_21a,"panel");
var opts=_21c.options;
if(_21d){
opts.queryParams=_21b;
}
if(!opts.href){
return;
}
if(!_21c.isLoaded||!opts.cache){
var _21d=$.extend({},opts.queryParams);
if(opts.onBeforeLoad.call(_21a,_21d)==false){
return;
}
_21c.isLoaded=false;
$(_21a).panel("clear");
if(opts.loadingMessage){
$(_21a).html($("<div class=\"panel-loading\"></div>").html(opts.loadingMessage));
}
opts.loader.call(_21a,_21d,function(data){
var _21e=opts.extractor.call(_21a,data);
$(_21a).html(_21e);
$.parser.parse($(_21a));
opts.onLoad.apply(_21a,arguments);
_21c.isLoaded=true;
},function(){
opts.onLoadError.apply(_21a,arguments);
});
}
};
function _21f(_220){
var t=$(_220);
t.find(".combo-f").each(function(){
$(this).combo("destroy");
});
t.find(".m-btn").each(function(){
$(this).menubutton("destroy");
});
t.find(".s-btn").each(function(){
$(this).splitbutton("destroy");
});
t.find(".tooltip-f").each(function(){
$(this).tooltip("destroy");
});
t.children("div").each(function(){
$(this)._size("unfit");
});
t.empty();
};
function _221(_222){
$(_222).panel("doLayout",true);
};
function _223(_224,_225){
var opts=$.data(_224,"panel").options;
var _226=$.data(_224,"panel").panel;
if(_225!=true){
if(opts.onBeforeOpen.call(_224)==false){
return;
}
}
_226.stop(true,true);
if($.isFunction(opts.openAnimation)){
opts.openAnimation.call(_224,cb);
}else{
switch(opts.openAnimation){
case "slide":
_226.slideDown(opts.openDuration,cb);
break;
case "fade":
_226.fadeIn(opts.openDuration,cb);
break;
case "show":
_226.show(opts.openDuration,cb);
break;
default:
_226.show();
cb();
}
}
function cb(){
opts.closed=false;
opts.minimized=false;
var tool=_226.children("div.panel-header").find("a.panel-tool-restore");
if(tool.length){
opts.maximized=true;
}
opts.onOpen.call(_224);
if(opts.maximized==true){
opts.maximized=false;
_227(_224);
}
if(opts.collapsed==true){
opts.collapsed=false;
_228(_224);
}
if(!opts.collapsed){
_219(_224);
_221(_224);
}
};
};
function _229(_22a,_22b){
var opts=$.data(_22a,"panel").options;
var _22c=$.data(_22a,"panel").panel;
if(_22b!=true){
if(opts.onBeforeClose.call(_22a)==false){
return;
}
}
_22c.stop(true,true);
_22c._size("unfit");
if($.isFunction(opts.closeAnimation)){
opts.closeAnimation.call(_22a,cb);
}else{
switch(opts.closeAnimation){
case "slide":
_22c.slideUp(opts.closeDuration,cb);
break;
case "fade":
_22c.fadeOut(opts.closeDuration,cb);
break;
case "hide":
_22c.hide(opts.closeDuration,cb);
break;
default:
_22c.hide();
cb();
}
}
function cb(){
opts.closed=true;
opts.onClose.call(_22a);
};
};
function _22d(_22e,_22f){
var _230=$.data(_22e,"panel");
var opts=_230.options;
var _231=_230.panel;
if(_22f!=true){
if(opts.onBeforeDestroy.call(_22e)==false){
return;
}
}
$(_22e).panel("clear").panel("clear","footer");
_1fd(_231);
opts.onDestroy.call(_22e);
};
function _228(_232,_233){
var opts=$.data(_232,"panel").options;
var _234=$.data(_232,"panel").panel;
var body=_234.children("div.panel-body");
var tool=_234.children("div.panel-header").find("a.panel-tool-collapse");
if(opts.collapsed==true){
return;
}
body.stop(true,true);
if(opts.onBeforeCollapse.call(_232)==false){
return;
}
tool.addClass("panel-tool-expand");
if(_233==true){
body.slideUp("normal",function(){
opts.collapsed=true;
opts.onCollapse.call(_232);
});
}else{
body.hide();
opts.collapsed=true;
opts.onCollapse.call(_232);
}
};
function _235(_236,_237){
var opts=$.data(_236,"panel").options;
var _238=$.data(_236,"panel").panel;
var body=_238.children("div.panel-body");
var tool=_238.children("div.panel-header").find("a.panel-tool-collapse");
if(opts.collapsed==false){
return;
}
body.stop(true,true);
if(opts.onBeforeExpand.call(_236)==false){
return;
}
tool.removeClass("panel-tool-expand");
if(_237==true){
body.slideDown("normal",function(){
opts.collapsed=false;
opts.onExpand.call(_236);
_219(_236);
_221(_236);
});
}else{
body.show();
opts.collapsed=false;
opts.onExpand.call(_236);
_219(_236);
_221(_236);
}
};
function _227(_239){
var opts=$.data(_239,"panel").options;
var _23a=$.data(_239,"panel").panel;
var tool=_23a.children("div.panel-header").find("a.panel-tool-max");
if(opts.maximized==true){
return;
}
tool.addClass("panel-tool-restore");
if(!$.data(_239,"panel").original){
$.data(_239,"panel").original={width:opts.width,height:opts.height,left:opts.left,top:opts.top,fit:opts.fit};
}
opts.left=0;
opts.top=0;
opts.fit=true;
_1fe(_239);
opts.minimized=false;
opts.maximized=true;
opts.onMaximize.call(_239);
};
function _23b(_23c){
var opts=$.data(_23c,"panel").options;
var _23d=$.data(_23c,"panel").panel;
_23d._size("unfit");
_23d.hide();
opts.minimized=true;
opts.maximized=false;
opts.onMinimize.call(_23c);
};
function _23e(_23f){
var opts=$.data(_23f,"panel").options;
var _240=$.data(_23f,"panel").panel;
var tool=_240.children("div.panel-header").find("a.panel-tool-max");
if(opts.maximized==false){
return;
}
_240.show();
tool.removeClass("panel-tool-restore");
$.extend(opts,$.data(_23f,"panel").original);
_1fe(_23f);
opts.minimized=false;
opts.maximized=false;
$.data(_23f,"panel").original=null;
opts.onRestore.call(_23f);
};
function _241(_242,_243){
$.data(_242,"panel").options.title=_243;
$(_242).panel("header").find("div.panel-title").html(_243);
};
var _244=null;
$(window).unbind(".panel").bind("resize.panel",function(){
if(_244){
clearTimeout(_244);
}
_244=setTimeout(function(){
var _245=$("body.layout");
if(_245.length){
_245.layout("resize");
$("body").children(".easyui-fluid:visible").trigger("_resize");
}else{
$("body").panel("doLayout");
}
_244=null;
},100);
});
$.fn.panel=function(_246,_247){
if(typeof _246=="string"){
return $.fn.panel.methods[_246](this,_247);
}
_246=_246||{};
return this.each(function(){
var _248=$.data(this,"panel");
var opts;
if(_248){
opts=$.extend(_248.options,_246);
_248.isLoaded=false;
}else{
opts=$.extend({},$.fn.panel.defaults,$.fn.panel.parseOptions(this),_246);
$(this).attr("title","");
_248=$.data(this,"panel",{options:opts,panel:_20b(this),isLoaded:false});
}
_20f(this);
if(opts.doSize==true){
_248.panel.css("display","block");
_1fe(this);
}
if(opts.closed==true||opts.minimized==true){
_248.panel.hide();
}else{
_223(this);
}
});
};
$.fn.panel.methods={options:function(jq){
return $.data(jq[0],"panel").options;
},panel:function(jq){
return $.data(jq[0],"panel").panel;
},header:function(jq){
return $.data(jq[0],"panel").panel.find(">div.panel-header");
},footer:function(jq){
return jq.panel("panel").children(".panel-footer");
},body:function(jq){
return $.data(jq[0],"panel").panel.find(">div.panel-body");
},setTitle:function(jq,_249){
return jq.each(function(){
_241(this,_249);
});
},open:function(jq,_24a){
return jq.each(function(){
_223(this,_24a);
});
},close:function(jq,_24b){
return jq.each(function(){
_229(this,_24b);
});
},destroy:function(jq,_24c){
return jq.each(function(){
_22d(this,_24c);
});
},clear:function(jq,type){
return jq.each(function(){
_21f(type=="footer"?$(this).panel("footer"):this);
});
},refresh:function(jq,href){
return jq.each(function(){
var _24d=$.data(this,"panel");
_24d.isLoaded=false;
if(href){
if(typeof href=="string"){
_24d.options.href=href;
}else{
_24d.options.queryParams=href;
}
}
_219(this);
});
},resize:function(jq,_24e){
return jq.each(function(){
_1fe(this,_24e);
});
},doLayout:function(jq,all){
return jq.each(function(){
_24f(this,"body");
_24f($(this).siblings("div.panel-footer")[0],"footer");
function _24f(_250,type){
if(!_250){
return;
}
var _251=_250==$("body")[0];
var s=$(_250).find("div.panel:visible,div.accordion:visible,div.tabs-container:visible,div.layout:visible,.easyui-fluid:visible").filter(function(_252,el){
var p=$(el).parents("div.panel-"+type+":first");
return _251?p.length==0:p[0]==_250;
});
s.trigger("_resize",[all||false]);
};
});
},move:function(jq,_253){
return jq.each(function(){
_207(this,_253);
});
},maximize:function(jq){
return jq.each(function(){
_227(this);
});
},minimize:function(jq){
return jq.each(function(){
_23b(this);
});
},restore:function(jq){
return jq.each(function(){
_23e(this);
});
},collapse:function(jq,_254){
return jq.each(function(){
_228(this,_254);
});
},expand:function(jq,_255){
return jq.each(function(){
_235(this,_255);
});
}};
$.fn.panel.parseOptions=function(_256){
var t=$(_256);
return $.extend({},$.parser.parseOptions(_256,["id","width","height","left","top","title","iconCls","cls","headerCls","bodyCls","tools","href","method",{cache:"boolean",fit:"boolean",border:"boolean",noheader:"boolean"},{collapsible:"boolean",minimizable:"boolean",maximizable:"boolean"},{closable:"boolean",collapsed:"boolean",minimized:"boolean",maximized:"boolean",closed:"boolean"},"openAnimation","closeAnimation",{openDuration:"number",closeDuration:"number"},]),{loadingMessage:(t.attr("loadingMessage")!=undefined?t.attr("loadingMessage"):undefined)});
};
$.fn.panel.defaults={id:null,title:null,iconCls:null,width:"auto",height:"auto",left:null,top:null,cls:null,headerCls:null,bodyCls:null,style:{},href:null,cache:true,fit:false,border:true,doSize:true,noheader:false,content:null,collapsible:false,minimizable:false,maximizable:false,closable:false,collapsed:false,minimized:false,maximized:false,closed:false,openAnimation:false,openDuration:400,closeAnimation:false,closeDuration:400,tools:null,footer:null,queryParams:{},method:"get",href:null,loadingMessage:"Loading...",loader:function(_257,_258,_259){
var opts=$(this).panel("options");
if(!opts.href){
return false;
}
$.ajax({type:opts.method,url:opts.href,cache:false,data:_257,dataType:"html",success:function(data){
_258(data);
},error:function(){
_259.apply(this,arguments);
}});
},extractor:function(data){
var _25a=/<body[^>]*>((.|[\n\r])*)<\/body>/im;
var _25b=_25a.exec(data);
if(_25b){
return _25b[1];
}else{
return data;
}
},onBeforeLoad:function(_25c){
},onLoad:function(){
},onLoadError:function(){
},onBeforeOpen:function(){
},onOpen:function(){
},onBeforeClose:function(){
},onClose:function(){
},onBeforeDestroy:function(){
},onDestroy:function(){
},onResize:function(_25d,_25e){
},onMove:function(left,top){
},onMaximize:function(){
},onRestore:function(){
},onMinimize:function(){
},onBeforeCollapse:function(){
},onBeforeExpand:function(){
},onCollapse:function(){
},onExpand:function(){
}};
})(jQuery);
(function($){
function _25f(_260,_261){
var _262=$.data(_260,"window");
if(_261){
if(_261.left!=null){
_262.options.left=_261.left;
}
if(_261.top!=null){
_262.options.top=_261.top;
}
}
$(_260).panel("move",_262.options);
if(_262.shadow){
_262.shadow.css({left:_262.options.left,top:_262.options.top});
}
};
function _263(_264,_265){
var opts=$.data(_264,"window").options;
var pp=$(_264).window("panel");
var _266=pp._outerWidth();
if(opts.inline){
var _267=pp.parent();
opts.left=Math.ceil((_267.width()-_266)/2+_267.scrollLeft());
}else{
opts.left=Math.ceil(($(window)._outerWidth()-_266)/2+$(document).scrollLeft());
}
if(_265){
_25f(_264);
}
};
function _268(_269,_26a){
var opts=$.data(_269,"window").options;
var pp=$(_269).window("panel");
var _26b=pp._outerHeight();
if(opts.inline){
var _26c=pp.parent();
opts.top=Math.ceil((_26c.height()-_26b)/2+_26c.scrollTop());
}else{
opts.top=Math.ceil(($(window)._outerHeight()-_26b)/2+$(document).scrollTop());
}
if(_26a){
_25f(_269);
}
};
function _26d(_26e){
var _26f=$.data(_26e,"window");
var opts=_26f.options;
var win=$(_26e).panel($.extend({},_26f.options,{border:false,doSize:true,closed:true,cls:"window",headerCls:"window-header",bodyCls:"window-body "+(opts.noheader?"window-body-noheader":""),onBeforeDestroy:function(){
if(opts.onBeforeDestroy.call(_26e)==false){
return false;
}
if(_26f.shadow){
_26f.shadow.remove();
}
if(_26f.mask){
_26f.mask.remove();
}
},onClose:function(){
if(_26f.shadow){
_26f.shadow.hide();
}
if(_26f.mask){
_26f.mask.hide();
}
opts.onClose.call(_26e);
},onOpen:function(){
if(_26f.mask){
_26f.mask.css({display:"block",zIndex:$.fn.window.defaults.zIndex++});
}
if(_26f.shadow){
_26f.shadow.css({display:"block",zIndex:$.fn.window.defaults.zIndex++,left:opts.left,top:opts.top,width:_26f.window._outerWidth(),height:_26f.window._outerHeight()});
}
_26f.window.css("z-index",$.fn.window.defaults.zIndex++);
opts.onOpen.call(_26e);
},onResize:function(_270,_271){
var _272=$(this).panel("options");
$.extend(opts,{width:_272.width,height:_272.height,left:_272.left,top:_272.top});
if(_26f.shadow){
_26f.shadow.css({left:opts.left,top:opts.top,width:_26f.window._outerWidth(),height:_26f.window._outerHeight()});
}
opts.onResize.call(_26e,_270,_271);
},onMinimize:function(){
if(_26f.shadow){
_26f.shadow.hide();
}
if(_26f.mask){
_26f.mask.hide();
}
_26f.options.onMinimize.call(_26e);
},onBeforeCollapse:function(){
if(opts.onBeforeCollapse.call(_26e)==false){
return false;
}
if(_26f.shadow){
_26f.shadow.hide();
}
},onExpand:function(){
if(_26f.shadow){
_26f.shadow.show();
}
opts.onExpand.call(_26e);
}}));
_26f.window=win.panel("panel");
if(_26f.mask){
_26f.mask.remove();
}
if(opts.modal==true){
_26f.mask=$("<div class=\"window-mask\"></div>").insertAfter(_26f.window);
_26f.mask.css({width:(opts.inline?_26f.mask.parent().width():_273().width),height:(opts.inline?_26f.mask.parent().height():_273().height),display:"none"});
}
if(_26f.shadow){
_26f.shadow.remove();
}
if(opts.shadow==true){
_26f.shadow=$("<div class=\"window-shadow\"></div>").insertAfter(_26f.window);
_26f.shadow.css({display:"none"});
}
if(opts.left==null){
_263(_26e);
}
if(opts.top==null){
_268(_26e);
}
_25f(_26e);
if(!opts.closed){
win.window("open");
}
};
function _274(_275){
var _276=$.data(_275,"window");
_276.window.draggable({handle:">div.panel-header>div.panel-title",disabled:_276.options.draggable==false,onStartDrag:function(e){
if(_276.mask){
_276.mask.css("z-index",$.fn.window.defaults.zIndex++);
}
if(_276.shadow){
_276.shadow.css("z-index",$.fn.window.defaults.zIndex++);
}
_276.window.css("z-index",$.fn.window.defaults.zIndex++);
if(!_276.proxy){
_276.proxy=$("<div class=\"window-proxy\"></div>").insertAfter(_276.window);
}
_276.proxy.css({display:"none",zIndex:$.fn.window.defaults.zIndex++,left:e.data.left,top:e.data.top});
_276.proxy._outerWidth(_276.window._outerWidth());
_276.proxy._outerHeight(_276.window._outerHeight());
setTimeout(function(){
if(_276.proxy){
_276.proxy.show();
}
},500);
},onDrag:function(e){
_276.proxy.css({display:"block",left:e.data.left,top:e.data.top});
return false;
},onStopDrag:function(e){
_276.options.left=e.data.left;
_276.options.top=e.data.top;
$(_275).window("move");
_276.proxy.remove();
_276.proxy=null;
}});
_276.window.resizable({disabled:_276.options.resizable==false,onStartResize:function(e){
if(_276.pmask){
_276.pmask.remove();
}
_276.pmask=$("<div class=\"window-proxy-mask\"></div>").insertAfter(_276.window);
_276.pmask.css({zIndex:$.fn.window.defaults.zIndex++,left:e.data.left,top:e.data.top,width:_276.window._outerWidth(),height:_276.window._outerHeight()});
if(_276.proxy){
_276.proxy.remove();
}
_276.proxy=$("<div class=\"window-proxy\"></div>").insertAfter(_276.window);
_276.proxy.css({zIndex:$.fn.window.defaults.zIndex++,left:e.data.left,top:e.data.top});
_276.proxy._outerWidth(e.data.width)._outerHeight(e.data.height);
},onResize:function(e){
_276.proxy.css({left:e.data.left,top:e.data.top});
_276.proxy._outerWidth(e.data.width);
_276.proxy._outerHeight(e.data.height);
return false;
},onStopResize:function(e){
$(_275).window("resize",e.data);
_276.pmask.remove();
_276.pmask=null;
_276.proxy.remove();
_276.proxy=null;
}});
};
function _273(){
if(document.compatMode=="BackCompat"){
return {width:Math.max(document.body.scrollWidth,document.body.clientWidth),height:Math.max(document.body.scrollHeight,document.body.clientHeight)};
}else{
return {width:Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth),height:Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight)};
}
};
$(window).resize(function(){
$("body>div.window-mask").css({width:$(window)._outerWidth(),height:$(window)._outerHeight()});
setTimeout(function(){
$("body>div.window-mask").css({width:_273().width,height:_273().height});
},50);
});
$.fn.window=function(_277,_278){
if(typeof _277=="string"){
var _279=$.fn.window.methods[_277];
if(_279){
return _279(this,_278);
}else{
return this.panel(_277,_278);
}
}
_277=_277||{};
return this.each(function(){
var _27a=$.data(this,"window");
if(_27a){
$.extend(_27a.options,_277);
}else{
_27a=$.data(this,"window",{options:$.extend({},$.fn.window.defaults,$.fn.window.parseOptions(this),_277)});
if(!_27a.options.inline){
document.body.appendChild(this);
}
}
_26d(this);
_274(this);
});
};
$.fn.window.methods={options:function(jq){
var _27b=jq.panel("options");
var _27c=$.data(jq[0],"window").options;
return $.extend(_27c,{closed:_27b.closed,collapsed:_27b.collapsed,minimized:_27b.minimized,maximized:_27b.maximized});
},window:function(jq){
return $.data(jq[0],"window").window;
},move:function(jq,_27d){
return jq.each(function(){
_25f(this,_27d);
});
},hcenter:function(jq){
return jq.each(function(){
_263(this,true);
});
},vcenter:function(jq){
return jq.each(function(){
_268(this,true);
});
},center:function(jq){
return jq.each(function(){
_263(this);
_268(this);
_25f(this);
});
}};
$.fn.window.parseOptions=function(_27e){
return $.extend({},$.fn.panel.parseOptions(_27e),$.parser.parseOptions(_27e,[{draggable:"boolean",resizable:"boolean",shadow:"boolean",modal:"boolean",inline:"boolean"}]));
};
$.fn.window.defaults=$.extend({},$.fn.panel.defaults,{zIndex:9000,draggable:true,resizable:true,shadow:true,modal:false,inline:false,title:"New Window",collapsible:true,minimizable:true,maximizable:true,closable:true,closed:false});
})(jQuery);
(function($){
function _27f(_280){
var opts=$.data(_280,"dialog").options;
opts.inited=false;
$(_280).window($.extend({},opts,{onResize:function(w,h){
if(opts.inited){
_284(this);
opts.onResize.call(this,w,h);
}
}}));
var win=$(_280).window("window");
if(opts.toolbar){
if($.isArray(opts.toolbar)){
$(_280).siblings("div.dialog-toolbar").remove();
var _281=$("<div class=\"dialog-toolbar\"><table cellspacing=\"0\" cellpadding=\"0\"><tr></tr></table></div>").appendTo(win);
var tr=_281.find("tr");
for(var i=0;i<opts.toolbar.length;i++){
var btn=opts.toolbar[i];
if(btn=="-"){
$("<td><div class=\"dialog-tool-separator\"></div></td>").appendTo(tr);
}else{
var td=$("<td></td>").appendTo(tr);
var tool=$("<a href=\"javascript:void(0)\"></a>").appendTo(td);
tool[0].onclick=eval(btn.handler||function(){
});
tool.linkbutton($.extend({},btn,{plain:true}));
}
}
}else{
$(opts.toolbar).addClass("dialog-toolbar").appendTo(win);
$(opts.toolbar).show();
}
}else{
$(_280).siblings("div.dialog-toolbar").remove();
}
if(opts.buttons){
if($.isArray(opts.buttons)){
$(_280).siblings("div.dialog-button").remove();
var _282=$("<div class=\"dialog-button\"></div>").appendTo(win);
for(var i=0;i<opts.buttons.length;i++){
var p=opts.buttons[i];
var _283=$("<a href=\"javascript:void(0)\"></a>").appendTo(_282);
if(p.handler){
_283[0].onclick=p.handler;
}
_283.linkbutton(p);
}
}else{
$(opts.buttons).addClass("dialog-button").appendTo(win);
$(opts.buttons).show();
}
}else{
$(_280).siblings("div.dialog-button").remove();
}
opts.inited=true;
win.show();
$(_280).window("resize");
if(opts.closed){
win.hide();
}
};
function _284(_285,_286){
var t=$(_285);
var opts=t.dialog("options");
var _287=opts.noheader;
var tb=t.siblings(".dialog-toolbar");
var bb=t.siblings(".dialog-button");
tb.insertBefore(_285).css({position:"relative",borderTopWidth:(_287?1:0),top:(_287?tb.length:0)});
bb.insertAfter(_285).css({position:"relative",top:-1});
if(!isNaN(parseInt(opts.height))){
t._outerHeight(t._outerHeight()-tb._outerHeight()-bb._outerHeight());
}
tb.add(bb)._outerWidth(t._outerWidth());
var _288=$.data(_285,"window").shadow;
if(_288){
var cc=t.panel("panel");
_288.css({width:cc._outerWidth(),height:cc._outerHeight()});
}
};
$.fn.dialog=function(_289,_28a){
if(typeof _289=="string"){
var _28b=$.fn.dialog.methods[_289];
if(_28b){
return _28b(this,_28a);
}else{
return this.window(_289,_28a);
}
}
_289=_289||{};
return this.each(function(){
var _28c=$.data(this,"dialog");
if(_28c){
$.extend(_28c.options,_289);
}else{
$.data(this,"dialog",{options:$.extend({},$.fn.dialog.defaults,$.fn.dialog.parseOptions(this),_289)});
}
_27f(this);
});
};
$.fn.dialog.methods={options:function(jq){
var _28d=$.data(jq[0],"dialog").options;
var _28e=jq.panel("options");
$.extend(_28d,{width:_28e.width,height:_28e.height,left:_28e.left,top:_28e.top,closed:_28e.closed,collapsed:_28e.collapsed,minimized:_28e.minimized,maximized:_28e.maximized});
return _28d;
},dialog:function(jq){
return jq.window("window");
}};
$.fn.dialog.parseOptions=function(_28f){
return $.extend({},$.fn.window.parseOptions(_28f),$.parser.parseOptions(_28f,["toolbar","buttons"]));
};
$.fn.dialog.defaults=$.extend({},$.fn.window.defaults,{title:"New Dialog",collapsible:false,minimizable:false,maximizable:false,resizable:false,toolbar:null,buttons:null});
})(jQuery);
(function($){
function show(el,type,_290,_291){
var win=$(el).window("window");
if(!win){
return;
}
switch(type){
case null:
win.show();
break;
case "slide":
win.slideDown(_290);
break;
case "fade":
win.fadeIn(_290);
break;
case "show":
win.show(_290);
break;
}
var _292=null;
if(_291>0){
_292=setTimeout(function(){
hide(el,type,_290);
},_291);
}
win.hover(function(){
if(_292){
clearTimeout(_292);
}
},function(){
if(_291>0){
_292=setTimeout(function(){
hide(el,type,_290);
},_291);
}
});
};
function hide(el,type,_293){
if(el.locked==true){
return;
}
el.locked=true;
var win=$(el).window("window");
if(!win){
return;
}
switch(type){
case null:
win.hide();
break;
case "slide":
win.slideUp(_293);
break;
case "fade":
win.fadeOut(_293);
break;
case "show":
win.hide(_293);
break;
}
setTimeout(function(){
$(el).window("destroy");
},_293);
};
function _294(_295){
var opts=$.extend({},$.fn.window.defaults,{collapsible:false,minimizable:false,maximizable:false,shadow:false,draggable:false,resizable:false,closed:true,style:{left:"",top:"",right:0,zIndex:$.fn.window.defaults.zIndex++,bottom:-document.body.scrollTop-document.documentElement.scrollTop},onBeforeOpen:function(){
show(this,opts.showType,opts.showSpeed,opts.timeout);
return false;
},onBeforeClose:function(){
hide(this,opts.showType,opts.showSpeed);
return false;
}},{title:"",width:250,height:100,showType:"slide",showSpeed:600,msg:"",timeout:4000},_295);
opts.style.zIndex=$.fn.window.defaults.zIndex++;
var win=$("<div class=\"messager-body\"></div>").html(opts.msg).appendTo("body");
win.window(opts);
win.window("window").css(opts.style);
win.window("open");
return win;
};
function _296(_297,_298,_299){
var win=$("<div class=\"messager-body\"></div>").appendTo("body");
win.append(_298);
if(_299){
var tb=$("<div class=\"messager-button\"></div>").appendTo(win);
for(var _29a in _299){
$("<a></a>").attr("href","javascript:void(0)").text(_29a).css("margin-left",10).bind("click",eval(_299[_29a])).appendTo(tb).linkbutton();
}
}
win.window({title:_297,noheader:(_297?false:true),width:300,height:"auto",modal:true,collapsible:false,minimizable:false,maximizable:false,resizable:false,onClose:function(){
setTimeout(function(){
win.window("destroy");
},100);
}});
win.window("window").addClass("messager-window");
win.children("div.messager-button").children("a:first").focus();
return win;
};
$.messager={show:function(_29b){
return _294(_29b);
},alert:function(_29c,msg,icon,fn){
var _29d="<div>"+msg+"</div>";
switch(icon){
case "error":
_29d="<div class=\"messager-icon messager-error\"></div>"+_29d;
break;
case "info":
_29d="<div class=\"messager-icon messager-info\"></div>"+_29d;
break;
case "question":
_29d="<div class=\"messager-icon messager-question\"></div>"+_29d;
break;
case "warning":
_29d="<div class=\"messager-icon messager-warning\"></div>"+_29d;
break;
}
_29d+="<div style=\"clear:both;\"/>";
var _29e={};
_29e[$.messager.defaults.ok]=function(){
win.window("close");
if(fn){
fn();
return false;
}
};
var win=_296(_29c,_29d,_29e);
return win;
},confirm:function(_29f,msg,fn){
var _2a0="<div class=\"messager-icon messager-question\"></div>"+"<div>"+msg+"</div>"+"<div style=\"clear:both;\"/>";
var _2a1={};
_2a1[$.messager.defaults.ok]=function(){
win.window("close");
if(fn){
fn(true);
return false;
}
};
_2a1[$.messager.defaults.cancel]=function(){
win.window("close");
if(fn){
fn(false);
return false;
}
};
var win=_296(_29f,_2a0,_2a1);
return win;
},prompt:function(_2a2,msg,fn){
var _2a3="<div class=\"messager-icon messager-question\"></div>"+"<div>"+msg+"</div>"+"<br/>"+"<div style=\"clear:both;\"/>"+"<div><input class=\"messager-input\" type=\"text\"/></div>";
var _2a4={};
_2a4[$.messager.defaults.ok]=function(){
win.window("close");
if(fn){
fn($(".messager-input",win).val());
return false;
}
};
_2a4[$.messager.defaults.cancel]=function(){
win.window("close");
if(fn){
fn();
return false;
}
};
var win=_296(_2a2,_2a3,_2a4);
win.children("input.messager-input").focus();
return win;
},progress:function(_2a5){
var _2a6={bar:function(){
return $("body>div.messager-window").find("div.messager-p-bar");
},close:function(){
var win=$("body>div.messager-window>div.messager-body:has(div.messager-progress)");
if(win.length){
win.window("close");
}
}};
if(typeof _2a5=="string"){
var _2a7=_2a6[_2a5];
return _2a7();
}
var opts=$.extend({title:"",msg:"",text:undefined,interval:300},_2a5||{});
var _2a8="<div class=\"messager-progress\"><div class=\"messager-p-msg\"></div><div class=\"messager-p-bar\"></div></div>";
var win=_296(opts.title,_2a8,null);
win.find("div.messager-p-msg").html(opts.msg);
var bar=win.find("div.messager-p-bar");
bar.progressbar({text:opts.text});
win.window({closable:false,onClose:function(){
if(this.timer){
clearInterval(this.timer);
}
$(this).window("destroy");
}});
if(opts.interval){
win[0].timer=setInterval(function(){
var v=bar.progressbar("getValue");
v+=10;
if(v>100){
v=0;
}
bar.progressbar("setValue",v);
},opts.interval);
}
return win;
}};
$.messager.defaults={ok:"Ok",cancel:"Cancel"};
})(jQuery);
(function($){
function _2a9(_2aa,_2ab){
var _2ac=$.data(_2aa,"accordion");
var opts=_2ac.options;
var _2ad=_2ac.panels;
var cc=$(_2aa);
if(_2ab){
$.extend(opts,{width:_2ab.width,height:_2ab.height});
}
cc._size(opts);
var _2ae=0;
var _2af="auto";
var _2b0=cc.find(">div.panel>div.accordion-header");
if(_2b0.length){
_2ae=$(_2b0[0]).css("height","")._outerHeight();
}
if(!isNaN(parseInt(opts.height))){
_2af=cc.height()-_2ae*_2b0.length;
}
_2b1(true,_2af-_2b1(false)+1);
function _2b1(_2b2,_2b3){
var _2b4=0;
for(var i=0;i<_2ad.length;i++){
var p=_2ad[i];
var h=p.panel("header")._outerHeight(_2ae);
if(p.panel("options").collapsible==_2b2){
var _2b5=isNaN(_2b3)?undefined:(_2b3+_2ae*h.length);
p.panel("resize",{width:cc.width(),height:(_2b2?_2b5:undefined)});
_2b4+=p.panel("panel").outerHeight()-_2ae*h.length;
}
}
return _2b4;
};
};
function _2b6(_2b7,_2b8,_2b9,all){
var _2ba=$.data(_2b7,"accordion").panels;
var pp=[];
for(var i=0;i<_2ba.length;i++){
var p=_2ba[i];
if(_2b8){
if(p.panel("options")[_2b8]==_2b9){
pp.push(p);
}
}else{
if(p[0]==$(_2b9)[0]){
return i;
}
}
}
if(_2b8){
return all?pp:(pp.length?pp[0]:null);
}else{
return -1;
}
};
function _2bb(_2bc){
return _2b6(_2bc,"collapsed",false,true);
};
function _2bd(_2be){
var pp=_2bb(_2be);
return pp.length?pp[0]:null;
};
function _2bf(_2c0,_2c1){
return _2b6(_2c0,null,_2c1);
};
function _2c2(_2c3,_2c4){
var _2c5=$.data(_2c3,"accordion").panels;
if(typeof _2c4=="number"){
if(_2c4<0||_2c4>=_2c5.length){
return null;
}else{
return _2c5[_2c4];
}
}
return _2b6(_2c3,"title",_2c4);
};
function _2c6(_2c7){
var opts=$.data(_2c7,"accordion").options;
var cc=$(_2c7);
if(opts.border){
cc.removeClass("accordion-noborder");
}else{
cc.addClass("accordion-noborder");
}
};
function init(_2c8){
var _2c9=$.data(_2c8,"accordion");
var cc=$(_2c8);
cc.addClass("accordion");
_2c9.panels=[];
cc.children("div").each(function(){
var opts=$.extend({},$.parser.parseOptions(this),{selected:($(this).attr("selected")?true:undefined)});
var pp=$(this);
_2c9.panels.push(pp);
_2cb(_2c8,pp,opts);
});
cc.bind("_resize",function(e,_2ca){
if($(this).hasClass("easyui-fluid")||_2ca){
_2a9(_2c8);
}
return false;
});
};
function _2cb(_2cc,pp,_2cd){
var opts=$.data(_2cc,"accordion").options;
pp.panel($.extend({},{collapsible:true,minimizable:false,maximizable:false,closable:false,doSize:false,collapsed:true,headerCls:"accordion-header",bodyCls:"accordion-body"},_2cd,{onBeforeExpand:function(){
if(_2cd.onBeforeExpand){
if(_2cd.onBeforeExpand.call(this)==false){
return false;
}
}
if(!opts.multiple){
var all=$.grep(_2bb(_2cc),function(p){
return p.panel("options").collapsible;
});
for(var i=0;i<all.length;i++){
_2d6(_2cc,_2bf(_2cc,all[i]));
}
}
var _2ce=$(this).panel("header");
_2ce.addClass("accordion-header-selected");
_2ce.find(".accordion-collapse").removeClass("accordion-expand");
},onExpand:function(){
if(_2cd.onExpand){
_2cd.onExpand.call(this);
}
opts.onSelect.call(_2cc,$(this).panel("options").title,_2bf(_2cc,this));
},onBeforeCollapse:function(){
if(_2cd.onBeforeCollapse){
if(_2cd.onBeforeCollapse.call(this)==false){
return false;
}
}
var _2cf=$(this).panel("header");
_2cf.removeClass("accordion-header-selected");
_2cf.find(".accordion-collapse").addClass("accordion-expand");
},onCollapse:function(){
if(_2cd.onCollapse){
_2cd.onCollapse.call(this);
}
opts.onUnselect.call(_2cc,$(this).panel("options").title,_2bf(_2cc,this));
}}));
var _2d0=pp.panel("header");
var tool=_2d0.children("div.panel-tool");
tool.children("a.panel-tool-collapse").hide();
var t=$("<a href=\"javascript:void(0)\"></a>").addClass("accordion-collapse accordion-expand").appendTo(tool);
t.bind("click",function(){
var _2d1=_2bf(_2cc,pp);
if(pp.panel("options").collapsed){
_2d2(_2cc,_2d1);
}else{
_2d6(_2cc,_2d1);
}
return false;
});
pp.panel("options").collapsible?t.show():t.hide();
_2d0.click(function(){
$(this).find("a.accordion-collapse:visible").triggerHandler("click");
return false;
});
};
function _2d2(_2d3,_2d4){
var p=_2c2(_2d3,_2d4);
if(!p){
return;
}
_2d5(_2d3);
var opts=$.data(_2d3,"accordion").options;
p.panel("expand",opts.animate);
};
function _2d6(_2d7,_2d8){
var p=_2c2(_2d7,_2d8);
if(!p){
return;
}
_2d5(_2d7);
var opts=$.data(_2d7,"accordion").options;
p.panel("collapse",opts.animate);
};
function _2d9(_2da){
var opts=$.data(_2da,"accordion").options;
var p=_2b6(_2da,"selected",true);
if(p){
_2db(_2bf(_2da,p));
}else{
_2db(opts.selected);
}
function _2db(_2dc){
var _2dd=opts.animate;
opts.animate=false;
_2d2(_2da,_2dc);
opts.animate=_2dd;
};
};
function _2d5(_2de){
var _2df=$.data(_2de,"accordion").panels;
for(var i=0;i<_2df.length;i++){
_2df[i].stop(true,true);
}
};
function add(_2e0,_2e1){
var _2e2=$.data(_2e0,"accordion");
var opts=_2e2.options;
var _2e3=_2e2.panels;
if(_2e1.selected==undefined){
_2e1.selected=true;
}
_2d5(_2e0);
var pp=$("<div></div>").appendTo(_2e0);
_2e3.push(pp);
_2cb(_2e0,pp,_2e1);
_2a9(_2e0);
opts.onAdd.call(_2e0,_2e1.title,_2e3.length-1);
if(_2e1.selected){
_2d2(_2e0,_2e3.length-1);
}
};
function _2e4(_2e5,_2e6){
var _2e7=$.data(_2e5,"accordion");
var opts=_2e7.options;
var _2e8=_2e7.panels;
_2d5(_2e5);
var _2e9=_2c2(_2e5,_2e6);
var _2ea=_2e9.panel("options").title;
var _2eb=_2bf(_2e5,_2e9);
if(!_2e9){
return;
}
if(opts.onBeforeRemove.call(_2e5,_2ea,_2eb)==false){
return;
}
_2e8.splice(_2eb,1);
_2e9.panel("destroy");
if(_2e8.length){
_2a9(_2e5);
var curr=_2bd(_2e5);
if(!curr){
_2d2(_2e5,0);
}
}
opts.onRemove.call(_2e5,_2ea,_2eb);
};
$.fn.accordion=function(_2ec,_2ed){
if(typeof _2ec=="string"){
return $.fn.accordion.methods[_2ec](this,_2ed);
}
_2ec=_2ec||{};
return this.each(function(){
var _2ee=$.data(this,"accordion");
if(_2ee){
$.extend(_2ee.options,_2ec);
}else{
$.data(this,"accordion",{options:$.extend({},$.fn.accordion.defaults,$.fn.accordion.parseOptions(this),_2ec),accordion:$(this).addClass("accordion"),panels:[]});
init(this);
}
_2c6(this);
_2a9(this);
_2d9(this);
});
};
$.fn.accordion.methods={options:function(jq){
return $.data(jq[0],"accordion").options;
},panels:function(jq){
return $.data(jq[0],"accordion").panels;
},resize:function(jq,_2ef){
return jq.each(function(){
_2a9(this,_2ef);
});
},getSelections:function(jq){
return _2bb(jq[0]);
},getSelected:function(jq){
return _2bd(jq[0]);
},getPanel:function(jq,_2f0){
return _2c2(jq[0],_2f0);
},getPanelIndex:function(jq,_2f1){
return _2bf(jq[0],_2f1);
},select:function(jq,_2f2){
return jq.each(function(){
_2d2(this,_2f2);
});
},unselect:function(jq,_2f3){
return jq.each(function(){
_2d6(this,_2f3);
});
},add:function(jq,_2f4){
return jq.each(function(){
add(this,_2f4);
});
},remove:function(jq,_2f5){
return jq.each(function(){
_2e4(this,_2f5);
});
}};
$.fn.accordion.parseOptions=function(_2f6){
var t=$(_2f6);
return $.extend({},$.parser.parseOptions(_2f6,["width","height",{fit:"boolean",border:"boolean",animate:"boolean",multiple:"boolean",selected:"number"}]));
};
$.fn.accordion.defaults={width:"auto",height:"auto",fit:false,border:true,animate:true,multiple:false,selected:0,onSelect:function(_2f7,_2f8){
},onUnselect:function(_2f9,_2fa){
},onAdd:function(_2fb,_2fc){
},onBeforeRemove:function(_2fd,_2fe){
},onRemove:function(_2ff,_300){
}};
})(jQuery);
(function($){
function _301(_302){
var opts=$.data(_302,"tabs").options;
if(opts.tabPosition=="left"||opts.tabPosition=="right"||!opts.showHeader){
return;
}
var _303=$(_302).children("div.tabs-header");
var tool=_303.children("div.tabs-tool");
var _304=_303.children("div.tabs-scroller-left");
var _305=_303.children("div.tabs-scroller-right");
var wrap=_303.children("div.tabs-wrap");
var _306=_303.outerHeight();
if(opts.plain){
_306-=_306-_303.height();
}
tool._outerHeight(_306);
var _307=0;
$("ul.tabs li",_303).each(function(){
_307+=$(this).outerWidth(true);
});
var _308=_303.width()-tool._outerWidth();
if(_307>_308){
_304.add(_305).show()._outerHeight(_306);
if(opts.toolPosition=="left"){
tool.css({left:_304.outerWidth(),right:""});
wrap.css({marginLeft:_304.outerWidth()+tool._outerWidth(),marginRight:_305._outerWidth(),width:_308-_304.outerWidth()-_305.outerWidth()});
}else{
tool.css({left:"",right:_305.outerWidth()});
wrap.css({marginLeft:_304.outerWidth(),marginRight:_305.outerWidth()+tool._outerWidth(),width:_308-_304.outerWidth()-_305.outerWidth()});
}
}else{
_304.add(_305).hide();
if(opts.toolPosition=="left"){
tool.css({left:0,right:""});
wrap.css({marginLeft:tool._outerWidth(),marginRight:0,width:_308});
}else{
tool.css({left:"",right:0});
wrap.css({marginLeft:0,marginRight:tool._outerWidth(),width:_308});
}
}
};
function _309(_30a){
var opts=$.data(_30a,"tabs").options;
var _30b=$(_30a).children("div.tabs-header");
if(opts.tools){
if(typeof opts.tools=="string"){
$(opts.tools).addClass("tabs-tool").appendTo(_30b);
$(opts.tools).show();
}else{
_30b.children("div.tabs-tool").remove();
var _30c=$("<div class=\"tabs-tool\"><table cellspacing=\"0\" cellpadding=\"0\" style=\"height:100%\"><tr></tr></table></div>").appendTo(_30b);
var tr=_30c.find("tr");
for(var i=0;i<opts.tools.length;i++){
var td=$("<td></td>").appendTo(tr);
var tool=$("<a href=\"javascript:void(0);\"></a>").appendTo(td);
tool[0].onclick=eval(opts.tools[i].handler||function(){
});
tool.linkbutton($.extend({},opts.tools[i],{plain:true}));
}
}
}else{
_30b.children("div.tabs-tool").remove();
}
};
function _30d(_30e,_30f){
var _310=$.data(_30e,"tabs");
var opts=_310.options;
var cc=$(_30e);
if(_30f){
$.extend(opts,{width:_30f.width,height:_30f.height});
}
cc._size(opts);
var _311=cc.children("div.tabs-header");
var _312=cc.children("div.tabs-panels");
var wrap=_311.find("div.tabs-wrap");
var ul=wrap.find(".tabs");
for(var i=0;i<_310.tabs.length;i++){
var _313=_310.tabs[i].panel("options");
var p_t=_313.tab.find("a.tabs-inner");
var _314=parseInt(_313.tabWidth||opts.tabWidth)||undefined;
if(_314){
p_t._outerWidth(_314);
}else{
p_t.css("width","");
}
p_t._outerHeight(opts.tabHeight);
p_t.css("lineHeight",p_t.height()+"px");
}
if(opts.tabPosition=="left"||opts.tabPosition=="right"){
_311._outerWidth(opts.showHeader?opts.headerWidth:0);
_312._outerWidth(cc.width()-_311.outerWidth());
_311.add(_312)._outerHeight(opts.height);
wrap._outerWidth(_311.width());
ul._outerWidth(wrap.width()).css("height","");
}else{
var lrt=_311.children("div.tabs-scroller-left,div.tabs-scroller-right,div.tabs-tool");
_311._outerWidth(opts.width).css("height","");
if(opts.showHeader){
_311.css("background-color","");
wrap.css("height","");
lrt.show();
}else{
_311.css("background-color","transparent");
_311._outerHeight(0);
wrap._outerHeight(0);
lrt.hide();
}
ul._outerHeight(opts.tabHeight).css("width","");
_301(_30e);
_312._size("height",isNaN(opts.height)?"":(opts.height-_311.outerHeight()));
_312._size("width",isNaN(opts.width)?"":opts.width);
}
};
function _315(_316){
var opts=$.data(_316,"tabs").options;
var tab=_317(_316);
if(tab){
var _318=$(_316).children("div.tabs-panels");
var _319=opts.width=="auto"?"auto":_318.width();
var _31a=opts.height=="auto"?"auto":_318.height();
tab.panel("resize",{width:_319,height:_31a});
}
};
function _31b(_31c){
var tabs=$.data(_31c,"tabs").tabs;
var cc=$(_31c);
cc.addClass("tabs-container");
var pp=$("<div class=\"tabs-panels\"></div>").insertBefore(cc);
cc.children("div").each(function(){
pp[0].appendChild(this);
});
cc[0].appendChild(pp[0]);
$("<div class=\"tabs-header\">"+"<div class=\"tabs-scroller-left\"></div>"+"<div class=\"tabs-scroller-right\"></div>"+"<div class=\"tabs-wrap\">"+"<ul class=\"tabs\"></ul>"+"</div>"+"</div>").prependTo(_31c);
cc.children("div.tabs-panels").children("div").each(function(i){
var opts=$.extend({},$.parser.parseOptions(this),{selected:($(this).attr("selected")?true:undefined)});
var pp=$(this);
tabs.push(pp);
_329(_31c,pp,opts);
});
cc.children("div.tabs-header").find(".tabs-scroller-left, .tabs-scroller-right").hover(function(){
$(this).addClass("tabs-scroller-over");
},function(){
$(this).removeClass("tabs-scroller-over");
});
cc.bind("_resize",function(e,_31d){
if($(this).hasClass("easyui-fluid")||_31d){
_30d(_31c);
_315(_31c);
}
return false;
});
};
function _31e(_31f){
var _320=$.data(_31f,"tabs");
var opts=_320.options;
$(_31f).children("div.tabs-header").unbind().bind("click",function(e){
if($(e.target).hasClass("tabs-scroller-left")){
$(_31f).tabs("scrollBy",-opts.scrollIncrement);
}else{
if($(e.target).hasClass("tabs-scroller-right")){
$(_31f).tabs("scrollBy",opts.scrollIncrement);
}else{
var li=$(e.target).closest("li");
if(li.hasClass("tabs-disabled")){
return;
}
var a=$(e.target).closest("a.tabs-close");
if(a.length){
_33b(_31f,_321(li));
}else{
if(li.length){
var _322=_321(li);
var _323=_320.tabs[_322].panel("options");
if(_323.collapsible){
_323.closed?_331(_31f,_322):_352(_31f,_322);
}else{
_331(_31f,_322);
}
}
}
}
}
}).bind("contextmenu",function(e){
var li=$(e.target).closest("li");
if(li.hasClass("tabs-disabled")){
return;
}
if(li.length){
opts.onContextMenu.call(_31f,e,li.find("span.tabs-title").html(),_321(li));
}
});
function _321(li){
var _324=0;
li.parent().children("li").each(function(i){
if(li[0]==this){
_324=i;
return false;
}
});
return _324;
};
};
function _325(_326){
var opts=$.data(_326,"tabs").options;
var _327=$(_326).children("div.tabs-header");
var _328=$(_326).children("div.tabs-panels");
_327.removeClass("tabs-header-top tabs-header-bottom tabs-header-left tabs-header-right");
_328.removeClass("tabs-panels-top tabs-panels-bottom tabs-panels-left tabs-panels-right");
if(opts.tabPosition=="top"){
_327.insertBefore(_328);
}else{
if(opts.tabPosition=="bottom"){
_327.insertAfter(_328);
_327.addClass("tabs-header-bottom");
_328.addClass("tabs-panels-top");
}else{
if(opts.tabPosition=="left"){
_327.addClass("tabs-header-left");
_328.addClass("tabs-panels-right");
}else{
if(opts.tabPosition=="right"){
_327.addClass("tabs-header-right");
_328.addClass("tabs-panels-left");
}
}
}
}
if(opts.plain==true){
_327.addClass("tabs-header-plain");
}else{
_327.removeClass("tabs-header-plain");
}
if(opts.border==true){
_327.removeClass("tabs-header-noborder");
_328.removeClass("tabs-panels-noborder");
}else{
_327.addClass("tabs-header-noborder");
_328.addClass("tabs-panels-noborder");
}
};
function _329(_32a,pp,_32b){
var _32c=$.data(_32a,"tabs");
_32b=_32b||{};
pp.panel($.extend({},_32b,{border:false,noheader:true,closed:true,doSize:false,iconCls:(_32b.icon?_32b.icon:undefined),onLoad:function(){
if(_32b.onLoad){
_32b.onLoad.call(this,arguments);
}
_32c.options.onLoad.call(_32a,$(this));
}}));
var opts=pp.panel("options");
var tabs=$(_32a).children("div.tabs-header").find("ul.tabs");
opts.tab=$("<li></li>").appendTo(tabs);
opts.tab.append("<a href=\"javascript:void(0)\" class=\"tabs-inner\">"+"<span class=\"tabs-title\"></span>"+"<span class=\"tabs-icon\"></span>"+"</a>");
$(_32a).tabs("update",{tab:pp,options:opts,type:"header"});
};
function _32d(_32e,_32f){
var _330=$.data(_32e,"tabs");
var opts=_330.options;
var tabs=_330.tabs;
if(_32f.selected==undefined){
_32f.selected=true;
}
var pp=$("<div></div>").appendTo($(_32e).children("div.tabs-panels"));
tabs.push(pp);
_329(_32e,pp,_32f);
opts.onAdd.call(_32e,_32f.title,tabs.length-1);
_30d(_32e);
if(_32f.selected){
_331(_32e,tabs.length-1);
}
};
function _332(_333,_334){
_334.type=_334.type||"all";
var _335=$.data(_333,"tabs").selectHis;
var pp=_334.tab;
var _336=pp.panel("options").title;
if(_334.type=="all"||_334=="body"){
pp.panel($.extend({},_334.options,{iconCls:(_334.options.icon?_334.options.icon:undefined)}));
}
if(_334.type=="all"||_334.type=="header"){
var opts=pp.panel("options");
var tab=opts.tab;
var _337=tab.find("span.tabs-title");
var _338=tab.find("span.tabs-icon");
_337.html(opts.title);
_338.attr("class","tabs-icon");
tab.find("a.tabs-close").remove();
if(opts.closable){
_337.addClass("tabs-closable");
$("<a href=\"javascript:void(0)\" class=\"tabs-close\"></a>").appendTo(tab);
}else{
_337.removeClass("tabs-closable");
}
if(opts.iconCls){
_337.addClass("tabs-with-icon");
_338.addClass(opts.iconCls);
}else{
_337.removeClass("tabs-with-icon");
}
if(_336!=opts.title){
for(var i=0;i<_335.length;i++){
if(_335[i]==_336){
_335[i]=opts.title;
}
}
}
tab.find("span.tabs-p-tool").remove();
if(opts.tools){
var _339=$("<span class=\"tabs-p-tool\"></span>").insertAfter(tab.find("a.tabs-inner"));
if($.isArray(opts.tools)){
for(var i=0;i<opts.tools.length;i++){
var t=$("<a href=\"javascript:void(0)\"></a>").appendTo(_339);
t.addClass(opts.tools[i].iconCls);
if(opts.tools[i].handler){
t.bind("click",{handler:opts.tools[i].handler},function(e){
if($(this).parents("li").hasClass("tabs-disabled")){
return;
}
e.data.handler.call(this);
});
}
}
}else{
$(opts.tools).children().appendTo(_339);
}
var pr=_339.children().length*12;
if(opts.closable){
pr+=8;
}else{
pr-=3;
_339.css("right","5px");
}
_337.css("padding-right",pr+"px");
}
}
_30d(_333);
$.data(_333,"tabs").options.onUpdate.call(_333,opts.title,_33a(_333,pp));
};
function _33b(_33c,_33d){
var opts=$.data(_33c,"tabs").options;
var tabs=$.data(_33c,"tabs").tabs;
var _33e=$.data(_33c,"tabs").selectHis;
if(!_33f(_33c,_33d)){
return;
}
var tab=_340(_33c,_33d);
var _341=tab.panel("options").title;
var _342=_33a(_33c,tab);
if(opts.onBeforeClose.call(_33c,_341,_342)==false){
return;
}
var tab=_340(_33c,_33d,true);
tab.panel("options").tab.remove();
tab.panel("destroy");
opts.onClose.call(_33c,_341,_342);
_30d(_33c);
for(var i=0;i<_33e.length;i++){
if(_33e[i]==_341){
_33e.splice(i,1);
i--;
}
}
var _343=_33e.pop();
if(_343){
_331(_33c,_343);
}else{
if(tabs.length){
_331(_33c,0);
}
}
};
function _340(_344,_345,_346){
var tabs=$.data(_344,"tabs").tabs;
if(typeof _345=="number"){
if(_345<0||_345>=tabs.length){
return null;
}else{
var tab=tabs[_345];
if(_346){
tabs.splice(_345,1);
}
return tab;
}
}
for(var i=0;i<tabs.length;i++){
var tab=tabs[i];
if(tab.panel("options").title==_345){
if(_346){
tabs.splice(i,1);
}
return tab;
}
}
return null;
};
function _33a(_347,tab){
var tabs=$.data(_347,"tabs").tabs;
for(var i=0;i<tabs.length;i++){
if(tabs[i][0]==$(tab)[0]){
return i;
}
}
return -1;
};
function _317(_348){
var tabs=$.data(_348,"tabs").tabs;
for(var i=0;i<tabs.length;i++){
var tab=tabs[i];
if(tab.panel("options").closed==false){
return tab;
}
}
return null;
};
function _349(_34a){
var _34b=$.data(_34a,"tabs");
var tabs=_34b.tabs;
for(var i=0;i<tabs.length;i++){
if(tabs[i].panel("options").selected){
_331(_34a,i);
return;
}
}
_331(_34a,_34b.options.selected);
};
function _331(_34c,_34d){
var _34e=$.data(_34c,"tabs");
var opts=_34e.options;
var tabs=_34e.tabs;
var _34f=_34e.selectHis;
if(tabs.length==0){
return;
}
var _350=_340(_34c,_34d);
if(!_350){
return;
}
var _351=_317(_34c);
if(_351){
if(_350[0]==_351[0]){
_315(_34c);
return;
}
_352(_34c,_33a(_34c,_351));
if(!_351.panel("options").closed){
return;
}
}
_350.panel("open");
var _353=_350.panel("options").title;
_34f.push(_353);
var tab=_350.panel("options").tab;
tab.addClass("tabs-selected");
var wrap=$(_34c).find(">div.tabs-header>div.tabs-wrap");
var left=tab.position().left;
var _354=left+tab.outerWidth();
if(left<0||_354>wrap.width()){
var _355=left-(wrap.width()-tab.width())/2;
$(_34c).tabs("scrollBy",_355);
}else{
$(_34c).tabs("scrollBy",0);
}
_315(_34c);
opts.onSelect.call(_34c,_353,_33a(_34c,_350));
};
function _352(_356,_357){
var _358=$.data(_356,"tabs");
var p=_340(_356,_357);
if(p){
var opts=p.panel("options");
if(!opts.closed){
p.panel("close");
if(opts.closed){
opts.tab.removeClass("tabs-selected");
_358.options.onUnselect.call(_356,opts.title,_33a(_356,p));
}
}
}
};
function _33f(_359,_35a){
return _340(_359,_35a)!=null;
};
function _35b(_35c,_35d){
var opts=$.data(_35c,"tabs").options;
opts.showHeader=_35d;
$(_35c).tabs("resize");
};
$.fn.tabs=function(_35e,_35f){
if(typeof _35e=="string"){
return $.fn.tabs.methods[_35e](this,_35f);
}
_35e=_35e||{};
return this.each(function(){
var _360=$.data(this,"tabs");
if(_360){
$.extend(_360.options,_35e);
}else{
$.data(this,"tabs",{options:$.extend({},$.fn.tabs.defaults,$.fn.tabs.parseOptions(this),_35e),tabs:[],selectHis:[]});
_31b(this);
}
_309(this);
_325(this);
_30d(this);
_31e(this);
_349(this);
});
};
$.fn.tabs.methods={options:function(jq){
var cc=jq[0];
var opts=$.data(cc,"tabs").options;
var s=_317(cc);
opts.selected=s?_33a(cc,s):-1;
return opts;
},tabs:function(jq){
return $.data(jq[0],"tabs").tabs;
},resize:function(jq,_361){
return jq.each(function(){
_30d(this,_361);
_315(this);
});
},add:function(jq,_362){
return jq.each(function(){
_32d(this,_362);
});
},close:function(jq,_363){
return jq.each(function(){
_33b(this,_363);
});
},getTab:function(jq,_364){
return _340(jq[0],_364);
},getTabIndex:function(jq,tab){
return _33a(jq[0],tab);
},getSelected:function(jq){
return _317(jq[0]);
},select:function(jq,_365){
return jq.each(function(){
_331(this,_365);
});
},unselect:function(jq,_366){
return jq.each(function(){
_352(this,_366);
});
},exists:function(jq,_367){
return _33f(jq[0],_367);
},update:function(jq,_368){
return jq.each(function(){
_332(this,_368);
});
},enableTab:function(jq,_369){
return jq.each(function(){
$(this).tabs("getTab",_369).panel("options").tab.removeClass("tabs-disabled");
});
},disableTab:function(jq,_36a){
return jq.each(function(){
$(this).tabs("getTab",_36a).panel("options").tab.addClass("tabs-disabled");
});
},showHeader:function(jq){
return jq.each(function(){
_35b(this,true);
});
},hideHeader:function(jq){
return jq.each(function(){
_35b(this,false);
});
},scrollBy:function(jq,_36b){
return jq.each(function(){
var opts=$(this).tabs("options");
var wrap=$(this).find(">div.tabs-header>div.tabs-wrap");
var pos=Math.min(wrap._scrollLeft()+_36b,_36c());
wrap.animate({scrollLeft:pos},opts.scrollDuration);
function _36c(){
var w=0;
var ul=wrap.children("ul");
ul.children("li").each(function(){
w+=$(this).outerWidth(true);
});
return w-wrap.width()+(ul.outerWidth()-ul.width());
};
});
}};
$.fn.tabs.parseOptions=function(_36d){
return $.extend({},$.parser.parseOptions(_36d,["tools","toolPosition","tabPosition",{fit:"boolean",border:"boolean",plain:"boolean",headerWidth:"number",tabWidth:"number",tabHeight:"number",selected:"number",showHeader:"boolean"}]));
};
$.fn.tabs.defaults={width:"auto",height:"auto",headerWidth:150,tabWidth:"auto",tabHeight:27,selected:0,showHeader:true,plain:false,fit:false,border:true,tools:null,toolPosition:"right",tabPosition:"top",scrollIncrement:100,scrollDuration:400,onLoad:function(_36e){
},onSelect:function(_36f,_370){
},onUnselect:function(_371,_372){
},onBeforeClose:function(_373,_374){
},onClose:function(_375,_376){
},onAdd:function(_377,_378){
},onUpdate:function(_379,_37a){
},onContextMenu:function(e,_37b,_37c){
}};
})(jQuery);
(function($){
var _37d=false;
function _37e(_37f,_380){
var _381=$.data(_37f,"layout");
var opts=_381.options;
var _382=_381.panels;
var cc=$(_37f);
if(_380){
$.extend(opts,{width:_380.width,height:_380.height});
}
if(_37f.tagName.toLowerCase()=="body"){
cc._size("fit");
}else{
cc._size(opts);
}
var cpos={top:0,left:0,width:cc.width(),height:cc.height()};
_383(_384(_382.expandNorth)?_382.expandNorth:_382.north,"n");
_383(_384(_382.expandSouth)?_382.expandSouth:_382.south,"s");
_385(_384(_382.expandEast)?_382.expandEast:_382.east,"e");
_385(_384(_382.expandWest)?_382.expandWest:_382.west,"w");
_382.center.panel("resize",cpos);
function _383(pp,type){
if(!pp.length||!_384(pp)){
return;
}
var opts=pp.panel("options");
pp.panel("resize",{width:cc.width(),height:opts.height});
var _386=pp.panel("panel").outerHeight();
pp.panel("move",{left:0,top:(type=="n"?0:cc.height()-_386)});
cpos.height-=_386;
if(type=="n"){
cpos.top+=_386;
if(!opts.split&&opts.border){
cpos.top--;
}
}
if(!opts.split&&opts.border){
cpos.height++;
}
};
function _385(pp,type){
if(!pp.length||!_384(pp)){
return;
}
var opts=pp.panel("options");
pp.panel("resize",{width:opts.width,height:cpos.height});
var _387=pp.panel("panel").outerWidth();
pp.panel("move",{left:(type=="e"?cc.width()-_387:0),top:cpos.top});
cpos.width-=_387;
if(type=="w"){
cpos.left+=_387;
if(!opts.split&&opts.border){
cpos.left--;
}
}
if(!opts.split&&opts.border){
cpos.width++;
}
};
};
function init(_388){
var cc=$(_388);
cc.addClass("layout");
function _389(cc){
cc.children("div").each(function(){
var opts=$.fn.layout.parsePanelOptions(this);
if("north,south,east,west,center".indexOf(opts.region)>=0){
_38b(_388,opts,this);
}
});
};
cc.children("form").length?_389(cc.children("form")):_389(cc);
cc.append("<div class=\"layout-split-proxy-h\"></div><div class=\"layout-split-proxy-v\"></div>");
cc.bind("_resize",function(e,_38a){
if($(this).hasClass("easyui-fluid")||_38a){
_37e(_388);
}
return false;
});
};
function _38b(_38c,_38d,el){
_38d.region=_38d.region||"center";
var _38e=$.data(_38c,"layout").panels;
var cc=$(_38c);
var dir=_38d.region;
if(_38e[dir].length){
return;
}
var pp=$(el);
if(!pp.length){
pp=$("<div></div>").appendTo(cc);
}
var _38f=$.extend({},$.fn.layout.paneldefaults,{width:(pp.length?parseInt(pp[0].style.width)||pp.outerWidth():"auto"),height:(pp.length?parseInt(pp[0].style.height)||pp.outerHeight():"auto"),doSize:false,collapsible:true,cls:("layout-panel layout-panel-"+dir),bodyCls:"layout-body",onOpen:function(){
var tool=$(this).panel("header").children("div.panel-tool");
tool.children("a.panel-tool-collapse").hide();
var _390={north:"up",south:"down",east:"right",west:"left"};
if(!_390[dir]){
return;
}
var _391="layout-button-"+_390[dir];
var t=tool.children("a."+_391);
if(!t.length){
t=$("<a href=\"javascript:void(0)\"></a>").addClass(_391).appendTo(tool);
t.bind("click",{dir:dir},function(e){
_39d(_38c,e.data.dir);
return false;
});
}
$(this).panel("options").collapsible?t.show():t.hide();
}},_38d);
pp.panel(_38f);
_38e[dir]=pp;
if(pp.panel("options").split){
var _392=pp.panel("panel");
_392.addClass("layout-split-"+dir);
var _393="";
if(dir=="north"){
_393="s";
}
if(dir=="south"){
_393="n";
}
if(dir=="east"){
_393="w";
}
if(dir=="west"){
_393="e";
}
_392.resizable($.extend({},{handles:_393,onStartResize:function(e){
_37d=true;
if(dir=="north"||dir=="south"){
var _394=$(">div.layout-split-proxy-v",_38c);
}else{
var _394=$(">div.layout-split-proxy-h",_38c);
}
var top=0,left=0,_395=0,_396=0;
var pos={display:"block"};
if(dir=="north"){
pos.top=parseInt(_392.css("top"))+_392.outerHeight()-_394.height();
pos.left=parseInt(_392.css("left"));
pos.width=_392.outerWidth();
pos.height=_394.height();
}else{
if(dir=="south"){
pos.top=parseInt(_392.css("top"));
pos.left=parseInt(_392.css("left"));
pos.width=_392.outerWidth();
pos.height=_394.height();
}else{
if(dir=="east"){
pos.top=parseInt(_392.css("top"))||0;
pos.left=parseInt(_392.css("left"))||0;
pos.width=_394.width();
pos.height=_392.outerHeight();
}else{
if(dir=="west"){
pos.top=parseInt(_392.css("top"))||0;
pos.left=_392.outerWidth()-_394.width();
pos.width=_394.width();
pos.height=_392.outerHeight();
}
}
}
}
_394.css(pos);
$("<div class=\"layout-mask\"></div>").css({left:0,top:0,width:cc.width(),height:cc.height()}).appendTo(cc);
},onResize:function(e){
if(dir=="north"||dir=="south"){
var _397=$(">div.layout-split-proxy-v",_38c);
_397.css("top",e.pageY-$(_38c).offset().top-_397.height()/2);
}else{
var _397=$(">div.layout-split-proxy-h",_38c);
_397.css("left",e.pageX-$(_38c).offset().left-_397.width()/2);
}
return false;
},onStopResize:function(e){
cc.children("div.layout-split-proxy-v,div.layout-split-proxy-h").hide();
pp.panel("resize",e.data);
_37e(_38c);
_37d=false;
cc.find(">div.layout-mask").remove();
}},_38d));
}
};
function _398(_399,_39a){
var _39b=$.data(_399,"layout").panels;
if(_39b[_39a].length){
_39b[_39a].panel("destroy");
_39b[_39a]=$();
var _39c="expand"+_39a.substring(0,1).toUpperCase()+_39a.substring(1);
if(_39b[_39c]){
_39b[_39c].panel("destroy");
_39b[_39c]=undefined;
}
}
};
function _39d(_39e,_39f,_3a0){
if(_3a0==undefined){
_3a0="normal";
}
var _3a1=$.data(_39e,"layout").panels;
var p=_3a1[_39f];
var _3a2=p.panel("options");
if(_3a2.onBeforeCollapse.call(p)==false){
return;
}
var _3a3="expand"+_39f.substring(0,1).toUpperCase()+_39f.substring(1);
if(!_3a1[_3a3]){
_3a1[_3a3]=_3a4(_39f);
_3a1[_3a3].panel("panel").bind("click",function(){
p.panel("expand",false).panel("open");
var _3a5=_3a6();
p.panel("resize",_3a5.collapse);
p.panel("panel").animate(_3a5.expand,function(){
$(this).unbind(".layout").bind("mouseleave.layout",{region:_39f},function(e){
if(_37d==true){
return;
}
if($("body>div.combo-p>div.combo-panel:visible").length){
return;
}
_39d(_39e,e.data.region);
});
});
return false;
});
}
var _3a7=_3a6();
if(!_384(_3a1[_3a3])){
_3a1.center.panel("resize",_3a7.resizeC);
}
p.panel("panel").animate(_3a7.collapse,_3a0,function(){
p.panel("collapse",false).panel("close");
_3a1[_3a3].panel("open").panel("resize",_3a7.expandP);
$(this).unbind(".layout");
});
function _3a4(dir){
var icon;
if(dir=="east"){
icon="layout-button-left";
}else{
if(dir=="west"){
icon="layout-button-right";
}else{
if(dir=="north"){
icon="layout-button-down";
}else{
if(dir=="south"){
icon="layout-button-up";
}
}
}
}
var p=$("<div></div>").appendTo(_39e);
p.panel($.extend({},$.fn.layout.paneldefaults,{cls:("layout-expand layout-expand-"+dir),title:"&nbsp;",closed:true,minWidth:0,minHeight:0,doSize:false,tools:[{iconCls:icon,handler:function(){
_3ad(_39e,_39f);
return false;
}}]}));
p.panel("panel").hover(function(){
$(this).addClass("layout-expand-over");
},function(){
$(this).removeClass("layout-expand-over");
});
return p;
};
function _3a6(){
var cc=$(_39e);
var _3a8=_3a1.center.panel("options");
var _3a9=_3a2.collapsedSize;
if(_39f=="east"){
var _3aa=p.panel("panel")._outerWidth();
var _3ab=_3a8.width+_3aa-_3a9;
if(_3a2.split||!_3a2.border){
_3ab++;
}
return {resizeC:{width:_3ab},expand:{left:cc.width()-_3aa},expandP:{top:_3a8.top,left:cc.width()-_3a9,width:_3a9,height:_3a8.height},collapse:{left:cc.width(),top:_3a8.top,height:_3a8.height}};
}else{
if(_39f=="west"){
var _3aa=p.panel("panel")._outerWidth();
var _3ab=_3a8.width+_3aa-_3a9;
if(_3a2.split||!_3a2.border){
_3ab++;
}
return {resizeC:{width:_3ab,left:_3a9-1},expand:{left:0},expandP:{left:0,top:_3a8.top,width:_3a9,height:_3a8.height},collapse:{left:-_3aa,top:_3a8.top,height:_3a8.height}};
}else{
if(_39f=="north"){
var _3ac=p.panel("panel")._outerHeight();
var hh=_3a8.height;
if(!_384(_3a1.expandNorth)){
hh+=_3ac-_3a9+((_3a2.split||!_3a2.border)?1:0);
}
_3a1.east.add(_3a1.west).add(_3a1.expandEast).add(_3a1.expandWest).panel("resize",{top:_3a9-1,height:hh});
return {resizeC:{top:_3a9-1,height:hh},expand:{top:0},expandP:{top:0,left:0,width:cc.width(),height:_3a9},collapse:{top:-_3ac,width:cc.width()}};
}else{
if(_39f=="south"){
var _3ac=p.panel("panel")._outerHeight();
var hh=_3a8.height;
if(!_384(_3a1.expandSouth)){
hh+=_3ac-_3a9+((_3a2.split||!_3a2.border)?1:0);
}
_3a1.east.add(_3a1.west).add(_3a1.expandEast).add(_3a1.expandWest).panel("resize",{height:hh});
return {resizeC:{height:hh},expand:{top:cc.height()-_3ac},expandP:{top:cc.height()-_3a9,left:0,width:cc.width(),height:_3a9},collapse:{top:cc.height(),width:cc.width()}};
}
}
}
}
};
};
function _3ad(_3ae,_3af){
var _3b0=$.data(_3ae,"layout").panels;
var p=_3b0[_3af];
var _3b1=p.panel("options");
if(_3b1.onBeforeExpand.call(p)==false){
return;
}
var _3b2="expand"+_3af.substring(0,1).toUpperCase()+_3af.substring(1);
if(_3b0[_3b2]){
_3b0[_3b2].panel("close");
p.panel("panel").stop(true,true);
p.panel("expand",false).panel("open");
var _3b3=_3b4();
p.panel("resize",_3b3.collapse);
p.panel("panel").animate(_3b3.expand,function(){
_37e(_3ae);
});
}
function _3b4(){
var cc=$(_3ae);
var _3b5=_3b0.center.panel("options");
if(_3af=="east"&&_3b0.expandEast){
return {collapse:{left:cc.width(),top:_3b5.top,height:_3b5.height},expand:{left:cc.width()-p.panel("panel")._outerWidth()}};
}else{
if(_3af=="west"&&_3b0.expandWest){
return {collapse:{left:-p.panel("panel")._outerWidth(),top:_3b5.top,height:_3b5.height},expand:{left:0}};
}else{
if(_3af=="north"&&_3b0.expandNorth){
return {collapse:{top:-p.panel("panel")._outerHeight(),width:cc.width()},expand:{top:0}};
}else{
if(_3af=="south"&&_3b0.expandSouth){
return {collapse:{top:cc.height(),width:cc.width()},expand:{top:cc.height()-p.panel("panel")._outerHeight()}};
}
}
}
}
};
};
function _384(pp){
if(!pp){
return false;
}
if(pp.length){
return pp.panel("panel").is(":visible");
}else{
return false;
}
};
function _3b6(_3b7){
var _3b8=$.data(_3b7,"layout").panels;
if(_3b8.east.length&&_3b8.east.panel("options").collapsed){
_39d(_3b7,"east",0);
}
if(_3b8.west.length&&_3b8.west.panel("options").collapsed){
_39d(_3b7,"west",0);
}
if(_3b8.north.length&&_3b8.north.panel("options").collapsed){
_39d(_3b7,"north",0);
}
if(_3b8.south.length&&_3b8.south.panel("options").collapsed){
_39d(_3b7,"south",0);
}
};
$.fn.layout=function(_3b9,_3ba){
if(typeof _3b9=="string"){
return $.fn.layout.methods[_3b9](this,_3ba);
}
_3b9=_3b9||{};
return this.each(function(){
var _3bb=$.data(this,"layout");
if(_3bb){
$.extend(_3bb.options,_3b9);
}else{
var opts=$.extend({},$.fn.layout.defaults,$.fn.layout.parseOptions(this),_3b9);
$.data(this,"layout",{options:opts,panels:{center:$(),north:$(),south:$(),east:$(),west:$()}});
init(this);
}
_37e(this);
_3b6(this);
});
};
$.fn.layout.methods={options:function(jq){
return $.data(jq[0],"layout").options;
},resize:function(jq,_3bc){
return jq.each(function(){
_37e(this,_3bc);
});
},panel:function(jq,_3bd){
return $.data(jq[0],"layout").panels[_3bd];
},collapse:function(jq,_3be){
return jq.each(function(){
_39d(this,_3be);
});
},expand:function(jq,_3bf){
return jq.each(function(){
_3ad(this,_3bf);
});
},add:function(jq,_3c0){
return jq.each(function(){
_38b(this,_3c0);
_37e(this);
if($(this).layout("panel",_3c0.region).panel("options").collapsed){
_39d(this,_3c0.region,0);
}
});
},remove:function(jq,_3c1){
return jq.each(function(){
_398(this,_3c1);
_37e(this);
});
}};
$.fn.layout.parseOptions=function(_3c2){
return $.extend({},$.parser.parseOptions(_3c2,[{fit:"boolean"}]));
};
$.fn.layout.defaults={fit:false};
$.fn.layout.parsePanelOptions=function(_3c3){
var t=$(_3c3);
return $.extend({},$.fn.panel.parseOptions(_3c3),$.parser.parseOptions(_3c3,["region",{split:"boolean",collpasedSize:"number",minWidth:"number",minHeight:"number",maxWidth:"number",maxHeight:"number"}]));
};
$.fn.layout.paneldefaults=$.extend({},$.fn.panel.defaults,{region:null,split:false,collapsedSize:28,minWidth:10,minHeight:10,maxWidth:10000,maxHeight:10000});
})(jQuery);
(function($){
function init(_3c4){
$(_3c4).appendTo("body");
$(_3c4).addClass("menu-top");
$(document).unbind(".menu").bind("mousedown.menu",function(e){
var m=$(e.target).closest("div.menu,div.combo-p");
if(m.length){
return;
}
$("body>div.menu-top:visible").menu("hide");
});
var _3c5=_3c6($(_3c4));
for(var i=0;i<_3c5.length;i++){
_3c7(_3c5[i]);
}
function _3c6(menu){
var _3c8=[];
menu.addClass("menu");
_3c8.push(menu);
if(!menu.hasClass("menu-content")){
menu.children("div").each(function(){
var _3c9=$(this).children("div");
if(_3c9.length){
_3c9.insertAfter(_3c4);
this.submenu=_3c9;
var mm=_3c6(_3c9);
_3c8=_3c8.concat(mm);
}
});
}
return _3c8;
};
function _3c7(menu){
var wh=$.parser.parseOptions(menu[0],["width","height"]);
menu[0].originalHeight=wh.height||0;
if(menu.hasClass("menu-content")){
menu[0].originalWidth=wh.width||menu._outerWidth();
}else{
menu[0].originalWidth=wh.width||0;
menu.children("div").each(function(){
var item=$(this);
var _3ca=$.extend({},$.parser.parseOptions(this,["name","iconCls","href",{separator:"boolean"}]),{disabled:(item.attr("disabled")?true:undefined)});
if(_3ca.separator){
item.addClass("menu-sep");
}
if(!item.hasClass("menu-sep")){
item[0].itemName=_3ca.name||"";
item[0].itemHref=_3ca.href||"";
var text=item.addClass("menu-item").html();
item.empty().append($("<div class=\"menu-text\"></div>").html(text));
if(_3ca.iconCls){
$("<div class=\"menu-icon\"></div>").addClass(_3ca.iconCls).appendTo(item);
}
if(_3ca.disabled){
_3cb(_3c4,item[0],true);
}
if(item[0].submenu){
$("<div class=\"menu-rightarrow\"></div>").appendTo(item);
}
_3cc(_3c4,item);
}
});
$("<div class=\"menu-line\"></div>").prependTo(menu);
}
_3cd(_3c4,menu);
menu.hide();
_3ce(_3c4,menu);
};
};
function _3cd(_3cf,menu){
var opts=$.data(_3cf,"menu").options;
var _3d0=menu.attr("style")||"";
menu.css({display:"block",left:-10000,height:"auto",overflow:"hidden"});
var el=menu[0];
var _3d1=el.originalWidth||0;
if(!_3d1){
_3d1=0;
menu.find("div.menu-text").each(function(){
if(_3d1<$(this)._outerWidth()){
_3d1=$(this)._outerWidth();
}
$(this).closest("div.menu-item")._outerHeight($(this)._outerHeight()+2);
});
_3d1+=40;
}
_3d1=Math.max(_3d1,opts.minWidth);
var _3d2=el.originalHeight||0;
if(!_3d2){
_3d2=menu.outerHeight();
if(menu.hasClass("menu-top")&&opts.alignTo){
var at=$(opts.alignTo);
var h1=at.offset().top-$(document).scrollTop();
var h2=$(window)._outerHeight()+$(document).scrollTop()-at.offset().top-at._outerHeight();
_3d2=Math.min(_3d2,Math.max(h1,h2));
}else{
if(_3d2>$(window)._outerHeight()){
_3d2=$(window).height();
_3d0+=";overflow:auto";
}else{
_3d0+=";overflow:hidden";
}
}
}
var _3d3=Math.max(el.originalHeight,menu.outerHeight())-2;
menu._outerWidth(_3d1)._outerHeight(_3d2);
menu.children("div.menu-line")._outerHeight(_3d3);
_3d0+=";width:"+el.style.width+";height:"+el.style.height;
menu.attr("style",_3d0);
};
function _3ce(_3d4,menu){
var _3d5=$.data(_3d4,"menu");
menu.unbind(".menu").bind("mouseenter.menu",function(){
if(_3d5.timer){
clearTimeout(_3d5.timer);
_3d5.timer=null;
}
}).bind("mouseleave.menu",function(){
if(_3d5.options.hideOnUnhover){
_3d5.timer=setTimeout(function(){
_3d6(_3d4);
},_3d5.options.duration);
}
});
};
function _3cc(_3d7,item){
if(!item.hasClass("menu-item")){
return;
}
item.unbind(".menu");
item.bind("click.menu",function(){
if($(this).hasClass("menu-item-disabled")){
return;
}
if(!this.submenu){
_3d6(_3d7);
var href=this.itemHref;
if(href){
location.href=href;
}
}
var item=$(_3d7).menu("getItem",this);
$.data(_3d7,"menu").options.onClick.call(_3d7,item);
}).bind("mouseenter.menu",function(e){
item.siblings().each(function(){
if(this.submenu){
_3da(this.submenu);
}
$(this).removeClass("menu-active");
});
item.addClass("menu-active");
if($(this).hasClass("menu-item-disabled")){
item.addClass("menu-active-disabled");
return;
}
var _3d8=item[0].submenu;
if(_3d8){
$(_3d7).menu("show",{menu:_3d8,parent:item});
}
}).bind("mouseleave.menu",function(e){
item.removeClass("menu-active menu-active-disabled");
var _3d9=item[0].submenu;
if(_3d9){
if(e.pageX>=parseInt(_3d9.css("left"))){
item.addClass("menu-active");
}else{
_3da(_3d9);
}
}else{
item.removeClass("menu-active");
}
});
};
function _3d6(_3db){
var _3dc=$.data(_3db,"menu");
if(_3dc){
if($(_3db).is(":visible")){
_3da($(_3db));
_3dc.options.onHide.call(_3db);
}
}
return false;
};
function _3dd(_3de,_3df){
var left,top;
_3df=_3df||{};
var menu=$(_3df.menu||_3de);
$(_3de).menu("resize",menu[0]);
if(menu.hasClass("menu-top")){
var opts=$.data(_3de,"menu").options;
$.extend(opts,_3df);
left=opts.left;
top=opts.top;
if(opts.alignTo){
var at=$(opts.alignTo);
left=at.offset().left;
top=at.offset().top+at._outerHeight();
if(opts.align=="right"){
left+=at.outerWidth()-menu.outerWidth();
}
}
if(left+menu.outerWidth()>$(window)._outerWidth()+$(document)._scrollLeft()){
left=$(window)._outerWidth()+$(document).scrollLeft()-menu.outerWidth()-5;
}
if(left<0){
left=0;
}
top=_3e0(top,opts.alignTo);
}else{
var _3e1=_3df.parent;
left=_3e1.offset().left+_3e1.outerWidth()-2;
if(left+menu.outerWidth()+5>$(window)._outerWidth()+$(document).scrollLeft()){
left=_3e1.offset().left-menu.outerWidth()+2;
}
top=_3e0(_3e1.offset().top-3);
}
function _3e0(top,_3e2){
if(top+menu.outerHeight()>$(window)._outerHeight()+$(document).scrollTop()){
if(_3e2){
top=$(_3e2).offset().top-menu._outerHeight();
}else{
top=$(window)._outerHeight()+$(document).scrollTop()-menu.outerHeight();
}
}
if(top<0){
top=0;
}
return top;
};
menu.css({left:left,top:top});
menu.show(0,function(){
if(!menu[0].shadow){
menu[0].shadow=$("<div class=\"menu-shadow\"></div>").insertAfter(menu);
}
menu[0].shadow.css({display:"block",zIndex:$.fn.menu.defaults.zIndex++,left:menu.css("left"),top:menu.css("top"),width:menu.outerWidth(),height:menu.outerHeight()});
menu.css("z-index",$.fn.menu.defaults.zIndex++);
if(menu.hasClass("menu-top")){
$.data(menu[0],"menu").options.onShow.call(menu[0]);
}
});
};
function _3da(menu){
if(!menu){
return;
}
_3e3(menu);
menu.find("div.menu-item").each(function(){
if(this.submenu){
_3da(this.submenu);
}
$(this).removeClass("menu-active");
});
function _3e3(m){
m.stop(true,true);
if(m[0].shadow){
m[0].shadow.hide();
}
m.hide();
};
};
function _3e4(_3e5,text){
var _3e6=null;
var tmp=$("<div></div>");
function find(menu){
menu.children("div.menu-item").each(function(){
var item=$(_3e5).menu("getItem",this);
var s=tmp.empty().html(item.text).text();
if(text==$.trim(s)){
_3e6=item;
}else{
if(this.submenu&&!_3e6){
find(this.submenu);
}
}
});
};
find($(_3e5));
tmp.remove();
return _3e6;
};
function _3cb(_3e7,_3e8,_3e9){
var t=$(_3e8);
if(!t.hasClass("menu-item")){
return;
}
if(_3e9){
t.addClass("menu-item-disabled");
if(_3e8.onclick){
_3e8.onclick1=_3e8.onclick;
_3e8.onclick=null;
}
}else{
t.removeClass("menu-item-disabled");
if(_3e8.onclick1){
_3e8.onclick=_3e8.onclick1;
_3e8.onclick1=null;
}
}
};
function _3ea(_3eb,_3ec){
var menu=$(_3eb);
if(_3ec.parent){
if(!_3ec.parent.submenu){
var _3ed=$("<div class=\"menu\"><div class=\"menu-line\"></div></div>").appendTo("body");
_3ed.hide();
_3ec.parent.submenu=_3ed;
$("<div class=\"menu-rightarrow\"></div>").appendTo(_3ec.parent);
}
menu=_3ec.parent.submenu;
}
if(_3ec.separator){
var item=$("<div class=\"menu-sep\"></div>").appendTo(menu);
}else{
var item=$("<div class=\"menu-item\"></div>").appendTo(menu);
$("<div class=\"menu-text\"></div>").html(_3ec.text).appendTo(item);
}
if(_3ec.iconCls){
$("<div class=\"menu-icon\"></div>").addClass(_3ec.iconCls).appendTo(item);
}
if(_3ec.id){
item.attr("id",_3ec.id);
}
if(_3ec.name){
item[0].itemName=_3ec.name;
}
if(_3ec.href){
item[0].itemHref=_3ec.href;
}
if(_3ec.onclick){
if(typeof _3ec.onclick=="string"){
item.attr("onclick",_3ec.onclick);
}else{
item[0].onclick=eval(_3ec.onclick);
}
}
if(_3ec.handler){
item[0].onclick=eval(_3ec.handler);
}
if(_3ec.disabled){
_3cb(_3eb,item[0],true);
}
_3cc(_3eb,item);
_3ce(_3eb,menu);
_3cd(_3eb,menu);
};
function _3ee(_3ef,_3f0){
function _3f1(el){
if(el.submenu){
el.submenu.children("div.menu-item").each(function(){
_3f1(this);
});
var _3f2=el.submenu[0].shadow;
if(_3f2){
_3f2.remove();
}
el.submenu.remove();
}
$(el).remove();
};
var menu=$(_3f0).parent();
_3f1(_3f0);
_3cd(_3ef,menu);
};
function _3f3(_3f4,_3f5,_3f6){
var menu=$(_3f5).parent();
if(_3f6){
$(_3f5).show();
}else{
$(_3f5).hide();
}
_3cd(_3f4,menu);
};
function _3f7(_3f8){
$(_3f8).children("div.menu-item").each(function(){
_3ee(_3f8,this);
});
if(_3f8.shadow){
_3f8.shadow.remove();
}
$(_3f8).remove();
};
$.fn.menu=function(_3f9,_3fa){
if(typeof _3f9=="string"){
return $.fn.menu.methods[_3f9](this,_3fa);
}
_3f9=_3f9||{};
return this.each(function(){
var _3fb=$.data(this,"menu");
if(_3fb){
$.extend(_3fb.options,_3f9);
}else{
_3fb=$.data(this,"menu",{options:$.extend({},$.fn.menu.defaults,$.fn.menu.parseOptions(this),_3f9)});
init(this);
}
$(this).css({left:_3fb.options.left,top:_3fb.options.top});
});
};
$.fn.menu.methods={options:function(jq){
return $.data(jq[0],"menu").options;
},show:function(jq,pos){
return jq.each(function(){
_3dd(this,pos);
});
},hide:function(jq){
return jq.each(function(){
_3d6(this);
});
},destroy:function(jq){
return jq.each(function(){
_3f7(this);
});
},setText:function(jq,_3fc){
return jq.each(function(){
$(_3fc.target).children("div.menu-text").html(_3fc.text);
});
},setIcon:function(jq,_3fd){
return jq.each(function(){
$(_3fd.target).children("div.menu-icon").remove();
if(_3fd.iconCls){
$("<div class=\"menu-icon\"></div>").addClass(_3fd.iconCls).appendTo(_3fd.target);
}
});
},getItem:function(jq,_3fe){
var t=$(_3fe);
var item={target:_3fe,id:t.attr("id"),text:$.trim(t.children("div.menu-text").html()),disabled:t.hasClass("menu-item-disabled"),name:_3fe.itemName,href:_3fe.itemHref,onclick:_3fe.onclick};
var icon=t.children("div.menu-icon");
if(icon.length){
var cc=[];
var aa=icon.attr("class").split(" ");
for(var i=0;i<aa.length;i++){
if(aa[i]!="menu-icon"){
cc.push(aa[i]);
}
}
item.iconCls=cc.join(" ");
}
return item;
},findItem:function(jq,text){
return _3e4(jq[0],text);
},appendItem:function(jq,_3ff){
return jq.each(function(){
_3ea(this,_3ff);
});
},removeItem:function(jq,_400){
return jq.each(function(){
_3ee(this,_400);
});
},enableItem:function(jq,_401){
return jq.each(function(){
_3cb(this,_401,false);
});
},disableItem:function(jq,_402){
return jq.each(function(){
_3cb(this,_402,true);
});
},showItem:function(jq,_403){
return jq.each(function(){
_3f3(this,_403,true);
});
},hideItem:function(jq,_404){
return jq.each(function(){
_3f3(this,_404,false);
});
},resize:function(jq,_405){
return jq.each(function(){
_3cd(this,$(_405));
});
}};
$.fn.menu.parseOptions=function(_406){
return $.extend({},$.parser.parseOptions(_406,[{minWidth:"number",duration:"number",hideOnUnhover:"boolean"}]));
};
$.fn.menu.defaults={zIndex:110000,left:0,top:0,alignTo:null,align:"left",minWidth:120,duration:100,hideOnUnhover:true,onShow:function(){
},onHide:function(){
},onClick:function(item){
}};
})(jQuery);
(function($){
function init(_407){
var opts=$.data(_407,"menubutton").options;
var btn=$(_407);
btn.linkbutton(opts);
btn.removeClass(opts.cls.btn1+" "+opts.cls.btn2).addClass("m-btn");
btn.removeClass("m-btn-small m-btn-medium m-btn-large").addClass("m-btn-"+opts.size);
var _408=btn.find(".l-btn-left");
$("<span></span>").addClass(opts.cls.arrow).appendTo(_408);
$("<span></span>").addClass("m-btn-line").appendTo(_408);
if(opts.menu){
$(opts.menu).menu({duration:opts.duration});
var _409=$(opts.menu).menu("options");
var _40a=_409.onShow;
var _40b=_409.onHide;
$.extend(_409,{onShow:function(){
var _40c=$(this).menu("options");
var btn=$(_40c.alignTo);
var opts=btn.menubutton("options");
btn.addClass((opts.plain==true)?opts.cls.btn2:opts.cls.btn1);
_40a.call(this);
},onHide:function(){
var _40d=$(this).menu("options");
var btn=$(_40d.alignTo);
var opts=btn.menubutton("options");
btn.removeClass((opts.plain==true)?opts.cls.btn2:opts.cls.btn1);
_40b.call(this);
}});
}
};
function _40e(_40f){
var opts=$.data(_40f,"menubutton").options;
var btn=$(_40f);
var t=btn.find("."+opts.cls.trigger);
if(!t.length){
t=btn;
}
t.unbind(".menubutton");
var _410=null;
t.bind("click.menubutton",function(){
if(!_411()){
_412(_40f);
return false;
}
}).bind("mouseenter.menubutton",function(){
if(!_411()){
_410=setTimeout(function(){
_412(_40f);
},opts.duration);
return false;
}
}).bind("mouseleave.menubutton",function(){
if(_410){
clearTimeout(_410);
}
$(opts.menu).triggerHandler("mouseleave");
});
function _411(){
return $(_40f).linkbutton("options").disabled;
};
};
function _412(_413){
var opts=$(_413).menubutton("options");
if(opts.disabled||!opts.menu){
return;
}
$("body>div.menu-top").menu("hide");
var btn=$(_413);
var mm=$(opts.menu);
if(mm.length){
mm.menu("options").alignTo=btn;
mm.menu("show",{alignTo:btn,align:opts.menuAlign});
}
btn.blur();
};
$.fn.menubutton=function(_414,_415){
if(typeof _414=="string"){
var _416=$.fn.menubutton.methods[_414];
if(_416){
return _416(this,_415);
}else{
return this.linkbutton(_414,_415);
}
}
_414=_414||{};
return this.each(function(){
var _417=$.data(this,"menubutton");
if(_417){
$.extend(_417.options,_414);
}else{
$.data(this,"menubutton",{options:$.extend({},$.fn.menubutton.defaults,$.fn.menubutton.parseOptions(this),_414)});
$(this).removeAttr("disabled");
}
init(this);
_40e(this);
});
};
$.fn.menubutton.methods={options:function(jq){
var _418=jq.linkbutton("options");
return $.extend($.data(jq[0],"menubutton").options,{toggle:_418.toggle,selected:_418.selected,disabled:_418.disabled});
},destroy:function(jq){
return jq.each(function(){
var opts=$(this).menubutton("options");
if(opts.menu){
$(opts.menu).menu("destroy");
}
$(this).remove();
});
}};
$.fn.menubutton.parseOptions=function(_419){
var t=$(_419);
return $.extend({},$.fn.linkbutton.parseOptions(_419),$.parser.parseOptions(_419,["menu",{plain:"boolean",duration:"number"}]));
};
$.fn.menubutton.defaults=$.extend({},$.fn.linkbutton.defaults,{plain:true,menu:null,menuAlign:"left",duration:100,cls:{btn1:"m-btn-active",btn2:"m-btn-plain-active",arrow:"m-btn-downarrow",trigger:"m-btn"}});
})(jQuery);
(function($){
function init(_41a){
var opts=$.data(_41a,"splitbutton").options;
$(_41a).menubutton(opts);
$(_41a).addClass("s-btn");
};
$.fn.splitbutton=function(_41b,_41c){
if(typeof _41b=="string"){
var _41d=$.fn.splitbutton.methods[_41b];
if(_41d){
return _41d(this,_41c);
}else{
return this.menubutton(_41b,_41c);
}
}
_41b=_41b||{};
return this.each(function(){
var _41e=$.data(this,"splitbutton");
if(_41e){
$.extend(_41e.options,_41b);
}else{
$.data(this,"splitbutton",{options:$.extend({},$.fn.splitbutton.defaults,$.fn.splitbutton.parseOptions(this),_41b)});
$(this).removeAttr("disabled");
}
init(this);
});
};
$.fn.splitbutton.methods={options:function(jq){
var _41f=jq.menubutton("options");
var _420=$.data(jq[0],"splitbutton").options;
$.extend(_420,{disabled:_41f.disabled,toggle:_41f.toggle,selected:_41f.selected});
return _420;
}};
$.fn.splitbutton.parseOptions=function(_421){
var t=$(_421);
return $.extend({},$.fn.linkbutton.parseOptions(_421),$.parser.parseOptions(_421,["menu",{plain:"boolean",duration:"number"}]));
};
$.fn.splitbutton.defaults=$.extend({},$.fn.linkbutton.defaults,{plain:true,menu:null,duration:100,cls:{btn1:"m-btn-active s-btn-active",btn2:"m-btn-plain-active s-btn-plain-active",arrow:"m-btn-downarrow",trigger:"m-btn-line"}});
})(jQuery);
(function($){
function init(_422){
$(_422).addClass("validatebox-text");
};
function _423(_424){
var _425=$.data(_424,"validatebox");
_425.validating=false;
if(_425.timer){
clearTimeout(_425.timer);
}
$(_424).tooltip("destroy");
$(_424).unbind();
$(_424).remove();
};
function _426(_427){
var opts=$.data(_427,"validatebox").options;
var box=$(_427);
box.unbind(".validatebox");
if(opts.novalidate||box.is(":disabled")){
return;
}
for(var _428 in opts.events){
$(_427).bind(_428+".validatebox",{target:_427},opts.events[_428]);
}
};
function _429(e){
var _42a=e.data.target;
var _42b=$.data(_42a,"validatebox");
var box=$(_42a);
if($(_42a).attr("readonly")){
return;
}
_42b.validating=true;
_42b.value=undefined;
(function(){
if(_42b.validating){
if(_42b.value!=box.val()){
_42b.value=box.val();
if(_42b.timer){
clearTimeout(_42b.timer);
}
_42b.timer=setTimeout(function(){
$(_42a).validatebox("validate");
},_42b.options.delay);
}else{
_42c(_42a);
}
setTimeout(arguments.callee,200);
}
})();
};
function _42d(e){
var _42e=e.data.target;
var _42f=$.data(_42e,"validatebox");
if(_42f.timer){
clearTimeout(_42f.timer);
_42f.timer=undefined;
}
_42f.validating=false;
_430(_42e);
};
function _431(e){
var _432=e.data.target;
if($(_432).hasClass("validatebox-invalid")){
_433(_432);
}
};
function _434(e){
var _435=e.data.target;
var _436=$.data(_435,"validatebox");
if(!_436.validating){
_430(_435);
}
};
function _433(_437){
var _438=$.data(_437,"validatebox");
var opts=_438.options;
$(_437).tooltip($.extend({},opts.tipOptions,{content:_438.message,position:opts.tipPosition,deltaX:opts.deltaX})).tooltip("show");
_438.tip=true;
};
function _42c(_439){
var _43a=$.data(_439,"validatebox");
if(_43a&&_43a.tip){
$(_439).tooltip("reposition");
}
};
function _430(_43b){
var _43c=$.data(_43b,"validatebox");
_43c.tip=false;
$(_43b).tooltip("hide");
};
function _43d(_43e){
var _43f=$.data(_43e,"validatebox");
var opts=_43f.options;
var box=$(_43e);
opts.onBeforeValidate.call(_43e);
var _440=_441();
opts.onValidate.call(_43e,_440);
return _440;
function _442(msg){
_43f.message=msg;
};
function _443(_444,_445){
var _446=box.val();
var _447=/([a-zA-Z_]+)(.*)/.exec(_444);
var rule=opts.rules[_447[1]];
if(rule&&_446){
var _448=_445||opts.validParams||eval(_447[2]);
if(!rule["validator"].call(_43e,_446,_448)){
box.addClass("validatebox-invalid");
var _449=rule["message"];
if(_448){
for(var i=0;i<_448.length;i++){
_449=_449.replace(new RegExp("\\{"+i+"\\}","g"),_448[i]);
}
}
_442(opts.invalidMessage||_449);
if(_43f.validating){
_433(_43e);
}
return false;
}
}
return true;
};
function _441(){
box.removeClass("validatebox-invalid");
_430(_43e);
if(opts.novalidate||box.is(":disabled")){
return true;
}
if(opts.required){
if(box.val()==""){
box.addClass("validatebox-invalid");
_442(opts.missingMessage);
if(_43f.validating){
_433(_43e);
}
return false;
}
}
if(opts.validType){
if($.isArray(opts.validType)){
for(var i=0;i<opts.validType.length;i++){
if(!_443(opts.validType[i])){
return false;
}
}
}else{
if(typeof opts.validType=="string"){
if(!_443(opts.validType)){
return false;
}
}else{
for(var _44a in opts.validType){
var _44b=opts.validType[_44a];
if(!_443(_44a,_44b)){
return false;
}
}
}
}
}
return true;
};
};
function _44c(_44d,_44e){
var opts=$.data(_44d,"validatebox").options;
if(_44e!=undefined){
opts.novalidate=_44e;
}
if(opts.novalidate){
$(_44d).removeClass("validatebox-invalid");
_430(_44d);
}
_43d(_44d);
_426(_44d);
};
$.fn.validatebox=function(_44f,_450){
if(typeof _44f=="string"){
return $.fn.validatebox.methods[_44f](this,_450);
}
_44f=_44f||{};
return this.each(function(){
var _451=$.data(this,"validatebox");
if(_451){
$.extend(_451.options,_44f);
}else{
init(this);
$.data(this,"validatebox",{options:$.extend({},$.fn.validatebox.defaults,$.fn.validatebox.parseOptions(this),_44f)});
}
_44c(this);
_43d(this);
});
};
$.fn.validatebox.methods={options:function(jq){
return $.data(jq[0],"validatebox").options;
},destroy:function(jq){
return jq.each(function(){
_423(this);
});
},validate:function(jq){
return jq.each(function(){
_43d(this);
});
},isValid:function(jq){
return _43d(jq[0]);
},enableValidation:function(jq){
return jq.each(function(){
_44c(this,false);
});
},disableValidation:function(jq){
return jq.each(function(){
_44c(this,true);
});
}};
$.fn.validatebox.parseOptions=function(_452){
var t=$(_452);
return $.extend({},$.parser.parseOptions(_452,["validType","missingMessage","invalidMessage","tipPosition",{delay:"number",deltaX:"number"}]),{required:(t.attr("required")?true:undefined),novalidate:(t.attr("novalidate")!=undefined?true:undefined)});
};
$.fn.validatebox.defaults={required:false,validType:null,validParams:null,delay:200,missingMessage:"This field is required.",invalidMessage:null,tipPosition:"right",deltaX:0,novalidate:false,events:{focus:_429,blur:_42d,mouseenter:_431,mouseleave:_434,click:function(e){
var t=$(e.data.target);
if(!t.is(":focus")){
t.trigger("focus");
}
}},tipOptions:{showEvent:"none",hideEvent:"none",showDelay:0,hideDelay:0,zIndex:"",onShow:function(){
$(this).tooltip("tip").css({color:"#000",borderColor:"#CC9933",backgroundColor:"#FFFFCC"});
},onHide:function(){
$(this).tooltip("destroy");
}},rules:{email:{validator:function(_453){
return /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(_453);
},message:"Please enter a valid email address."},url:{validator:function(_454){
return /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(_454);
},message:"Please enter a valid URL."},length:{validator:function(_455,_456){
var len=$.trim(_455).length;
return len>=_456[0]&&len<=_456[1];
},message:"Please enter a value between {0} and {1}."},remote:{validator:function(_457,_458){
var data={};
data[_458[1]]=_457;
var _459=$.ajax({url:_458[0],dataType:"json",data:data,async:false,cache:false,type:"post"}).responseText;
return _459=="true";
},message:"Please fix this field."}},onBeforeValidate:function(){
},onValidate:function(_45a){
}};
})(jQuery);
(function($){
function init(_45b){
$(_45b).addClass("textbox-f").hide();
var span=$("<span class=\"textbox\">"+"<input class=\"textbox-text\" autocomplete=\"off\">"+"<input type=\"hidden\" class=\"textbox-value\">"+"</span>").insertAfter(_45b);
var name=$(_45b).attr("name");
if(name){
span.find("input.textbox-value").attr("name",name);
$(_45b).removeAttr("name").attr("textboxName",name);
}
return span;
};
function _45c(_45d){
var _45e=$.data(_45d,"textbox");
var opts=_45e.options;
var tb=_45e.textbox;
tb.find(".textbox-text").remove();
if(opts.multiline){
$("<textarea class=\"textbox-text\" autocomplete=\"off\"></textarea>").prependTo(tb);
}else{
$("<input type=\""+opts.type+"\" class=\"textbox-text\" autocomplete=\"off\">").prependTo(tb);
}
tb.find(".textbox-addon").remove();
var bb=opts.icons?$.extend(true,[],opts.icons):[];
if(opts.iconCls){
bb.push({iconCls:opts.iconCls,disabled:true});
}
if(bb.length){
var bc=$("<span class=\"textbox-addon\"></span>").prependTo(tb);
bc.addClass("textbox-addon-"+opts.iconAlign);
for(var i=0;i<bb.length;i++){
bc.append("<a href=\"javascript:void(0)\" class=\"textbox-icon "+bb[i].iconCls+"\" icon-index=\""+i+"\" tabindex=\"-1\"></a>");
}
}
tb.find(".textbox-button").remove();
if(opts.buttonText||opts.buttonIcon){
var btn=$("<a href=\"javascript:void(0)\" class=\"textbox-button\"></a>").prependTo(tb);
btn.addClass("textbox-button-"+opts.buttonAlign).linkbutton({text:opts.buttonText,iconCls:opts.buttonIcon});
}
_45f(_45d,opts.disabled);
_460(_45d,opts.readonly);
};
function _461(_462){
var tb=$.data(_462,"textbox").textbox;
tb.find(".textbox-text").validatebox("destroy");
tb.remove();
$(_462).remove();
};
function _463(_464,_465){
var _466=$.data(_464,"textbox");
var opts=_466.options;
var tb=_466.textbox;
var _467=tb.parent();
if(_465){
opts.width=_465;
}
if(isNaN(parseInt(opts.width))){
var c=$(_464).clone();
c.css("visibility","hidden");
c.insertAfter(_464);
opts.width=c.outerWidth();
c.remove();
}
tb.appendTo("body");
var _468=tb.find(".textbox-text");
var btn=tb.find(".textbox-button");
var _469=tb.find(".textbox-addon");
var _46a=_469.find(".textbox-icon");
tb._size(opts,_467);
btn.linkbutton("resize",{height:tb.height()});
btn.css({left:(opts.buttonAlign=="left"?0:""),right:(opts.buttonAlign=="right"?0:"")});
_469.css({left:(opts.iconAlign=="left"?(opts.buttonAlign=="left"?btn._outerWidth():0):""),right:(opts.iconAlign=="right"?(opts.buttonAlign=="right"?btn._outerWidth():0):"")});
_46a.css({width:opts.iconWidth+"px",height:tb.height()+"px"});
_468.css({paddingLeft:(_464.style.paddingLeft||""),paddingRight:(_464.style.paddingRight||""),marginLeft:_46b("left"),marginRight:_46b("right")});
if(opts.multiline){
_468.css({paddingTop:(_464.style.paddingTop||""),paddingBottom:(_464.style.paddingBottom||"")});
_468._outerHeight(tb.height());
}else{
var _46c=Math.floor((tb.height()-_468.height())/2);
_468.css({paddingTop:_46c+"px",paddingBottom:_46c+"px"});
}
_468._outerWidth(tb.width()-_46a.length*opts.iconWidth-btn._outerWidth());
tb.insertAfter(_464);
opts.onResize.call(_464,opts.width,opts.height);
function _46b(_46d){
return (opts.iconAlign==_46d?_469._outerWidth():0)+(opts.buttonAlign==_46d?btn._outerWidth():0);
};
};
function _46e(_46f){
var opts=$(_46f).textbox("options");
var _470=$(_46f).textbox("textbox");
_470.validatebox($.extend({},opts,{deltaX:$(_46f).textbox("getTipX"),onBeforeValidate:function(){
var box=$(this);
if(!box.is(":focus")){
opts.oldInputValue=box.val();
box.val(opts.value);
}
},onValidate:function(_471){
var box=$(this);
if(opts.oldInputValue!=undefined){
box.val(opts.oldInputValue);
opts.oldInputValue=undefined;
}
var tb=box.parent();
if(_471){
tb.removeClass("textbox-invalid");
}else{
tb.addClass("textbox-invalid");
}
}}));
};
function _472(_473){
var _474=$.data(_473,"textbox");
var opts=_474.options;
var tb=_474.textbox;
var _475=tb.find(".textbox-text");
_475.attr("placeholder",opts.prompt);
_475.unbind(".textbox");
if(!opts.disabled&&!opts.readonly){
_475.bind("blur.textbox",function(e){
if(!tb.hasClass("textbox-focused")){
return;
}
opts.value=$(this).val();
if(opts.value==""){
$(this).val(opts.prompt).addClass("textbox-prompt");
}else{
$(this).removeClass("textbox-prompt");
}
tb.removeClass("textbox-focused");
}).bind("focus.textbox",function(e){
if(tb.hasClass("textbox-focused")){
return;
}
if($(this).val()!=opts.value){
$(this).val(opts.value);
}
$(this).removeClass("textbox-prompt");
tb.addClass("textbox-focused");
});
for(var _476 in opts.inputEvents){
_475.bind(_476+".textbox",{target:_473},opts.inputEvents[_476]);
}
}
var _477=tb.find(".textbox-addon");
_477.unbind().bind("click",{target:_473},function(e){
var icon=$(e.target).closest("a.textbox-icon:not(.textbox-icon-disabled)");
if(icon.length){
var _478=parseInt(icon.attr("icon-index"));
var conf=opts.icons[_478];
if(conf&&conf.handler){
conf.handler.call(icon[0],e);
opts.onClickIcon.call(_473,_478);
}
}
});
_477.find(".textbox-icon").each(function(_479){
var conf=opts.icons[_479];
var icon=$(this);
if(!conf||conf.disabled||opts.disabled||opts.readonly){
icon.addClass("textbox-icon-disabled");
}else{
icon.removeClass("textbox-icon-disabled");
}
});
var btn=tb.find(".textbox-button");
btn.unbind(".textbox").bind("click.textbox",function(){
if(!btn.linkbutton("options").disabled){
opts.onClickButton.call(_473);
}
});
btn.linkbutton((opts.disabled||opts.readonly)?"disable":"enable");
tb.unbind(".textbox").bind("_resize.textbox",function(e,_47a){
if($(this).hasClass("easyui-fluid")||_47a){
_463(_473);
}
return false;
});
};
function _45f(_47b,_47c){
var _47d=$.data(_47b,"textbox");
var opts=_47d.options;
var tb=_47d.textbox;
if(_47c){
opts.disabled=true;
$(_47b).attr("disabled","disabled");
tb.find(".textbox-text,.textbox-value").attr("disabled","disabled");
}else{
opts.disabled=false;
$(_47b).removeAttr("disabled");
tb.find(".textbox-text,.textbox-value").removeAttr("disabled");
}
};
function _460(_47e,mode){
var _47f=$.data(_47e,"textbox");
var opts=_47f.options;
opts.readonly=mode==undefined?true:mode;
var _480=_47f.textbox.find(".textbox-text");
_480.removeAttr("readonly").removeClass("textbox-text-readonly");
if(opts.readonly||!opts.editable){
_480.attr("readonly","readonly").addClass("textbox-text-readonly");
}
};
$.fn.textbox=function(_481,_482){
if(typeof _481=="string"){
var _483=$.fn.textbox.methods[_481];
if(_483){
return _483(this,_482);
}else{
return this.each(function(){
var _484=$(this).textbox("textbox");
_484.validatebox(_481,_482);
});
}
}
_481=_481||{};
return this.each(function(){
var _485=$.data(this,"textbox");
if(_485){
$.extend(_485.options,_481);
if(_481.value!=undefined){
_485.options.originalValue=_481.value;
}
}else{
_485=$.data(this,"textbox",{options:$.extend({},$.fn.textbox.defaults,$.fn.textbox.parseOptions(this),_481),textbox:init(this)});
_485.options.originalValue=_485.options.value;
}
_45c(this);
_472(this);
_463(this);
_46e(this);
$(this).textbox("initValue",_485.options.value);
});
};
$.fn.textbox.methods={options:function(jq){
return $.data(jq[0],"textbox").options;
},cloneFrom:function(jq,from){
return jq.each(function(){
var t=$(this);
if(t.data("textbox")){
return;
}
if(!$(from).data("textbox")){
$(from).textbox();
}
var name=t.attr("name")||"";
t.addClass("textbox-f").hide();
t.removeAttr("name").attr("textboxName",name);
var span=$(from).next().clone().insertAfter(t);
span.find("input.textbox-value").attr("name",name);
$.data(this,"textbox",{options:$.extend(true,{},$(from).textbox("options")),textbox:span});
var _486=$(from).textbox("button");
if(_486.length){
t.textbox("button").linkbutton($.extend(true,{},_486.linkbutton("options")));
}
_472(this);
_46e(this);
});
},textbox:function(jq){
return $.data(jq[0],"textbox").textbox.find(".textbox-text");
},button:function(jq){
return $.data(jq[0],"textbox").textbox.find(".textbox-button");
},destroy:function(jq){
return jq.each(function(){
_461(this);
});
},resize:function(jq,_487){
return jq.each(function(){
_463(this,_487);
});
},disable:function(jq){
return jq.each(function(){
_45f(this,true);
_472(this);
});
},enable:function(jq){
return jq.each(function(){
_45f(this,false);
_472(this);
});
},readonly:function(jq,mode){
return jq.each(function(){
_460(this,mode);
_472(this);
});
},isValid:function(jq){
return jq.textbox("textbox").validatebox("isValid");
},clear:function(jq){
return jq.each(function(){
$(this).textbox("setValue","");
});
},setText:function(jq,_488){
return jq.each(function(){
var opts=$(this).textbox("options");
var _489=$(this).textbox("textbox");
if($(this).textbox("getText")!=_488){
opts.value=_488;
_489.val(_488);
}
if(!_489.is(":focus")){
if(_488){
_489.removeClass("textbox-prompt");
}else{
_489.val(opts.prompt).addClass("textbox-prompt");
}
}
$(this).textbox("validate");
});
},initValue:function(jq,_48a){
return jq.each(function(){
var _48b=$.data(this,"textbox");
_48b.options.value="";
$(this).textbox("setText",_48a);
_48b.textbox.find(".textbox-value").val(_48a);
$(this).val(_48a);
});
},setValue:function(jq,_48c){
return jq.each(function(){
var opts=$.data(this,"textbox").options;
var _48d=$(this).textbox("getValue");
$(this).textbox("initValue",_48c);
if(_48d!=_48c){
opts.onChange.call(this,_48c,_48d);
}
});
},getText:function(jq){
var _48e=jq.textbox("textbox");
if(_48e.is(":focus")){
return _48e.val();
}else{
return jq.textbox("options").value;
}
},getValue:function(jq){
return jq.data("textbox").textbox.find(".textbox-value").val();
},reset:function(jq){
return jq.each(function(){
var opts=$(this).textbox("options");
$(this).textbox("setValue",opts.originalValue);
});
},getIcon:function(jq,_48f){
return jq.data("textbox").textbox.find(".textbox-icon:eq("+_48f+")");
},getTipX:function(jq){
var _490=jq.data("textbox");
var opts=_490.options;
var tb=_490.textbox;
var _491=tb.find(".textbox-text");
var _492=tb.find(".textbox-addon")._outerWidth();
var _493=tb.find(".textbox-button")._outerWidth();
if(opts.tipPosition=="right"){
return (opts.iconAlign=="right"?_492:0)+(opts.buttonAlign=="right"?_493:0)+1;
}else{
if(opts.tipPosition=="left"){
return (opts.iconAlign=="left"?-_492:0)+(opts.buttonAlign=="left"?-_493:0)-1;
}else{
return _492/2*(opts.iconAlign=="right"?1:-1);
}
}
}};
$.fn.textbox.parseOptions=function(_494){
var t=$(_494);
return $.extend({},$.fn.validatebox.parseOptions(_494),$.parser.parseOptions(_494,["prompt","iconCls","iconAlign","buttonText","buttonIcon","buttonAlign",{multiline:"boolean",editable:"boolean",iconWidth:"number"}]),{value:(t.val()||undefined),type:(t.attr("type")?t.attr("type"):undefined),disabled:(t.attr("disabled")?true:undefined),readonly:(t.attr("readonly")?true:undefined)});
};
$.fn.textbox.defaults=$.extend({},$.fn.validatebox.defaults,{width:"auto",height:22,prompt:"",value:"",type:"text",multiline:false,editable:true,disabled:false,readonly:false,icons:[],iconCls:null,iconAlign:"right",iconWidth:18,buttonText:"",buttonIcon:null,buttonAlign:"right",inputEvents:{blur:function(e){
var t=$(e.data.target);
var opts=t.textbox("options");
t.textbox("setValue",opts.value);
},keydown:function(e){
if(e.keyCode==13){
var t=$(e.data.target);
t.textbox("setValue",t.textbox("getText"));
}
}},onChange:function(_495,_496){
},onResize:function(_497,_498){
},onClickButton:function(){
},onClickIcon:function(_499){
}});
})(jQuery);
(function($){
var _49a=0;
function _49b(_49c){
var _49d=$.data(_49c,"filebox");
var opts=_49d.options;
var id="filebox_file_id_"+(++_49a);
$(_49c).addClass("filebox-f").textbox($.extend({},opts,{buttonText:opts.buttonText?("<label for=\""+id+"\">"+opts.buttonText+"</label>"):""}));
$(_49c).textbox("textbox").attr("readonly","readonly");
_49d.filebox=$(_49c).next().addClass("filebox");
_49d.filebox.find(".textbox-value").remove();
opts.oldValue="";
var file=$("<input type=\"file\" class=\"textbox-value\">").appendTo(_49d.filebox);
file.attr("id",id).attr("name",$(_49c).attr("textboxName")||"");
file.change(function(){
$(_49c).filebox("setText",this.value);
opts.onChange.call(_49c,this.value,opts.oldValue);
opts.oldValue=this.value;
});
var btn=$(_49c).filebox("button");
if(btn.length){
if(btn.linkbutton("options").disabled){
file.attr("disabled","disabled");
}else{
file.removeAttr("disabled");
}
}
};
$.fn.filebox=function(_49e,_49f){
if(typeof _49e=="string"){
var _4a0=$.fn.filebox.methods[_49e];
if(_4a0){
return _4a0(this,_49f);
}else{
return this.textbox(_49e,_49f);
}
}
_49e=_49e||{};
return this.each(function(){
var _4a1=$.data(this,"filebox");
if(_4a1){
$.extend(_4a1.options,_49e);
}else{
$.data(this,"filebox",{options:$.extend({},$.fn.filebox.defaults,$.fn.filebox.parseOptions(this),_49e)});
}
_49b(this);
});
};
$.fn.filebox.methods={options:function(jq){
var opts=jq.textbox("options");
return $.extend($.data(jq[0],"filebox").options,{width:opts.width,value:opts.value,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
}};
$.fn.filebox.parseOptions=function(_4a2){
return $.extend({},$.fn.textbox.parseOptions(_4a2),{});
};
$.fn.filebox.defaults=$.extend({},$.fn.textbox.defaults,{buttonIcon:null,buttonText:"Choose File",buttonAlign:"right",inputEvents:{}});
})(jQuery);
(function($){
function _4a3(_4a4){
var _4a5=$.data(_4a4,"searchbox");
var opts=_4a5.options;
var _4a6=$.extend(true,[],opts.icons);
_4a6.push({iconCls:"searchbox-button",handler:function(e){
var t=$(e.data.target);
var opts=t.searchbox("options");
opts.searcher.call(e.data.target,t.searchbox("getValue"),t.searchbox("getName"));
}});
_4a7();
var _4a8=_4a9();
$(_4a4).addClass("searchbox-f").textbox($.extend({},opts,{icons:_4a6,buttonText:(_4a8?_4a8.text:"")}));
$(_4a4).attr("searchboxName",$(_4a4).attr("textboxName"));
_4a5.searchbox=$(_4a4).next();
_4a5.searchbox.addClass("searchbox");
_4aa(_4a8);
function _4a7(){
if(opts.menu){
_4a5.menu=$(opts.menu).menu();
var _4ab=_4a5.menu.menu("options");
var _4ac=_4ab.onClick;
_4ab.onClick=function(item){
_4aa(item);
_4ac.call(this,item);
};
}else{
if(_4a5.menu){
_4a5.menu.menu("destroy");
}
_4a5.menu=null;
}
};
function _4a9(){
if(_4a5.menu){
var item=_4a5.menu.children("div.menu-item:first");
_4a5.menu.children("div.menu-item").each(function(){
var _4ad=$.extend({},$.parser.parseOptions(this),{selected:($(this).attr("selected")?true:undefined)});
if(_4ad.selected){
item=$(this);
return false;
}
});
return _4a5.menu.menu("getItem",item[0]);
}else{
return null;
}
};
function _4aa(item){
if(!item){
return;
}
$(_4a4).textbox("button").menubutton({text:item.text,iconCls:(item.iconCls||null),menu:_4a5.menu,menuAlign:opts.buttonAlign,plain:false});
_4a5.searchbox.find("input.textbox-value").attr("name",item.name||item.text);
$(_4a4).searchbox("resize");
};
};
$.fn.searchbox=function(_4ae,_4af){
if(typeof _4ae=="string"){
var _4b0=$.fn.searchbox.methods[_4ae];
if(_4b0){
return _4b0(this,_4af);
}else{
return this.textbox(_4ae,_4af);
}
}
_4ae=_4ae||{};
return this.each(function(){
var _4b1=$.data(this,"searchbox");
if(_4b1){
$.extend(_4b1.options,_4ae);
}else{
$.data(this,"searchbox",{options:$.extend({},$.fn.searchbox.defaults,$.fn.searchbox.parseOptions(this),_4ae)});
}
_4a3(this);
});
};
$.fn.searchbox.methods={options:function(jq){
var opts=jq.textbox("options");
return $.extend($.data(jq[0],"searchbox").options,{width:opts.width,value:opts.value,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
},menu:function(jq){
return $.data(jq[0],"searchbox").menu;
},getName:function(jq){
return $.data(jq[0],"searchbox").searchbox.find("input.textbox-value").attr("name");
},selectName:function(jq,name){
return jq.each(function(){
var menu=$.data(this,"searchbox").menu;
if(menu){
menu.children("div.menu-item").each(function(){
var item=menu.menu("getItem",this);
if(item.name==name){
$(this).triggerHandler("click");
return false;
}
});
}
});
},destroy:function(jq){
return jq.each(function(){
var menu=$(this).searchbox("menu");
if(menu){
menu.menu("destroy");
}
$(this).textbox("destroy");
});
}};
$.fn.searchbox.parseOptions=function(_4b2){
var t=$(_4b2);
return $.extend({},$.fn.textbox.parseOptions(_4b2),$.parser.parseOptions(_4b2,["menu"]),{searcher:(t.attr("searcher")?eval(t.attr("searcher")):undefined)});
};
$.fn.searchbox.defaults=$.extend({},$.fn.textbox.defaults,{inputEvents:$.extend({},$.fn.textbox.defaults.inputEvents,{keydown:function(e){
if(e.keyCode==13){
e.preventDefault();
var t=$(e.data.target);
var opts=t.searchbox("options");
t.searchbox("setValue",$(this).val());
opts.searcher.call(e.data.target,t.searchbox("getValue"),t.searchbox("getName"));
return false;
}
}}),buttonAlign:"left",menu:null,searcher:function(_4b3,name){
}});
})(jQuery);
(function($){
function _4b4(_4b5,_4b6){
var opts=$.data(_4b5,"form").options;
$.extend(opts,_4b6||{});
var _4b7=$.extend({},opts.queryParams);
if(opts.onSubmit.call(_4b5,_4b7)==false){
return;
}
$(_4b5).find(".textbox-text:focus").blur();
var _4b8="easyui_frame_"+(new Date().getTime());
var _4b9=$("<iframe id="+_4b8+" name="+_4b8+"></iframe>").appendTo("body");
_4b9.attr("src",window.ActiveXObject?"javascript:false":"about:blank");
_4b9.css({position:"absolute",top:-1000,left:-1000});
_4b9.bind("load",cb);
_4ba(_4b7);
function _4ba(_4bb){
var form=$(_4b5);
if(opts.url){
form.attr("action",opts.url);
}
var t=form.attr("target"),a=form.attr("action");
form.attr("target",_4b8);
var _4bc=$();
try{
for(var n in _4bb){
var _4bd=$("<input type=\"hidden\" name=\""+n+"\">").val(_4bb[n]).appendTo(form);
_4bc=_4bc.add(_4bd);
}
_4be();
form[0].submit();
}
finally{
form.attr("action",a);
t?form.attr("target",t):form.removeAttr("target");
_4bc.remove();
}
};
function _4be(){
var f=$("#"+_4b8);
if(!f.length){
return;
}
try{
var s=f.contents()[0].readyState;
if(s&&s.toLowerCase()=="uninitialized"){
setTimeout(_4be,100);
}
}
catch(e){
cb();
}
};
var _4bf=10;
function cb(){
var f=$("#"+_4b8);
if(!f.length){
return;
}
f.unbind();
var data="";
try{
var body=f.contents().find("body");
data=body.html();
if(data==""){
if(--_4bf){
setTimeout(cb,100);
return;
}
}
var ta=body.find(">textarea");
if(ta.length){
data=ta.val();
}else{
var pre=body.find(">pre");
if(pre.length){
data=pre.html();
}
}
}
catch(e){
}
opts.success(data);
setTimeout(function(){
f.unbind();
f.remove();
},100);
};
};
function load(_4c0,data){
var opts=$.data(_4c0,"form").options;
if(typeof data=="string"){
var _4c1={};
if(opts.onBeforeLoad.call(_4c0,_4c1)==false){
return;
}
$.ajax({url:data,data:_4c1,dataType:"json",success:function(data){
_4c2(data);
},error:function(){
opts.onLoadError.apply(_4c0,arguments);
}});
}else{
_4c2(data);
}
function _4c2(data){
var form=$(_4c0);
for(var name in data){
var val=data[name];
var rr=_4c3(name,val);
if(!rr.length){
var _4c4=_4c5(name,val);
if(!_4c4){
$("input[name=\""+name+"\"]",form).val(val);
$("textarea[name=\""+name+"\"]",form).val(val);
$("select[name=\""+name+"\"]",form).val(val);
}
}
_4c6(name,val);
}
opts.onLoadSuccess.call(_4c0,data);
_4cd(_4c0);
};
function _4c3(name,val){
var rr=$(_4c0).find("input[name=\""+name+"\"][type=radio], input[name=\""+name+"\"][type=checkbox]");
rr._propAttr("checked",false);
rr.each(function(){
var f=$(this);
if(f.val()==String(val)||$.inArray(f.val(),$.isArray(val)?val:[val])>=0){
f._propAttr("checked",true);
}
});
return rr;
};
function _4c5(name,val){
var _4c7=0;
var pp=["textbox","numberbox","slider"];
for(var i=0;i<pp.length;i++){
var p=pp[i];
var f=$(_4c0).find("input["+p+"Name=\""+name+"\"]");
if(f.length){
f[p]("setValue",val);
_4c7+=f.length;
}
}
return _4c7;
};
function _4c6(name,val){
var form=$(_4c0);
var cc=["combobox","combotree","combogrid","datetimebox","datebox","combo"];
var c=form.find("[comboName=\""+name+"\"]");
if(c.length){
for(var i=0;i<cc.length;i++){
var type=cc[i];
if(c.hasClass(type+"-f")){
if(c[type]("options").multiple){
c[type]("setValues",val);
}else{
c[type]("setValue",val);
}
return;
}
}
}
};
};
function _4c8(_4c9){
$("input,select,textarea",_4c9).each(function(){
var t=this.type,tag=this.tagName.toLowerCase();
if(t=="text"||t=="hidden"||t=="password"||tag=="textarea"){
this.value="";
}else{
if(t=="file"){
var file=$(this);
if(!file.hasClass("textbox-value")){
var _4ca=file.clone().val("");
_4ca.insertAfter(file);
if(file.data("validatebox")){
file.validatebox("destroy");
_4ca.validatebox();
}else{
file.remove();
}
}
}else{
if(t=="checkbox"||t=="radio"){
this.checked=false;
}else{
if(tag=="select"){
this.selectedIndex=-1;
}
}
}
}
});
var t=$(_4c9);
var _4cb=["textbox","combo","combobox","combotree","combogrid","slider"];
for(var i=0;i<_4cb.length;i++){
var _4cc=_4cb[i];
var r=t.find("."+_4cc+"-f");
if(r.length&&r[_4cc]){
r[_4cc]("clear");
}
}
_4cd(_4c9);
};
function _4ce(_4cf){
_4cf.reset();
var t=$(_4cf);
var _4d0=["textbox","combo","combobox","combotree","combogrid","datebox","datetimebox","spinner","timespinner","numberbox","numberspinner","slider"];
for(var i=0;i<_4d0.length;i++){
var _4d1=_4d0[i];
var r=t.find("."+_4d1+"-f");
if(r.length&&r[_4d1]){
r[_4d1]("reset");
}
}
_4cd(_4cf);
};
function _4d2(_4d3){
var _4d4=$.data(_4d3,"form").options;
$(_4d3).unbind(".form");
if(_4d4.ajax){
$(_4d3).bind("submit.form",function(){
setTimeout(function(){
_4b4(_4d3,_4d4);
},0);
return false;
});
}
_4d5(_4d3,_4d4.novalidate);
};
function _4d6(_4d7,_4d8){
_4d8=_4d8||{};
var _4d9=$.data(_4d7,"form");
if(_4d9){
$.extend(_4d9.options,_4d8);
}else{
$.data(_4d7,"form",{options:$.extend({},$.fn.form.defaults,$.fn.form.parseOptions(_4d7),_4d8)});
}
};
function _4cd(_4da){
if($.fn.validatebox){
var t=$(_4da);
t.find(".validatebox-text:not(:disabled)").validatebox("validate");
var _4db=t.find(".validatebox-invalid");
_4db.filter(":not(:disabled):first").focus();
return _4db.length==0;
}
return true;
};
function _4d5(_4dc,_4dd){
var opts=$.data(_4dc,"form").options;
opts.novalidate=_4dd;
$(_4dc).find(".validatebox-text:not(:disabled)").validatebox(_4dd?"disableValidation":"enableValidation");
};
$.fn.form=function(_4de,_4df){
if(typeof _4de=="string"){
this.each(function(){
_4d6(this);
});
return $.fn.form.methods[_4de](this,_4df);
}
return this.each(function(){
_4d6(this,_4de);
_4d2(this);
});
};
$.fn.form.methods={options:function(jq){
return $.data(jq[0],"form").options;
},submit:function(jq,_4e0){
return jq.each(function(){
_4b4(this,_4e0);
});
},load:function(jq,data){
return jq.each(function(){
load(this,data);
});
},clear:function(jq){
return jq.each(function(){
_4c8(this);
});
},reset:function(jq){
return jq.each(function(){
_4ce(this);
});
},validate:function(jq){
return _4cd(jq[0]);
},disableValidation:function(jq){
return jq.each(function(){
_4d5(this,true);
});
},enableValidation:function(jq){
return jq.each(function(){
_4d5(this,false);
});
}};
$.fn.form.parseOptions=function(_4e1){
var t=$(_4e1);
return $.extend({},$.parser.parseOptions(_4e1,[{ajax:"boolean"}]),{url:(t.attr("action")?t.attr("action"):undefined)});
};
$.fn.form.defaults={novalidate:false,ajax:true,url:null,queryParams:{},onSubmit:function(_4e2){
return $(this).form("validate");
},success:function(data){
},onBeforeLoad:function(_4e3){
},onLoadSuccess:function(data){
},onLoadError:function(){
}};
})(jQuery);
(function($){
function _4e4(_4e5){
var _4e6=$.data(_4e5,"numberbox");
var opts=_4e6.options;
$(_4e5).addClass("numberbox-f").textbox(opts);
$(_4e5).textbox("textbox").css({imeMode:"disabled"});
$(_4e5).attr("numberboxName",$(_4e5).attr("textboxName"));
_4e6.numberbox=$(_4e5).next();
_4e6.numberbox.addClass("numberbox");
var _4e7=opts.parser.call(_4e5,opts.value);
var _4e8=opts.formatter.call(_4e5,_4e7);
$(_4e5).numberbox("initValue",_4e7).numberbox("setText",_4e8);
};
function _4e9(_4ea,_4eb){
var _4ec=$.data(_4ea,"numberbox");
var opts=_4ec.options;
var _4eb=opts.parser.call(_4ea,_4eb);
var text=opts.formatter.call(_4ea,_4eb);
opts.value=_4eb;
$(_4ea).textbox("setValue",_4eb).textbox("setText",text);
};
$.fn.numberbox=function(_4ed,_4ee){
if(typeof _4ed=="string"){
var _4ef=$.fn.numberbox.methods[_4ed];
if(_4ef){
return _4ef(this,_4ee);
}else{
return this.textbox(_4ed,_4ee);
}
}
_4ed=_4ed||{};
return this.each(function(){
var _4f0=$.data(this,"numberbox");
if(_4f0){
$.extend(_4f0.options,_4ed);
}else{
_4f0=$.data(this,"numberbox",{options:$.extend({},$.fn.numberbox.defaults,$.fn.numberbox.parseOptions(this),_4ed)});
}
_4e4(this);
});
};
$.fn.numberbox.methods={options:function(jq){
var opts=jq.data("textbox")?jq.textbox("options"):{};
return $.extend($.data(jq[0],"numberbox").options,{width:opts.width,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
},fix:function(jq){
return jq.each(function(){
$(this).numberbox("setValue",$(this).numberbox("getText"));
});
},setValue:function(jq,_4f1){
return jq.each(function(){
_4e9(this,_4f1);
});
},clear:function(jq){
return jq.each(function(){
$(this).textbox("clear");
$(this).numberbox("options").value="";
});
},reset:function(jq){
return jq.each(function(){
$(this).textbox("reset");
$(this).numberbox("setValue",$(this).numberbox("getValue"));
});
}};
$.fn.numberbox.parseOptions=function(_4f2){
var t=$(_4f2);
return $.extend({},$.fn.textbox.parseOptions(_4f2),$.parser.parseOptions(_4f2,["decimalSeparator","groupSeparator","suffix",{min:"number",max:"number",precision:"number"}]),{prefix:(t.attr("prefix")?t.attr("prefix"):undefined)});
};
$.fn.numberbox.defaults=$.extend({},$.fn.textbox.defaults,{inputEvents:{keypress:function(e){
var _4f3=e.data.target;
var opts=$(_4f3).numberbox("options");
return opts.filter.call(_4f3,e);
},blur:function(e){
var _4f4=e.data.target;
$(_4f4).numberbox("setValue",$(_4f4).numberbox("getText"));
},keydown:function(e){
if(e.keyCode==13){
var _4f5=e.data.target;
$(_4f5).numberbox("setValue",$(_4f5).numberbox("getText"));
}
}},min:null,max:null,precision:0,decimalSeparator:".",groupSeparator:"",prefix:"",suffix:"",filter:function(e){
var opts=$(this).numberbox("options");
var s=$(this).numberbox("getText");
if(e.which==13){
return true;
}
if(e.which==45){
return (s.indexOf("-")==-1?true:false);
}
var c=String.fromCharCode(e.which);
if(c==opts.decimalSeparator){
return (s.indexOf(c)==-1?true:false);
}else{
if(c==opts.groupSeparator){
return true;
}else{
if((e.which>=48&&e.which<=57&&e.ctrlKey==false&&e.shiftKey==false)||e.which==0||e.which==8){
return true;
}else{
if(e.ctrlKey==true&&(e.which==99||e.which==118)){
return true;
}else{
return false;
}
}
}
}
},formatter:function(_4f6){
if(!_4f6){
return _4f6;
}
_4f6=_4f6+"";
var opts=$(this).numberbox("options");
var s1=_4f6,s2="";
var dpos=_4f6.indexOf(".");
if(dpos>=0){
s1=_4f6.substring(0,dpos);
s2=_4f6.substring(dpos+1,_4f6.length);
}
if(opts.groupSeparator){
var p=/(\d+)(\d{3})/;
while(p.test(s1)){
s1=s1.replace(p,"$1"+opts.groupSeparator+"$2");
}
}
if(s2){
return opts.prefix+s1+opts.decimalSeparator+s2+opts.suffix;
}else{
return opts.prefix+s1+opts.suffix;
}
},parser:function(s){
s=s+"";
var opts=$(this).numberbox("options");
if(parseFloat(s)!=s){
if(opts.prefix){
s=$.trim(s.replace(new RegExp("\\"+$.trim(opts.prefix),"g"),""));
}
if(opts.suffix){
s=$.trim(s.replace(new RegExp("\\"+$.trim(opts.suffix),"g"),""));
}
if(opts.groupSeparator){
s=$.trim(s.replace(new RegExp("\\"+opts.groupSeparator,"g"),""));
}
if(opts.decimalSeparator){
s=$.trim(s.replace(new RegExp("\\"+opts.decimalSeparator,"g"),"."));
}
s=s.replace(/\s/g,"");
}
var val=parseFloat(s).toFixed(opts.precision);
if(isNaN(val)){
val="";
}else{
if(typeof (opts.min)=="number"&&val<opts.min){
val=opts.min.toFixed(opts.precision);
}else{
if(typeof (opts.max)=="number"&&val>opts.max){
val=opts.max.toFixed(opts.precision);
}
}
}
return val;
}});
})(jQuery);
(function($){
function _4f7(_4f8,_4f9){
var opts=$.data(_4f8,"calendar").options;
var t=$(_4f8);
if(_4f9){
$.extend(opts,{width:_4f9.width,height:_4f9.height});
}
t._size(opts,t.parent());
t.find(".calendar-body")._outerHeight(t.height()-t.find(".calendar-header")._outerHeight());
if(t.find(".calendar-menu").is(":visible")){
_4fa(_4f8);
}
};
function init(_4fb){
$(_4fb).addClass("calendar").html("<div class=\"calendar-header\">"+"<div class=\"calendar-nav calendar-prevmonth\"></div>"+"<div class=\"calendar-nav calendar-nextmonth\"></div>"+"<div class=\"calendar-nav calendar-prevyear\"></div>"+"<div class=\"calendar-nav calendar-nextyear\"></div>"+"<div class=\"calendar-title\">"+"<span class=\"calendar-text\"></span>"+"</div>"+"</div>"+"<div class=\"calendar-body\">"+"<div class=\"calendar-menu\">"+"<div class=\"calendar-menu-year-inner\">"+"<span class=\"calendar-nav calendar-menu-prev\"></span>"+"<span><input class=\"calendar-menu-year\" type=\"text\"></input></span>"+"<span class=\"calendar-nav calendar-menu-next\"></span>"+"</div>"+"<div class=\"calendar-menu-month-inner\">"+"</div>"+"</div>"+"</div>");
$(_4fb).bind("_resize",function(e,_4fc){
if($(this).hasClass("easyui-fluid")||_4fc){
_4f7(_4fb);
}
return false;
});
};
function _4fd(_4fe){
var opts=$.data(_4fe,"calendar").options;
var menu=$(_4fe).find(".calendar-menu");
menu.find(".calendar-menu-year").unbind(".calendar").bind("keypress.calendar",function(e){
if(e.keyCode==13){
_4ff(true);
}
});
$(_4fe).unbind(".calendar").bind("mouseover.calendar",function(e){
var t=_500(e.target);
if(t.hasClass("calendar-nav")||t.hasClass("calendar-text")||(t.hasClass("calendar-day")&&!t.hasClass("calendar-disabled"))){
t.addClass("calendar-nav-hover");
}
}).bind("mouseout.calendar",function(e){
var t=_500(e.target);
if(t.hasClass("calendar-nav")||t.hasClass("calendar-text")||(t.hasClass("calendar-day")&&!t.hasClass("calendar-disabled"))){
t.removeClass("calendar-nav-hover");
}
}).bind("click.calendar",function(e){
var t=_500(e.target);
if(t.hasClass("calendar-menu-next")||t.hasClass("calendar-nextyear")){
_501(1);
}else{
if(t.hasClass("calendar-menu-prev")||t.hasClass("calendar-prevyear")){
_501(-1);
}else{
if(t.hasClass("calendar-menu-month")){
menu.find(".calendar-selected").removeClass("calendar-selected");
t.addClass("calendar-selected");
_4ff(true);
}else{
if(t.hasClass("calendar-prevmonth")){
_502(-1);
}else{
if(t.hasClass("calendar-nextmonth")){
_502(1);
}else{
if(t.hasClass("calendar-text")){
if(menu.is(":visible")){
menu.hide();
}else{
_4fa(_4fe);
}
}else{
if(t.hasClass("calendar-day")){
if(t.hasClass("calendar-disabled")){
return;
}
var _503=opts.current;
t.closest("div.calendar-body").find(".calendar-selected").removeClass("calendar-selected");
t.addClass("calendar-selected");
var _504=t.attr("abbr").split(",");
var y=parseInt(_504[0]);
var m=parseInt(_504[1]);
var d=parseInt(_504[2]);
opts.current=new Date(y,m-1,d);
opts.onSelect.call(_4fe,opts.current);
if(!_503||_503.getTime()!=opts.current.getTime()){
opts.onChange.call(_4fe,opts.current,_503);
}
if(opts.year!=y||opts.month!=m){
opts.year=y;
opts.month=m;
show(_4fe);
}
}
}
}
}
}
}
}
});
function _500(t){
var day=$(t).closest(".calendar-day");
if(day.length){
return day;
}else{
return $(t);
}
};
function _4ff(_505){
var menu=$(_4fe).find(".calendar-menu");
var year=menu.find(".calendar-menu-year").val();
var _506=menu.find(".calendar-selected").attr("abbr");
if(!isNaN(year)){
opts.year=parseInt(year);
opts.month=parseInt(_506);
show(_4fe);
}
if(_505){
menu.hide();
}
};
function _501(_507){
opts.year+=_507;
show(_4fe);
menu.find(".calendar-menu-year").val(opts.year);
};
function _502(_508){
opts.month+=_508;
if(opts.month>12){
opts.year++;
opts.month=1;
}else{
if(opts.month<1){
opts.year--;
opts.month=12;
}
}
show(_4fe);
menu.find("td.calendar-selected").removeClass("calendar-selected");
menu.find("td:eq("+(opts.month-1)+")").addClass("calendar-selected");
};
};
function _4fa(_509){
var opts=$.data(_509,"calendar").options;
$(_509).find(".calendar-menu").show();
if($(_509).find(".calendar-menu-month-inner").is(":empty")){
$(_509).find(".calendar-menu-month-inner").empty();
var t=$("<table class=\"calendar-mtable\"></table>").appendTo($(_509).find(".calendar-menu-month-inner"));
var idx=0;
for(var i=0;i<3;i++){
var tr=$("<tr></tr>").appendTo(t);
for(var j=0;j<4;j++){
$("<td class=\"calendar-nav calendar-menu-month\"></td>").html(opts.months[idx++]).attr("abbr",idx).appendTo(tr);
}
}
}
var body=$(_509).find(".calendar-body");
var sele=$(_509).find(".calendar-menu");
var _50a=sele.find(".calendar-menu-year-inner");
var _50b=sele.find(".calendar-menu-month-inner");
_50a.find("input").val(opts.year).focus();
_50b.find("td.calendar-selected").removeClass("calendar-selected");
_50b.find("td:eq("+(opts.month-1)+")").addClass("calendar-selected");
sele._outerWidth(body._outerWidth());
sele._outerHeight(body._outerHeight());
_50b._outerHeight(sele.height()-_50a._outerHeight());
};
function _50c(_50d,year,_50e){
var opts=$.data(_50d,"calendar").options;
var _50f=[];
var _510=new Date(year,_50e,0).getDate();
for(var i=1;i<=_510;i++){
_50f.push([year,_50e,i]);
}
var _511=[],week=[];
var _512=-1;
while(_50f.length>0){
var date=_50f.shift();
week.push(date);
var day=new Date(date[0],date[1]-1,date[2]).getDay();
if(_512==day){
day=0;
}else{
if(day==(opts.firstDay==0?7:opts.firstDay)-1){
_511.push(week);
week=[];
}
}
_512=day;
}
if(week.length){
_511.push(week);
}
var _513=_511[0];
if(_513.length<7){
while(_513.length<7){
var _514=_513[0];
var date=new Date(_514[0],_514[1]-1,_514[2]-1);
_513.unshift([date.getFullYear(),date.getMonth()+1,date.getDate()]);
}
}else{
var _514=_513[0];
var week=[];
for(var i=1;i<=7;i++){
var date=new Date(_514[0],_514[1]-1,_514[2]-i);
week.unshift([date.getFullYear(),date.getMonth()+1,date.getDate()]);
}
_511.unshift(week);
}
var _515=_511[_511.length-1];
while(_515.length<7){
var _516=_515[_515.length-1];
var date=new Date(_516[0],_516[1]-1,_516[2]+1);
_515.push([date.getFullYear(),date.getMonth()+1,date.getDate()]);
}
if(_511.length<6){
var _516=_515[_515.length-1];
var week=[];
for(var i=1;i<=7;i++){
var date=new Date(_516[0],_516[1]-1,_516[2]+i);
week.push([date.getFullYear(),date.getMonth()+1,date.getDate()]);
}
_511.push(week);
}
return _511;
};
function show(_517){
var opts=$.data(_517,"calendar").options;
if(opts.current&&!opts.validator.call(_517,opts.current)){
opts.current=null;
}
var now=new Date();
var _518=now.getFullYear()+","+(now.getMonth()+1)+","+now.getDate();
var _519=opts.current?(opts.current.getFullYear()+","+(opts.current.getMonth()+1)+","+opts.current.getDate()):"";
var _51a=6-opts.firstDay;
var _51b=_51a+1;
if(_51a>=7){
_51a-=7;
}
if(_51b>=7){
_51b-=7;
}
$(_517).find(".calendar-title span").html(opts.months[opts.month-1]+" "+opts.year);
var body=$(_517).find("div.calendar-body");
body.children("table").remove();
var data=["<table class=\"calendar-dtable\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\">"];
data.push("<thead><tr>");
for(var i=opts.firstDay;i<opts.weeks.length;i++){
data.push("<th>"+opts.weeks[i]+"</th>");
}
for(var i=0;i<opts.firstDay;i++){
data.push("<th>"+opts.weeks[i]+"</th>");
}
data.push("</tr></thead>");
data.push("<tbody>");
var _51c=_50c(_517,opts.year,opts.month);
for(var i=0;i<_51c.length;i++){
var week=_51c[i];
var cls="";
if(i==0){
cls="calendar-first";
}else{
if(i==_51c.length-1){
cls="calendar-last";
}
}
data.push("<tr class=\""+cls+"\">");
for(var j=0;j<week.length;j++){
var day=week[j];
var s=day[0]+","+day[1]+","+day[2];
var _51d=new Date(day[0],parseInt(day[1])-1,day[2]);
var d=opts.formatter.call(_517,_51d);
var css=opts.styler.call(_517,_51d);
var _51e="";
var _51f="";
if(typeof css=="string"){
_51f=css;
}else{
if(css){
_51e=css["class"]||"";
_51f=css["style"]||"";
}
}
var cls="calendar-day";
if(!(opts.year==day[0]&&opts.month==day[1])){
cls+=" calendar-other-month";
}
if(s==_518){
cls+=" calendar-today";
}
if(s==_519){
cls+=" calendar-selected";
}
if(j==_51a){
cls+=" calendar-saturday";
}else{
if(j==_51b){
cls+=" calendar-sunday";
}
}
if(j==0){
cls+=" calendar-first";
}else{
if(j==week.length-1){
cls+=" calendar-last";
}
}
cls+=" "+_51e;
if(!opts.validator.call(_517,_51d)){
cls+=" calendar-disabled";
}
data.push("<td class=\""+cls+"\" abbr=\""+s+"\" style=\""+_51f+"\">"+d+"</td>");
}
data.push("</tr>");
}
data.push("</tbody>");
data.push("</table>");
body.append(data.join(""));
body.children("table.calendar-dtable").prependTo(body);
opts.onNavigate.call(_517,opts.year,opts.month);
};
$.fn.calendar=function(_520,_521){
if(typeof _520=="string"){
return $.fn.calendar.methods[_520](this,_521);
}
_520=_520||{};
return this.each(function(){
var _522=$.data(this,"calendar");
if(_522){
$.extend(_522.options,_520);
}else{
_522=$.data(this,"calendar",{options:$.extend({},$.fn.calendar.defaults,$.fn.calendar.parseOptions(this),_520)});
init(this);
}
if(_522.options.border==false){
$(this).addClass("calendar-noborder");
}
_4f7(this);
_4fd(this);
show(this);
$(this).find("div.calendar-menu").hide();
});
};
$.fn.calendar.methods={options:function(jq){
return $.data(jq[0],"calendar").options;
},resize:function(jq,_523){
return jq.each(function(){
_4f7(this,_523);
});
},moveTo:function(jq,date){
return jq.each(function(){
var opts=$(this).calendar("options");
if(opts.validator.call(this,date)){
var _524=opts.current;
$(this).calendar({year:date.getFullYear(),month:date.getMonth()+1,current:date});
if(!_524||_524.getTime()!=date.getTime()){
opts.onChange.call(this,opts.current,_524);
}
}
});
}};
$.fn.calendar.parseOptions=function(_525){
var t=$(_525);
return $.extend({},$.parser.parseOptions(_525,[{firstDay:"number",fit:"boolean",border:"boolean"}]));
};
$.fn.calendar.defaults={width:180,height:180,fit:false,border:true,firstDay:0,weeks:["S","M","T","W","T","F","S"],months:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],year:new Date().getFullYear(),month:new Date().getMonth()+1,current:(function(){
var d=new Date();
return new Date(d.getFullYear(),d.getMonth(),d.getDate());
})(),formatter:function(date){
return date.getDate();
},styler:function(date){
return "";
},validator:function(date){
return true;
},onSelect:function(date){
},onChange:function(_526,_527){
},onNavigate:function(year,_528){
}};
})(jQuery);
(function($){
function _529(_52a){
var _52b=$.data(_52a,"spinner");
var opts=_52b.options;
var _52c=$.extend(true,[],opts.icons);
_52c.push({iconCls:"spinner-arrow",handler:function(e){
_52d(e);
}});
$(_52a).addClass("spinner-f").textbox($.extend({},opts,{icons:_52c}));
var _52e=$(_52a).textbox("getIcon",_52c.length-1);
_52e.append("<a href=\"javascript:void(0)\" class=\"spinner-arrow-up\" tabindex=\"-1\"></a>");
_52e.append("<a href=\"javascript:void(0)\" class=\"spinner-arrow-down\" tabindex=\"-1\"></a>");
$(_52a).attr("spinnerName",$(_52a).attr("textboxName"));
_52b.spinner=$(_52a).next();
_52b.spinner.addClass("spinner");
};
function _52d(e){
var _52f=e.data.target;
var opts=$(_52f).spinner("options");
var up=$(e.target).closest("a.spinner-arrow-up");
if(up.length){
opts.spin.call(_52f,false);
opts.onSpinUp.call(_52f);
$(_52f).spinner("validate");
}
var down=$(e.target).closest("a.spinner-arrow-down");
if(down.length){
opts.spin.call(_52f,true);
opts.onSpinDown.call(_52f);
$(_52f).spinner("validate");
}
};
$.fn.spinner=function(_530,_531){
if(typeof _530=="string"){
var _532=$.fn.spinner.methods[_530];
if(_532){
return _532(this,_531);
}else{
return this.textbox(_530,_531);
}
}
_530=_530||{};
return this.each(function(){
var _533=$.data(this,"spinner");
if(_533){
$.extend(_533.options,_530);
}else{
_533=$.data(this,"spinner",{options:$.extend({},$.fn.spinner.defaults,$.fn.spinner.parseOptions(this),_530)});
}
_529(this);
});
};
$.fn.spinner.methods={options:function(jq){
var opts=jq.textbox("options");
return $.extend($.data(jq[0],"spinner").options,{width:opts.width,value:opts.value,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
}};
$.fn.spinner.parseOptions=function(_534){
return $.extend({},$.fn.textbox.parseOptions(_534),$.parser.parseOptions(_534,["min","max",{increment:"number"}]));
};
$.fn.spinner.defaults=$.extend({},$.fn.textbox.defaults,{min:null,max:null,increment:1,spin:function(down){
},onSpinUp:function(){
},onSpinDown:function(){
}});
})(jQuery);
(function($){
function _535(_536){
$(_536).addClass("numberspinner-f");
var opts=$.data(_536,"numberspinner").options;
$(_536).numberbox(opts).spinner(opts);
$(_536).numberbox("setValue",opts.value);
};
function _537(_538,down){
var opts=$.data(_538,"numberspinner").options;
var v=parseFloat($(_538).numberbox("getValue")||opts.value)||0;
if(down){
v-=opts.increment;
}else{
v+=opts.increment;
}
$(_538).numberbox("setValue",v);
};
$.fn.numberspinner=function(_539,_53a){
if(typeof _539=="string"){
var _53b=$.fn.numberspinner.methods[_539];
if(_53b){
return _53b(this,_53a);
}else{
return this.numberbox(_539,_53a);
}
}
_539=_539||{};
return this.each(function(){
var _53c=$.data(this,"numberspinner");
if(_53c){
$.extend(_53c.options,_539);
}else{
$.data(this,"numberspinner",{options:$.extend({},$.fn.numberspinner.defaults,$.fn.numberspinner.parseOptions(this),_539)});
}
_535(this);
});
};
$.fn.numberspinner.methods={options:function(jq){
var opts=jq.numberbox("options");
return $.extend($.data(jq[0],"numberspinner").options,{width:opts.width,value:opts.value,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
}};
$.fn.numberspinner.parseOptions=function(_53d){
return $.extend({},$.fn.spinner.parseOptions(_53d),$.fn.numberbox.parseOptions(_53d),{});
};
$.fn.numberspinner.defaults=$.extend({},$.fn.spinner.defaults,$.fn.numberbox.defaults,{spin:function(down){
_537(this,down);
}});
})(jQuery);
(function($){
function _53e(_53f){
var _540=0;
if(_53f.selectionStart){
_540=_53f.selectionStart;
}else{
if(_53f.createTextRange){
var _541=_53f.createTextRange();
var s=document.selection.createRange();
s.setEndPoint("StartToStart",_541);
_540=s.text.length;
}
}
return _540;
};
function _542(_543,_544,end){
if(_543.selectionStart){
_543.setSelectionRange(_544,end);
}else{
if(_543.createTextRange){
var _545=_543.createTextRange();
_545.collapse();
_545.moveEnd("character",end);
_545.moveStart("character",_544);
_545.select();
}
}
};
function _546(_547){
var opts=$.data(_547,"timespinner").options;
$(_547).addClass("timespinner-f").spinner(opts);
var _548=opts.formatter.call(_547,opts.parser.call(_547,opts.value));
$(_547).timespinner("initValue",_548);
};
function _549(e){
var _54a=e.data.target;
var opts=$.data(_54a,"timespinner").options;
var _54b=_53e(this);
for(var i=0;i<opts.selections.length;i++){
var _54c=opts.selections[i];
if(_54b>=_54c[0]&&_54b<=_54c[1]){
_54d(_54a,i);
return;
}
}
};
function _54d(_54e,_54f){
var opts=$.data(_54e,"timespinner").options;
if(_54f!=undefined){
opts.highlight=_54f;
}
var _550=opts.selections[opts.highlight];
if(_550){
var tb=$(_54e).timespinner("textbox");
_542(tb[0],_550[0],_550[1]);
tb.focus();
}
};
function _551(_552,_553){
var opts=$.data(_552,"timespinner").options;
var _553=opts.parser.call(_552,_553);
var text=opts.formatter.call(_552,_553);
$(_552).spinner("setValue",text);
};
function _554(_555,down){
var opts=$.data(_555,"timespinner").options;
var s=$(_555).timespinner("getValue");
var _556=opts.selections[opts.highlight];
var s1=s.substring(0,_556[0]);
var s2=s.substring(_556[0],_556[1]);
var s3=s.substring(_556[1]);
var v=s1+((parseInt(s2)||0)+opts.increment*(down?-1:1))+s3;
$(_555).timespinner("setValue",v);
_54d(_555);
};
$.fn.timespinner=function(_557,_558){
if(typeof _557=="string"){
var _559=$.fn.timespinner.methods[_557];
if(_559){
return _559(this,_558);
}else{
return this.spinner(_557,_558);
}
}
_557=_557||{};
return this.each(function(){
var _55a=$.data(this,"timespinner");
if(_55a){
$.extend(_55a.options,_557);
}else{
$.data(this,"timespinner",{options:$.extend({},$.fn.timespinner.defaults,$.fn.timespinner.parseOptions(this),_557)});
}
_546(this);
});
};
$.fn.timespinner.methods={options:function(jq){
var opts=jq.data("spinner")?jq.spinner("options"):{};
return $.extend($.data(jq[0],"timespinner").options,{width:opts.width,value:opts.value,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
},setValue:function(jq,_55b){
return jq.each(function(){
_551(this,_55b);
});
},getHours:function(jq){
var opts=$.data(jq[0],"timespinner").options;
var vv=jq.timespinner("getValue").split(opts.separator);
return parseInt(vv[0],10);
},getMinutes:function(jq){
var opts=$.data(jq[0],"timespinner").options;
var vv=jq.timespinner("getValue").split(opts.separator);
return parseInt(vv[1],10);
},getSeconds:function(jq){
var opts=$.data(jq[0],"timespinner").options;
var vv=jq.timespinner("getValue").split(opts.separator);
return parseInt(vv[2],10)||0;
}};
$.fn.timespinner.parseOptions=function(_55c){
return $.extend({},$.fn.spinner.parseOptions(_55c),$.parser.parseOptions(_55c,["separator",{showSeconds:"boolean",highlight:"number"}]));
};
$.fn.timespinner.defaults=$.extend({},$.fn.spinner.defaults,{inputEvents:$.extend({},$.fn.spinner.defaults.inputEvents,{click:function(e){
_549.call(this,e);
},blur:function(e){
var t=$(e.data.target);
t.timespinner("setValue",t.timespinner("getText"));
},keydown:function(e){
if(e.keyCode==13){
var t=$(e.data.target);
t.timespinner("setValue",t.timespinner("getText"));
}
}}),formatter:function(date){
if(!date){
return "";
}
var opts=$(this).timespinner("options");
var tt=[_55d(date.getHours()),_55d(date.getMinutes())];
if(opts.showSeconds){
tt.push(_55d(date.getSeconds()));
}
return tt.join(opts.separator);
function _55d(_55e){
return (_55e<10?"0":"")+_55e;
};
},parser:function(s){
var opts=$(this).timespinner("options");
var date=_55f(s);
if(date){
var min=_55f(opts.min);
var max=_55f(opts.max);
if(min&&min>date){
date=min;
}
if(max&&max<date){
date=max;
}
}
return date;
function _55f(s){
if(!s){
return null;
}
var tt=s.split(opts.separator);
return new Date(1900,0,0,parseInt(tt[0],10)||0,parseInt(tt[1],10)||0,parseInt(tt[2],10)||0);
};
if(!s){
return null;
}
var tt=s.split(opts.separator);
return new Date(1900,0,0,parseInt(tt[0],10)||0,parseInt(tt[1],10)||0,parseInt(tt[2],10)||0);
},selections:[[0,2],[3,5],[6,8]],separator:":",showSeconds:false,highlight:0,spin:function(down){
_554(this,down);
}});
})(jQuery);
(function($){
function _560(_561){
var opts=$.data(_561,"datetimespinner").options;
$(_561).addClass("datetimespinner-f").timespinner(opts);
};
$.fn.datetimespinner=function(_562,_563){
if(typeof _562=="string"){
var _564=$.fn.datetimespinner.methods[_562];
if(_564){
return _564(this,_563);
}else{
return this.timespinner(_562,_563);
}
}
_562=_562||{};
return this.each(function(){
var _565=$.data(this,"datetimespinner");
if(_565){
$.extend(_565.options,_562);
}else{
$.data(this,"datetimespinner",{options:$.extend({},$.fn.datetimespinner.defaults,$.fn.datetimespinner.parseOptions(this),_562)});
}
_560(this);
});
};
$.fn.datetimespinner.methods={options:function(jq){
var opts=jq.timespinner("options");
return $.extend($.data(jq[0],"datetimespinner").options,{width:opts.width,value:opts.value,originalValue:opts.originalValue,disabled:opts.disabled,readonly:opts.readonly});
}};
$.fn.datetimespinner.parseOptions=function(_566){
return $.extend({},$.fn.timespinner.parseOptions(_566),$.parser.parseOptions(_566,[]));
};
$.fn.datetimespinner.defaults=$.extend({},$.fn.timespinner.defaults,{formatter:function(date){
if(!date){
return "";
}
return $.fn.datebox.defaults.formatter.call(this,date)+" "+$.fn.timespinner.defaults.formatter.call(this,date);
},parser:function(s){
s=$.trim(s);
if(!s){
return null;
}
var dt=s.split(" ");
var _567=$.fn.datebox.defaults.parser.call(this,dt[0]);
if(dt.length<2){
return _567;
}
var _568=$.fn.timespinner.defaults.parser.call(this,dt[1]);
return new Date(_567.getFullYear(),_567.getMonth(),_567.getDate(),_568.getHours(),_568.getMinutes(),_568.getSeconds());
},selections:[[0,2],[3,5],[6,10],[11,13],[14,16],[17,19]]});
})(jQuery);
(function($){
var _569=0;
function _56a(a,o){
for(var i=0,len=a.length;i<len;i++){
if(a[i]==o){
return i;
}
}
return -1;
};
function _56b(a,o,id){
if(typeof o=="string"){
for(var i=0,len=a.length;i<len;i++){
if(a[i][o]==id){
a.splice(i,1);
return;
}
}
}else{
var _56c=_56a(a,o);
if(_56c!=-1){
a.splice(_56c,1);
}
}
};
function _56d(a,o,r){
for(var i=0,len=a.length;i<len;i++){
if(a[i][o]==r[o]){
return;
}
}
a.push(r);
};
function _56e(_56f){
var _570=$.data(_56f,"datagrid");
var opts=_570.options;
var _571=_570.panel;
var dc=_570.dc;
var ss=null;
if(opts.sharedStyleSheet){
ss=typeof opts.sharedStyleSheet=="boolean"?"head":opts.sharedStyleSheet;
}else{
ss=_571.closest("div.datagrid-view");
if(!ss.length){
ss=dc.view;
}
}
var cc=$(ss);
var _572=$.data(cc[0],"ss");
if(!_572){
_572=$.data(cc[0],"ss",{cache:{},dirty:[]});
}
return {add:function(_573){
var ss=["<style type=\"text/css\" easyui=\"true\">"];
for(var i=0;i<_573.length;i++){
_572.cache[_573[i][0]]={width:_573[i][1]};
}
var _574=0;
for(var s in _572.cache){
var item=_572.cache[s];
item.index=_574++;
ss.push(s+"{width:"+item.width+"}");
}
ss.push("</style>");
$(ss.join("\n")).appendTo(cc);
cc.children("style[easyui]:not(:last)").remove();
},getRule:function(_575){
var _576=cc.children("style[easyui]:last")[0];
var _577=_576.styleSheet?_576.styleSheet:(_576.sheet||document.styleSheets[document.styleSheets.length-1]);
var _578=_577.cssRules||_577.rules;
return _578[_575];
},set:function(_579,_57a){
var item=_572.cache[_579];
if(item){
item.width=_57a;
var rule=this.getRule(item.index);
if(rule){
rule.style["width"]=_57a;
}
}
},remove:function(_57b){
var tmp=[];
for(var s in _572.cache){
if(s.indexOf(_57b)==-1){
tmp.push([s,_572.cache[s].width]);
}
}
_572.cache={};
this.add(tmp);
},dirty:function(_57c){
if(_57c){
_572.dirty.push(_57c);
}
},clean:function(){
for(var i=0;i<_572.dirty.length;i++){
this.remove(_572.dirty[i]);
}
_572.dirty=[];
}};
};
function _57d(_57e,_57f){
var _580=$.data(_57e,"datagrid");
var opts=_580.options;
var _581=_580.panel;
if(_57f){
$.extend(opts,_57f);
}
if(opts.fit==true){
var p=_581.panel("panel").parent();
opts.width=p.width();
opts.height=p.height();
}
_581.panel("resize",opts);
};
function _582(_583){
var _584=$.data(_583,"datagrid");
var opts=_584.options;
var dc=_584.dc;
var wrap=_584.panel;
var _585=wrap.width();
var _586=wrap.height();
var view=dc.view;
var _587=dc.view1;
var _588=dc.view2;
var _589=_587.children("div.datagrid-header");
var _58a=_588.children("div.datagrid-header");
var _58b=_589.find("table");
var _58c=_58a.find("table");
view.width(_585);
var _58d=_589.children("div.datagrid-header-inner").show();
_587.width(_58d.find("table").width());
if(!opts.showHeader){
_58d.hide();
}
_588.width(_585-_587._outerWidth());
_587.children("div.datagrid-header,div.datagrid-body,div.datagrid-footer").width(_587.width());
_588.children("div.datagrid-header,div.datagrid-body,div.datagrid-footer").width(_588.width());
var hh;
_589.add(_58a).css("height","");
_58b.add(_58c).css("height","");
hh=Math.max(_58b.height(),_58c.height());
_58b.add(_58c).height(hh);
_589.add(_58a)._outerHeight(hh);
dc.body1.add(dc.body2).children("table.datagrid-btable-frozen").css({position:"absolute",top:dc.header2._outerHeight()});
var _58e=dc.body2.children("table.datagrid-btable-frozen")._outerHeight();
var _58f=_58e+_588.children("div.datagrid-header")._outerHeight()+_588.children("div.datagrid-footer")._outerHeight()+wrap.children("div.datagrid-toolbar")._outerHeight();
wrap.children("div.datagrid-pager").each(function(){
_58f+=$(this)._outerHeight();
});
var _590=wrap.outerHeight()-wrap.height();
var _591=wrap._size("minHeight")||"";
var _592=wrap._size("maxHeight")||"";
_587.add(_588).children("div.datagrid-body").css({marginTop:_58e,height:(isNaN(parseInt(opts.height))?"":(_586-_58f)),minHeight:(_591?_591-_590-_58f:""),maxHeight:(_592?_592-_590-_58f:"")});
view.height(_588.height());
};
function _593(_594,_595,_596){
var rows=$.data(_594,"datagrid").data.rows;
var opts=$.data(_594,"datagrid").options;
var dc=$.data(_594,"datagrid").dc;
if(!dc.body1.is(":empty")&&(!opts.nowrap||opts.autoRowHeight||_596)){
if(_595!=undefined){
var tr1=opts.finder.getTr(_594,_595,"body",1);
var tr2=opts.finder.getTr(_594,_595,"body",2);
_597(tr1,tr2);
}else{
var tr1=opts.finder.getTr(_594,0,"allbody",1);
var tr2=opts.finder.getTr(_594,0,"allbody",2);
_597(tr1,tr2);
if(opts.showFooter){
var tr1=opts.finder.getTr(_594,0,"allfooter",1);
var tr2=opts.finder.getTr(_594,0,"allfooter",2);
_597(tr1,tr2);
}
}
}
_582(_594);
if(opts.height=="auto"){
var _598=dc.body1.parent();
var _599=dc.body2;
var _59a=_59b(_599);
var _59c=_59a.height;
if(_59a.width>_599.width()){
_59c+=18;
}
_59c-=parseInt(_599.css("marginTop"))||0;
_598.height(_59c);
_599.height(_59c);
dc.view.height(dc.view2.height());
}
dc.body2.triggerHandler("scroll");
function _597(trs1,trs2){
for(var i=0;i<trs2.length;i++){
var tr1=$(trs1[i]);
var tr2=$(trs2[i]);
tr1.css("height","");
tr2.css("height","");
var _59d=Math.max(tr1.height(),tr2.height());
tr1.css("height",_59d);
tr2.css("height",_59d);
}
};
function _59b(cc){
var _59e=0;
var _59f=0;
$(cc).children().each(function(){
var c=$(this);
if(c.is(":visible")){
_59f+=c._outerHeight();
if(_59e<c._outerWidth()){
_59e=c._outerWidth();
}
}
});
return {width:_59e,height:_59f};
};
};
function _5a0(_5a1,_5a2){
var _5a3=$.data(_5a1,"datagrid");
var opts=_5a3.options;
var dc=_5a3.dc;
if(!dc.body2.children("table.datagrid-btable-frozen").length){
dc.body1.add(dc.body2).prepend("<table class=\"datagrid-btable datagrid-btable-frozen\" cellspacing=\"0\" cellpadding=\"0\"></table>");
}
_5a4(true);
_5a4(false);
_582(_5a1);
function _5a4(_5a5){
var _5a6=_5a5?1:2;
var tr=opts.finder.getTr(_5a1,_5a2,"body",_5a6);
(_5a5?dc.body1:dc.body2).children("table.datagrid-btable-frozen").append(tr);
};
};
function _5a7(_5a8,_5a9){
function _5aa(){
var _5ab=[];
var _5ac=[];
$(_5a8).children("thead").each(function(){
var opt=$.parser.parseOptions(this,[{frozen:"boolean"}]);
$(this).find("tr").each(function(){
var cols=[];
$(this).find("th").each(function(){
var th=$(this);
var col=$.extend({},$.parser.parseOptions(this,["field","align","halign","order","width",{sortable:"boolean",checkbox:"boolean",resizable:"boolean",fixed:"boolean"},{rowspan:"number",colspan:"number"}]),{title:(th.html()||undefined),hidden:(th.attr("hidden")?true:undefined),formatter:(th.attr("formatter")?eval(th.attr("formatter")):undefined),styler:(th.attr("styler")?eval(th.attr("styler")):undefined),sorter:(th.attr("sorter")?eval(th.attr("sorter")):undefined)});
if(col.width&&String(col.width).indexOf("%")==-1){
col.width=parseInt(col.width);
}
if(th.attr("editor")){
var s=$.trim(th.attr("editor"));
if(s.substr(0,1)=="{"){
col.editor=eval("("+s+")");
}else{
col.editor=s;
}
}
cols.push(col);
});
opt.frozen?_5ab.push(cols):_5ac.push(cols);
});
});
return [_5ab,_5ac];
};
var _5ad=$("<div class=\"datagrid-wrap\">"+"<div class=\"datagrid-view\">"+"<div class=\"datagrid-view1\">"+"<div class=\"datagrid-header\">"+"<div class=\"datagrid-header-inner\"></div>"+"</div>"+"<div class=\"datagrid-body\">"+"<div class=\"datagrid-body-inner\"></div>"+"</div>"+"<div class=\"datagrid-footer\">"+"<div class=\"datagrid-footer-inner\"></div>"+"</div>"+"</div>"+"<div class=\"datagrid-view2\">"+"<div class=\"datagrid-header\">"+"<div class=\"datagrid-header-inner\"></div>"+"</div>"+"<div class=\"datagrid-body\"></div>"+"<div class=\"datagrid-footer\">"+"<div class=\"datagrid-footer-inner\"></div>"+"</div>"+"</div>"+"</div>"+"</div>").insertAfter(_5a8);
_5ad.panel({doSize:false,cls:"datagrid"});
$(_5a8).addClass("datagrid-f").hide().appendTo(_5ad.children("div.datagrid-view"));
var cc=_5aa();
var view=_5ad.children("div.datagrid-view");
var _5ae=view.children("div.datagrid-view1");
var _5af=view.children("div.datagrid-view2");
return {panel:_5ad,frozenColumns:cc[0],columns:cc[1],dc:{view:view,view1:_5ae,view2:_5af,header1:_5ae.children("div.datagrid-header").children("div.datagrid-header-inner"),header2:_5af.children("div.datagrid-header").children("div.datagrid-header-inner"),body1:_5ae.children("div.datagrid-body").children("div.datagrid-body-inner"),body2:_5af.children("div.datagrid-body"),footer1:_5ae.children("div.datagrid-footer").children("div.datagrid-footer-inner"),footer2:_5af.children("div.datagrid-footer").children("div.datagrid-footer-inner")}};
};
function _5b0(_5b1){
var _5b2=$.data(_5b1,"datagrid");
var opts=_5b2.options;
var dc=_5b2.dc;
var _5b3=_5b2.panel;
_5b2.ss=$(_5b1).datagrid("createStyleSheet");
_5b3.panel($.extend({},opts,{id:null,doSize:false,onResize:function(_5b4,_5b5){
setTimeout(function(){
if($.data(_5b1,"datagrid")){
_582(_5b1);
_5f7(_5b1);
opts.onResize.call(_5b3,_5b4,_5b5);
}
},0);
},onExpand:function(){
_593(_5b1);
opts.onExpand.call(_5b3);
}}));
_5b2.rowIdPrefix="datagrid-row-r"+(++_569);
_5b2.cellClassPrefix="datagrid-cell-c"+_569;
_5b6(dc.header1,opts.frozenColumns,true);
_5b6(dc.header2,opts.columns,false);
_5b7();
dc.header1.add(dc.header2).css("display",opts.showHeader?"block":"none");
dc.footer1.add(dc.footer2).css("display",opts.showFooter?"block":"none");
if(opts.toolbar){
if($.isArray(opts.toolbar)){
$("div.datagrid-toolbar",_5b3).remove();
var tb=$("<div class=\"datagrid-toolbar\"><table cellspacing=\"0\" cellpadding=\"0\"><tr></tr></table></div>").prependTo(_5b3);
var tr=tb.find("tr");
for(var i=0;i<opts.toolbar.length;i++){
var btn=opts.toolbar[i];
if(btn=="-"){
$("<td><div class=\"datagrid-btn-separator\"></div></td>").appendTo(tr);
}else{
var td=$("<td></td>").appendTo(tr);
var tool=$("<a href=\"javascript:void(0)\"></a>").appendTo(td);
tool[0].onclick=eval(btn.handler||function(){
});
tool.linkbutton($.extend({},btn,{plain:true}));
}
}
}else{
$(opts.toolbar).addClass("datagrid-toolbar").prependTo(_5b3);
$(opts.toolbar).show();
}
}else{
$("div.datagrid-toolbar",_5b3).remove();
}
$("div.datagrid-pager",_5b3).remove();
if(opts.pagination){
var _5b8=$("<div class=\"datagrid-pager\"></div>");
if(opts.pagePosition=="bottom"){
_5b8.appendTo(_5b3);
}else{
if(opts.pagePosition=="top"){
_5b8.addClass("datagrid-pager-top").prependTo(_5b3);
}else{
var ptop=$("<div class=\"datagrid-pager datagrid-pager-top\"></div>").prependTo(_5b3);
_5b8.appendTo(_5b3);
_5b8=_5b8.add(ptop);
}
}
_5b8.pagination({total:(opts.pageNumber*opts.pageSize),pageNumber:opts.pageNumber,pageSize:opts.pageSize,pageList:opts.pageList,onSelectPage:function(_5b9,_5ba){
opts.pageNumber=_5b9||1;
opts.pageSize=_5ba;
_5b8.pagination("refresh",{pageNumber:_5b9,pageSize:_5ba});
_5f5(_5b1);
}});
opts.pageSize=_5b8.pagination("options").pageSize;
}
function _5b6(_5bb,_5bc,_5bd){
if(!_5bc){
return;
}
$(_5bb).show();
$(_5bb).empty();
var _5be=[];
var _5bf=[];
if(opts.sortName){
_5be=opts.sortName.split(",");
_5bf=opts.sortOrder.split(",");
}
var t=$("<table class=\"datagrid-htable\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\"><tbody></tbody></table>").appendTo(_5bb);
for(var i=0;i<_5bc.length;i++){
var tr=$("<tr class=\"datagrid-header-row\"></tr>").appendTo($("tbody",t));
var cols=_5bc[i];
for(var j=0;j<cols.length;j++){
var col=cols[j];
var attr="";
if(col.rowspan){
attr+="rowspan=\""+col.rowspan+"\" ";
}
if(col.colspan){
attr+="colspan=\""+col.colspan+"\" ";
}
var td=$("<td "+attr+"></td>").appendTo(tr);
if(col.checkbox){
td.attr("field",col.field);
$("<div class=\"datagrid-header-check\"></div>").html("<input type=\"checkbox\"/>").appendTo(td);
}else{
if(col.field){
td.attr("field",col.field);
td.append("<div class=\"datagrid-cell\"><span></span><span class=\"datagrid-sort-icon\"></span></div>");
$("span",td).html(col.title);
$("span.datagrid-sort-icon",td).html("&nbsp;");
var cell=td.find("div.datagrid-cell");
var pos=_56a(_5be,col.field);
if(pos>=0){
cell.addClass("datagrid-sort-"+_5bf[pos]);
}
if(col.resizable==false){
cell.attr("resizable","false");
}
if(col.width){
var _5c0=$.parser.parseValue("width",col.width,dc.view,opts.scrollbarSize);
cell._outerWidth(_5c0-1);
col.boxWidth=parseInt(cell[0].style.width);
col.deltaWidth=_5c0-col.boxWidth;
}else{
col.auto=true;
}
cell.css("text-align",(col.halign||col.align||""));
col.cellClass=_5b2.cellClassPrefix+"-"+col.field.replace(/[\.|\s]/g,"-");
cell.addClass(col.cellClass).css("width","");
}else{
$("<div class=\"datagrid-cell-group\"></div>").html(col.title).appendTo(td);
}
}
if(col.hidden){
td.hide();
}
}
}
if(_5bd&&opts.rownumbers){
var td=$("<td rowspan=\""+opts.frozenColumns.length+"\"><div class=\"datagrid-header-rownumber\"></div></td>");
if($("tr",t).length==0){
td.wrap("<tr class=\"datagrid-header-row\"></tr>").parent().appendTo($("tbody",t));
}else{
td.prependTo($("tr:first",t));
}
}
};
function _5b7(){
var _5c1=[];
var _5c2=_5c3(_5b1,true).concat(_5c3(_5b1));
for(var i=0;i<_5c2.length;i++){
var col=_5c4(_5b1,_5c2[i]);
if(col&&!col.checkbox){
_5c1.push(["."+col.cellClass,col.boxWidth?col.boxWidth+"px":"auto"]);
}
}
_5b2.ss.add(_5c1);
_5b2.ss.dirty(_5b2.cellSelectorPrefix);
_5b2.cellSelectorPrefix="."+_5b2.cellClassPrefix;
};
};
function _5c5(_5c6){
var _5c7=$.data(_5c6,"datagrid");
var _5c8=_5c7.panel;
var opts=_5c7.options;
var dc=_5c7.dc;
var _5c9=dc.header1.add(dc.header2);
_5c9.find("input[type=checkbox]").unbind(".datagrid").bind("click.datagrid",function(e){
if(opts.singleSelect&&opts.selectOnCheck){
return false;
}
if($(this).is(":checked")){
_65d(_5c6);
}else{
_663(_5c6);
}
e.stopPropagation();
});
var _5ca=_5c9.find("div.datagrid-cell");
_5ca.closest("td").unbind(".datagrid").bind("mouseenter.datagrid",function(){
if(_5c7.resizing){
return;
}
$(this).addClass("datagrid-header-over");
}).bind("mouseleave.datagrid",function(){
$(this).removeClass("datagrid-header-over");
}).bind("contextmenu.datagrid",function(e){
var _5cb=$(this).attr("field");
opts.onHeaderContextMenu.call(_5c6,e,_5cb);
});
_5ca.unbind(".datagrid").bind("click.datagrid",function(e){
var p1=$(this).offset().left+5;
var p2=$(this).offset().left+$(this)._outerWidth()-5;
if(e.pageX<p2&&e.pageX>p1){
_5ea(_5c6,$(this).parent().attr("field"));
}
}).bind("dblclick.datagrid",function(e){
var p1=$(this).offset().left+5;
var p2=$(this).offset().left+$(this)._outerWidth()-5;
var cond=opts.resizeHandle=="right"?(e.pageX>p2):(opts.resizeHandle=="left"?(e.pageX<p1):(e.pageX<p1||e.pageX>p2));
if(cond){
var _5cc=$(this).parent().attr("field");
var col=_5c4(_5c6,_5cc);
if(col.resizable==false){
return;
}
$(_5c6).datagrid("autoSizeColumn",_5cc);
col.auto=false;
}
});
var _5cd=opts.resizeHandle=="right"?"e":(opts.resizeHandle=="left"?"w":"e,w");
_5ca.each(function(){
$(this).resizable({handles:_5cd,disabled:($(this).attr("resizable")?$(this).attr("resizable")=="false":false),minWidth:25,onStartResize:function(e){
_5c7.resizing=true;
_5c9.css("cursor",$("body").css("cursor"));
if(!_5c7.proxy){
_5c7.proxy=$("<div class=\"datagrid-resize-proxy\"></div>").appendTo(dc.view);
}
_5c7.proxy.css({left:e.pageX-$(_5c8).offset().left-1,display:"none"});
setTimeout(function(){
if(_5c7.proxy){
_5c7.proxy.show();
}
},500);
},onResize:function(e){
_5c7.proxy.css({left:e.pageX-$(_5c8).offset().left-1,display:"block"});
return false;
},onStopResize:function(e){
_5c9.css("cursor","");
$(this).css("height","");
var _5ce=$(this).parent().attr("field");
var col=_5c4(_5c6,_5ce);
col.width=$(this)._outerWidth();
col.boxWidth=col.width-col.deltaWidth;
col.auto=undefined;
$(this).css("width","");
_613(_5c6,_5ce);
_5c7.proxy.remove();
_5c7.proxy=null;
if($(this).parents("div:first.datagrid-header").parent().hasClass("datagrid-view1")){
_582(_5c6);
}
_5f7(_5c6);
opts.onResizeColumn.call(_5c6,_5ce,col.width);
setTimeout(function(){
_5c7.resizing=false;
},0);
}});
});
var bb=dc.body1.add(dc.body2);
bb.unbind();
for(var _5cf in opts.rowEvents){
bb.bind(_5cf,opts.rowEvents[_5cf]);
}
dc.body1.bind("mousewheel DOMMouseScroll",function(e){
var e1=e.originalEvent||window.event;
var _5d0=e1.wheelDelta||e1.detail*(-1);
var dg=$(e.target).closest("div.datagrid-view").children(".datagrid-f");
var dc=dg.data("datagrid").dc;
dc.body2.scrollTop(dc.body2.scrollTop()-_5d0);
});
dc.body2.bind("scroll",function(){
var b1=dc.view1.children("div.datagrid-body");
b1.scrollTop($(this).scrollTop());
var c1=dc.body1.children(":first");
var c2=dc.body2.children(":first");
if(c1.length&&c2.length){
var top1=c1.offset().top;
var top2=c2.offset().top;
if(top1!=top2){
b1.scrollTop(b1.scrollTop()+top1-top2);
}
}
dc.view2.children("div.datagrid-header,div.datagrid-footer")._scrollLeft($(this)._scrollLeft());
dc.body2.children("table.datagrid-btable-frozen").css("left",-$(this)._scrollLeft());
});
};
function _5d1(_5d2){
return function(e){
var tr=_5d3(e.target);
if(!tr){
return;
}
var _5d4=_5d5(tr);
if($.data(_5d4,"datagrid").resizing){
return;
}
var _5d6=_5d7(tr);
if(_5d2){
_5d8(_5d4,_5d6);
}else{
var opts=$.data(_5d4,"datagrid").options;
opts.finder.getTr(_5d4,_5d6).removeClass("datagrid-row-over");
}
};
};
function _5d9(e){
var tr=_5d3(e.target);
if(!tr){
return;
}
var _5da=_5d5(tr);
var opts=$.data(_5da,"datagrid").options;
var _5db=_5d7(tr);
var tt=$(e.target);
if(tt.parent().hasClass("datagrid-cell-check")){
if(opts.singleSelect&&opts.selectOnCheck){
tt._propAttr("checked",!tt.is(":checked"));
_5dc(_5da,_5db);
}else{
if(tt.is(":checked")){
tt._propAttr("checked",false);
_5dc(_5da,_5db);
}else{
tt._propAttr("checked",true);
_5dd(_5da,_5db);
}
}
}else{
var row=opts.finder.getRow(_5da,_5db);
var td=tt.closest("td[field]",tr);
if(td.length){
var _5de=td.attr("field");
opts.onClickCell.call(_5da,_5db,_5de,row[_5de]);
}
if(opts.singleSelect==true){
_5df(_5da,_5db);
}else{
if(opts.ctrlSelect){
if(e.ctrlKey){
if(tr.hasClass("datagrid-row-selected")){
_5e0(_5da,_5db);
}else{
_5df(_5da,_5db);
}
}else{
if(e.shiftKey){
$(_5da).datagrid("clearSelections");
var _5e1=Math.min(opts.lastSelectedIndex||0,_5db);
var _5e2=Math.max(opts.lastSelectedIndex||0,_5db);
for(var i=_5e1;i<=_5e2;i++){
_5df(_5da,i);
}
}else{
$(_5da).datagrid("clearSelections");
_5df(_5da,_5db);
opts.lastSelectedIndex=_5db;
}
}
}else{
if(tr.hasClass("datagrid-row-selected")){
_5e0(_5da,_5db);
}else{
_5df(_5da,_5db);
}
}
}
opts.onClickRow.call(_5da,_5db,row);
}
};
function _5e3(e){
var tr=_5d3(e.target);
if(!tr){
return;
}
var _5e4=_5d5(tr);
var opts=$.data(_5e4,"datagrid").options;
var _5e5=_5d7(tr);
var row=opts.finder.getRow(_5e4,_5e5);
var td=$(e.target).closest("td[field]",tr);
if(td.length){
var _5e6=td.attr("field");
opts.onDblClickCell.call(_5e4,_5e5,_5e6,row[_5e6]);
}
opts.onDblClickRow.call(_5e4,_5e5,row);
};
function _5e7(e){
var tr=_5d3(e.target);
if(!tr){
return;
}
var _5e8=_5d5(tr);
var opts=$.data(_5e8,"datagrid").options;
var _5e9=_5d7(tr);
var row=opts.finder.getRow(_5e8,_5e9);
opts.onRowContextMenu.call(_5e8,e,_5e9,row);
};
function _5d5(t){
return $(t).closest("div.datagrid-view").children(".datagrid-f")[0];
};
function _5d3(t){
var tr=$(t).closest("tr.datagrid-row");
if(tr.length&&tr.parent().length){
return tr;
}else{
return undefined;
}
};
function _5d7(tr){
if(tr.attr("datagrid-row-index")){
return parseInt(tr.attr("datagrid-row-index"));
}else{
return tr.attr("node-id");
}
};
function _5ea(_5eb,_5ec){
var _5ed=$.data(_5eb,"datagrid");
var opts=_5ed.options;
_5ec=_5ec||{};
var _5ee={sortName:opts.sortName,sortOrder:opts.sortOrder};
if(typeof _5ec=="object"){
$.extend(_5ee,_5ec);
}
var _5ef=[];
var _5f0=[];
if(_5ee.sortName){
_5ef=_5ee.sortName.split(",");
_5f0=_5ee.sortOrder.split(",");
}
if(typeof _5ec=="string"){
var _5f1=_5ec;
var col=_5c4(_5eb,_5f1);
if(!col.sortable||_5ed.resizing){
return;
}
var _5f2=col.order||"asc";
var pos=_56a(_5ef,_5f1);
if(pos>=0){
var _5f3=_5f0[pos]=="asc"?"desc":"asc";
if(opts.multiSort&&_5f3==_5f2){
_5ef.splice(pos,1);
_5f0.splice(pos,1);
}else{
_5f0[pos]=_5f3;
}
}else{
if(opts.multiSort){
_5ef.push(_5f1);
_5f0.push(_5f2);
}else{
_5ef=[_5f1];
_5f0=[_5f2];
}
}
_5ee.sortName=_5ef.join(",");
_5ee.sortOrder=_5f0.join(",");
}
if(opts.onBeforeSortColumn.call(_5eb,_5ee.sortName,_5ee.sortOrder)==false){
return;
}
$.extend(opts,_5ee);
var dc=_5ed.dc;
var _5f4=dc.header1.add(dc.header2);
_5f4.find("div.datagrid-cell").removeClass("datagrid-sort-asc datagrid-sort-desc");
for(var i=0;i<_5ef.length;i++){
var col=_5c4(_5eb,_5ef[i]);
_5f4.find("div."+col.cellClass).addClass("datagrid-sort-"+_5f0[i]);
}
if(opts.remoteSort){
_5f5(_5eb);
}else{
_5f6(_5eb,$(_5eb).datagrid("getData"));
}
opts.onSortColumn.call(_5eb,opts.sortName,opts.sortOrder);
};
function _5f7(_5f8){
var _5f9=$.data(_5f8,"datagrid");
var opts=_5f9.options;
var dc=_5f9.dc;
var _5fa=dc.view2.children("div.datagrid-header");
dc.body2.css("overflow-x","");
_5fb();
_5fc();
if(_5fa.width()>=_5fa.find("table").width()){
dc.body2.css("overflow-x","hidden");
}
function _5fc(){
if(!opts.fitColumns){
return;
}
if(!_5f9.leftWidth){
_5f9.leftWidth=0;
}
var _5fd=0;
var cc=[];
var _5fe=_5c3(_5f8,false);
for(var i=0;i<_5fe.length;i++){
var col=_5c4(_5f8,_5fe[i]);
if(_5ff(col)){
_5fd+=col.width;
cc.push({field:col.field,col:col,addingWidth:0});
}
}
if(!_5fd){
return;
}
cc[cc.length-1].addingWidth-=_5f9.leftWidth;
var _600=_5fa.children("div.datagrid-header-inner").show();
var _601=_5fa.width()-_5fa.find("table").width()-opts.scrollbarSize+_5f9.leftWidth;
var rate=_601/_5fd;
if(!opts.showHeader){
_600.hide();
}
for(var i=0;i<cc.length;i++){
var c=cc[i];
var _602=parseInt(c.col.width*rate);
c.addingWidth+=_602;
_601-=_602;
}
cc[cc.length-1].addingWidth+=_601;
for(var i=0;i<cc.length;i++){
var c=cc[i];
if(c.col.boxWidth+c.addingWidth>0){
c.col.boxWidth+=c.addingWidth;
c.col.width+=c.addingWidth;
}
}
_5f9.leftWidth=_601;
_613(_5f8);
};
function _5fb(){
var _603=false;
var _604=_5c3(_5f8,true).concat(_5c3(_5f8,false));
$.map(_604,function(_605){
var col=_5c4(_5f8,_605);
if(String(col.width||"").indexOf("%")>=0){
var _606=$.parser.parseValue("width",col.width,dc.view,opts.scrollbarSize)-col.deltaWidth;
if(_606>0){
col.boxWidth=_606;
_603=true;
}
}
});
if(_603){
_613(_5f8);
}
};
function _5ff(col){
if(String(col.width||"").indexOf("%")>=0){
return false;
}
if(!col.hidden&&!col.checkbox&&!col.auto&&!col.fixed){
return true;
}
};
};
function _607(_608,_609){
var _60a=$.data(_608,"datagrid");
var opts=_60a.options;
var dc=_60a.dc;
var tmp=$("<div class=\"datagrid-cell\" style=\"position:absolute;left:-9999px\"></div>").appendTo("body");
if(_609){
_57d(_609);
if(opts.fitColumns){
_582(_608);
_5f7(_608);
}
}else{
var _60b=false;
var _60c=_5c3(_608,true).concat(_5c3(_608,false));
for(var i=0;i<_60c.length;i++){
var _609=_60c[i];
var col=_5c4(_608,_609);
if(col.auto){
_57d(_609);
_60b=true;
}
}
if(_60b&&opts.fitColumns){
_582(_608);
_5f7(_608);
}
}
tmp.remove();
function _57d(_60d){
var _60e=dc.view.find("div.datagrid-header td[field=\""+_60d+"\"] div.datagrid-cell");
_60e.css("width","");
var col=$(_608).datagrid("getColumnOption",_60d);
col.width=undefined;
col.boxWidth=undefined;
col.auto=true;
$(_608).datagrid("fixColumnSize",_60d);
var _60f=Math.max(_610("header"),_610("allbody"),_610("allfooter"))+1;
_60e._outerWidth(_60f-1);
col.width=_60f;
col.boxWidth=parseInt(_60e[0].style.width);
col.deltaWidth=_60f-col.boxWidth;
_60e.css("width","");
$(_608).datagrid("fixColumnSize",_60d);
opts.onResizeColumn.call(_608,_60d,col.width);
function _610(type){
var _611=0;
if(type=="header"){
_611=_612(_60e);
}else{
opts.finder.getTr(_608,0,type).find("td[field=\""+_60d+"\"] div.datagrid-cell").each(function(){
var w=_612($(this));
if(_611<w){
_611=w;
}
});
}
return _611;
function _612(cell){
return cell.is(":visible")?cell._outerWidth():tmp.html(cell.html())._outerWidth();
};
};
};
};
function _613(_614,_615){
var _616=$.data(_614,"datagrid");
var opts=_616.options;
var dc=_616.dc;
var _617=dc.view.find("table.datagrid-btable,table.datagrid-ftable");
_617.css("table-layout","fixed");
if(_615){
fix(_615);
}else{
var ff=_5c3(_614,true).concat(_5c3(_614,false));
for(var i=0;i<ff.length;i++){
fix(ff[i]);
}
}
_617.css("table-layout","auto");
_618(_614);
_593(_614);
_619(_614);
function fix(_61a){
var col=_5c4(_614,_61a);
if(col.cellClass){
_616.ss.set("."+col.cellClass,col.boxWidth?col.boxWidth+"px":"auto");
}
};
};
function _618(_61b){
var dc=$.data(_61b,"datagrid").dc;
dc.view.find("td.datagrid-td-merged").each(function(){
var td=$(this);
var _61c=td.attr("colspan")||1;
var col=_5c4(_61b,td.attr("field"));
var _61d=col.boxWidth+col.deltaWidth-1;
for(var i=1;i<_61c;i++){
td=td.next();
col=_5c4(_61b,td.attr("field"));
_61d+=col.boxWidth+col.deltaWidth;
}
$(this).children("div.datagrid-cell")._outerWidth(_61d);
});
};
function _619(_61e){
var dc=$.data(_61e,"datagrid").dc;
dc.view.find("div.datagrid-editable").each(function(){
var cell=$(this);
var _61f=cell.parent().attr("field");
var col=$(_61e).datagrid("getColumnOption",_61f);
cell._outerWidth(col.boxWidth+col.deltaWidth-1);
var ed=$.data(this,"datagrid.editor");
if(ed.actions.resize){
ed.actions.resize(ed.target,cell.width());
}
});
};
function _5c4(_620,_621){
function find(_622){
if(_622){
for(var i=0;i<_622.length;i++){
var cc=_622[i];
for(var j=0;j<cc.length;j++){
var c=cc[j];
if(c.field==_621){
return c;
}
}
}
}
return null;
};
var opts=$.data(_620,"datagrid").options;
var col=find(opts.columns);
if(!col){
col=find(opts.frozenColumns);
}
return col;
};
function _5c3(_623,_624){
var opts=$.data(_623,"datagrid").options;
var _625=(_624==true)?(opts.frozenColumns||[[]]):opts.columns;
if(_625.length==0){
return [];
}
var aa=[];
var _626=_627();
for(var i=0;i<_625.length;i++){
aa[i]=new Array(_626);
}
for(var _628=0;_628<_625.length;_628++){
$.map(_625[_628],function(col){
var _629=_62a(aa[_628]);
if(_629>=0){
var _62b=col.field||"";
for(var c=0;c<(col.colspan||1);c++){
for(var r=0;r<(col.rowspan||1);r++){
aa[_628+r][_629]=_62b;
}
_629++;
}
}
});
}
return aa[aa.length-1];
function _627(){
var _62c=0;
$.map(_625[0],function(col){
_62c+=col.colspan||1;
});
return _62c;
};
function _62a(a){
for(var i=0;i<a.length;i++){
if(a[i]==undefined){
return i;
}
}
return -1;
};
};
function _5f6(_62d,data){
var _62e=$.data(_62d,"datagrid");
var opts=_62e.options;
var dc=_62e.dc;
data=opts.loadFilter.call(_62d,data);
data.total=parseInt(data.total);
_62e.data=data;
if(data.footer){
_62e.footer=data.footer;
}
if(!opts.remoteSort&&opts.sortName){
var _62f=opts.sortName.split(",");
var _630=opts.sortOrder.split(",");
data.rows.sort(function(r1,r2){
var r=0;
for(var i=0;i<_62f.length;i++){
var sn=_62f[i];
var so=_630[i];
var col=_5c4(_62d,sn);
var _631=col.sorter||function(a,b){
return a==b?0:(a>b?1:-1);
};
r=_631(r1[sn],r2[sn])*(so=="asc"?1:-1);
if(r!=0){
return r;
}
}
return r;
});
}
if(opts.view.onBeforeRender){
opts.view.onBeforeRender.call(opts.view,_62d,data.rows);
}
opts.view.render.call(opts.view,_62d,dc.body2,false);
opts.view.render.call(opts.view,_62d,dc.body1,true);
if(opts.showFooter){
opts.view.renderFooter.call(opts.view,_62d,dc.footer2,false);
opts.view.renderFooter.call(opts.view,_62d,dc.footer1,true);
}
if(opts.view.onAfterRender){
opts.view.onAfterRender.call(opts.view,_62d);
}
_62e.ss.clean();
var _632=$(_62d).datagrid("getPager");
if(_632.length){
var _633=_632.pagination("options");
if(_633.total!=data.total){
_632.pagination("refresh",{total:data.total});
if(opts.pageNumber!=_633.pageNumber&&_633.pageNumber>0){
opts.pageNumber=_633.pageNumber;
_5f5(_62d);
}
}
}
_593(_62d);
dc.body2.triggerHandler("scroll");
$(_62d).datagrid("setSelectionState");
$(_62d).datagrid("autoSizeColumn");
opts.onLoadSuccess.call(_62d,data);
};
function _634(_635){
var _636=$.data(_635,"datagrid");
var opts=_636.options;
var dc=_636.dc;
dc.header1.add(dc.header2).find("input[type=checkbox]")._propAttr("checked",false);
if(opts.idField){
var _637=$.data(_635,"treegrid")?true:false;
var _638=opts.onSelect;
var _639=opts.onCheck;
opts.onSelect=opts.onCheck=function(){
};
var rows=opts.finder.getRows(_635);
for(var i=0;i<rows.length;i++){
var row=rows[i];
var _63a=_637?row[opts.idField]:i;
if(_63b(_636.selectedRows,row)){
_5df(_635,_63a,true);
}
if(_63b(_636.checkedRows,row)){
_5dc(_635,_63a,true);
}
}
opts.onSelect=_638;
opts.onCheck=_639;
}
function _63b(a,r){
for(var i=0;i<a.length;i++){
if(a[i][opts.idField]==r[opts.idField]){
a[i]=r;
return true;
}
}
return false;
};
};
function _63c(_63d,row){
var _63e=$.data(_63d,"datagrid");
var opts=_63e.options;
var rows=_63e.data.rows;
if(typeof row=="object"){
return _56a(rows,row);
}else{
for(var i=0;i<rows.length;i++){
if(rows[i][opts.idField]==row){
return i;
}
}
return -1;
}
};
function _63f(_640){
var _641=$.data(_640,"datagrid");
var opts=_641.options;
var data=_641.data;
if(opts.idField){
return _641.selectedRows;
}else{
var rows=[];
opts.finder.getTr(_640,"","selected",2).each(function(){
rows.push(opts.finder.getRow(_640,$(this)));
});
return rows;
}
};
function _642(_643){
var _644=$.data(_643,"datagrid");
var opts=_644.options;
if(opts.idField){
return _644.checkedRows;
}else{
var rows=[];
opts.finder.getTr(_643,"","checked",2).each(function(){
rows.push(opts.finder.getRow(_643,$(this)));
});
return rows;
}
};
function _645(_646,_647){
var _648=$.data(_646,"datagrid");
var dc=_648.dc;
var opts=_648.options;
var tr=opts.finder.getTr(_646,_647);
if(tr.length){
if(tr.closest("table").hasClass("datagrid-btable-frozen")){
return;
}
var _649=dc.view2.children("div.datagrid-header")._outerHeight();
var _64a=dc.body2;
var _64b=_64a.outerHeight(true)-_64a.outerHeight();
var top=tr.position().top-_649-_64b;
if(top<0){
_64a.scrollTop(_64a.scrollTop()+top);
}else{
if(top+tr._outerHeight()>_64a.height()-18){
_64a.scrollTop(_64a.scrollTop()+top+tr._outerHeight()-_64a.height()+18);
}
}
}
};
function _5d8(_64c,_64d){
var _64e=$.data(_64c,"datagrid");
var opts=_64e.options;
opts.finder.getTr(_64c,_64e.highlightIndex).removeClass("datagrid-row-over");
opts.finder.getTr(_64c,_64d).addClass("datagrid-row-over");
_64e.highlightIndex=_64d;
};
function _5df(_64f,_650,_651){
var _652=$.data(_64f,"datagrid");
var opts=_652.options;
var row=opts.finder.getRow(_64f,_650);
if(opts.onBeforeSelect.call(_64f,_650,row)==false){
return;
}
if(opts.singleSelect){
_653(_64f,true);
_652.selectedRows=[];
}
if(!_651&&opts.checkOnSelect){
_5dc(_64f,_650,true);
}
if(opts.idField){
_56d(_652.selectedRows,opts.idField,row);
}
opts.finder.getTr(_64f,_650).addClass("datagrid-row-selected");
opts.onSelect.call(_64f,_650,row);
_645(_64f,_650);
};
function _5e0(_654,_655,_656){
var _657=$.data(_654,"datagrid");
var dc=_657.dc;
var opts=_657.options;
var row=opts.finder.getRow(_654,_655);
if(opts.onBeforeUnselect.call(_654,_655,row)==false){
return;
}
if(!_656&&opts.checkOnSelect){
_5dd(_654,_655,true);
}
opts.finder.getTr(_654,_655).removeClass("datagrid-row-selected");
if(opts.idField){
_56b(_657.selectedRows,opts.idField,row[opts.idField]);
}
opts.onUnselect.call(_654,_655,row);
};
function _658(_659,_65a){
var _65b=$.data(_659,"datagrid");
var opts=_65b.options;
var rows=opts.finder.getRows(_659);
var _65c=$.data(_659,"datagrid").selectedRows;
if(!_65a&&opts.checkOnSelect){
_65d(_659,true);
}
opts.finder.getTr(_659,"","allbody").addClass("datagrid-row-selected");
if(opts.idField){
for(var _65e=0;_65e<rows.length;_65e++){
_56d(_65c,opts.idField,rows[_65e]);
}
}
opts.onSelectAll.call(_659,rows);
};
function _653(_65f,_660){
var _661=$.data(_65f,"datagrid");
var opts=_661.options;
var rows=opts.finder.getRows(_65f);
var _662=$.data(_65f,"datagrid").selectedRows;
if(!_660&&opts.checkOnSelect){
_663(_65f,true);
}
opts.finder.getTr(_65f,"","selected").removeClass("datagrid-row-selected");
if(opts.idField){
for(var _664=0;_664<rows.length;_664++){
_56b(_662,opts.idField,rows[_664][opts.idField]);
}
}
opts.onUnselectAll.call(_65f,rows);
};
function _5dc(_665,_666,_667){
var _668=$.data(_665,"datagrid");
var opts=_668.options;
var row=opts.finder.getRow(_665,_666);
if(opts.onBeforeCheck.call(_665,_666,row)==false){
return;
}
if(opts.singleSelect&&opts.selectOnCheck){
_663(_665,true);
_668.checkedRows=[];
}
if(!_667&&opts.selectOnCheck){
_5df(_665,_666,true);
}
var tr=opts.finder.getTr(_665,_666).addClass("datagrid-row-checked");
tr.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked",true);
tr=opts.finder.getTr(_665,"","checked",2);
if(tr.length==opts.finder.getRows(_665).length){
var dc=_668.dc;
dc.header1.add(dc.header2).find("input[type=checkbox]")._propAttr("checked",true);
}
if(opts.idField){
_56d(_668.checkedRows,opts.idField,row);
}
opts.onCheck.call(_665,_666,row);
};
function _5dd(_669,_66a,_66b){
var _66c=$.data(_669,"datagrid");
var opts=_66c.options;
var row=opts.finder.getRow(_669,_66a);
if(opts.onBeforeUncheck.call(_669,_66a,row)==false){
return;
}
if(!_66b&&opts.selectOnCheck){
_5e0(_669,_66a,true);
}
var tr=opts.finder.getTr(_669,_66a).removeClass("datagrid-row-checked");
tr.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked",false);
var dc=_66c.dc;
var _66d=dc.header1.add(dc.header2);
_66d.find("input[type=checkbox]")._propAttr("checked",false);
if(opts.idField){
_56b(_66c.checkedRows,opts.idField,row[opts.idField]);
}
opts.onUncheck.call(_669,_66a,row);
};
function _65d(_66e,_66f){
var _670=$.data(_66e,"datagrid");
var opts=_670.options;
var rows=opts.finder.getRows(_66e);
if(!_66f&&opts.selectOnCheck){
_658(_66e,true);
}
var dc=_670.dc;
var hck=dc.header1.add(dc.header2).find("input[type=checkbox]");
var bck=opts.finder.getTr(_66e,"","allbody").addClass("datagrid-row-checked").find("div.datagrid-cell-check input[type=checkbox]");
hck.add(bck)._propAttr("checked",true);
if(opts.idField){
for(var i=0;i<rows.length;i++){
_56d(_670.checkedRows,opts.idField,rows[i]);
}
}
opts.onCheckAll.call(_66e,rows);
};
function _663(_671,_672){
var _673=$.data(_671,"datagrid");
var opts=_673.options;
var rows=opts.finder.getRows(_671);
if(!_672&&opts.selectOnCheck){
_653(_671,true);
}
var dc=_673.dc;
var hck=dc.header1.add(dc.header2).find("input[type=checkbox]");
var bck=opts.finder.getTr(_671,"","checked").removeClass("datagrid-row-checked").find("div.datagrid-cell-check input[type=checkbox]");
hck.add(bck)._propAttr("checked",false);
if(opts.idField){
for(var i=0;i<rows.length;i++){
_56b(_673.checkedRows,opts.idField,rows[i][opts.idField]);
}
}
opts.onUncheckAll.call(_671,rows);
};
function _674(_675,_676){
var opts=$.data(_675,"datagrid").options;
var tr=opts.finder.getTr(_675,_676);
var row=opts.finder.getRow(_675,_676);
if(tr.hasClass("datagrid-row-editing")){
return;
}
if(opts.onBeforeEdit.call(_675,_676,row)==false){
return;
}
tr.addClass("datagrid-row-editing");
_677(_675,_676);
_619(_675);
tr.find("div.datagrid-editable").each(function(){
var _678=$(this).parent().attr("field");
var ed=$.data(this,"datagrid.editor");
ed.actions.setValue(ed.target,row[_678]);
});
_679(_675,_676);
opts.onBeginEdit.call(_675,_676,row);
};
function _67a(_67b,_67c,_67d){
var _67e=$.data(_67b,"datagrid");
var opts=_67e.options;
var _67f=_67e.updatedRows;
var _680=_67e.insertedRows;
var tr=opts.finder.getTr(_67b,_67c);
var row=opts.finder.getRow(_67b,_67c);
if(!tr.hasClass("datagrid-row-editing")){
return;
}
if(!_67d){
if(!_679(_67b,_67c)){
return;
}
var _681=false;
var _682={};
tr.find("div.datagrid-editable").each(function(){
var _683=$(this).parent().attr("field");
var ed=$.data(this,"datagrid.editor");
var t=$(ed.target);
var _684=t.data("textbox")?t.textbox("textbox"):t;
_684.triggerHandler("blur");
var _685=ed.actions.getValue(ed.target);
if(row[_683]!=_685){
row[_683]=_685;
_681=true;
_682[_683]=_685;
}
});
if(_681){
if(_56a(_680,row)==-1){
if(_56a(_67f,row)==-1){
_67f.push(row);
}
}
}
opts.onEndEdit.call(_67b,_67c,row,_682);
}
tr.removeClass("datagrid-row-editing");
_686(_67b,_67c);
$(_67b).datagrid("refreshRow",_67c);
if(!_67d){
opts.onAfterEdit.call(_67b,_67c,row,_682);
}else{
opts.onCancelEdit.call(_67b,_67c,row);
}
};
function _687(_688,_689){
var opts=$.data(_688,"datagrid").options;
var tr=opts.finder.getTr(_688,_689);
var _68a=[];
tr.children("td").each(function(){
var cell=$(this).find("div.datagrid-editable");
if(cell.length){
var ed=$.data(cell[0],"datagrid.editor");
_68a.push(ed);
}
});
return _68a;
};
function _68b(_68c,_68d){
var _68e=_687(_68c,_68d.index!=undefined?_68d.index:_68d.id);
for(var i=0;i<_68e.length;i++){
if(_68e[i].field==_68d.field){
return _68e[i];
}
}
return null;
};
function _677(_68f,_690){
var opts=$.data(_68f,"datagrid").options;
var tr=opts.finder.getTr(_68f,_690);
tr.children("td").each(function(){
var cell=$(this).find("div.datagrid-cell");
var _691=$(this).attr("field");
var col=_5c4(_68f,_691);
if(col&&col.editor){
var _692,_693;
if(typeof col.editor=="string"){
_692=col.editor;
}else{
_692=col.editor.type;
_693=col.editor.options;
}
var _694=opts.editors[_692];
if(_694){
var _695=cell.html();
var _696=cell._outerWidth();
cell.addClass("datagrid-editable");
cell._outerWidth(_696);
cell.html("<table border=\"0\" cellspacing=\"0\" cellpadding=\"1\"><tr><td></td></tr></table>");
cell.children("table").bind("click dblclick contextmenu",function(e){
e.stopPropagation();
});
$.data(cell[0],"datagrid.editor",{actions:_694,target:_694.init(cell.find("td"),_693),field:_691,type:_692,oldHtml:_695});
}
}
});
_593(_68f,_690,true);
};
function _686(_697,_698){
var opts=$.data(_697,"datagrid").options;
var tr=opts.finder.getTr(_697,_698);
tr.children("td").each(function(){
var cell=$(this).find("div.datagrid-editable");
if(cell.length){
var ed=$.data(cell[0],"datagrid.editor");
if(ed.actions.destroy){
ed.actions.destroy(ed.target);
}
cell.html(ed.oldHtml);
$.removeData(cell[0],"datagrid.editor");
cell.removeClass("datagrid-editable");
cell.css("width","");
}
});
};
function _679(_699,_69a){
var tr=$.data(_699,"datagrid").options.finder.getTr(_699,_69a);
if(!tr.hasClass("datagrid-row-editing")){
return true;
}
var vbox=tr.find(".validatebox-text");
vbox.validatebox("validate");
vbox.trigger("mouseleave");
var _69b=tr.find(".validatebox-invalid");
return _69b.length==0;
};
function _69c(_69d,_69e){
var _69f=$.data(_69d,"datagrid").insertedRows;
var _6a0=$.data(_69d,"datagrid").deletedRows;
var _6a1=$.data(_69d,"datagrid").updatedRows;
if(!_69e){
var rows=[];
rows=rows.concat(_69f);
rows=rows.concat(_6a0);
rows=rows.concat(_6a1);
return rows;
}else{
if(_69e=="inserted"){
return _69f;
}else{
if(_69e=="deleted"){
return _6a0;
}else{
if(_69e=="updated"){
return _6a1;
}
}
}
}
return [];
};
function _6a2(_6a3,_6a4){
var _6a5=$.data(_6a3,"datagrid");
var opts=_6a5.options;
var data=_6a5.data;
var _6a6=_6a5.insertedRows;
var _6a7=_6a5.deletedRows;
$(_6a3).datagrid("cancelEdit",_6a4);
var row=opts.finder.getRow(_6a3,_6a4);
if(_56a(_6a6,row)>=0){
_56b(_6a6,row);
}else{
_6a7.push(row);
}
_56b(_6a5.selectedRows,opts.idField,row[opts.idField]);
_56b(_6a5.checkedRows,opts.idField,row[opts.idField]);
opts.view.deleteRow.call(opts.view,_6a3,_6a4);
if(opts.height=="auto"){
_593(_6a3);
}
$(_6a3).datagrid("getPager").pagination("refresh",{total:data.total});
};
function _6a8(_6a9,_6aa){
var data=$.data(_6a9,"datagrid").data;
var view=$.data(_6a9,"datagrid").options.view;
var _6ab=$.data(_6a9,"datagrid").insertedRows;
view.insertRow.call(view,_6a9,_6aa.index,_6aa.row);
_6ab.push(_6aa.row);
$(_6a9).datagrid("getPager").pagination("refresh",{total:data.total});
};
function _6ac(_6ad,row){
var data=$.data(_6ad,"datagrid").data;
var view=$.data(_6ad,"datagrid").options.view;
var _6ae=$.data(_6ad,"datagrid").insertedRows;
view.insertRow.call(view,_6ad,null,row);
_6ae.push(row);
$(_6ad).datagrid("getPager").pagination("refresh",{total:data.total});
};
function _6af(_6b0){
var _6b1=$.data(_6b0,"datagrid");
var data=_6b1.data;
var rows=data.rows;
var _6b2=[];
for(var i=0;i<rows.length;i++){
_6b2.push($.extend({},rows[i]));
}
_6b1.originalRows=_6b2;
_6b1.updatedRows=[];
_6b1.insertedRows=[];
_6b1.deletedRows=[];
};
function _6b3(_6b4){
var data=$.data(_6b4,"datagrid").data;
var ok=true;
for(var i=0,len=data.rows.length;i<len;i++){
if(_679(_6b4,i)){
$(_6b4).datagrid("endEdit",i);
}else{
ok=false;
}
}
if(ok){
_6af(_6b4);
}
};
function _6b5(_6b6){
var _6b7=$.data(_6b6,"datagrid");
var opts=_6b7.options;
var _6b8=_6b7.originalRows;
var _6b9=_6b7.insertedRows;
var _6ba=_6b7.deletedRows;
var _6bb=_6b7.selectedRows;
var _6bc=_6b7.checkedRows;
var data=_6b7.data;
function _6bd(a){
var ids=[];
for(var i=0;i<a.length;i++){
ids.push(a[i][opts.idField]);
}
return ids;
};
function _6be(ids,_6bf){
for(var i=0;i<ids.length;i++){
var _6c0=_63c(_6b6,ids[i]);
if(_6c0>=0){
(_6bf=="s"?_5df:_5dc)(_6b6,_6c0,true);
}
}
};
for(var i=0;i<data.rows.length;i++){
$(_6b6).datagrid("cancelEdit",i);
}
var _6c1=_6bd(_6bb);
var _6c2=_6bd(_6bc);
_6bb.splice(0,_6bb.length);
_6bc.splice(0,_6bc.length);
data.total+=_6ba.length-_6b9.length;
data.rows=_6b8;
_5f6(_6b6,data);
_6be(_6c1,"s");
_6be(_6c2,"c");
_6af(_6b6);
};
function _5f5(_6c3,_6c4){
var opts=$.data(_6c3,"datagrid").options;
if(_6c4){
opts.queryParams=_6c4;
}
var _6c5=$.extend({},opts.queryParams);
if(opts.pagination){
$.extend(_6c5,{page:opts.pageNumber||1,rows:opts.pageSize});
}
if(opts.sortName){
$.extend(_6c5,{sort:opts.sortName,order:opts.sortOrder});
}
if(opts.onBeforeLoad.call(_6c3,_6c5)==false){
return;
}
$(_6c3).datagrid("loading");
setTimeout(function(){
_6c6();
},0);
function _6c6(){
var _6c7=opts.loader.call(_6c3,_6c5,function(data){
setTimeout(function(){
$(_6c3).datagrid("loaded");
},0);
_5f6(_6c3,data);
setTimeout(function(){
_6af(_6c3);
},0);
},function(){
setTimeout(function(){
$(_6c3).datagrid("loaded");
},0);
opts.onLoadError.apply(_6c3,arguments);
});
if(_6c7==false){
$(_6c3).datagrid("loaded");
}
};
};
function _6c8(_6c9,_6ca){
var opts=$.data(_6c9,"datagrid").options;
_6ca.type=_6ca.type||"body";
_6ca.rowspan=_6ca.rowspan||1;
_6ca.colspan=_6ca.colspan||1;
if(_6ca.rowspan==1&&_6ca.colspan==1){
return;
}
var tr=opts.finder.getTr(_6c9,(_6ca.index!=undefined?_6ca.index:_6ca.id),_6ca.type);
if(!tr.length){
return;
}
var td=tr.find("td[field=\""+_6ca.field+"\"]");
td.attr("rowspan",_6ca.rowspan).attr("colspan",_6ca.colspan);
td.addClass("datagrid-td-merged");
_6cb(td.next(),_6ca.colspan-1);
for(var i=1;i<_6ca.rowspan;i++){
tr=tr.next();
if(!tr.length){
break;
}
td=tr.find("td[field=\""+_6ca.field+"\"]");
_6cb(td,_6ca.colspan);
}
_618(_6c9);
function _6cb(td,_6cc){
for(var i=0;i<_6cc;i++){
td.hide();
td=td.next();
}
};
};
$.fn.datagrid=function(_6cd,_6ce){
if(typeof _6cd=="string"){
return $.fn.datagrid.methods[_6cd](this,_6ce);
}
_6cd=_6cd||{};
return this.each(function(){
var _6cf=$.data(this,"datagrid");
var opts;
if(_6cf){
opts=$.extend(_6cf.options,_6cd);
_6cf.options=opts;
}else{
opts=$.extend({},$.extend({},$.fn.datagrid.defaults,{queryParams:{}}),$.fn.datagrid.parseOptions(this),_6cd);
$(this).css("width","").css("height","");
var _6d0=_5a7(this,opts.rownumbers);
if(!opts.columns){
opts.columns=_6d0.columns;
}
if(!opts.frozenColumns){
opts.frozenColumns=_6d0.frozenColumns;
}
opts.columns=$.extend(true,[],opts.columns);
opts.frozenColumns=$.extend(true,[],opts.frozenColumns);
opts.view=$.extend({},opts.view);
$.data(this,"datagrid",{options:opts,panel:_6d0.panel,dc:_6d0.dc,ss:null,selectedRows:[],checkedRows:[],data:{total:0,rows:[]},originalRows:[],updatedRows:[],insertedRows:[],deletedRows:[]});
}
_5b0(this);
_5c5(this);
_57d(this);
if(opts.data){
_5f6(this,opts.data);
_6af(this);
}else{
var data=$.fn.datagrid.parseData(this);
if(data.total>0){
_5f6(this,data);
_6af(this);
}
}
_5f5(this);
});
};
function _6d1(_6d2){
var _6d3={};
$.map(_6d2,function(name){
_6d3[name]=_6d4(name);
});
return _6d3;
function _6d4(name){
function isA(_6d5){
return $.data($(_6d5)[0],name)!=undefined;
};
return {init:function(_6d6,_6d7){
var _6d8=$("<input type=\"text\" class=\"datagrid-editable-input\">").appendTo(_6d6);
if(_6d8[name]&&name!="text"){
return _6d8[name](_6d7);
}else{
return _6d8;
}
},destroy:function(_6d9){
if(isA(_6d9,name)){
$(_6d9)[name]("destroy");
}
},getValue:function(_6da){
if(isA(_6da,name)){
var opts=$(_6da)[name]("options");
if(opts.multiple){
return $(_6da)[name]("getValues").join(opts.separator);
}else{
return $(_6da)[name]("getValue");
}
}else{
return $(_6da).val();
}
},setValue:function(_6db,_6dc){
if(isA(_6db,name)){
var opts=$(_6db)[name]("options");
if(opts.multiple){
if(_6dc){
$(_6db)[name]("setValues",_6dc.split(opts.separator));
}else{
$(_6db)[name]("clear");
}
}else{
$(_6db)[name]("setValue",_6dc);
}
}else{
$(_6db).val(_6dc);
}
},resize:function(_6dd,_6de){
if(isA(_6dd,name)){
$(_6dd)[name]("resize",_6de);
}else{
$(_6dd)._outerWidth(_6de)._outerHeight(22);
}
}};
};
};
var _6df=$.extend({},_6d1(["text","textbox","numberbox","numberspinner","combobox","combotree","combogrid","datebox","datetimebox","timespinner","datetimespinner"]),{textarea:{init:function(_6e0,_6e1){
var _6e2=$("<textarea class=\"datagrid-editable-input\"></textarea>").appendTo(_6e0);
return _6e2;
},getValue:function(_6e3){
return $(_6e3).val();
},setValue:function(_6e4,_6e5){
$(_6e4).val(_6e5);
},resize:function(_6e6,_6e7){
$(_6e6)._outerWidth(_6e7);
}},checkbox:{init:function(_6e8,_6e9){
var _6ea=$("<input type=\"checkbox\">").appendTo(_6e8);
_6ea.val(_6e9.on);
_6ea.attr("offval",_6e9.off);
return _6ea;
},getValue:function(_6eb){
if($(_6eb).is(":checked")){
return $(_6eb).val();
}else{
return $(_6eb).attr("offval");
}
},setValue:function(_6ec,_6ed){
var _6ee=false;
if($(_6ec).val()==_6ed){
_6ee=true;
}
$(_6ec)._propAttr("checked",_6ee);
}},validatebox:{init:function(_6ef,_6f0){
var _6f1=$("<input type=\"text\" class=\"datagrid-editable-input\">").appendTo(_6ef);
_6f1.validatebox(_6f0);
return _6f1;
},destroy:function(_6f2){
$(_6f2).validatebox("destroy");
},getValue:function(_6f3){
return $(_6f3).val();
},setValue:function(_6f4,_6f5){
$(_6f4).val(_6f5);
},resize:function(_6f6,_6f7){
$(_6f6)._outerWidth(_6f7)._outerHeight(22);
}}});
$.fn.datagrid.methods={options:function(jq){
var _6f8=$.data(jq[0],"datagrid").options;
var _6f9=$.data(jq[0],"datagrid").panel.panel("options");
var opts=$.extend(_6f8,{width:_6f9.width,height:_6f9.height,closed:_6f9.closed,collapsed:_6f9.collapsed,minimized:_6f9.minimized,maximized:_6f9.maximized});
return opts;
},setSelectionState:function(jq){
return jq.each(function(){
_634(this);
});
},createStyleSheet:function(jq){
return _56e(jq[0]);
},getPanel:function(jq){
return $.data(jq[0],"datagrid").panel;
},getPager:function(jq){
return $.data(jq[0],"datagrid").panel.children("div.datagrid-pager");
},getColumnFields:function(jq,_6fa){
return _5c3(jq[0],_6fa);
},getColumnOption:function(jq,_6fb){
return _5c4(jq[0],_6fb);
},resize:function(jq,_6fc){
return jq.each(function(){
_57d(this,_6fc);
});
},load:function(jq,_6fd){
return jq.each(function(){
var opts=$(this).datagrid("options");
if(typeof _6fd=="string"){
opts.url=_6fd;
_6fd=null;
}
opts.pageNumber=1;
var _6fe=$(this).datagrid("getPager");
_6fe.pagination("refresh",{pageNumber:1});
_5f5(this,_6fd);
});
},reload:function(jq,_6ff){
return jq.each(function(){
var opts=$(this).datagrid("options");
if(typeof _6ff=="string"){
opts.url=_6ff;
_6ff=null;
}
_5f5(this,_6ff);
});
},reloadFooter:function(jq,_700){
return jq.each(function(){
var opts=$.data(this,"datagrid").options;
var dc=$.data(this,"datagrid").dc;
if(_700){
$.data(this,"datagrid").footer=_700;
}
if(opts.showFooter){
opts.view.renderFooter.call(opts.view,this,dc.footer2,false);
opts.view.renderFooter.call(opts.view,this,dc.footer1,true);
if(opts.view.onAfterRender){
opts.view.onAfterRender.call(opts.view,this);
}
$(this).datagrid("fixRowHeight");
}
});
},loading:function(jq){
return jq.each(function(){
var opts=$.data(this,"datagrid").options;
$(this).datagrid("getPager").pagination("loading");
if(opts.loadMsg){
var _701=$(this).datagrid("getPanel");
if(!_701.children("div.datagrid-mask").length){
$("<div class=\"datagrid-mask\" style=\"display:block\"></div>").appendTo(_701);
var msg=$("<div class=\"datagrid-mask-msg\" style=\"display:block;left:50%\"></div>").html(opts.loadMsg).appendTo(_701);
msg._outerHeight(40);
msg.css({marginLeft:(-msg.outerWidth()/2),lineHeight:(msg.height()+"px")});
}
}
});
},loaded:function(jq){
return jq.each(function(){
$(this).datagrid("getPager").pagination("loaded");
var _702=$(this).datagrid("getPanel");
_702.children("div.datagrid-mask-msg").remove();
_702.children("div.datagrid-mask").remove();
});
},fitColumns:function(jq){
return jq.each(function(){
_5f7(this);
});
},fixColumnSize:function(jq,_703){
return jq.each(function(){
_613(this,_703);
});
},fixRowHeight:function(jq,_704){
return jq.each(function(){
_593(this,_704);
});
},freezeRow:function(jq,_705){
return jq.each(function(){
_5a0(this,_705);
});
},autoSizeColumn:function(jq,_706){
return jq.each(function(){
_607(this,_706);
});
},loadData:function(jq,data){
return jq.each(function(){
_5f6(this,data);
_6af(this);
});
},getData:function(jq){
return $.data(jq[0],"datagrid").data;
},getRows:function(jq){
return $.data(jq[0],"datagrid").data.rows;
},getFooterRows:function(jq){
return $.data(jq[0],"datagrid").footer;
},getRowIndex:function(jq,id){
return _63c(jq[0],id);
},getChecked:function(jq){
return _642(jq[0]);
},getSelected:function(jq){
var rows=_63f(jq[0]);
return rows.length>0?rows[0]:null;
},getSelections:function(jq){
return _63f(jq[0]);
},clearSelections:function(jq){
return jq.each(function(){
var _707=$.data(this,"datagrid");
var _708=_707.selectedRows;
var _709=_707.checkedRows;
_708.splice(0,_708.length);
_653(this);
if(_707.options.checkOnSelect){
_709.splice(0,_709.length);
}
});
},clearChecked:function(jq){
return jq.each(function(){
var _70a=$.data(this,"datagrid");
var _70b=_70a.selectedRows;
var _70c=_70a.checkedRows;
_70c.splice(0,_70c.length);
_663(this);
if(_70a.options.selectOnCheck){
_70b.splice(0,_70b.length);
}
});
},scrollTo:function(jq,_70d){
return jq.each(function(){
_645(this,_70d);
});
},highlightRow:function(jq,_70e){
return jq.each(function(){
_5d8(this,_70e);
_645(this,_70e);
});
},selectAll:function(jq){
return jq.each(function(){
_658(this);
});
},unselectAll:function(jq){
return jq.each(function(){
_653(this);
});
},selectRow:function(jq,_70f){
return jq.each(function(){
_5df(this,_70f);
});
},selectRecord:function(jq,id){
return jq.each(function(){
var opts=$.data(this,"datagrid").options;
if(opts.idField){
var _710=_63c(this,id);
if(_710>=0){
$(this).datagrid("selectRow",_710);
}
}
});
},unselectRow:function(jq,_711){
return jq.each(function(){
_5e0(this,_711);
});
},checkRow:function(jq,_712){
return jq.each(function(){
_5dc(this,_712);
});
},uncheckRow:function(jq,_713){
return jq.each(function(){
_5dd(this,_713);
});
},checkAll:function(jq){
return jq.each(function(){
_65d(this);
});
},uncheckAll:function(jq){
return jq.each(function(){
_663(this);
});
},beginEdit:function(jq,_714){
return jq.each(function(){
_674(this,_714);
});
},endEdit:function(jq,_715){
return jq.each(function(){
_67a(this,_715,false);
});
},cancelEdit:function(jq,_716){
return jq.each(function(){
_67a(this,_716,true);
});
},getEditors:function(jq,_717){
return _687(jq[0],_717);
},getEditor:function(jq,_718){
return _68b(jq[0],_718);
},refreshRow:function(jq,_719){
return jq.each(function(){
var opts=$.data(this,"datagrid").options;
opts.view.refreshRow.call(opts.view,this,_719);
});
},validateRow:function(jq,_71a){
return _679(jq[0],_71a);
},updateRow:function(jq,_71b){
return jq.each(function(){
var opts=$.data(this,"datagrid").options;
opts.view.updateRow.call(opts.view,this,_71b.index,_71b.row);
});
},appendRow:function(jq,row){
return jq.each(function(){
_6ac(this,row);
});
},insertRow:function(jq,_71c){
return jq.each(function(){
_6a8(this,_71c);
});
},deleteRow:function(jq,_71d){
return jq.each(function(){
_6a2(this,_71d);
});
},getChanges:function(jq,_71e){
return _69c(jq[0],_71e);
},acceptChanges:function(jq){
return jq.each(function(){
_6b3(this);
});
},rejectChanges:function(jq){
return jq.each(function(){
_6b5(this);
});
},mergeCells:function(jq,_71f){
return jq.each(function(){
_6c8(this,_71f);
});
},showColumn:function(jq,_720){
return jq.each(function(){
var _721=$(this).datagrid("getPanel");
_721.find("td[field=\""+_720+"\"]").show();
$(this).datagrid("getColumnOption",_720).hidden=false;
$(this).datagrid("fitColumns");
});
},hideColumn:function(jq,_722){
return jq.each(function(){
var _723=$(this).datagrid("getPanel");
_723.find("td[field=\""+_722+"\"]").hide();
$(this).datagrid("getColumnOption",_722).hidden=true;
$(this).datagrid("fitColumns");
});
},sort:function(jq,_724){
return jq.each(function(){
_5ea(this,_724);
});
}};
$.fn.datagrid.parseOptions=function(_725){
var t=$(_725);
return $.extend({},$.fn.panel.parseOptions(_725),$.parser.parseOptions(_725,["url","toolbar","idField","sortName","sortOrder","pagePosition","resizeHandle",{sharedStyleSheet:"boolean",fitColumns:"boolean",autoRowHeight:"boolean",striped:"boolean",nowrap:"boolean"},{rownumbers:"boolean",singleSelect:"boolean",ctrlSelect:"boolean",checkOnSelect:"boolean",selectOnCheck:"boolean"},{pagination:"boolean",pageSize:"number",pageNumber:"number"},{multiSort:"boolean",remoteSort:"boolean",showHeader:"boolean",showFooter:"boolean"},{scrollbarSize:"number"}]),{pageList:(t.attr("pageList")?eval(t.attr("pageList")):undefined),loadMsg:(t.attr("loadMsg")!=undefined?t.attr("loadMsg"):undefined),rowStyler:(t.attr("rowStyler")?eval(t.attr("rowStyler")):undefined)});
};
$.fn.datagrid.parseData=function(_726){
var t=$(_726);
var data={total:0,rows:[]};
var _727=t.datagrid("getColumnFields",true).concat(t.datagrid("getColumnFields",false));
t.find("tbody tr").each(function(){
data.total++;
var row={};
$.extend(row,$.parser.parseOptions(this,["iconCls","state"]));
for(var i=0;i<_727.length;i++){
row[_727[i]]=$(this).find("td:eq("+i+")").html();
}
data.rows.push(row);
});
return data;
};
var _728={render:function(_729,_72a,_72b){
var _72c=$.data(_729,"datagrid");
var opts=_72c.options;
var rows=_72c.data.rows;
var _72d=$(_729).datagrid("getColumnFields",_72b);
if(_72b){
if(!(opts.rownumbers||(opts.frozenColumns&&opts.frozenColumns.length))){
return;
}
}
var _72e=["<table class=\"datagrid-btable\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tbody>"];
for(var i=0;i<rows.length;i++){
var css=opts.rowStyler?opts.rowStyler.call(_729,i,rows[i]):"";
var _72f="";
var _730="";
if(typeof css=="string"){
_730=css;
}else{
if(css){
_72f=css["class"]||"";
_730=css["style"]||"";
}
}
var cls="class=\"datagrid-row "+(i%2&&opts.striped?"datagrid-row-alt ":" ")+_72f+"\"";
var _731=_730?"style=\""+_730+"\"":"";
var _732=_72c.rowIdPrefix+"-"+(_72b?1:2)+"-"+i;
_72e.push("<tr id=\""+_732+"\" datagrid-row-index=\""+i+"\" "+cls+" "+_731+">");
_72e.push(this.renderRow.call(this,_729,_72d,_72b,i,rows[i]));
_72e.push("</tr>");
}
_72e.push("</tbody></table>");
$(_72a).html(_72e.join(""));
},renderFooter:function(_733,_734,_735){
var opts=$.data(_733,"datagrid").options;
var rows=$.data(_733,"datagrid").footer||[];
var _736=$(_733).datagrid("getColumnFields",_735);
var _737=["<table class=\"datagrid-ftable\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tbody>"];
for(var i=0;i<rows.length;i++){
_737.push("<tr class=\"datagrid-row\" datagrid-row-index=\""+i+"\">");
_737.push(this.renderRow.call(this,_733,_736,_735,i,rows[i]));
_737.push("</tr>");
}
_737.push("</tbody></table>");
$(_734).html(_737.join(""));
},renderRow:function(_738,_739,_73a,_73b,_73c){
var opts=$.data(_738,"datagrid").options;
var cc=[];
if(_73a&&opts.rownumbers){
var _73d=_73b+1;
if(opts.pagination){
_73d+=(opts.pageNumber-1)*opts.pageSize;
}
cc.push("<td class=\"datagrid-td-rownumber\"><div class=\"datagrid-cell-rownumber\">"+_73d+"</div></td>");
}
for(var i=0;i<_739.length;i++){
var _73e=_739[i];
var col=$(_738).datagrid("getColumnOption",_73e);
if(col){
var _73f=_73c[_73e];
var css=col.styler?(col.styler(_73f,_73c,_73b)||""):"";
var _740="";
var _741="";
if(typeof css=="string"){
_741=css;
}else{
if(css){
_740=css["class"]||"";
_741=css["style"]||"";
}
}
var cls=_740?"class=\""+_740+"\"":"";
var _742=col.hidden?"style=\"display:none;"+_741+"\"":(_741?"style=\""+_741+"\"":"");
cc.push("<td field=\""+_73e+"\" "+cls+" "+_742+">");
var _742="";
if(!col.checkbox){
if(col.align){
_742+="text-align:"+col.align+";";
}
if(!opts.nowrap){
_742+="white-space:normal;height:auto;";
}else{
if(opts.autoRowHeight){
_742+="height:auto;";
}
}
}
cc.push("<div style=\""+_742+"\" ");
cc.push(col.checkbox?"class=\"datagrid-cell-check\"":"class=\"datagrid-cell "+col.cellClass+"\"");
cc.push(">");
if(col.checkbox){
cc.push("<input type=\"checkbox\" "+(_73c.checked?"checked=\"checked\"":""));
cc.push(" name=\""+_73e+"\" value=\""+(_73f!=undefined?_73f:"")+"\">");
}else{
if(col.formatter){
cc.push(col.formatter(_73f,_73c,_73b));
}else{
cc.push(_73f);
}
}
cc.push("</div>");
cc.push("</td>");
}
}
return cc.join("");
},refreshRow:function(_743,_744){
this.updateRow.call(this,_743,_744,{});
},updateRow:function(_745,_746,row){
var opts=$.data(_745,"datagrid").options;
var rows=$(_745).datagrid("getRows");
var _747=_748(_746);
$.extend(rows[_746],row);
var _749=_748(_746);
var _74a=_747.c;
var _74b=_749.s;
var _74c="datagrid-row "+(_746%2&&opts.striped?"datagrid-row-alt ":" ")+_749.c;
function _748(_74d){
var css=opts.rowStyler?opts.rowStyler.call(_745,_74d,rows[_74d]):"";
var _74e="";
var _74f="";
if(typeof css=="string"){
_74f=css;
}else{
if(css){
_74e=css["class"]||"";
_74f=css["style"]||"";
}
}
return {c:_74e,s:_74f};
};
function _750(_751){
var _752=$(_745).datagrid("getColumnFields",_751);
var tr=opts.finder.getTr(_745,_746,"body",(_751?1:2));
var _753=tr.find("div.datagrid-cell-check input[type=checkbox]").is(":checked");
tr.html(this.renderRow.call(this,_745,_752,_751,_746,rows[_746]));
tr.attr("style",_74b).removeClass(_74a).addClass(_74c);
if(_753){
tr.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked",true);
}
};
_750.call(this,true);
_750.call(this,false);
$(_745).datagrid("fixRowHeight",_746);
},insertRow:function(_754,_755,row){
var _756=$.data(_754,"datagrid");
var opts=_756.options;
var dc=_756.dc;
var data=_756.data;
if(_755==undefined||_755==null){
_755=data.rows.length;
}
if(_755>data.rows.length){
_755=data.rows.length;
}
function _757(_758){
var _759=_758?1:2;
for(var i=data.rows.length-1;i>=_755;i--){
var tr=opts.finder.getTr(_754,i,"body",_759);
tr.attr("datagrid-row-index",i+1);
tr.attr("id",_756.rowIdPrefix+"-"+_759+"-"+(i+1));
if(_758&&opts.rownumbers){
var _75a=i+2;
if(opts.pagination){
_75a+=(opts.pageNumber-1)*opts.pageSize;
}
tr.find("div.datagrid-cell-rownumber").html(_75a);
}
if(opts.striped){
tr.removeClass("datagrid-row-alt").addClass((i+1)%2?"datagrid-row-alt":"");
}
}
};
function _75b(_75c){
var _75d=_75c?1:2;
var _75e=$(_754).datagrid("getColumnFields",_75c);
var _75f=_756.rowIdPrefix+"-"+_75d+"-"+_755;
var tr="<tr id=\""+_75f+"\" class=\"datagrid-row\" datagrid-row-index=\""+_755+"\"></tr>";
if(_755>=data.rows.length){
if(data.rows.length){
opts.finder.getTr(_754,"","last",_75d).after(tr);
}else{
var cc=_75c?dc.body1:dc.body2;
cc.html("<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tbody>"+tr+"</tbody></table>");
}
}else{
opts.finder.getTr(_754,_755+1,"body",_75d).before(tr);
}
};
_757.call(this,true);
_757.call(this,false);
_75b.call(this,true);
_75b.call(this,false);
data.total+=1;
data.rows.splice(_755,0,row);
this.refreshRow.call(this,_754,_755);
},deleteRow:function(_760,_761){
var _762=$.data(_760,"datagrid");
var opts=_762.options;
var data=_762.data;
function _763(_764){
var _765=_764?1:2;
for(var i=_761+1;i<data.rows.length;i++){
var tr=opts.finder.getTr(_760,i,"body",_765);
tr.attr("datagrid-row-index",i-1);
tr.attr("id",_762.rowIdPrefix+"-"+_765+"-"+(i-1));
if(_764&&opts.rownumbers){
var _766=i;
if(opts.pagination){
_766+=(opts.pageNumber-1)*opts.pageSize;
}
tr.find("div.datagrid-cell-rownumber").html(_766);
}
if(opts.striped){
tr.removeClass("datagrid-row-alt").addClass((i-1)%2?"datagrid-row-alt":"");
}
}
};
opts.finder.getTr(_760,_761).remove();
_763.call(this,true);
_763.call(this,false);
data.total-=1;
data.rows.splice(_761,1);
},onBeforeRender:function(_767,rows){
},onAfterRender:function(_768){
var opts=$.data(_768,"datagrid").options;
if(opts.showFooter){
var _769=$(_768).datagrid("getPanel").find("div.datagrid-footer");
_769.find("div.datagrid-cell-rownumber,div.datagrid-cell-check").css("visibility","hidden");
}
}};
$.fn.datagrid.defaults=$.extend({},$.fn.panel.defaults,{sharedStyleSheet:false,frozenColumns:undefined,columns:undefined,fitColumns:false,resizeHandle:"right",autoRowHeight:true,toolbar:null,striped:false,method:"post",nowrap:true,idField:null,url:null,data:null,loadMsg:"Processing, please wait ...",rownumbers:false,singleSelect:false,ctrlSelect:false,selectOnCheck:true,checkOnSelect:true,pagination:false,pagePosition:"bottom",pageNumber:1,pageSize:10,pageList:[10,20,30,40,50],queryParams:{},sortName:null,sortOrder:"asc",multiSort:false,remoteSort:true,showHeader:true,showFooter:false,scrollbarSize:18,rowEvents:{mouseover:_5d1(true),mouseout:_5d1(false),click:_5d9,dblclick:_5e3,contextmenu:_5e7},rowStyler:function(_76a,_76b){
},loader:function(_76c,_76d,_76e){
var opts=$(this).datagrid("options");
if(!opts.url){
return false;
}
$.ajax({type:opts.method,url:opts.url,data:_76c,dataType:"json",success:function(data){
_76d(data);
},error:function(){
_76e.apply(this,arguments);
}});
},loadFilter:function(data){
if(typeof data.length=="number"&&typeof data.splice=="function"){
return {total:data.length,rows:data};
}else{
return data;
}
},editors:_6df,finder:{getTr:function(_76f,_770,type,_771){
type=type||"body";
_771=_771||0;
var _772=$.data(_76f,"datagrid");
var dc=_772.dc;
var opts=_772.options;
if(_771==0){
var tr1=opts.finder.getTr(_76f,_770,type,1);
var tr2=opts.finder.getTr(_76f,_770,type,2);
return tr1.add(tr2);
}else{
if(type=="body"){
var tr=$("#"+_772.rowIdPrefix+"-"+_771+"-"+_770);
if(!tr.length){
tr=(_771==1?dc.body1:dc.body2).find(">table>tbody>tr[datagrid-row-index="+_770+"]");
}
return tr;
}else{
if(type=="footer"){
return (_771==1?dc.footer1:dc.footer2).find(">table>tbody>tr[datagrid-row-index="+_770+"]");
}else{
if(type=="selected"){
return (_771==1?dc.body1:dc.body2).find(">table>tbody>tr.datagrid-row-selected");
}else{
if(type=="highlight"){
return (_771==1?dc.body1:dc.body2).find(">table>tbody>tr.datagrid-row-over");
}else{
if(type=="checked"){
return (_771==1?dc.body1:dc.body2).find(">table>tbody>tr.datagrid-row-checked");
}else{
if(type=="editing"){
return (_771==1?dc.body1:dc.body2).find(">table>tbody>tr.datagrid-row-editing");
}else{
if(type=="last"){
return (_771==1?dc.body1:dc.body2).find(">table>tbody>tr[datagrid-row-index]:last");
}else{
if(type=="allbody"){
return (_771==1?dc.body1:dc.body2).find(">table>tbody>tr[datagrid-row-index]");
}else{
if(type=="allfooter"){
return (_771==1?dc.footer1:dc.footer2).find(">table>tbody>tr[datagrid-row-index]");
}
}
}
}
}
}
}
}
}
}
},getRow:function(_773,p){
var _774=(typeof p=="object")?p.attr("datagrid-row-index"):p;
return $.data(_773,"datagrid").data.rows[parseInt(_774)];
},getRows:function(_775){
return $(_775).datagrid("getRows");
}},view:_728,onBeforeLoad:function(_776){
},onLoadSuccess:function(){
},onLoadError:function(){
},onClickRow:function(_777,_778){
},onDblClickRow:function(_779,_77a){
},onClickCell:function(_77b,_77c,_77d){
},onDblClickCell:function(_77e,_77f,_780){
},onBeforeSortColumn:function(sort,_781){
},onSortColumn:function(sort,_782){
},onResizeColumn:function(_783,_784){
},onBeforeSelect:function(_785,_786){
},onSelect:function(_787,_788){
},onBeforeUnselect:function(_789,_78a){
},onUnselect:function(_78b,_78c){
},onSelectAll:function(rows){
},onUnselectAll:function(rows){
},onBeforeCheck:function(_78d,_78e){
},onCheck:function(_78f,_790){
},onBeforeUncheck:function(_791,_792){
},onUncheck:function(_793,_794){
},onCheckAll:function(rows){
},onUncheckAll:function(rows){
},onBeforeEdit:function(_795,_796){
},onBeginEdit:function(_797,_798){
},onEndEdit:function(_799,_79a,_79b){
},onAfterEdit:function(_79c,_79d,_79e){
},onCancelEdit:function(_79f,_7a0){
},onHeaderContextMenu:function(e,_7a1){
},onRowContextMenu:function(e,_7a2,_7a3){
}});
})(jQuery);
(function($){
var _7a4;
$(document).unbind(".propertygrid").bind("mousedown.propertygrid",function(e){
var p=$(e.target).closest("div.datagrid-view,div.combo-panel");
if(p.length){
return;
}
_7a5(_7a4);
_7a4=undefined;
});
function _7a6(_7a7){
var _7a8=$.data(_7a7,"propertygrid");
var opts=$.data(_7a7,"propertygrid").options;
$(_7a7).datagrid($.extend({},opts,{cls:"propertygrid",view:(opts.showGroup?opts.groupView:opts.view),onBeforeEdit:function(_7a9,row){
if(opts.onBeforeEdit.call(_7a7,_7a9,row)==false){
return false;
}
var dg=$(this);
var row=dg.datagrid("getRows")[_7a9];
var col=dg.datagrid("getColumnOption","value");
col.editor=row.editor;
},onClickCell:function(_7aa,_7ab,_7ac){
if(_7a4!=this){
_7a5(_7a4);
_7a4=this;
}
if(opts.editIndex!=_7aa){
_7a5(_7a4);
$(this).datagrid("beginEdit",_7aa);
var ed=$(this).datagrid("getEditor",{index:_7aa,field:_7ab});
if(!ed){
ed=$(this).datagrid("getEditor",{index:_7aa,field:"value"});
}
if(ed){
var t=$(ed.target);
var _7ad=t.data("textbox")?t.textbox("textbox"):t;
_7ad.focus();
opts.editIndex=_7aa;
}
}
opts.onClickCell.call(_7a7,_7aa,_7ab,_7ac);
},loadFilter:function(data){
_7a5(this);
return opts.loadFilter.call(this,data);
}}));
};
function _7a5(_7ae){
var t=$(_7ae);
if(!t.length){
return;
}
var opts=$.data(_7ae,"propertygrid").options;
opts.finder.getTr(_7ae,null,"editing").each(function(){
var _7af=parseInt($(this).attr("datagrid-row-index"));
if(t.datagrid("validateRow",_7af)){
t.datagrid("endEdit",_7af);
}else{
t.datagrid("cancelEdit",_7af);
}
});
};
$.fn.propertygrid=function(_7b0,_7b1){
if(typeof _7b0=="string"){
var _7b2=$.fn.propertygrid.methods[_7b0];
if(_7b2){
return _7b2(this,_7b1);
}else{
return this.datagrid(_7b0,_7b1);
}
}
_7b0=_7b0||{};
return this.each(function(){
var _7b3=$.data(this,"propertygrid");
if(_7b3){
$.extend(_7b3.options,_7b0);
}else{
var opts=$.extend({},$.fn.propertygrid.defaults,$.fn.propertygrid.parseOptions(this),_7b0);
opts.frozenColumns=$.extend(true,[],opts.frozenColumns);
opts.columns=$.extend(true,[],opts.columns);
$.data(this,"propertygrid",{options:opts});
}
_7a6(this);
});
};
$.fn.propertygrid.methods={options:function(jq){
return $.data(jq[0],"propertygrid").options;
}};
$.fn.propertygrid.parseOptions=function(_7b4){
return $.extend({},$.fn.datagrid.parseOptions(_7b4),$.parser.parseOptions(_7b4,[{showGroup:"boolean"}]));
};
var _7b5=$.extend({},$.fn.datagrid.defaults.view,{render:function(_7b6,_7b7,_7b8){
var _7b9=[];
var _7ba=this.groups;
for(var i=0;i<_7ba.length;i++){
_7b9.push(this.renderGroup.call(this,_7b6,i,_7ba[i],_7b8));
}
$(_7b7).html(_7b9.join(""));
},renderGroup:function(_7bb,_7bc,_7bd,_7be){
var _7bf=$.data(_7bb,"datagrid");
var opts=_7bf.options;
var _7c0=$(_7bb).datagrid("getColumnFields",_7be);
var _7c1=[];
_7c1.push("<div class=\"datagrid-group\" group-index="+_7bc+">");
_7c1.push("<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\" style=\"height:100%\"><tbody>");
_7c1.push("<tr>");
if((_7be&&(opts.rownumbers||opts.frozenColumns.length))||(!_7be&&!(opts.rownumbers||opts.frozenColumns.length))){
_7c1.push("<td style=\"border:0;text-align:center;width:25px\"><span class=\"datagrid-row-expander datagrid-row-collapse\" style=\"display:inline-block;width:16px;height:16px;cursor:pointer\">&nbsp;</span></td>");
}
_7c1.push("<td style=\"border:0;\">");
if(!_7be){
_7c1.push("<span class=\"datagrid-group-title\">");
_7c1.push(opts.groupFormatter.call(_7bb,_7bd.value,_7bd.rows));
_7c1.push("</span>");
}
_7c1.push("</td>");
_7c1.push("</tr>");
_7c1.push("</tbody></table>");
_7c1.push("</div>");
_7c1.push("<table class=\"datagrid-btable\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tbody>");
var _7c2=_7bd.startIndex;
for(var j=0;j<_7bd.rows.length;j++){
var css=opts.rowStyler?opts.rowStyler.call(_7bb,_7c2,_7bd.rows[j]):"";
var _7c3="";
var _7c4="";
if(typeof css=="string"){
_7c4=css;
}else{
if(css){
_7c3=css["class"]||"";
_7c4=css["style"]||"";
}
}
var cls="class=\"datagrid-row "+(_7c2%2&&opts.striped?"datagrid-row-alt ":" ")+_7c3+"\"";
var _7c5=_7c4?"style=\""+_7c4+"\"":"";
var _7c6=_7bf.rowIdPrefix+"-"+(_7be?1:2)+"-"+_7c2;
_7c1.push("<tr id=\""+_7c6+"\" datagrid-row-index=\""+_7c2+"\" "+cls+" "+_7c5+">");
_7c1.push(this.renderRow.call(this,_7bb,_7c0,_7be,_7c2,_7bd.rows[j]));
_7c1.push("</tr>");
_7c2++;
}
_7c1.push("</tbody></table>");
return _7c1.join("");
},bindEvents:function(_7c7){
var _7c8=$.data(_7c7,"datagrid");
var dc=_7c8.dc;
var body=dc.body1.add(dc.body2);
var _7c9=($.data(body[0],"events")||$._data(body[0],"events")).click[0].handler;
body.unbind("click").bind("click",function(e){
var tt=$(e.target);
var _7ca=tt.closest("span.datagrid-row-expander");
if(_7ca.length){
var _7cb=_7ca.closest("div.datagrid-group").attr("group-index");
if(_7ca.hasClass("datagrid-row-collapse")){
$(_7c7).datagrid("collapseGroup",_7cb);
}else{
$(_7c7).datagrid("expandGroup",_7cb);
}
}else{
_7c9(e);
}
e.stopPropagation();
});
},onBeforeRender:function(_7cc,rows){
var _7cd=$.data(_7cc,"datagrid");
var opts=_7cd.options;
_7ce();
var _7cf=[];
for(var i=0;i<rows.length;i++){
var row=rows[i];
var _7d0=_7d1(row[opts.groupField]);
if(!_7d0){
_7d0={value:row[opts.groupField],rows:[row]};
_7cf.push(_7d0);
}else{
_7d0.rows.push(row);
}
}
var _7d2=0;
var _7d3=[];
for(var i=0;i<_7cf.length;i++){
var _7d0=_7cf[i];
_7d0.startIndex=_7d2;
_7d2+=_7d0.rows.length;
_7d3=_7d3.concat(_7d0.rows);
}
_7cd.data.rows=_7d3;
this.groups=_7cf;
var that=this;
setTimeout(function(){
that.bindEvents(_7cc);
},0);
function _7d1(_7d4){
for(var i=0;i<_7cf.length;i++){
var _7d5=_7cf[i];
if(_7d5.value==_7d4){
return _7d5;
}
}
return null;
};
function _7ce(){
if(!$("#datagrid-group-style").length){
$("head").append("<style id=\"datagrid-group-style\">"+".datagrid-group{height:25px;overflow:hidden;font-weight:bold;border-bottom:1px solid #ccc;}"+"</style>");
}
};
}});
$.extend($.fn.datagrid.methods,{expandGroup:function(jq,_7d6){
return jq.each(function(){
var view=$.data(this,"datagrid").dc.view;
var _7d7=view.find(_7d6!=undefined?"div.datagrid-group[group-index=\""+_7d6+"\"]":"div.datagrid-group");
var _7d8=_7d7.find("span.datagrid-row-expander");
if(_7d8.hasClass("datagrid-row-expand")){
_7d8.removeClass("datagrid-row-expand").addClass("datagrid-row-collapse");
_7d7.next("table").show();
}
$(this).datagrid("fixRowHeight");
});
},collapseGroup:function(jq,_7d9){
return jq.each(function(){
var view=$.data(this,"datagrid").dc.view;
var _7da=view.find(_7d9!=undefined?"div.datagrid-group[group-index=\""+_7d9+"\"]":"div.datagrid-group");
var _7db=_7da.find("span.datagrid-row-expander");
if(_7db.hasClass("datagrid-row-collapse")){
_7db.removeClass("datagrid-row-collapse").addClass("datagrid-row-expand");
_7da.next("table").hide();
}
$(this).datagrid("fixRowHeight");
});
}});
$.extend(_7b5,{refreshGroupTitle:function(_7dc,_7dd){
var _7de=$.data(_7dc,"datagrid");
var opts=_7de.options;
var dc=_7de.dc;
var _7df=this.groups[_7dd];
var span=dc.body2.children("div.datagrid-group[group-index="+_7dd+"]").find("span.datagrid-group-title");
span.html(opts.groupFormatter.call(_7dc,_7df.value,_7df.rows));
},insertRow:function(_7e0,_7e1,row){
var _7e2=$.data(_7e0,"datagrid");
var opts=_7e2.options;
var dc=_7e2.dc;
var _7e3=null;
var _7e4;
for(var i=0;i<this.groups.length;i++){
if(this.groups[i].value==row[opts.groupField]){
_7e3=this.groups[i];
_7e4=i;
break;
}
}
if(_7e3){
if(_7e1==undefined||_7e1==null){
_7e1=_7e2.data.rows.length;
}
if(_7e1<_7e3.startIndex){
_7e1=_7e3.startIndex;
}else{
if(_7e1>_7e3.startIndex+_7e3.rows.length){
_7e1=_7e3.startIndex+_7e3.rows.length;
}
}
$.fn.datagrid.defaults.view.insertRow.call(this,_7e0,_7e1,row);
if(_7e1>=_7e3.startIndex+_7e3.rows.length){
_7e5(_7e1,true);
_7e5(_7e1,false);
}
_7e3.rows.splice(_7e1-_7e3.startIndex,0,row);
}else{
_7e3={value:row[opts.groupField],rows:[row],startIndex:_7e2.data.rows.length};
_7e4=this.groups.length;
dc.body1.append(this.renderGroup.call(this,_7e0,_7e4,_7e3,true));
dc.body2.append(this.renderGroup.call(this,_7e0,_7e4,_7e3,false));
this.groups.push(_7e3);
_7e2.data.rows.push(row);
}
this.refreshGroupTitle(_7e0,_7e4);
function _7e5(_7e6,_7e7){
var _7e8=_7e7?1:2;
var _7e9=opts.finder.getTr(_7e0,_7e6-1,"body",_7e8);
var tr=opts.finder.getTr(_7e0,_7e6,"body",_7e8);
tr.insertAfter(_7e9);
};
},updateRow:function(_7ea,_7eb,row){
var opts=$.data(_7ea,"datagrid").options;
$.fn.datagrid.defaults.view.updateRow.call(this,_7ea,_7eb,row);
var tb=opts.finder.getTr(_7ea,_7eb,"body",2).closest("table.datagrid-btable");
var _7ec=parseInt(tb.prev().attr("group-index"));
this.refreshGroupTitle(_7ea,_7ec);
},deleteRow:function(_7ed,_7ee){
var _7ef=$.data(_7ed,"datagrid");
var opts=_7ef.options;
var dc=_7ef.dc;
var body=dc.body1.add(dc.body2);
var tb=opts.finder.getTr(_7ed,_7ee,"body",2).closest("table.datagrid-btable");
var _7f0=parseInt(tb.prev().attr("group-index"));
$.fn.datagrid.defaults.view.deleteRow.call(this,_7ed,_7ee);
var _7f1=this.groups[_7f0];
if(_7f1.rows.length>1){
_7f1.rows.splice(_7ee-_7f1.startIndex,1);
this.refreshGroupTitle(_7ed,_7f0);
}else{
body.children("div.datagrid-group[group-index="+_7f0+"]").remove();
for(var i=_7f0+1;i<this.groups.length;i++){
body.children("div.datagrid-group[group-index="+i+"]").attr("group-index",i-1);
}
this.groups.splice(_7f0,1);
}
var _7ee=0;
for(var i=0;i<this.groups.length;i++){
var _7f1=this.groups[i];
_7f1.startIndex=_7ee;
_7ee+=_7f1.rows.length;
}
}});
$.fn.propertygrid.defaults=$.extend({},$.fn.datagrid.defaults,{singleSelect:true,remoteSort:false,fitColumns:true,loadMsg:"",frozenColumns:[[{field:"f",width:16,resizable:false}]],columns:[[{field:"name",title:"Name",width:100,sortable:true},{field:"value",title:"Value",width:100,resizable:false}]],showGroup:false,groupView:_7b5,groupField:"group",groupFormatter:function(_7f2,rows){
return _7f2;
}});
})(jQuery);
(function($){
function _7f3(_7f4){
var _7f5=$.data(_7f4,"treegrid");
var opts=_7f5.options;
$(_7f4).datagrid($.extend({},opts,{url:null,data:null,loader:function(){
return false;
},onBeforeLoad:function(){
return false;
},onLoadSuccess:function(){
},onResizeColumn:function(_7f6,_7f7){
_812(_7f4);
opts.onResizeColumn.call(_7f4,_7f6,_7f7);
},onBeforeSortColumn:function(sort,_7f8){
if(opts.onBeforeSortColumn.call(_7f4,sort,_7f8)==false){
return false;
}
},onSortColumn:function(sort,_7f9){
opts.sortName=sort;
opts.sortOrder=_7f9;
if(opts.remoteSort){
_811(_7f4);
}else{
var data=$(_7f4).treegrid("getData");
_828(_7f4,0,data);
}
opts.onSortColumn.call(_7f4,sort,_7f9);
},onBeforeEdit:function(_7fa,row){
if(opts.onBeforeEdit.call(_7f4,row)==false){
return false;
}
},onAfterEdit:function(_7fb,row,_7fc){
opts.onAfterEdit.call(_7f4,row,_7fc);
},onCancelEdit:function(_7fd,row){
opts.onCancelEdit.call(_7f4,row);
},onBeforeSelect:function(_7fe){
if(opts.onBeforeSelect.call(_7f4,find(_7f4,_7fe))==false){
return false;
}
},onSelect:function(_7ff){
opts.onSelect.call(_7f4,find(_7f4,_7ff));
},onBeforeUnselect:function(_800){
if(opts.onBeforeUnselect.call(_7f4,find(_7f4,_800))==false){
return false;
}
},onUnselect:function(_801){
opts.onUnselect.call(_7f4,find(_7f4,_801));
},onBeforeCheck:function(_802){
if(opts.onBeforeCheck.call(_7f4,find(_7f4,_802))==false){
return false;
}
},onCheck:function(_803){
opts.onCheck.call(_7f4,find(_7f4,_803));
},onBeforeUncheck:function(_804){
if(opts.onBeforeUncheck.call(_7f4,find(_7f4,_804))==false){
return false;
}
},onUncheck:function(_805){
opts.onUncheck.call(_7f4,find(_7f4,_805));
},onClickRow:function(_806){
opts.onClickRow.call(_7f4,find(_7f4,_806));
},onDblClickRow:function(_807){
opts.onDblClickRow.call(_7f4,find(_7f4,_807));
},onClickCell:function(_808,_809){
opts.onClickCell.call(_7f4,_809,find(_7f4,_808));
},onDblClickCell:function(_80a,_80b){
opts.onDblClickCell.call(_7f4,_80b,find(_7f4,_80a));
},onRowContextMenu:function(e,_80c){
opts.onContextMenu.call(_7f4,e,find(_7f4,_80c));
}}));
if(!opts.columns){
var _80d=$.data(_7f4,"datagrid").options;
opts.columns=_80d.columns;
opts.frozenColumns=_80d.frozenColumns;
}
_7f5.dc=$.data(_7f4,"datagrid").dc;
if(opts.pagination){
var _80e=$(_7f4).datagrid("getPager");
_80e.pagination({pageNumber:opts.pageNumber,pageSize:opts.pageSize,pageList:opts.pageList,onSelectPage:function(_80f,_810){
opts.pageNumber=_80f;
opts.pageSize=_810;
_811(_7f4);
}});
opts.pageSize=_80e.pagination("options").pageSize;
}
};
function _812(_813,_814){
var opts=$.data(_813,"datagrid").options;
var dc=$.data(_813,"datagrid").dc;
if(!dc.body1.is(":empty")&&(!opts.nowrap||opts.autoRowHeight)){
if(_814!=undefined){
var _815=_816(_813,_814);
for(var i=0;i<_815.length;i++){
_817(_815[i][opts.idField]);
}
}
}
$(_813).datagrid("fixRowHeight",_814);
function _817(_818){
var tr1=opts.finder.getTr(_813,_818,"body",1);
var tr2=opts.finder.getTr(_813,_818,"body",2);
tr1.css("height","");
tr2.css("height","");
var _819=Math.max(tr1.height(),tr2.height());
tr1.css("height",_819);
tr2.css("height",_819);
};
};
function _81a(_81b){
var dc=$.data(_81b,"datagrid").dc;
var opts=$.data(_81b,"treegrid").options;
if(!opts.rownumbers){
return;
}
dc.body1.find("div.datagrid-cell-rownumber").each(function(i){
$(this).html(i+1);
});
};
function _81c(_81d){
return function(e){
$.fn.datagrid.defaults.rowEvents[_81d?"mouseover":"mouseout"](e);
var tt=$(e.target);
var fn=_81d?"addClass":"removeClass";
if(tt.hasClass("tree-hit")){
tt.hasClass("tree-expanded")?tt[fn]("tree-expanded-hover"):tt[fn]("tree-collapsed-hover");
}
};
};
function _81e(e){
var tt=$(e.target);
if(tt.hasClass("tree-hit")){
var tr=tt.closest("tr.datagrid-row");
var _81f=tr.closest("div.datagrid-view").children(".datagrid-f")[0];
_820(_81f,tr.attr("node-id"));
}else{
$.fn.datagrid.defaults.rowEvents.click(e);
}
};
function _821(_822,_823){
var opts=$.data(_822,"treegrid").options;
var tr1=opts.finder.getTr(_822,_823,"body",1);
var tr2=opts.finder.getTr(_822,_823,"body",2);
var _824=$(_822).datagrid("getColumnFields",true).length+(opts.rownumbers?1:0);
var _825=$(_822).datagrid("getColumnFields",false).length;
_826(tr1,_824);
_826(tr2,_825);
function _826(tr,_827){
$("<tr class=\"treegrid-tr-tree\">"+"<td style=\"border:0px\" colspan=\""+_827+"\">"+"<div></div>"+"</td>"+"</tr>").insertAfter(tr);
};
};
function _828(_829,_82a,data,_82b){
var _82c=$.data(_829,"treegrid");
var opts=_82c.options;
var dc=_82c.dc;
data=opts.loadFilter.call(_829,data,_82a);
var node=find(_829,_82a);
if(node){
var _82d=opts.finder.getTr(_829,_82a,"body",1);
var _82e=opts.finder.getTr(_829,_82a,"body",2);
var cc1=_82d.next("tr.treegrid-tr-tree").children("td").children("div");
var cc2=_82e.next("tr.treegrid-tr-tree").children("td").children("div");
if(!_82b){
node.children=[];
}
}else{
var cc1=dc.body1;
var cc2=dc.body2;
if(!_82b){
_82c.data=[];
}
}
if(!_82b){
cc1.empty();
cc2.empty();
}
if(opts.view.onBeforeRender){
opts.view.onBeforeRender.call(opts.view,_829,_82a,data);
}
opts.view.render.call(opts.view,_829,cc1,true);
opts.view.render.call(opts.view,_829,cc2,false);
if(opts.showFooter){
opts.view.renderFooter.call(opts.view,_829,dc.footer1,true);
opts.view.renderFooter.call(opts.view,_829,dc.footer2,false);
}
if(opts.view.onAfterRender){
opts.view.onAfterRender.call(opts.view,_829);
}
if(!_82a&&opts.pagination){
var _82f=$.data(_829,"treegrid").total;
var _830=$(_829).datagrid("getPager");
if(_830.pagination("options").total!=_82f){
_830.pagination({total:_82f});
}
}
_812(_829);
_81a(_829);
$(_829).treegrid("showLines");
$(_829).treegrid("setSelectionState");
$(_829).treegrid("autoSizeColumn");
opts.onLoadSuccess.call(_829,node,data);
};
function _811(_831,_832,_833,_834,_835){
var opts=$.data(_831,"treegrid").options;
var body=$(_831).datagrid("getPanel").find("div.datagrid-body");
if(_833){
opts.queryParams=_833;
}
var _836=$.extend({},opts.queryParams);
if(opts.pagination){
$.extend(_836,{page:opts.pageNumber,rows:opts.pageSize});
}
if(opts.sortName){
$.extend(_836,{sort:opts.sortName,order:opts.sortOrder});
}
var row=find(_831,_832);
if(opts.onBeforeLoad.call(_831,row,_836)==false){
return;
}
var _837=body.find("tr[node-id=\""+_832+"\"] span.tree-folder");
_837.addClass("tree-loading");
$(_831).treegrid("loading");
var _838=opts.loader.call(_831,_836,function(data){
_837.removeClass("tree-loading");
$(_831).treegrid("loaded");
_828(_831,_832,data,_834);
if(_835){
_835();
}
},function(){
_837.removeClass("tree-loading");
$(_831).treegrid("loaded");
opts.onLoadError.apply(_831,arguments);
if(_835){
_835();
}
});
if(_838==false){
_837.removeClass("tree-loading");
$(_831).treegrid("loaded");
}
};
function _839(_83a){
var rows=_83b(_83a);
if(rows.length){
return rows[0];
}else{
return null;
}
};
function _83b(_83c){
return $.data(_83c,"treegrid").data;
};
function _83d(_83e,_83f){
var row=find(_83e,_83f);
if(row._parentId){
return find(_83e,row._parentId);
}else{
return null;
}
};
function _816(_840,_841){
var opts=$.data(_840,"treegrid").options;
var body=$(_840).datagrid("getPanel").find("div.datagrid-view2 div.datagrid-body");
var _842=[];
if(_841){
_843(_841);
}else{
var _844=_83b(_840);
for(var i=0;i<_844.length;i++){
_842.push(_844[i]);
_843(_844[i][opts.idField]);
}
}
function _843(_845){
var _846=find(_840,_845);
if(_846&&_846.children){
for(var i=0,len=_846.children.length;i<len;i++){
var _847=_846.children[i];
_842.push(_847);
_843(_847[opts.idField]);
}
}
};
return _842;
};
function _848(_849,_84a){
if(!_84a){
return 0;
}
var opts=$.data(_849,"treegrid").options;
var view=$(_849).datagrid("getPanel").children("div.datagrid-view");
var node=view.find("div.datagrid-body tr[node-id=\""+_84a+"\"]").children("td[field=\""+opts.treeField+"\"]");
return node.find("span.tree-indent,span.tree-hit").length;
};
function find(_84b,_84c){
var opts=$.data(_84b,"treegrid").options;
var data=$.data(_84b,"treegrid").data;
var cc=[data];
while(cc.length){
var c=cc.shift();
for(var i=0;i<c.length;i++){
var node=c[i];
if(node[opts.idField]==_84c){
return node;
}else{
if(node["children"]){
cc.push(node["children"]);
}
}
}
}
return null;
};
function _84d(_84e,_84f){
var opts=$.data(_84e,"treegrid").options;
var row=find(_84e,_84f);
var tr=opts.finder.getTr(_84e,_84f);
var hit=tr.find("span.tree-hit");
if(hit.length==0){
return;
}
if(hit.hasClass("tree-collapsed")){
return;
}
if(opts.onBeforeCollapse.call(_84e,row)==false){
return;
}
hit.removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed");
hit.next().removeClass("tree-folder-open");
row.state="closed";
tr=tr.next("tr.treegrid-tr-tree");
var cc=tr.children("td").children("div");
if(opts.animate){
cc.slideUp("normal",function(){
$(_84e).treegrid("autoSizeColumn");
_812(_84e,_84f);
opts.onCollapse.call(_84e,row);
});
}else{
cc.hide();
$(_84e).treegrid("autoSizeColumn");
_812(_84e,_84f);
opts.onCollapse.call(_84e,row);
}
};
function _850(_851,_852){
var opts=$.data(_851,"treegrid").options;
var tr=opts.finder.getTr(_851,_852);
var hit=tr.find("span.tree-hit");
var row=find(_851,_852);
if(hit.length==0){
return;
}
if(hit.hasClass("tree-expanded")){
return;
}
if(opts.onBeforeExpand.call(_851,row)==false){
return;
}
hit.removeClass("tree-collapsed tree-collapsed-hover").addClass("tree-expanded");
hit.next().addClass("tree-folder-open");
var _853=tr.next("tr.treegrid-tr-tree");
if(_853.length){
var cc=_853.children("td").children("div");
_854(cc);
}else{
_821(_851,row[opts.idField]);
var _853=tr.next("tr.treegrid-tr-tree");
var cc=_853.children("td").children("div");
cc.hide();
var _855=$.extend({},opts.queryParams||{});
_855.id=row[opts.idField];
_811(_851,row[opts.idField],_855,true,function(){
if(cc.is(":empty")){
_853.remove();
}else{
_854(cc);
}
});
}
function _854(cc){
row.state="open";
if(opts.animate){
cc.slideDown("normal",function(){
$(_851).treegrid("autoSizeColumn");
_812(_851,_852);
opts.onExpand.call(_851,row);
});
}else{
cc.show();
$(_851).treegrid("autoSizeColumn");
_812(_851,_852);
opts.onExpand.call(_851,row);
}
};
};
function _820(_856,_857){
var opts=$.data(_856,"treegrid").options;
var tr=opts.finder.getTr(_856,_857);
var hit=tr.find("span.tree-hit");
if(hit.hasClass("tree-expanded")){
_84d(_856,_857);
}else{
_850(_856,_857);
}
};
function _858(_859,_85a){
var opts=$.data(_859,"treegrid").options;
var _85b=_816(_859,_85a);
if(_85a){
_85b.unshift(find(_859,_85a));
}
for(var i=0;i<_85b.length;i++){
_84d(_859,_85b[i][opts.idField]);
}
};
function _85c(_85d,_85e){
var opts=$.data(_85d,"treegrid").options;
var _85f=_816(_85d,_85e);
if(_85e){
_85f.unshift(find(_85d,_85e));
}
for(var i=0;i<_85f.length;i++){
_850(_85d,_85f[i][opts.idField]);
}
};
function _860(_861,_862){
var opts=$.data(_861,"treegrid").options;
var ids=[];
var p=_83d(_861,_862);
while(p){
var id=p[opts.idField];
ids.unshift(id);
p=_83d(_861,id);
}
for(var i=0;i<ids.length;i++){
_850(_861,ids[i]);
}
};
function _863(_864,_865){
var opts=$.data(_864,"treegrid").options;
if(_865.parent){
var tr=opts.finder.getTr(_864,_865.parent);
if(tr.next("tr.treegrid-tr-tree").length==0){
_821(_864,_865.parent);
}
var cell=tr.children("td[field=\""+opts.treeField+"\"]").children("div.datagrid-cell");
var _866=cell.children("span.tree-icon");
if(_866.hasClass("tree-file")){
_866.removeClass("tree-file").addClass("tree-folder tree-folder-open");
var hit=$("<span class=\"tree-hit tree-expanded\"></span>").insertBefore(_866);
if(hit.prev().length){
hit.prev().remove();
}
}
}
_828(_864,_865.parent,_865.data,true);
};
function _867(_868,_869){
var ref=_869.before||_869.after;
var opts=$.data(_868,"treegrid").options;
var _86a=_83d(_868,ref);
_863(_868,{parent:(_86a?_86a[opts.idField]:null),data:[_869.data]});
var _86b=_86a?_86a.children:$(_868).treegrid("getRoots");
for(var i=0;i<_86b.length;i++){
if(_86b[i][opts.idField]==ref){
var _86c=_86b[_86b.length-1];
_86b.splice(_869.before?i:(i+1),0,_86c);
_86b.splice(_86b.length-1,1);
break;
}
}
_86d(true);
_86d(false);
_81a(_868);
$(_868).treegrid("showLines");
function _86d(_86e){
var _86f=_86e?1:2;
var tr=opts.finder.getTr(_868,_869.data[opts.idField],"body",_86f);
var _870=tr.closest("table.datagrid-btable");
tr=tr.parent().children();
var dest=opts.finder.getTr(_868,ref,"body",_86f);
if(_869.before){
tr.insertBefore(dest);
}else{
var sub=dest.next("tr.treegrid-tr-tree");
tr.insertAfter(sub.length?sub:dest);
}
_870.remove();
};
};
function _871(_872,_873){
var _874=$.data(_872,"treegrid");
$(_872).datagrid("deleteRow",_873);
_81a(_872);
_874.total-=1;
$(_872).datagrid("getPager").pagination("refresh",{total:_874.total});
$(_872).treegrid("showLines");
};
function _875(_876){
var t=$(_876);
var opts=t.treegrid("options");
if(opts.lines){
t.treegrid("getPanel").addClass("tree-lines");
}else{
t.treegrid("getPanel").removeClass("tree-lines");
return;
}
t.treegrid("getPanel").find("span.tree-indent").removeClass("tree-line tree-join tree-joinbottom");
t.treegrid("getPanel").find("div.datagrid-cell").removeClass("tree-node-last tree-root-first tree-root-one");
var _877=t.treegrid("getRoots");
if(_877.length>1){
_878(_877[0]).addClass("tree-root-first");
}else{
if(_877.length==1){
_878(_877[0]).addClass("tree-root-one");
}
}
_879(_877);
_87a(_877);
function _879(_87b){
$.map(_87b,function(node){
if(node.children&&node.children.length){
_879(node.children);
}else{
var cell=_878(node);
cell.find(".tree-icon").prev().addClass("tree-join");
}
});
if(_87b.length){
var cell=_878(_87b[_87b.length-1]);
cell.addClass("tree-node-last");
cell.find(".tree-join").removeClass("tree-join").addClass("tree-joinbottom");
}
};
function _87a(_87c){
$.map(_87c,function(node){
if(node.children&&node.children.length){
_87a(node.children);
}
});
for(var i=0;i<_87c.length-1;i++){
var node=_87c[i];
var _87d=t.treegrid("getLevel",node[opts.idField]);
var tr=opts.finder.getTr(_876,node[opts.idField]);
var cc=tr.next().find("tr.datagrid-row td[field=\""+opts.treeField+"\"] div.datagrid-cell");
cc.find("span:eq("+(_87d-1)+")").addClass("tree-line");
}
};
function _878(node){
var tr=opts.finder.getTr(_876,node[opts.idField]);
var cell=tr.find("td[field=\""+opts.treeField+"\"] div.datagrid-cell");
return cell;
};
};
$.fn.treegrid=function(_87e,_87f){
if(typeof _87e=="string"){
var _880=$.fn.treegrid.methods[_87e];
if(_880){
return _880(this,_87f);
}else{
return this.datagrid(_87e,_87f);
}
}
_87e=_87e||{};
return this.each(function(){
var _881=$.data(this,"treegrid");
if(_881){
$.extend(_881.options,_87e);
}else{
_881=$.data(this,"treegrid",{options:$.extend({},$.fn.treegrid.defaults,$.fn.treegrid.parseOptions(this),_87e),data:[]});
}
_7f3(this);
if(_881.options.data){
$(this).treegrid("loadData",_881.options.data);
}
_811(this);
});
};
$.fn.treegrid.methods={options:function(jq){
return $.data(jq[0],"treegrid").options;
},resize:function(jq,_882){
return jq.each(function(){
$(this).datagrid("resize",_882);
});
},fixRowHeight:function(jq,_883){
return jq.each(function(){
_812(this,_883);
});
},loadData:function(jq,data){
return jq.each(function(){
_828(this,data.parent,data);
});
},load:function(jq,_884){
return jq.each(function(){
$(this).treegrid("options").pageNumber=1;
$(this).treegrid("getPager").pagination({pageNumber:1});
$(this).treegrid("reload",_884);
});
},reload:function(jq,id){
return jq.each(function(){
var opts=$(this).treegrid("options");
var _885={};
if(typeof id=="object"){
_885=id;
}else{
_885=$.extend({},opts.queryParams);
_885.id=id;
}
if(_885.id){
var node=$(this).treegrid("find",_885.id);
if(node.children){
node.children.splice(0,node.children.length);
}
opts.queryParams=_885;
var tr=opts.finder.getTr(this,_885.id);
tr.next("tr.treegrid-tr-tree").remove();
tr.find("span.tree-hit").removeClass("tree-expanded tree-expanded-hover").addClass("tree-collapsed");
_850(this,_885.id);
}else{
_811(this,null,_885);
}
});
},reloadFooter:function(jq,_886){
return jq.each(function(){
var opts=$.data(this,"treegrid").options;
var dc=$.data(this,"datagrid").dc;
if(_886){
$.data(this,"treegrid").footer=_886;
}
if(opts.showFooter){
opts.view.renderFooter.call(opts.view,this,dc.footer1,true);
opts.view.renderFooter.call(opts.view,this,dc.footer2,false);
if(opts.view.onAfterRender){
opts.view.onAfterRender.call(opts.view,this);
}
$(this).treegrid("fixRowHeight");
}
});
},getData:function(jq){
return $.data(jq[0],"treegrid").data;
},getFooterRows:function(jq){
return $.data(jq[0],"treegrid").footer;
},getRoot:function(jq){
return _839(jq[0]);
},getRoots:function(jq){
return _83b(jq[0]);
},getParent:function(jq,id){
return _83d(jq[0],id);
},getChildren:function(jq,id){
return _816(jq[0],id);
},getLevel:function(jq,id){
return _848(jq[0],id);
},find:function(jq,id){
return find(jq[0],id);
},isLeaf:function(jq,id){
var opts=$.data(jq[0],"treegrid").options;
var tr=opts.finder.getTr(jq[0],id);
var hit=tr.find("span.tree-hit");
return hit.length==0;
},select:function(jq,id){
return jq.each(function(){
$(this).datagrid("selectRow",id);
});
},unselect:function(jq,id){
return jq.each(function(){
$(this).datagrid("unselectRow",id);
});
},collapse:function(jq,id){
return jq.each(function(){
_84d(this,id);
});
},expand:function(jq,id){
return jq.each(function(){
_850(this,id);
});
},toggle:function(jq,id){
return jq.each(function(){
_820(this,id);
});
},collapseAll:function(jq,id){
return jq.each(function(){
_858(this,id);
});
},expandAll:function(jq,id){
return jq.each(function(){
_85c(this,id);
});
},expandTo:function(jq,id){
return jq.each(function(){
_860(this,id);
});
},append:function(jq,_887){
return jq.each(function(){
_863(this,_887);
});
},insert:function(jq,_888){
return jq.each(function(){
_867(this,_888);
});
},remove:function(jq,id){
return jq.each(function(){
_871(this,id);
});
},pop:function(jq,id){
var row=jq.treegrid("find",id);
jq.treegrid("remove",id);
return row;
},refresh:function(jq,id){
return jq.each(function(){
var opts=$.data(this,"treegrid").options;
opts.view.refreshRow.call(opts.view,this,id);
});
},update:function(jq,_889){
return jq.each(function(){
var opts=$.data(this,"treegrid").options;
opts.view.updateRow.call(opts.view,this,_889.id,_889.row);
});
},beginEdit:function(jq,id){
return jq.each(function(){
$(this).datagrid("beginEdit",id);
$(this).treegrid("fixRowHeight",id);
});
},endEdit:function(jq,id){
return jq.each(function(){
$(this).datagrid("endEdit",id);
});
},cancelEdit:function(jq,id){
return jq.each(function(){
$(this).datagrid("cancelEdit",id);
});
},showLines:function(jq){
return jq.each(function(){
_875(this);
});
}};
$.fn.treegrid.parseOptions=function(_88a){
return $.extend({},$.fn.datagrid.parseOptions(_88a),$.parser.parseOptions(_88a,["treeField",{animate:"boolean"}]));
};
var _88b=$.extend({},$.fn.datagrid.defaults.view,{render:function(_88c,_88d,_88e){
var opts=$.data(_88c,"treegrid").options;
var _88f=$(_88c).datagrid("getColumnFields",_88e);
var _890=$.data(_88c,"datagrid").rowIdPrefix;
if(_88e){
if(!(opts.rownumbers||(opts.frozenColumns&&opts.frozenColumns.length))){
return;
}
}
var view=this;
if(this.treeNodes&&this.treeNodes.length){
var _891=_892(_88e,this.treeLevel,this.treeNodes);
$(_88d).append(_891.join(""));
}
function _892(_893,_894,_895){
var _896=$(_88c).treegrid("getParent",_895[0][opts.idField]);
var _897=(_896?_896.children.length:$(_88c).treegrid("getRoots").length)-_895.length;
var _898=["<table class=\"datagrid-btable\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tbody>"];
for(var i=0;i<_895.length;i++){
var row=_895[i];
if(row.state!="open"&&row.state!="closed"){
row.state="open";
}
var css=opts.rowStyler?opts.rowStyler.call(_88c,row):"";
var _899="";
var _89a="";
if(typeof css=="string"){
_89a=css;
}else{
if(css){
_899=css["class"]||"";
_89a=css["style"]||"";
}
}
var cls="class=\"datagrid-row "+(_897++%2&&opts.striped?"datagrid-row-alt ":" ")+_899+"\"";
var _89b=_89a?"style=\""+_89a+"\"":"";
var _89c=_890+"-"+(_893?1:2)+"-"+row[opts.idField];
_898.push("<tr id=\""+_89c+"\" node-id=\""+row[opts.idField]+"\" "+cls+" "+_89b+">");
_898=_898.concat(view.renderRow.call(view,_88c,_88f,_893,_894,row));
_898.push("</tr>");
if(row.children&&row.children.length){
var tt=_892(_893,_894+1,row.children);
var v=row.state=="closed"?"none":"block";
_898.push("<tr class=\"treegrid-tr-tree\"><td style=\"border:0px\" colspan="+(_88f.length+(opts.rownumbers?1:0))+"><div style=\"display:"+v+"\">");
_898=_898.concat(tt);
_898.push("</div></td></tr>");
}
}
_898.push("</tbody></table>");
return _898;
};
},renderFooter:function(_89d,_89e,_89f){
var opts=$.data(_89d,"treegrid").options;
var rows=$.data(_89d,"treegrid").footer||[];
var _8a0=$(_89d).datagrid("getColumnFields",_89f);
var _8a1=["<table class=\"datagrid-ftable\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\"><tbody>"];
for(var i=0;i<rows.length;i++){
var row=rows[i];
row[opts.idField]=row[opts.idField]||("foot-row-id"+i);
_8a1.push("<tr class=\"datagrid-row\" node-id=\""+row[opts.idField]+"\">");
_8a1.push(this.renderRow.call(this,_89d,_8a0,_89f,0,row));
_8a1.push("</tr>");
}
_8a1.push("</tbody></table>");
$(_89e).html(_8a1.join(""));
},renderRow:function(_8a2,_8a3,_8a4,_8a5,row){
var opts=$.data(_8a2,"treegrid").options;
var cc=[];
if(_8a4&&opts.rownumbers){
cc.push("<td class=\"datagrid-td-rownumber\"><div class=\"datagrid-cell-rownumber\">0</div></td>");
}
for(var i=0;i<_8a3.length;i++){
var _8a6=_8a3[i];
var col=$(_8a2).datagrid("getColumnOption",_8a6);
if(col){
var css=col.styler?(col.styler(row[_8a6],row)||""):"";
var _8a7="";
var _8a8="";
if(typeof css=="string"){
_8a8=css;
}else{
if(cc){
_8a7=css["class"]||"";
_8a8=css["style"]||"";
}
}
var cls=_8a7?"class=\""+_8a7+"\"":"";
var _8a9=col.hidden?"style=\"display:none;"+_8a8+"\"":(_8a8?"style=\""+_8a8+"\"":"");
cc.push("<td field=\""+_8a6+"\" "+cls+" "+_8a9+">");
var _8a9="";
if(!col.checkbox){
if(col.align){
_8a9+="text-align:"+col.align+";";
}
if(!opts.nowrap){
_8a9+="white-space:normal;height:auto;";
}else{
if(opts.autoRowHeight){
_8a9+="height:auto;";
}
}
}
cc.push("<div style=\""+_8a9+"\" ");
if(col.checkbox){
cc.push("class=\"datagrid-cell-check ");
}else{
cc.push("class=\"datagrid-cell "+col.cellClass);
}
cc.push("\">");
if(col.checkbox){
if(row.checked){
cc.push("<input type=\"checkbox\" checked=\"checked\"");
}else{
cc.push("<input type=\"checkbox\"");
}
cc.push(" name=\""+_8a6+"\" value=\""+(row[_8a6]!=undefined?row[_8a6]:"")+"\">");
}else{
var val=null;
if(col.formatter){
val=col.formatter(row[_8a6],row);
}else{
val=row[_8a6];
}
if(_8a6==opts.treeField){
for(var j=0;j<_8a5;j++){
cc.push("<span class=\"tree-indent\"></span>");
}
if(row.state=="closed"){
cc.push("<span class=\"tree-hit tree-collapsed\"></span>");
cc.push("<span class=\"tree-icon tree-folder "+(row.iconCls?row.iconCls:"")+"\"></span>");
}else{
if(row.children&&row.children.length){
cc.push("<span class=\"tree-hit tree-expanded\"></span>");
cc.push("<span class=\"tree-icon tree-folder tree-folder-open "+(row.iconCls?row.iconCls:"")+"\"></span>");
}else{
cc.push("<span class=\"tree-indent\"></span>");
cc.push("<span class=\"tree-icon tree-file "+(row.iconCls?row.iconCls:"")+"\"></span>");
}
}
cc.push("<span class=\"tree-title\">"+val+"</span>");
}else{
cc.push(val);
}
}
cc.push("</div>");
cc.push("</td>");
}
}
return cc.join("");
},refreshRow:function(_8aa,id){
this.updateRow.call(this,_8aa,id,{});
},updateRow:function(_8ab,id,row){
var opts=$.data(_8ab,"treegrid").options;
var _8ac=$(_8ab).treegrid("find",id);
$.extend(_8ac,row);
var _8ad=$(_8ab).treegrid("getLevel",id)-1;
var _8ae=opts.rowStyler?opts.rowStyler.call(_8ab,_8ac):"";
var _8af=$.data(_8ab,"datagrid").rowIdPrefix;
var _8b0=_8ac[opts.idField];
function _8b1(_8b2){
var _8b3=$(_8ab).treegrid("getColumnFields",_8b2);
var tr=opts.finder.getTr(_8ab,id,"body",(_8b2?1:2));
var _8b4=tr.find("div.datagrid-cell-rownumber").html();
var _8b5=tr.find("div.datagrid-cell-check input[type=checkbox]").is(":checked");
tr.html(this.renderRow(_8ab,_8b3,_8b2,_8ad,_8ac));
tr.attr("style",_8ae||"");
tr.find("div.datagrid-cell-rownumber").html(_8b4);
if(_8b5){
tr.find("div.datagrid-cell-check input[type=checkbox]")._propAttr("checked",true);
}
if(_8b0!=id){
tr.attr("id",_8af+"-"+(_8b2?1:2)+"-"+_8b0);
tr.attr("node-id",_8b0);
}
};
_8b1.call(this,true);
_8b1.call(this,false);
$(_8ab).treegrid("fixRowHeight",id);
},deleteRow:function(_8b6,id){
var opts=$.data(_8b6,"treegrid").options;
var tr=opts.finder.getTr(_8b6,id);
tr.next("tr.treegrid-tr-tree").remove();
tr.remove();
var _8b7=del(id);
if(_8b7){
if(_8b7.children.length==0){
tr=opts.finder.getTr(_8b6,_8b7[opts.idField]);
tr.next("tr.treegrid-tr-tree").remove();
var cell=tr.children("td[field=\""+opts.treeField+"\"]").children("div.datagrid-cell");
cell.find(".tree-icon").removeClass("tree-folder").addClass("tree-file");
cell.find(".tree-hit").remove();
$("<span class=\"tree-indent\"></span>").prependTo(cell);
}
}
function del(id){
var cc;
var _8b8=$(_8b6).treegrid("getParent",id);
if(_8b8){
cc=_8b8.children;
}else{
cc=$(_8b6).treegrid("getData");
}
for(var i=0;i<cc.length;i++){
if(cc[i][opts.idField]==id){
cc.splice(i,1);
break;
}
}
return _8b8;
};
},onBeforeRender:function(_8b9,_8ba,data){
if($.isArray(_8ba)){
data={total:_8ba.length,rows:_8ba};
_8ba=null;
}
if(!data){
return false;
}
var _8bb=$.data(_8b9,"treegrid");
var opts=_8bb.options;
if(data.length==undefined){
if(data.footer){
_8bb.footer=data.footer;
}
if(data.total){
_8bb.total=data.total;
}
data=this.transfer(_8b9,_8ba,data.rows);
}else{
function _8bc(_8bd,_8be){
for(var i=0;i<_8bd.length;i++){
var row=_8bd[i];
row._parentId=_8be;
if(row.children&&row.children.length){
_8bc(row.children,row[opts.idField]);
}
}
};
_8bc(data,_8ba);
}
var node=find(_8b9,_8ba);
if(node){
if(node.children){
node.children=node.children.concat(data);
}else{
node.children=data;
}
}else{
_8bb.data=_8bb.data.concat(data);
}
this.sort(_8b9,data);
this.treeNodes=data;
this.treeLevel=$(_8b9).treegrid("getLevel",_8ba);
},sort:function(_8bf,data){
var opts=$.data(_8bf,"treegrid").options;
if(!opts.remoteSort&&opts.sortName){
var _8c0=opts.sortName.split(",");
var _8c1=opts.sortOrder.split(",");
_8c2(data);
}
function _8c2(rows){
rows.sort(function(r1,r2){
var r=0;
for(var i=0;i<_8c0.length;i++){
var sn=_8c0[i];
var so=_8c1[i];
var col=$(_8bf).treegrid("getColumnOption",sn);
var _8c3=col.sorter||function(a,b){
return a==b?0:(a>b?1:-1);
};
r=_8c3(r1[sn],r2[sn])*(so=="asc"?1:-1);
if(r!=0){
return r;
}
}
return r;
});
for(var i=0;i<rows.length;i++){
var _8c4=rows[i].children;
if(_8c4&&_8c4.length){
_8c2(_8c4);
}
}
};
},transfer:function(_8c5,_8c6,data){
var opts=$.data(_8c5,"treegrid").options;
var rows=[];
for(var i=0;i<data.length;i++){
rows.push(data[i]);
}
var _8c7=[];
for(var i=0;i<rows.length;i++){
var row=rows[i];
if(!_8c6){
if(!row._parentId){
_8c7.push(row);
rows.splice(i,1);
i--;
}
}else{
if(row._parentId==_8c6){
_8c7.push(row);
rows.splice(i,1);
i--;
}
}
}
var toDo=[];
for(var i=0;i<_8c7.length;i++){
toDo.push(_8c7[i]);
}
while(toDo.length){
var node=toDo.shift();
for(var i=0;i<rows.length;i++){
var row=rows[i];
if(row._parentId==node[opts.idField]){
if(node.children){
node.children.push(row);
}else{
node.children=[row];
}
toDo.push(row);
rows.splice(i,1);
i--;
}
}
}
return _8c7;
}});
$.fn.treegrid.defaults=$.extend({},$.fn.datagrid.defaults,{treeField:null,lines:false,animate:false,singleSelect:true,view:_88b,rowEvents:$.extend({},$.fn.datagrid.defaults.rowEvents,{mouseover:_81c(true),mouseout:_81c(false),click:_81e}),loader:function(_8c8,_8c9,_8ca){
var opts=$(this).treegrid("options");
if(!opts.url){
return false;
}
$.ajax({type:opts.method,url:opts.url,data:_8c8,dataType:"json",success:function(data){
_8c9(data);
},error:function(){
_8ca.apply(this,arguments);
}});
},loadFilter:function(data,_8cb){
return data;
},finder:{getTr:function(_8cc,id,type,_8cd){
type=type||"body";
_8cd=_8cd||0;
var dc=$.data(_8cc,"datagrid").dc;
if(_8cd==0){
var opts=$.data(_8cc,"treegrid").options;
var tr1=opts.finder.getTr(_8cc,id,type,1);
var tr2=opts.finder.getTr(_8cc,id,type,2);
return tr1.add(tr2);
}else{
if(type=="body"){
var tr=$("#"+$.data(_8cc,"datagrid").rowIdPrefix+"-"+_8cd+"-"+id);
if(!tr.length){
tr=(_8cd==1?dc.body1:dc.body2).find("tr[node-id=\""+id+"\"]");
}
return tr;
}else{
if(type=="footer"){
return (_8cd==1?dc.footer1:dc.footer2).find("tr[node-id=\""+id+"\"]");
}else{
if(type=="selected"){
return (_8cd==1?dc.body1:dc.body2).find("tr.datagrid-row-selected");
}else{
if(type=="highlight"){
return (_8cd==1?dc.body1:dc.body2).find("tr.datagrid-row-over");
}else{
if(type=="checked"){
return (_8cd==1?dc.body1:dc.body2).find("tr.datagrid-row-checked");
}else{
if(type=="last"){
return (_8cd==1?dc.body1:dc.body2).find("tr:last[node-id]");
}else{
if(type=="allbody"){
return (_8cd==1?dc.body1:dc.body2).find("tr[node-id]");
}else{
if(type=="allfooter"){
return (_8cd==1?dc.footer1:dc.footer2).find("tr[node-id]");
}
}
}
}
}
}
}
}
}
},getRow:function(_8ce,p){
var id=(typeof p=="object")?p.attr("node-id"):p;
return $(_8ce).treegrid("find",id);
},getRows:function(_8cf){
return $(_8cf).treegrid("getChildren");
}},onBeforeLoad:function(row,_8d0){
},onLoadSuccess:function(row,data){
},onLoadError:function(){
},onBeforeCollapse:function(row){
},onCollapse:function(row){
},onBeforeExpand:function(row){
},onExpand:function(row){
},onClickRow:function(row){
},onDblClickRow:function(row){
},onClickCell:function(_8d1,row){
},onDblClickCell:function(_8d2,row){
},onContextMenu:function(e,row){
},onBeforeEdit:function(row){
},onAfterEdit:function(row,_8d3){
},onCancelEdit:function(row){
}});
})(jQuery);
(function($){
$(function(){
$(document).unbind(".combo").bind("mousedown.combo mousewheel.combo",function(e){
var p=$(e.target).closest("span.combo,div.combo-p");
if(p.length){
_8d4(p);
return;
}
$("body>div.combo-p>div.combo-panel:visible").panel("close");
});
});
function _8d5(_8d6){
var _8d7=$.data(_8d6,"combo");
var opts=_8d7.options;
if(!_8d7.panel){
_8d7.panel=$("<div class=\"combo-panel\"></div>").appendTo("body");
_8d7.panel.panel({minWidth:opts.panelMinWidth,maxWidth:opts.panelMaxWidth,minHeight:opts.panelMinHeight,maxHeight:opts.panelMaxHeight,doSize:false,closed:true,cls:"combo-p",style:{position:"absolute",zIndex:10},onOpen:function(){
var _8d8=$(this).panel("options").comboTarget;
var _8d9=$.data(_8d8,"combo");
if(_8d9){
_8d9.options.onShowPanel.call(_8d8);
}
},onBeforeClose:function(){
_8d4(this);
},onClose:function(){
var _8da=$(this).panel("options").comboTarget;
var _8db=$.data(_8da,"combo");
if(_8db){
_8db.options.onHidePanel.call(_8da);
}
}});
}
var _8dc=$.extend(true,[],opts.icons);
if(opts.hasDownArrow){
_8dc.push({iconCls:"combo-arrow",handler:function(e){
_8e0(e.data.target);
}});
}
$(_8d6).addClass("combo-f").textbox($.extend({},opts,{icons:_8dc,onChange:function(){
}}));
$(_8d6).attr("comboName",$(_8d6).attr("textboxName"));
_8d7.combo=$(_8d6).next();
_8d7.combo.addClass("combo");
};
function _8dd(_8de){
var _8df=$.data(_8de,"combo");
var opts=_8df.options;
var p=_8df.panel;
if(p.is(":visible")){
p.panel("close");
}
if(!opts.cloned){
p.panel("destroy");
}
$(_8de).textbox("destroy");
};
function _8e0(_8e1){
var _8e2=$.data(_8e1,"combo").panel;
if(_8e2.is(":visible")){
_8e3(_8e1);
}else{
var p=$(_8e1).closest("div.combo-panel");
$("div.combo-panel:visible").not(_8e2).not(p).panel("close");
$(_8e1).combo("showPanel");
}
$(_8e1).combo("textbox").focus();
};
function _8d4(_8e4){
$(_8e4).find(".combo-f").each(function(){
var p=$(this).combo("panel");
if(p.is(":visible")){
p.panel("close");
}
});
};
function _8e5(e){
var _8e6=e.data.target;
var _8e7=$.data(_8e6,"combo");
var opts=_8e7.options;
var _8e8=_8e7.panel;
if(!opts.editable){
_8e0(_8e6);
}else{
var p=$(_8e6).closest("div.combo-panel");
$("div.combo-panel:visible").not(_8e8).not(p).panel("close");
}
};
function _8e9(e){
var _8ea=e.data.target;
var t=$(_8ea);
var _8eb=t.data("combo");
var opts=t.combo("options");
switch(e.keyCode){
case 38:
opts.keyHandler.up.call(_8ea,e);
break;
case 40:
opts.keyHandler.down.call(_8ea,e);
break;
case 37:
opts.keyHandler.left.call(_8ea,e);
break;
case 39:
opts.keyHandler.right.call(_8ea,e);
break;
case 13:
e.preventDefault();
opts.keyHandler.enter.call(_8ea,e);
return false;
case 9:
case 27:
_8e3(_8ea);
break;
default:
if(opts.editable){
if(_8eb.timer){
clearTimeout(_8eb.timer);
}
_8eb.timer=setTimeout(function(){
var q=t.combo("getText");
if(_8eb.previousText!=q){
_8eb.previousText=q;
t.combo("showPanel");
opts.keyHandler.query.call(_8ea,q,e);
t.combo("validate");
}
},opts.delay);
}
}
};
function _8ec(_8ed){
var _8ee=$.data(_8ed,"combo");
var _8ef=_8ee.combo;
var _8f0=_8ee.panel;
var opts=$(_8ed).combo("options");
var _8f1=_8f0.panel("options");
_8f1.comboTarget=_8ed;
if(_8f1.closed){
_8f0.panel("panel").show().css({zIndex:($.fn.menu?$.fn.menu.defaults.zIndex++:$.fn.window.defaults.zIndex++),left:-999999});
_8f0.panel("resize",{width:(opts.panelWidth?opts.panelWidth:_8ef._outerWidth()),height:opts.panelHeight});
_8f0.panel("panel").hide();
_8f0.panel("open");
}
(function(){
if(_8f0.is(":visible")){
_8f0.panel("move",{left:_8f2(),top:_8f3()});
setTimeout(arguments.callee,200);
}
})();
function _8f2(){
var left=_8ef.offset().left;
if(opts.panelAlign=="right"){
left+=_8ef._outerWidth()-_8f0._outerWidth();
}
if(left+_8f0._outerWidth()>$(window)._outerWidth()+$(document).scrollLeft()){
left=$(window)._outerWidth()+$(document).scrollLeft()-_8f0._outerWidth();
}
if(left<0){
left=0;
}
return left;
};
function _8f3(){
var top=_8ef.offset().top+_8ef._outerHeight();
if(top+_8f0._outerHeight()>$(window)._outerHeight()+$(document).scrollTop()){
top=_8ef.offset().top-_8f0._outerHeight();
}
if(top<$(document).scrollTop()){
top=_8ef.offset().top+_8ef._outerHeight();
}
return top;
};
};
function _8e3(_8f4){
var _8f5=$.data(_8f4,"combo").panel;
_8f5.panel("close");
};
function _8f6(_8f7){
var _8f8=$.data(_8f7,"combo");
var opts=_8f8.options;
var _8f9=_8f8.combo;
$(_8f7).textbox("clear");
if(opts.multiple){
_8f9.find(".textbox-value").remove();
}else{
_8f9.find(".textbox-value").val("");
}
};
function _8fa(_8fb,text){
var _8fc=$.data(_8fb,"combo");
var _8fd=$(_8fb).textbox("getText");
if(_8fd!=text){
$(_8fb).textbox("setText",text);
_8fc.previousText=text;
}
};
function _8fe(_8ff){
var _900=[];
var _901=$.data(_8ff,"combo").combo;
_901.find(".textbox-value").each(function(){
_900.push($(this).val());
});
return _900;
};
function _902(_903,_904){
var _905=$.data(_903,"combo");
var opts=_905.options;
var _906=_905.combo;
if(!$.isArray(_904)){
_904=_904.split(opts.separator);
}
var _907=_8fe(_903);
_906.find(".textbox-value").remove();
var name=$(_903).attr("textboxName")||"";
for(var i=0;i<_904.length;i++){
var _908=$("<input type=\"hidden\" class=\"textbox-value\">").appendTo(_906);
_908.attr("name",name);
if(opts.disabled){
_908.attr("disabled","disabled");
}
_908.val(_904[i]);
}
var _909=(function(){
if(_907.length!=_904.length){
return true;
}
var a1=$.extend(true,[],_907);
var a2=$.extend(true,[],_904);
a1.sort();
a2.sort();
for(var i=0;i<a1.length;i++){
if(a1[i]!=a2[i]){
return true;
}
}
return false;
})();
if(_909){
if(opts.multiple){
opts.onChange.call(_903,_904,_907);
}else{
opts.onChange.call(_903,_904[0],_907[0]);
}
}
};
function _90a(_90b){
var _90c=_8fe(_90b);
return _90c[0];
};
function _90d(_90e,_90f){
_902(_90e,[_90f]);
};
function _910(_911){
var opts=$.data(_911,"combo").options;
var _912=opts.onChange;
opts.onChange=function(){
};
if(opts.multiple){
_902(_911,opts.value?opts.value:[]);
}else{
_90d(_911,opts.value);
}
opts.onChange=_912;
};
$.fn.combo=function(_913,_914){
if(typeof _913=="string"){
var _915=$.fn.combo.methods[_913];
if(_915){
return _915(this,_914);
}else{
return this.textbox(_913,_914);
}
}
_913=_913||{};
return this.each(function(){
var _916=$.data(this,"combo");
if(_916){
$.extend(_916.options,_913);
if(_913.value!=undefined){
_916.options.originalValue=_913.value;
}
}else{
_916=$.data(this,"combo",{options:$.extend({},$.fn.combo.defaults,$.fn.combo.parseOptions(this),_913),previousText:""});
_916.options.originalValue=_916.options.value;
}
_8d5(this);
_910(this);
});
};
$.fn.combo.methods={options:function(jq){
var opts=jq.textbox("options");
return $.extend($.data(jq[0],"combo").options,{width:opts.width,height:opts.height,disabled:opts.disabled,readonly:opts.readonly});
},cloneFrom:function(jq,from){
return jq.each(function(){
$(this).textbox("cloneFrom",from);
$.data(this,"combo",{options:$.extend(true,{cloned:true},$(from).combo("options")),combo:$(this).next(),panel:$(from).combo("panel")});
$(this).addClass("combo-f").attr("comboName",$(this).attr("textboxName"));
});
},panel:function(jq){
return $.data(jq[0],"combo").panel;
},destroy:function(jq){
return jq.each(function(){
_8dd(this);
});
},showPanel:function(jq){
return jq.each(function(){
_8ec(this);
});
},hidePanel:function(jq){
return jq.each(function(){
_8e3(this);
});
},clear:function(jq){
return jq.each(function(){
_8f6(this);
});
},reset:function(jq){
return jq.each(function(){
var opts=$.data(this,"combo").options;
if(opts.multiple){
$(this).combo("setValues",opts.originalValue);
}else{
$(this).combo("setValue",opts.originalValue);
}
});
},setText:function(jq,text){
return jq.each(function(){
_8fa(this,text);
});
},getValues:function(jq){
return _8fe(jq[0]);
},setValues:function(jq,_917){
return jq.each(function(){
_902(this,_917);
});
},getValue:function(jq){
return _90a(jq[0]);
},setValue:function(jq,_918){
return jq.each(function(){
_90d(this,_918);
});
}};
$.fn.combo.parseOptions=function(_919){
var t=$(_919);
return $.extend({},$.fn.textbox.parseOptions(_919),$.parser.parseOptions(_919,["separator","panelAlign",{panelWidth:"number",hasDownArrow:"boolean",delay:"number",selectOnNavigation:"boolean"},{panelMinWidth:"number",panelMaxWidth:"number",panelMinHeight:"number",panelMaxHeight:"number"}]),{panelHeight:(t.attr("panelHeight")=="auto"?"auto":parseInt(t.attr("panelHeight"))||undefined),multiple:(t.attr("multiple")?true:undefined)});
};
$.fn.combo.defaults=$.extend({},$.fn.textbox.defaults,{inputEvents:{click:_8e5,keydown:_8e9,paste:_8e9,drop:_8e9},panelWidth:null,panelHeight:200,panelMinWidth:null,panelMaxWidth:null,panelMinHeight:null,panelMaxHeight:null,panelAlign:"left",multiple:false,selectOnNavigation:true,separator:",",hasDownArrow:true,delay:200,keyHandler:{up:function(e){
},down:function(e){
},left:function(e){
},right:function(e){
},enter:function(e){
},query:function(q,e){
}},onShowPanel:function(){
},onHidePanel:function(){
},onChange:function(_91a,_91b){
}});
})(jQuery);
(function($){
var _91c=0;
function _91d(_91e,_91f){
var _920=$.data(_91e,"combobox");
var opts=_920.options;
var data=_920.data;
for(var i=0;i<data.length;i++){
if(data[i][opts.valueField]==_91f){
return i;
}
}
return -1;
};
function _921(_922,_923){
var opts=$.data(_922,"combobox").options;
var _924=$(_922).combo("panel");
var item=opts.finder.getEl(_922,_923);
if(item.length){
if(item.position().top<=0){
var h=_924.scrollTop()+item.position().top;
_924.scrollTop(h);
}else{
if(item.position().top+item.outerHeight()>_924.height()){
var h=_924.scrollTop()+item.position().top+item.outerHeight()-_924.height();
_924.scrollTop(h);
}
}
}
};
function nav(_925,dir){
var opts=$.data(_925,"combobox").options;
var _926=$(_925).combobox("panel");
var item=_926.children("div.combobox-item-hover");
if(!item.length){
item=_926.children("div.combobox-item-selected");
}
item.removeClass("combobox-item-hover");
var _927="div.combobox-item:visible:not(.combobox-item-disabled):first";
var _928="div.combobox-item:visible:not(.combobox-item-disabled):last";
if(!item.length){
item=_926.children(dir=="next"?_927:_928);
}else{
if(dir=="next"){
item=item.nextAll(_927);
if(!item.length){
item=_926.children(_927);
}
}else{
item=item.prevAll(_927);
if(!item.length){
item=_926.children(_928);
}
}
}
if(item.length){
item.addClass("combobox-item-hover");
var row=opts.finder.getRow(_925,item);
if(row){
_921(_925,row[opts.valueField]);
if(opts.selectOnNavigation){
_929(_925,row[opts.valueField]);
}
}
}
};
function _929(_92a,_92b){
var opts=$.data(_92a,"combobox").options;
var _92c=$(_92a).combo("getValues");
if($.inArray(_92b+"",_92c)==-1){
if(opts.multiple){
_92c.push(_92b);
}else{
_92c=[_92b];
}
_92d(_92a,_92c);
opts.onSelect.call(_92a,opts.finder.getRow(_92a,_92b));
}
};
function _92e(_92f,_930){
var opts=$.data(_92f,"combobox").options;
var _931=$(_92f).combo("getValues");
var _932=$.inArray(_930+"",_931);
if(_932>=0){
_931.splice(_932,1);
_92d(_92f,_931);
opts.onUnselect.call(_92f,opts.finder.getRow(_92f,_930));
}
};
function _92d(_933,_934,_935){
var opts=$.data(_933,"combobox").options;
var _936=$(_933).combo("panel");
if(!$.isArray(_934)){
_934=_934.split(opts.separator);
}
_936.find("div.combobox-item-selected").removeClass("combobox-item-selected");
var vv=[],ss=[];
for(var i=0;i<_934.length;i++){
var v=_934[i];
var s=v;
opts.finder.getEl(_933,v).addClass("combobox-item-selected");
var row=opts.finder.getRow(_933,v);
if(row){
s=row[opts.textField];
}
vv.push(v);
ss.push(s);
}
$(_933).combo("setValues",vv);
if(!_935){
$(_933).combo("setText",ss.join(opts.separator));
}
};
function _937(_938,data,_939){
var _93a=$.data(_938,"combobox");
var opts=_93a.options;
_93a.data=opts.loadFilter.call(_938,data);
_93a.groups=[];
data=_93a.data;
var _93b=$(_938).combobox("getValues");
var dd=[];
var _93c=undefined;
for(var i=0;i<data.length;i++){
var row=data[i];
var v=row[opts.valueField]+"";
var s=row[opts.textField];
var g=row[opts.groupField];
if(g){
if(_93c!=g){
_93c=g;
_93a.groups.push(g);
dd.push("<div id=\""+(_93a.groupIdPrefix+"_"+(_93a.groups.length-1))+"\" class=\"combobox-group\">");
dd.push(opts.groupFormatter?opts.groupFormatter.call(_938,g):g);
dd.push("</div>");
}
}else{
_93c=undefined;
}
var cls="combobox-item"+(row.disabled?" combobox-item-disabled":"")+(g?" combobox-gitem":"");
dd.push("<div id=\""+(_93a.itemIdPrefix+"_"+i)+"\" class=\""+cls+"\">");
dd.push(opts.formatter?opts.formatter.call(_938,row):s);
dd.push("</div>");
if(row["selected"]&&$.inArray(v,_93b)==-1){
_93b.push(v);
}
}
$(_938).combo("panel").html(dd.join(""));
if(opts.multiple){
_92d(_938,_93b,_939);
}else{
_92d(_938,_93b.length?[_93b[_93b.length-1]]:[],_939);
}
opts.onLoadSuccess.call(_938,data);
};
function _93d(_93e,url,_93f,_940){
var opts=$.data(_93e,"combobox").options;
if(url){
opts.url=url;
}
_93f=_93f||{};
if(opts.onBeforeLoad.call(_93e,_93f)==false){
return;
}
opts.loader.call(_93e,_93f,function(data){
_937(_93e,data,_940);
},function(){
opts.onLoadError.apply(this,arguments);
});
};
function _941(_942,q){
var _943=$.data(_942,"combobox");
var opts=_943.options;
if(opts.multiple&&!q){
_92d(_942,[],true);
}else{
_92d(_942,[q],true);
}
if(opts.mode=="remote"){
_93d(_942,null,{q:q},true);
}else{
var _944=$(_942).combo("panel");
_944.find("div.combobox-item-selected,div.combobox-item-hover").removeClass("combobox-item-selected combobox-item-hover");
_944.find("div.combobox-item,div.combobox-group").hide();
var data=_943.data;
var vv=[];
var qq=opts.multiple?q.split(opts.separator):[q];
$.map(qq,function(q){
q=$.trim(q);
var _945=undefined;
for(var i=0;i<data.length;i++){
var row=data[i];
if(opts.filter.call(_942,q,row)){
var v=row[opts.valueField];
var s=row[opts.textField];
var g=row[opts.groupField];
var item=opts.finder.getEl(_942,v).show();
if(s.toLowerCase()==q.toLowerCase()){
vv.push(v);
item.addClass("combobox-item-selected");
}
if(opts.groupField&&_945!=g){
$("#"+_943.groupIdPrefix+"_"+$.inArray(g,_943.groups)).show();
_945=g;
}
}
}
});
_92d(_942,vv,true);
}
};
function _946(_947){
var t=$(_947);
var opts=t.combobox("options");
var _948=t.combobox("panel");
var item=_948.children("div.combobox-item-hover");
if(item.length){
var row=opts.finder.getRow(_947,item);
var _949=row[opts.valueField];
if(opts.multiple){
if(item.hasClass("combobox-item-selected")){
t.combobox("unselect",_949);
}else{
t.combobox("select",_949);
}
}else{
t.combobox("select",_949);
}
}
var vv=[];
$.map(t.combobox("getValues"),function(v){
if(_91d(_947,v)>=0){
vv.push(v);
}
});
t.combobox("setValues",vv);
if(!opts.multiple){
t.combobox("hidePanel");
}
};
function _94a(_94b){
var _94c=$.data(_94b,"combobox");
var opts=_94c.options;
_91c++;
_94c.itemIdPrefix="_easyui_combobox_i"+_91c;
_94c.groupIdPrefix="_easyui_combobox_g"+_91c;
$(_94b).addClass("combobox-f");
$(_94b).combo($.extend({},opts,{onShowPanel:function(){
$(_94b).combo("panel").find("div.combobox-item,div.combobox-group").show();
_921(_94b,$(_94b).combobox("getValue"));
opts.onShowPanel.call(_94b);
}}));
$(_94b).combo("panel").unbind().bind("mouseover",function(e){
$(this).children("div.combobox-item-hover").removeClass("combobox-item-hover");
var item=$(e.target).closest("div.combobox-item");
if(!item.hasClass("combobox-item-disabled")){
item.addClass("combobox-item-hover");
}
e.stopPropagation();
}).bind("mouseout",function(e){
$(e.target).closest("div.combobox-item").removeClass("combobox-item-hover");
e.stopPropagation();
}).bind("click",function(e){
var item=$(e.target).closest("div.combobox-item");
if(!item.length||item.hasClass("combobox-item-disabled")){
return;
}
var row=opts.finder.getRow(_94b,item);
if(!row){
return;
}
var _94d=row[opts.valueField];
if(opts.multiple){
if(item.hasClass("combobox-item-selected")){
_92e(_94b,_94d);
}else{
_929(_94b,_94d);
}
}else{
_929(_94b,_94d);
$(_94b).combo("hidePanel");
}
e.stopPropagation();
});
};
$.fn.combobox=function(_94e,_94f){
if(typeof _94e=="string"){
var _950=$.fn.combobox.methods[_94e];
if(_950){
return _950(this,_94f);
}else{
return this.combo(_94e,_94f);
}
}
_94e=_94e||{};
return this.each(function(){
var _951=$.data(this,"combobox");
if(_951){
$.extend(_951.options,_94e);
_94a(this);
}else{
_951=$.data(this,"combobox",{options:$.extend({},$.fn.combobox.defaults,$.fn.combobox.parseOptions(this),_94e),data:[]});
_94a(this);
var data=$.fn.combobox.parseData(this);
if(data.length){
_937(this,data);
}
}
if(_951.options.data){
_937(this,_951.options.data);
}
_93d(this);
});
};
$.fn.combobox.methods={options:function(jq){
var _952=jq.combo("options");
return $.extend($.data(jq[0],"combobox").options,{width:_952.width,height:_952.height,originalValue:_952.originalValue,disabled:_952.disabled,readonly:_952.readonly});
},getData:function(jq){
return $.data(jq[0],"combobox").data;
},setValues:function(jq,_953){
return jq.each(function(){
_92d(this,_953);
});
},setValue:function(jq,_954){
return jq.each(function(){
_92d(this,[_954]);
});
},clear:function(jq){
return jq.each(function(){
$(this).combo("clear");
var _955=$(this).combo("panel");
_955.find("div.combobox-item-selected").removeClass("combobox-item-selected");
});
},reset:function(jq){
return jq.each(function(){
var opts=$(this).combobox("options");
if(opts.multiple){
$(this).combobox("setValues",opts.originalValue);
}else{
$(this).combobox("setValue",opts.originalValue);
}
});
},loadData:function(jq,data){
return jq.each(function(){
_937(this,data);
});
},reload:function(jq,url){
return jq.each(function(){
_93d(this,url);
});
},select:function(jq,_956){
return jq.each(function(){
_929(this,_956);
});
},unselect:function(jq,_957){
return jq.each(function(){
_92e(this,_957);
});
}};
$.fn.combobox.parseOptions=function(_958){
var t=$(_958);
return $.extend({},$.fn.combo.parseOptions(_958),$.parser.parseOptions(_958,["valueField","textField","groupField","mode","method","url"]));
};
$.fn.combobox.parseData=function(_959){
var data=[];
var opts=$(_959).combobox("options");
$(_959).children().each(function(){
if(this.tagName.toLowerCase()=="optgroup"){
var _95a=$(this).attr("label");
$(this).children().each(function(){
_95b(this,_95a);
});
}else{
_95b(this);
}
});
return data;
function _95b(el,_95c){
var t=$(el);
var row={};
row[opts.valueField]=t.attr("value")!=undefined?t.attr("value"):t.text();
row[opts.textField]=t.text();
row["selected"]=t.is(":selected");
row["disabled"]=t.is(":disabled");
if(_95c){
opts.groupField=opts.groupField||"group";
row[opts.groupField]=_95c;
}
data.push(row);
};
};
$.fn.combobox.defaults=$.extend({},$.fn.combo.defaults,{valueField:"value",textField:"text",groupField:null,groupFormatter:function(_95d){
return _95d;
},mode:"local",method:"post",url:null,data:null,keyHandler:{up:function(e){
nav(this,"prev");
e.preventDefault();
},down:function(e){
nav(this,"next");
e.preventDefault();
},left:function(e){
},right:function(e){
},enter:function(e){
_946(this);
},query:function(q,e){
_941(this,q);
}},filter:function(q,row){
var opts=$(this).combobox("options");
return row[opts.textField].toLowerCase().indexOf(q.toLowerCase())==0;
},formatter:function(row){
var opts=$(this).combobox("options");
return row[opts.textField];
},loader:function(_95e,_95f,_960){
var opts=$(this).combobox("options");
if(!opts.url){
return false;
}
$.ajax({type:opts.method,url:opts.url,data:_95e,dataType:"json",success:function(data){
_95f(data);
},error:function(){
_960.apply(this,arguments);
}});
},loadFilter:function(data){
return data;
},finder:{getEl:function(_961,_962){
var _963=_91d(_961,_962);
var id=$.data(_961,"combobox").itemIdPrefix+"_"+_963;
return $("#"+id);
},getRow:function(_964,p){
var _965=$.data(_964,"combobox");
var _966=(p instanceof jQuery)?p.attr("id").substr(_965.itemIdPrefix.length+1):_91d(_964,p);
return _965.data[parseInt(_966)];
}},onBeforeLoad:function(_967){
},onLoadSuccess:function(){
},onLoadError:function(){
},onSelect:function(_968){
},onUnselect:function(_969){
}});
})(jQuery);
(function($){
function _96a(_96b){
var _96c=$.data(_96b,"combotree");
var opts=_96c.options;
var tree=_96c.tree;
$(_96b).addClass("combotree-f");
$(_96b).combo(opts);
var _96d=$(_96b).combo("panel");
if(!tree){
tree=$("<ul></ul>").appendTo(_96d);
$.data(_96b,"combotree").tree=tree;
}
tree.tree($.extend({},opts,{checkbox:opts.multiple,onLoadSuccess:function(node,data){
var _96e=$(_96b).combotree("getValues");
if(opts.multiple){
var _96f=tree.tree("getChecked");
for(var i=0;i<_96f.length;i++){
var id=_96f[i].id;
(function(){
for(var i=0;i<_96e.length;i++){
if(id==_96e[i]){
return;
}
}
_96e.push(id);
})();
}
}
$(_96b).combotree("setValues",_96e);
opts.onLoadSuccess.call(this,node,data);
},onClick:function(node){
if(opts.multiple){
$(this).tree(node.checked?"uncheck":"check",node.target);
}else{
$(_96b).combo("hidePanel");
}
_971(_96b);
opts.onClick.call(this,node);
},onCheck:function(node,_970){
_971(_96b);
opts.onCheck.call(this,node,_970);
}}));
};
function _971(_972){
var _973=$.data(_972,"combotree");
var opts=_973.options;
var tree=_973.tree;
var vv=[],ss=[];
if(opts.multiple){
var _974=tree.tree("getChecked");
for(var i=0;i<_974.length;i++){
vv.push(_974[i].id);
ss.push(_974[i].text);
}
}else{
var node=tree.tree("getSelected");
if(node){
vv.push(node.id);
ss.push(node.text);
}
}
$(_972).combo("setValues",vv).combo("setText",ss.join(opts.separator));
};
function _975(_976,_977){
var _978=$.data(_976,"combotree");
var opts=_978.options;
var tree=_978.tree;
var _979=tree.tree("options");
var _97a=_979.onCheck;
var _97b=_979.onSelect;
_979.onCheck=_979.onSelect=function(){
};
tree.find("span.tree-checkbox").addClass("tree-checkbox0").removeClass("tree-checkbox1 tree-checkbox2");
if(!$.isArray(_977)){
_977=_977.split(opts.separator);
}
for(var i=0;i<_977.length;i++){
var node=tree.tree("find",_977[i]);
if(node){
tree.tree("check",node.target);
tree.tree("select",node.target);
}
}
_979.onCheck=_97a;
_979.onSelect=_97b;
_971(_976);
};
$.fn.combotree=function(_97c,_97d){
if(typeof _97c=="string"){
var _97e=$.fn.combotree.methods[_97c];
if(_97e){
return _97e(this,_97d);
}else{
return this.combo(_97c,_97d);
}
}
_97c=_97c||{};
return this.each(function(){
var _97f=$.data(this,"combotree");
if(_97f){
$.extend(_97f.options,_97c);
}else{
$.data(this,"combotree",{options:$.extend({},$.fn.combotree.defaults,$.fn.combotree.parseOptions(this),_97c)});
}
_96a(this);
});
};
$.fn.combotree.methods={options:function(jq){
var _980=jq.combo("options");
return $.extend($.data(jq[0],"combotree").options,{width:_980.width,height:_980.height,originalValue:_980.originalValue,disabled:_980.disabled,readonly:_980.readonly});
},clone:function(jq,_981){
var t=jq.combo("clone",_981);
t.data("combotree",{options:$.extend(true,{},jq.combotree("options")),tree:jq.combotree("tree")});
return t;
},tree:function(jq){
return $.data(jq[0],"combotree").tree;
},loadData:function(jq,data){
return jq.each(function(){
var opts=$.data(this,"combotree").options;
opts.data=data;
var tree=$.data(this,"combotree").tree;
tree.tree("loadData",data);
});
},reload:function(jq,url){
return jq.each(function(){
var opts=$.data(this,"combotree").options;
var tree=$.data(this,"combotree").tree;
if(url){
opts.url=url;
}
tree.tree({url:opts.url});
});
},setValues:function(jq,_982){
return jq.each(function(){
_975(this,_982);
});
},setValue:function(jq,_983){
return jq.each(function(){
_975(this,[_983]);
});
},clear:function(jq){
return jq.each(function(){
var tree=$.data(this,"combotree").tree;
tree.find("div.tree-node-selected").removeClass("tree-node-selected");
var cc=tree.tree("getChecked");
for(var i=0;i<cc.length;i++){
tree.tree("uncheck",cc[i].target);
}
$(this).combo("clear");
});
},reset:function(jq){
return jq.each(function(){
var opts=$(this).combotree("options");
if(opts.multiple){
$(this).combotree("setValues",opts.originalValue);
}else{
$(this).combotree("setValue",opts.originalValue);
}
});
}};
$.fn.combotree.parseOptions=function(_984){
return $.extend({},$.fn.combo.parseOptions(_984),$.fn.tree.parseOptions(_984));
};
$.fn.combotree.defaults=$.extend({},$.fn.combo.defaults,$.fn.tree.defaults,{editable:false});
})(jQuery);
(function($){
function _985(_986){
var _987=$.data(_986,"combogrid");
var opts=_987.options;
var grid=_987.grid;
$(_986).addClass("combogrid-f").combo($.extend({},opts,{onShowPanel:function(){
var p=$(this).combogrid("panel");
var _988=p.outerHeight()-p.height();
var _989=p._size("minHeight");
var _98a=p._size("maxHeight");
$(this).combogrid("grid").datagrid("resize",{width:"100%",height:(isNaN(parseInt(opts.panelHeight))?"auto":"100%"),minHeight:(_989?_989-_988:""),maxHeight:(_98a?_98a-_988:"")});
opts.onShowPanel.call(this);
}}));
var _98b=$(_986).combo("panel");
if(!grid){
grid=$("<table></table>").appendTo(_98b);
_987.grid=grid;
}
grid.datagrid($.extend({},opts,{border:false,singleSelect:(!opts.multiple),onLoadSuccess:function(data){
var _98c=$(_986).combo("getValues");
var _98d=opts.onSelect;
opts.onSelect=function(){
};
_997(_986,_98c,_987.remainText);
opts.onSelect=_98d;
opts.onLoadSuccess.apply(_986,arguments);
},onClickRow:_98e,onSelect:function(_98f,row){
_990();
opts.onSelect.call(this,_98f,row);
},onUnselect:function(_991,row){
_990();
opts.onUnselect.call(this,_991,row);
},onSelectAll:function(rows){
_990();
opts.onSelectAll.call(this,rows);
},onUnselectAll:function(rows){
if(opts.multiple){
_990();
}
opts.onUnselectAll.call(this,rows);
}}));
function _98e(_992,row){
_987.remainText=false;
_990();
if(!opts.multiple){
$(_986).combo("hidePanel");
}
opts.onClickRow.call(this,_992,row);
};
function _990(){
var rows=grid.datagrid("getSelections");
var vv=[],ss=[];
for(var i=0;i<rows.length;i++){
vv.push(rows[i][opts.idField]);
ss.push(rows[i][opts.textField]);
}
if(!opts.multiple){
$(_986).combo("setValues",(vv.length?vv:[""]));
}else{
$(_986).combo("setValues",vv);
}
if(!_987.remainText){
$(_986).combo("setText",ss.join(opts.separator));
}
};
};
function nav(_993,dir){
var _994=$.data(_993,"combogrid");
var opts=_994.options;
var grid=_994.grid;
var _995=grid.datagrid("getRows").length;
if(!_995){
return;
}
var tr=opts.finder.getTr(grid[0],null,"highlight");
if(!tr.length){
tr=opts.finder.getTr(grid[0],null,"selected");
}
var _996;
if(!tr.length){
_996=(dir=="next"?0:_995-1);
}else{
var _996=parseInt(tr.attr("datagrid-row-index"));
_996+=(dir=="next"?1:-1);
if(_996<0){
_996=_995-1;
}
if(_996>=_995){
_996=0;
}
}
grid.datagrid("highlightRow",_996);
if(opts.selectOnNavigation){
_994.remainText=false;
grid.datagrid("selectRow",_996);
}
};
function _997(_998,_999,_99a){
var _99b=$.data(_998,"combogrid");
var opts=_99b.options;
var grid=_99b.grid;
var rows=grid.datagrid("getRows");
var ss=[];
var _99c=$(_998).combo("getValues");
var _99d=$(_998).combo("options");
var _99e=_99d.onChange;
_99d.onChange=function(){
};
grid.datagrid("clearSelections");
if(!$.isArray(_999)){
_999=_999.split(opts.separator);
}
for(var i=0;i<_999.length;i++){
var _99f=grid.datagrid("getRowIndex",_999[i]);
if(_99f>=0){
grid.datagrid("selectRow",_99f);
ss.push(rows[_99f][opts.textField]);
}else{
ss.push(_999[i]);
}
}
$(_998).combo("setValues",_99c);
_99d.onChange=_99e;
$(_998).combo("setValues",_999);
if(!_99a){
var s=ss.join(opts.separator);
if($(_998).combo("getText")!=s){
$(_998).combo("setText",s);
}
}
};
function _9a0(_9a1,q){
var _9a2=$.data(_9a1,"combogrid");
var opts=_9a2.options;
var grid=_9a2.grid;
_9a2.remainText=true;
if(opts.multiple&&!q){
_997(_9a1,[],true);
}else{
_997(_9a1,[q],true);
}
if(opts.mode=="remote"){
grid.datagrid("clearSelections");
grid.datagrid("load",$.extend({},opts.queryParams,{q:q}));
}else{
if(!q){
return;
}
grid.datagrid("clearSelections").datagrid("highlightRow",-1);
var rows=grid.datagrid("getRows");
var qq=opts.multiple?q.split(opts.separator):[q];
$.map(qq,function(q){
q=$.trim(q);
if(q){
$.map(rows,function(row,i){
if(q==row[opts.textField]){
grid.datagrid("selectRow",i);
}else{
if(opts.filter.call(_9a1,q,row)){
grid.datagrid("highlightRow",i);
}
}
});
}
});
}
};
function _9a3(_9a4){
var _9a5=$.data(_9a4,"combogrid");
var opts=_9a5.options;
var grid=_9a5.grid;
var tr=opts.finder.getTr(grid[0],null,"highlight");
_9a5.remainText=false;
if(tr.length){
var _9a6=parseInt(tr.attr("datagrid-row-index"));
if(opts.multiple){
if(tr.hasClass("datagrid-row-selected")){
grid.datagrid("unselectRow",_9a6);
}else{
grid.datagrid("selectRow",_9a6);
}
}else{
grid.datagrid("selectRow",_9a6);
}
}
var vv=[];
$.map(grid.datagrid("getSelections"),function(row){
vv.push(row[opts.idField]);
});
$(_9a4).combogrid("setValues",vv);
if(!opts.multiple){
$(_9a4).combogrid("hidePanel");
}
};
$.fn.combogrid=function(_9a7,_9a8){
if(typeof _9a7=="string"){
var _9a9=$.fn.combogrid.methods[_9a7];
if(_9a9){
return _9a9(this,_9a8);
}else{
return this.combo(_9a7,_9a8);
}
}
_9a7=_9a7||{};
return this.each(function(){
var _9aa=$.data(this,"combogrid");
if(_9aa){
$.extend(_9aa.options,_9a7);
}else{
_9aa=$.data(this,"combogrid",{options:$.extend({},$.fn.combogrid.defaults,$.fn.combogrid.parseOptions(this),_9a7)});
}
_985(this);
});
};
$.fn.combogrid.methods={options:function(jq){
var _9ab=jq.combo("options");
return $.extend($.data(jq[0],"combogrid").options,{width:_9ab.width,height:_9ab.height,originalValue:_9ab.originalValue,disabled:_9ab.disabled,readonly:_9ab.readonly});
},grid:function(jq){
return $.data(jq[0],"combogrid").grid;
},setValues:function(jq,_9ac){
return jq.each(function(){
_997(this,_9ac);
});
},setValue:function(jq,_9ad){
return jq.each(function(){
_997(this,[_9ad]);
});
},clear:function(jq){
return jq.each(function(){
$(this).combogrid("grid").datagrid("clearSelections");
$(this).combo("clear");
});
},reset:function(jq){
return jq.each(function(){
var opts=$(this).combogrid("options");
if(opts.multiple){
$(this).combogrid("setValues",opts.originalValue);
}else{
$(this).combogrid("setValue",opts.originalValue);
}
});
}};
$.fn.combogrid.parseOptions=function(_9ae){
var t=$(_9ae);
return $.extend({},$.fn.combo.parseOptions(_9ae),$.fn.datagrid.parseOptions(_9ae),$.parser.parseOptions(_9ae,["idField","textField","mode"]));
};
$.fn.combogrid.defaults=$.extend({},$.fn.combo.defaults,$.fn.datagrid.defaults,{height:22,loadMsg:null,idField:null,textField:null,mode:"local",keyHandler:{up:function(e){
nav(this,"prev");
e.preventDefault();
},down:function(e){
nav(this,"next");
e.preventDefault();
},left:function(e){
},right:function(e){
},enter:function(e){
_9a3(this);
},query:function(q,e){
_9a0(this,q);
}},filter:function(q,row){
var opts=$(this).combogrid("options");
return row[opts.textField].toLowerCase().indexOf(q.toLowerCase())==0;
}});
})(jQuery);
(function($){
function _9af(_9b0){
var _9b1=$.data(_9b0,"datebox");
var opts=_9b1.options;
$(_9b0).addClass("datebox-f").combo($.extend({},opts,{onShowPanel:function(){
_9b2(this);
_9b3(this);
_9b4(this);
_9c2(this,$(this).datebox("getText"),true);
opts.onShowPanel.call(this);
}}));
if(!_9b1.calendar){
var _9b5=$(_9b0).combo("panel").css("overflow","hidden");
_9b5.panel("options").onBeforeDestroy=function(){
var c=$(this).find(".calendar-shared");
if(c.length){
c.insertBefore(c[0].pholder);
}
};
var cc=$("<div class=\"datebox-calendar-inner\"></div>").prependTo(_9b5);
if(opts.sharedCalendar){
var c=$(opts.sharedCalendar);
if(!c[0].pholder){
c[0].pholder=$("<div class=\"calendar-pholder\" style=\"display:none\"></div>").insertAfter(c);
}
c.addClass("calendar-shared").appendTo(cc);
if(!c.hasClass("calendar")){
c.calendar();
}
_9b1.calendar=c;
}else{
_9b1.calendar=$("<div></div>").appendTo(cc).calendar();
}
$.extend(_9b1.calendar.calendar("options"),{fit:true,border:false,onSelect:function(date){
var _9b6=this.target;
var opts=$(_9b6).datebox("options");
_9c2(_9b6,opts.formatter.call(_9b6,date));
$(_9b6).combo("hidePanel");
opts.onSelect.call(_9b6,date);
}});
}
$(_9b0).combo("textbox").parent().addClass("datebox");
$(_9b0).datebox("initValue",opts.value);
function _9b2(_9b7){
var opts=$(_9b7).datebox("options");
var _9b8=$(_9b7).combo("panel");
_9b8.unbind(".datebox").bind("click.datebox",function(e){
if($(e.target).hasClass("datebox-button-a")){
var _9b9=parseInt($(e.target).attr("datebox-button-index"));
opts.buttons[_9b9].handler.call(e.target,_9b7);
}
});
};
function _9b3(_9ba){
var _9bb=$(_9ba).combo("panel");
if(_9bb.children("div.datebox-button").length){
return;
}
var _9bc=$("<div class=\"datebox-button\"><table cellspacing=\"0\" cellpadding=\"0\" style=\"width:100%\"><tr></tr></table></div>").appendTo(_9bb);
var tr=_9bc.find("tr");
for(var i=0;i<opts.buttons.length;i++){
var td=$("<td></td>").appendTo(tr);
var btn=opts.buttons[i];
var t=$("<a class=\"datebox-button-a\" href=\"javascript:void(0)\"></a>").html($.isFunction(btn.text)?btn.text(_9ba):btn.text).appendTo(td);
t.attr("datebox-button-index",i);
}
tr.find("td").css("width",(100/opts.buttons.length)+"%");
};
function _9b4(_9bd){
var _9be=$(_9bd).combo("panel");
var cc=_9be.children("div.datebox-calendar-inner");
_9be.children()._outerWidth(_9be.width());
_9b1.calendar.appendTo(cc);
_9b1.calendar[0].target=_9bd;
if(opts.panelHeight!="auto"){
var _9bf=_9be.height();
_9be.children().not(cc).each(function(){
_9bf-=$(this).outerHeight();
});
cc._outerHeight(_9bf);
}
_9b1.calendar.calendar("resize");
};
};
function _9c0(_9c1,q){
_9c2(_9c1,q,true);
};
function _9c3(_9c4){
var _9c5=$.data(_9c4,"datebox");
var opts=_9c5.options;
var _9c6=_9c5.calendar.calendar("options").current;
if(_9c6){
_9c2(_9c4,opts.formatter.call(_9c4,_9c6));
$(_9c4).combo("hidePanel");
}
};
function _9c2(_9c7,_9c8,_9c9){
var _9ca=$.data(_9c7,"datebox");
var opts=_9ca.options;
var _9cb=_9ca.calendar;
$(_9c7).combo("setValue",_9c8);
_9cb.calendar("moveTo",opts.parser.call(_9c7,_9c8));
if(!_9c9){
if(_9c8){
_9c8=opts.formatter.call(_9c7,_9cb.calendar("options").current);
$(_9c7).combo("setValue",_9c8).combo("setText",_9c8);
}else{
$(_9c7).combo("setText",_9c8);
}
}
};
$.fn.datebox=function(_9cc,_9cd){
if(typeof _9cc=="string"){
var _9ce=$.fn.datebox.methods[_9cc];
if(_9ce){
return _9ce(this,_9cd);
}else{
return this.combo(_9cc,_9cd);
}
}
_9cc=_9cc||{};
return this.each(function(){
var _9cf=$.data(this,"datebox");
if(_9cf){
$.extend(_9cf.options,_9cc);
}else{
$.data(this,"datebox",{options:$.extend({},$.fn.datebox.defaults,$.fn.datebox.parseOptions(this),_9cc)});
}
_9af(this);
});
};
$.fn.datebox.methods={options:function(jq){
var _9d0=jq.combo("options");
return $.extend($.data(jq[0],"datebox").options,{width:_9d0.width,height:_9d0.height,originalValue:_9d0.originalValue,disabled:_9d0.disabled,readonly:_9d0.readonly});
},cloneFrom:function(jq,from){
return jq.each(function(){
$(this).combo("cloneFrom",from);
$.data(this,"datebox",{options:$.extend(true,{},$(from).datebox("options")),calendar:$(from).datebox("calendar")});
$(this).addClass("datebox-f");
});
},calendar:function(jq){
return $.data(jq[0],"datebox").calendar;
},initValue:function(jq,_9d1){
return jq.each(function(){
var opts=$(this).datebox("options");
var _9d2=opts.value;
if(_9d2){
_9d2=opts.formatter.call(this,opts.parser.call(this,_9d2));
}
$(this).combo("initValue",_9d2).combo("setText",_9d2);
});
},setValue:function(jq,_9d3){
return jq.each(function(){
_9c2(this,_9d3);
});
},reset:function(jq){
return jq.each(function(){
var opts=$(this).datebox("options");
$(this).datebox("setValue",opts.originalValue);
});
}};
$.fn.datebox.parseOptions=function(_9d4){
return $.extend({},$.fn.combo.parseOptions(_9d4),$.parser.parseOptions(_9d4,["sharedCalendar"]));
};
$.fn.datebox.defaults=$.extend({},$.fn.combo.defaults,{panelWidth:180,panelHeight:"auto",sharedCalendar:null,keyHandler:{up:function(e){
},down:function(e){
},left:function(e){
},right:function(e){
},enter:function(e){
_9c3(this);
},query:function(q,e){
_9c0(this,q);
}},currentText:"Today",closeText:"Close",okText:"Ok",buttons:[{text:function(_9d5){
return $(_9d5).datebox("options").currentText;
},handler:function(_9d6){
$(_9d6).datebox("calendar").calendar({year:new Date().getFullYear(),month:new Date().getMonth()+1,current:new Date()});
_9c3(_9d6);
}},{text:function(_9d7){
return $(_9d7).datebox("options").closeText;
},handler:function(_9d8){
$(this).closest("div.combo-panel").panel("close");
}}],formatter:function(date){
var y=date.getFullYear();
var m=date.getMonth()+1;
var d=date.getDate();
return (m<10?("0"+m):m)+"/"+(d<10?("0"+d):d)+"/"+y;
},parser:function(s){
if(!s){
return new Date();
}
var ss=s.split("/");
var m=parseInt(ss[0],10);
var d=parseInt(ss[1],10);
var y=parseInt(ss[2],10);
if(!isNaN(y)&&!isNaN(m)&&!isNaN(d)){
return new Date(y,m-1,d);
}else{
return new Date();
}
},onSelect:function(date){
}});
})(jQuery);
(function($){
function _9d9(_9da){
var _9db=$.data(_9da,"datetimebox");
var opts=_9db.options;
$(_9da).datebox($.extend({},opts,{onShowPanel:function(){
var _9dc=$(this).datetimebox("getValue");
_9e2(this,_9dc,true);
opts.onShowPanel.call(this);
},formatter:$.fn.datebox.defaults.formatter,parser:$.fn.datebox.defaults.parser}));
$(_9da).removeClass("datebox-f").addClass("datetimebox-f");
$(_9da).datebox("calendar").calendar({onSelect:function(date){
opts.onSelect.call(this.target,date);
}});
if(!_9db.spinner){
var _9dd=$(_9da).datebox("panel");
var p=$("<div style=\"padding:2px\"><input></div>").insertAfter(_9dd.children("div.datebox-calendar-inner"));
_9db.spinner=p.children("input");
}
_9db.spinner.timespinner({width:opts.spinnerWidth,showSeconds:opts.showSeconds,separator:opts.timeSeparator});
$(_9da).datetimebox("initValue",opts.value);
};
function _9de(_9df){
var c=$(_9df).datetimebox("calendar");
var t=$(_9df).datetimebox("spinner");
var date=c.calendar("options").current;
return new Date(date.getFullYear(),date.getMonth(),date.getDate(),t.timespinner("getHours"),t.timespinner("getMinutes"),t.timespinner("getSeconds"));
};
function _9e0(_9e1,q){
_9e2(_9e1,q,true);
};
function _9e3(_9e4){
var opts=$.data(_9e4,"datetimebox").options;
var date=_9de(_9e4);
_9e2(_9e4,opts.formatter.call(_9e4,date));
$(_9e4).combo("hidePanel");
};
function _9e2(_9e5,_9e6,_9e7){
var opts=$.data(_9e5,"datetimebox").options;
$(_9e5).combo("setValue",_9e6);
if(!_9e7){
if(_9e6){
var date=opts.parser.call(_9e5,_9e6);
$(_9e5).combo("setValue",opts.formatter.call(_9e5,date));
$(_9e5).combo("setText",opts.formatter.call(_9e5,date));
}else{
$(_9e5).combo("setText",_9e6);
}
}
var date=opts.parser.call(_9e5,_9e6);
$(_9e5).datetimebox("calendar").calendar("moveTo",date);
$(_9e5).datetimebox("spinner").timespinner("setValue",_9e8(date));
function _9e8(date){
function _9e9(_9ea){
return (_9ea<10?"0":"")+_9ea;
};
var tt=[_9e9(date.getHours()),_9e9(date.getMinutes())];
if(opts.showSeconds){
tt.push(_9e9(date.getSeconds()));
}
return tt.join($(_9e5).datetimebox("spinner").timespinner("options").separator);
};
};
$.fn.datetimebox=function(_9eb,_9ec){
if(typeof _9eb=="string"){
var _9ed=$.fn.datetimebox.methods[_9eb];
if(_9ed){
return _9ed(this,_9ec);
}else{
return this.datebox(_9eb,_9ec);
}
}
_9eb=_9eb||{};
return this.each(function(){
var _9ee=$.data(this,"datetimebox");
if(_9ee){
$.extend(_9ee.options,_9eb);
}else{
$.data(this,"datetimebox",{options:$.extend({},$.fn.datetimebox.defaults,$.fn.datetimebox.parseOptions(this),_9eb)});
}
_9d9(this);
});
};
$.fn.datetimebox.methods={options:function(jq){
var _9ef=jq.datebox("options");
return $.extend($.data(jq[0],"datetimebox").options,{originalValue:_9ef.originalValue,disabled:_9ef.disabled,readonly:_9ef.readonly});
},cloneFrom:function(jq,from){
return jq.each(function(){
$(this).datebox("cloneFrom",from);
$.data(this,"datetimebox",{options:$.extend(true,{},$(from).datetimebox("options")),spinner:$(from).datetimebox("spinner")});
$(this).removeClass("datebox-f").addClass("datetimebox-f");
});
},spinner:function(jq){
return $.data(jq[0],"datetimebox").spinner;
},initValue:function(jq,_9f0){
return jq.each(function(){
var opts=$(this).datetimebox("options");
var _9f1=opts.value;
if(_9f1){
_9f1=opts.formatter.call(this,opts.parser.call(this,_9f1));
}
$(this).combo("initValue",_9f1).combo("setText",_9f1);
});
},setValue:function(jq,_9f2){
return jq.each(function(){
_9e2(this,_9f2);
});
},reset:function(jq){
return jq.each(function(){
var opts=$(this).datetimebox("options");
$(this).datetimebox("setValue",opts.originalValue);
});
}};
$.fn.datetimebox.parseOptions=function(_9f3){
var t=$(_9f3);
return $.extend({},$.fn.datebox.parseOptions(_9f3),$.parser.parseOptions(_9f3,["timeSeparator","spinnerWidth",{showSeconds:"boolean"}]));
};
$.fn.datetimebox.defaults=$.extend({},$.fn.datebox.defaults,{spinnerWidth:"100%",showSeconds:true,timeSeparator:":",keyHandler:{up:function(e){
},down:function(e){
},left:function(e){
},right:function(e){
},enter:function(e){
_9e3(this);
},query:function(q,e){
_9e0(this,q);
}},buttons:[{text:function(_9f4){
return $(_9f4).datetimebox("options").currentText;
},handler:function(_9f5){
var opts=$(_9f5).datetimebox("options");
_9e2(_9f5,opts.formatter.call(_9f5,new Date()));
$(_9f5).datetimebox("hidePanel");
}},{text:function(_9f6){
return $(_9f6).datetimebox("options").okText;
},handler:function(_9f7){
_9e3(_9f7);
}},{text:function(_9f8){
return $(_9f8).datetimebox("options").closeText;
},handler:function(_9f9){
$(_9f9).datetimebox("hidePanel");
}}],formatter:function(date){
var h=date.getHours();
var M=date.getMinutes();
var s=date.getSeconds();
function _9fa(_9fb){
return (_9fb<10?"0":"")+_9fb;
};
var _9fc=$(this).datetimebox("spinner").timespinner("options").separator;
var r=$.fn.datebox.defaults.formatter(date)+" "+_9fa(h)+_9fc+_9fa(M);
if($(this).datetimebox("options").showSeconds){
r+=_9fc+_9fa(s);
}
return r;
},parser:function(s){
if($.trim(s)==""){
return new Date();
}
var dt=s.split(" ");
var d=$.fn.datebox.defaults.parser(dt[0]);
if(dt.length<2){
return d;
}
var _9fd=$(this).datetimebox("spinner").timespinner("options").separator;
var tt=dt[1].split(_9fd);
var hour=parseInt(tt[0],10)||0;
var _9fe=parseInt(tt[1],10)||0;
var _9ff=parseInt(tt[2],10)||0;
return new Date(d.getFullYear(),d.getMonth(),d.getDate(),hour,_9fe,_9ff);
}});
})(jQuery);
(function($){
function init(_a00){
var _a01=$("<div class=\"slider\">"+"<div class=\"slider-inner\">"+"<a href=\"javascript:void(0)\" class=\"slider-handle\"></a>"+"<span class=\"slider-tip\"></span>"+"</div>"+"<div class=\"slider-rule\"></div>"+"<div class=\"slider-rulelabel\"></div>"+"<div style=\"clear:both\"></div>"+"<input type=\"hidden\" class=\"slider-value\">"+"</div>").insertAfter(_a00);
var t=$(_a00);
t.addClass("slider-f").hide();
var name=t.attr("name");
if(name){
_a01.find("input.slider-value").attr("name",name);
t.removeAttr("name").attr("sliderName",name);
}
_a01.bind("_resize",function(e,_a02){
if($(this).hasClass("easyui-fluid")||_a02){
_a03(_a00);
}
return false;
});
return _a01;
};
function _a03(_a04,_a05){
var _a06=$.data(_a04,"slider");
var opts=_a06.options;
var _a07=_a06.slider;
if(_a05){
if(_a05.width){
opts.width=_a05.width;
}
if(_a05.height){
opts.height=_a05.height;
}
}
_a07._size(opts);
if(opts.mode=="h"){
_a07.css("height","");
_a07.children("div").css("height","");
}else{
_a07.css("width","");
_a07.children("div").css("width","");
_a07.children("div.slider-rule,div.slider-rulelabel,div.slider-inner")._outerHeight(_a07._outerHeight());
}
_a08(_a04);
};
function _a09(_a0a){
var _a0b=$.data(_a0a,"slider");
var opts=_a0b.options;
var _a0c=_a0b.slider;
var aa=opts.mode=="h"?opts.rule:opts.rule.slice(0).reverse();
if(opts.reversed){
aa=aa.slice(0).reverse();
}
_a0d(aa);
function _a0d(aa){
var rule=_a0c.find("div.slider-rule");
var _a0e=_a0c.find("div.slider-rulelabel");
rule.empty();
_a0e.empty();
for(var i=0;i<aa.length;i++){
var _a0f=i*100/(aa.length-1)+"%";
var span=$("<span></span>").appendTo(rule);
span.css((opts.mode=="h"?"left":"top"),_a0f);
if(aa[i]!="|"){
span=$("<span></span>").appendTo(_a0e);
span.html(aa[i]);
if(opts.mode=="h"){
span.css({left:_a0f,marginLeft:-Math.round(span.outerWidth()/2)});
}else{
span.css({top:_a0f,marginTop:-Math.round(span.outerHeight()/2)});
}
}
}
};
};
function _a10(_a11){
var _a12=$.data(_a11,"slider");
var opts=_a12.options;
var _a13=_a12.slider;
_a13.removeClass("slider-h slider-v slider-disabled");
_a13.addClass(opts.mode=="h"?"slider-h":"slider-v");
_a13.addClass(opts.disabled?"slider-disabled":"");
_a13.find("a.slider-handle").draggable({axis:opts.mode,cursor:"pointer",disabled:opts.disabled,onDrag:function(e){
var left=e.data.left;
var _a14=_a13.width();
if(opts.mode!="h"){
left=e.data.top;
_a14=_a13.height();
}
if(left<0||left>_a14){
return false;
}else{
var _a15=_a27(_a11,left);
_a16(_a15);
return false;
}
},onBeforeDrag:function(){
_a12.isDragging=true;
},onStartDrag:function(){
opts.onSlideStart.call(_a11,opts.value);
},onStopDrag:function(e){
var _a17=_a27(_a11,(opts.mode=="h"?e.data.left:e.data.top));
_a16(_a17);
opts.onSlideEnd.call(_a11,opts.value);
opts.onComplete.call(_a11,opts.value);
_a12.isDragging=false;
}});
_a13.find("div.slider-inner").unbind(".slider").bind("mousedown.slider",function(e){
if(_a12.isDragging||opts.disabled){
return;
}
var pos=$(this).offset();
var _a18=_a27(_a11,(opts.mode=="h"?(e.pageX-pos.left):(e.pageY-pos.top)));
_a16(_a18);
opts.onComplete.call(_a11,opts.value);
});
function _a16(_a19){
var s=Math.abs(_a19%opts.step);
if(s<opts.step/2){
_a19-=s;
}else{
_a19=_a19-s+opts.step;
}
_a1a(_a11,_a19);
};
};
function _a1a(_a1b,_a1c){
var _a1d=$.data(_a1b,"slider");
var opts=_a1d.options;
var _a1e=_a1d.slider;
var _a1f=opts.value;
if(_a1c<opts.min){
_a1c=opts.min;
}
if(_a1c>opts.max){
_a1c=opts.max;
}
opts.value=_a1c;
$(_a1b).val(_a1c);
_a1e.find("input.slider-value").val(_a1c);
var pos=_a20(_a1b,_a1c);
var tip=_a1e.find(".slider-tip");
if(opts.showTip){
tip.show();
tip.html(opts.tipFormatter.call(_a1b,opts.value));
}else{
tip.hide();
}
if(opts.mode=="h"){
var _a21="left:"+pos+"px;";
_a1e.find(".slider-handle").attr("style",_a21);
tip.attr("style",_a21+"margin-left:"+(-Math.round(tip.outerWidth()/2))+"px");
}else{
var _a21="top:"+pos+"px;";
_a1e.find(".slider-handle").attr("style",_a21);
tip.attr("style",_a21+"margin-left:"+(-Math.round(tip.outerWidth()))+"px");
}
if(_a1f!=_a1c){
opts.onChange.call(_a1b,_a1c,_a1f);
}
};
function _a08(_a22){
var opts=$.data(_a22,"slider").options;
var fn=opts.onChange;
opts.onChange=function(){
};
_a1a(_a22,opts.value);
opts.onChange=fn;
};
function _a20(_a23,_a24){
var _a25=$.data(_a23,"slider");
var opts=_a25.options;
var _a26=_a25.slider;
var size=opts.mode=="h"?_a26.width():_a26.height();
var pos=opts.converter.toPosition.call(_a23,_a24,size);
if(opts.mode=="v"){
pos=_a26.height()-pos;
}
if(opts.reversed){
pos=size-pos;
}
return pos.toFixed(0);
};
function _a27(_a28,pos){
var _a29=$.data(_a28,"slider");
var opts=_a29.options;
var _a2a=_a29.slider;
var size=opts.mode=="h"?_a2a.width():_a2a.height();
var _a2b=opts.converter.toValue.call(_a28,opts.mode=="h"?(opts.reversed?(size-pos):pos):(size-pos),size);
return _a2b.toFixed(0);
};
$.fn.slider=function(_a2c,_a2d){
if(typeof _a2c=="string"){
return $.fn.slider.methods[_a2c](this,_a2d);
}
_a2c=_a2c||{};
return this.each(function(){
var _a2e=$.data(this,"slider");
if(_a2e){
$.extend(_a2e.options,_a2c);
}else{
_a2e=$.data(this,"slider",{options:$.extend({},$.fn.slider.defaults,$.fn.slider.parseOptions(this),_a2c),slider:init(this)});
$(this).removeAttr("disabled");
}
var opts=_a2e.options;
opts.min=parseFloat(opts.min);
opts.max=parseFloat(opts.max);
opts.value=parseFloat(opts.value);
opts.step=parseFloat(opts.step);
opts.originalValue=opts.value;
_a10(this);
_a09(this);
_a03(this);
});
};
$.fn.slider.methods={options:function(jq){
return $.data(jq[0],"slider").options;
},destroy:function(jq){
return jq.each(function(){
$.data(this,"slider").slider.remove();
$(this).remove();
});
},resize:function(jq,_a2f){
return jq.each(function(){
_a03(this,_a2f);
});
},getValue:function(jq){
return jq.slider("options").value;
},setValue:function(jq,_a30){
return jq.each(function(){
_a1a(this,_a30);
});
},clear:function(jq){
return jq.each(function(){
var opts=$(this).slider("options");
_a1a(this,opts.min);
});
},reset:function(jq){
return jq.each(function(){
var opts=$(this).slider("options");
_a1a(this,opts.originalValue);
});
},enable:function(jq){
return jq.each(function(){
$.data(this,"slider").options.disabled=false;
_a10(this);
});
},disable:function(jq){
return jq.each(function(){
$.data(this,"slider").options.disabled=true;
_a10(this);
});
}};
$.fn.slider.parseOptions=function(_a31){
var t=$(_a31);
return $.extend({},$.parser.parseOptions(_a31,["width","height","mode",{reversed:"boolean",showTip:"boolean",min:"number",max:"number",step:"number"}]),{value:(t.val()||undefined),disabled:(t.attr("disabled")?true:undefined),rule:(t.attr("rule")?eval(t.attr("rule")):undefined)});
};
$.fn.slider.defaults={width:"auto",height:"auto",mode:"h",reversed:false,showTip:false,disabled:false,value:0,min:0,max:100,step:1,rule:[],tipFormatter:function(_a32){
return _a32;
},converter:{toPosition:function(_a33,size){
var opts=$(this).slider("options");
return (_a33-opts.min)/(opts.max-opts.min)*size;
},toValue:function(pos,size){
var opts=$(this).slider("options");
return opts.min+(opts.max-opts.min)*(pos/size);
}},onChange:function(_a34,_a35){
},onSlideStart:function(_a36){
},onSlideEnd:function(_a37){
},onComplete:function(_a38){
}};
})(jQuery);



/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAQCAYAAABQrvyxAAAAV0lEQVR42mNgGAWjgHbA2Nj4Pz4+tfTQzPHIlqPzqa1vUDieWvqlDHIx9IPE6GI5NcyBORimB91DdIt+aniCaMcPCw8M+SQ0LDLxsChGh0VFNgpGAXEAAFaMoMnD3BaeAAAAAElFTkSuQmCC"

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAARElEQVR42mNgGAWDGRgbG/8H4QG1nBRHEFJLtFnoCqnhCLItp4YjqOZzchxBdjqiRhqgWUiMnDRADUcMirJktEgf1AAAYxJywWGQAbcAAAAASUVORK5CYII="

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAZ0lEQVR42u2VMQ7AMAgD+f9XeYBHd+mA2IqrJFJ8EkMGrNiCJMIYY86Eh2otDYA7dNgq2/kLEEzwhxDGGrURQxGlN97gUUrxQCU9DM33ALjYQA0vlRGCcPEUjGxdgasfQX+DxphreAA2tk8BzQnbmgAAAABJRU5ErkJggg=="

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAVElEQVR42mNgGAWjYDADY2Pj/4aGht8HzHIQNjIy+gOiSdGDTT0+ObwGAUPgH9EacVhEtuVkGYCkHtnxZFtOiSNg0UesHqoDAwOD7wNm+SgYBcQCAGMaTEhwX5dbAAAAAElFTkSuQmCC"

/***/ }),
/* 16 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

if(typeof com == "undefined")
	var com = {};
com.chanjet = {};
com.chanjet.gzq = {};
com.chanjet.gzq.aflow = {};
com.chanjet.gzq.aflow.Application = Class.extend({

	appName: "com.chanjet.gzq.aflow.Application",

	/**
	 * @constructor
	 * 
	 * @param Option param {String} canvasID the id of the DOM element to use as paint container.
	 */
	init: function(canvasID){
		//-- 1. activiti-designer的画布

        var uuid = draw2d.util.UUID.create();

		this.canvas = new com.chanjet.gzq.aflow.Canvas('Canvas');
		this.canvas.userData.id = uuid;

		//-- 2. activiti-designer的连接器(全局)
		draw2d.Connection.createConnection = this.createConnection;
		
		//-- 3. activiti-designer的手风琴导航菜单
		this.accordion = new com.chanjet.gzq.aflow.Accordion(this.canvas);
		
		//-- 4. activiti-designer的工具条
		this.toolbar = new com.chanjet.gzq.aflow.ToolBar(this.canvas);
		
	},
	loadFigure: function(json){

		this.canvas.clear();
		var self = this;

		var elements = [];
		var conns = [];

		this.canvas.userData = json['userData'];

		if(json['canvas'].length == 0) {
		    return;
        }

		json['canvas'].forEach(function (e, i) {

		    var element = eval("new com.chanjet.gzq.aflow."+e.type+"()");

            var keys = Object.getOwnPropertyNames(e);
            if (e.type == "Connection") {
                conns.push(e);
            }
            else {
		        keys.forEach ( function (k) {
                    if (k.toLowerCase().indexOf("color") >= 0) {
                        element[k] = new draw2d.util.Color(e[k]);
                        // TODO: add a color deserializer here from json for color and bgColor fields
                    }
                    else if (k == "ports") {
                        if (e.type == "BranchTask") {
                            //分支条件，需要初始化多个ports
                            if (e[k].length > 2) {
                                for (var i = e[k].length - 4; i >= 0; i--) {
                                    var rightLocator = new draw2d.layout.locator.OutputPortLocator();
                                    var p = element.createPort("output",rightLocator);
                                    p.setBackgroundColor('#00FF00');
                                    p.setMaxFanOut(1);
                                }
                            }
                        }
                    }
                    else if (k == 'vertices') {

                    }
                    else {
                        element[k] = e[k];
                    }
                });

                element.getOutputPorts().each( function (i, p) {
                        p.setMaxFanOut(1);
                });

                elements.push(element);

                self.canvas.add(element, element.x, element.y);
            }
        });

		conns.forEach ( function (e, i) {

		    var start = null;
		    var end = null;

		    elements.forEach(function (shape, i) {
                if(shape.id == e.source.node) {
                    for (var size = shape.outputPorts.data.length - 1; size >= 0; size --) {
                        if (shape.outputPorts.data[size].name == e.source.port) {
                            start = shape.outputPorts.data[size];
                        }
                    }
                }
                if(shape.id == e.target.node) {
                    for (var size = shape.inputPorts.data.length - 1; size >= 0; size --) {
                        if (shape.inputPorts.data[size].name == e.target.port) {
                            end = shape.inputPorts.data[size];
                        }
                    }
                }
            });

            var cmd = new draw2d.command.CommandConnect(self.canvas, start, end);
            // self.canvas.getCommandStack().execute(cmd);
            cmd.execute();
            cmd.connection.id = e.id;
            cmd.connection.userData = e.userData;
            if (start.parent.cssClass == 'BranchTask') {
                cmd.connection.showExpression();
            }

        });
	},

	createConnection: function(sourcePort, targetPort){

		var conn = new com.chanjet.gzq.aflow.Connection();

        if(sourcePort != null && sourcePort.parent != null) {
            conn.userData['from'] = sourcePort.parent.id;

            if (sourcePort.parent.cssClass == 'BranchTask') {
                conn.userData['expression'] = '';
                conn.setColor('#0000ff');
                conn.userData['help']=
                "条件输入支持：<br />" +
                "逗号分隔的多个条件，同时满足<br />" +
                "<br />" +
                "支持的运算符：<br />" +
                "> 大于<br />" +
                ">= 大于等于<br />" +
                "< 小于<br />" +
                "<= 大于等于<br />" +
                "= 等于<br />"+
                "!= 不等于<br />"+
                "* 缺省条件，不满足其他条件时成立<br />"+
                "<br />" +
                "例子：<br />" +
                ">500, <= 50000<br />" +
                "-表示条件大于500并且小于等于50000<br />" +
                "=1, =2, =3<br />" +
                "-表示条件等于1，2，或者3<br />"+
                "=报销单<br />" +
                "-表示条件等于报销单<br />",
                conn.showExpression();
            }
        }

		if(targetPort != null && targetPort.parent != null) {
            conn.userData['to'] = targetPort.parent.id;
		}

	    return conn;
	},

});

/***/ }),
/* 18 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.Accordion = Class.extend({
	accordionName: "com.chanjet.gzq.aflow.Accordion",

    thisAccordion:null,

	init: function(view){
        thisAccordion = this;
		this.view = view;
		$('.easyui-accordion .easyui-linkbutton').draggable({
			// 代理
			proxy:function(source){
				var p = $('<div class="draggable-model-proxy"></div>');
				p.html($(source).html()).appendTo('body');
				return p;
			},
			deltaX: -5,// 拖拽元素相对于光标的位置X
			deltaY: -5,// 拖拽元素相对于光标的位置Y
			revert: true,// 设置为true,拖拽结束后元素返回起始位置
			cursor: 'pointer',// 手形
			onStartDrag: function(){
				$(this).draggable('options').cursor = "not-allowed";
			},
			onStopDrag: function(){
				$(this).draggable('options').cursor = "pointer";
			}
		});
		
		$('#'+view.id).droppable({
			accept: '.easyui-linkbutton',
			onDragEnter: function(e,source){
				$(source).draggable('options').cursor = 'move';
			},
			onDragLeave: function(e,source){
				$(source).draggable('options').cursor = 'not-allowed';
			},
			onDrop: function(e, source){
				var nodeType = $(source).attr('nodeType');// 图元类型

				var x = $(source).draggable('proxy').offset().left;
				var y = $(source).draggable('proxy').offset().top;

				var xOffset = view.getAbsoluteX();
				var yOffset = view.getAbsoluteY();

				var scrollLeft = view.getScrollLeft();
				var scrollTop = view.getScrollTop();

                thisAccordion.addNode(nodeType, x-xOffset+scrollLeft,y-yOffset+scrollTop);
			}
		});
	},

    addNode: function(nodeType, x, y) {

        var shape = eval("new com.chanjet.gzq.aflow."+nodeType+"()");
        //view.add(shape,x,y);
        var command = new draw2d.command.CommandAdd(app.canvas, shape, x, y);
        app.canvas.getCommandStack().execute(command);// 放入堆栈，撤销或者重做

        var count = 0;
        var sourcePort;
        if (shape.cssClass != 'Connection') {
            app.canvas.figures.data.forEach(function (e, i) {
                if (e.cssClass != "Connection" && e.id != shape.id)  {
                    e.getOutputPorts().each( function (i, p) {
                        p.setMaxFanOut(1);
                        if(p.connections.data.length==0) {
                            count += 1;
                            sourcePort = p;
                        }
                    });
                }
            });
        }
        if(count == 1) {
            var cmd = new draw2d.command.CommandConnect(app.canvas, sourcePort, shape.inputPorts.data[0]);
            app.canvas.getCommandStack().execute(cmd);// 放入堆栈，撤销或者重做
            if (sourcePort.parent.cssClass == 'BranchTask') {
                cmd.connection.showExpression();
            }
        }
    },
});

/***/ }),
/* 19 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.Canvas = draw2d.Canvas.extend({
	canvasName: "com.chanjet.gzq.aflow.Canvas",

	init: function(id){
		this._super(id);
		this.setScrollArea("#"+id);
		this.id = id;

		var MyInterceptorPolicy = draw2d.policy.canvas.ConnectionInterceptorPolicy.extend({

			init : function()
			{
				this._super();
			},

			delegateDrop: function(draggedFigure, dropTarget){
				return this._super(draggedFigure, dropTarget);
			}

		});
		this.installEditPolicy(new MyInterceptorPolicy());

        this.userData = {
            name: "流程模版",
            id: this.id,
            type: "FlowDefinition",
            formTemplateId: 'uuid',
            formTemplateName: '表单模版名称',
        };
	},

	insertTask: function (connection, taskType) {

        var shape = eval("new com.chanjet.gzq.aflow."+taskType+"()");

        var x = connection.getBoundingBox().getTopLeft().getX() + (connection.getBoundingBox().getWidth() / 2) - 48;
        var y = connection.getBoundingBox().getCenter().getY() - shape.getHeight() / 2;

        var sourcePort = connection.getSource();
        var targetPort = connection.getTarget();

        var cmd = new draw2d.command.CommandDelete(connection);
        this.getCommandStack().execute(cmd);


        var command = new draw2d.command.CommandAdd(this, shape, x, y);
        this.getCommandStack().execute(command);

        var cmd = new draw2d.command.CommandConnect(this, sourcePort, shape.inputPorts.data[0]);
        // cmd.execute();
        this.getCommandStack().execute(cmd);
        if (sourcePort.parent.cssClass == 'BranchTask') {
            connection.showExpression();
        }

        cmd = new draw2d.command.CommandConnect(this, shape.outputPorts.data[0], targetPort);
        // cmd.execute();
        this.getCommandStack().execute(cmd);
    },

    appendTask: function (thisTask, taskType, value, xPos, yPos) {

	    var emptyPort = null;
	    thisTask.outputPorts.data.forEach(function (e, i) {
            if(e.connections.data.length == 0) {
                emptyPort = e;
            }
        });

        if(emptyPort == null) {
	        return;
        }

        var x = xPos != null? xPos : thisTask.getBoundingBox().getTopLeft().getX() + 96 + 100;
        var y = yPos != null? yPos : thisTask.getBoundingBox().getCenter().getY();

        var shape = eval("new com.chanjet.gzq.aflow."+taskType+"()");

        if(taskType == "UserTask") {
            shape.userData['userIds'] = value;
        }
        else if(taskType == "RoleTask") {
            shape.userData['roleIds'] = value;
        }
        else {
            console.log(value);
        }


        var command = new draw2d.command.CommandAdd(this, shape, x, y - shape.getHeight() / 2);
        this.getCommandStack().execute(command);

        var cmd = new draw2d.command.CommandConnect(this, emptyPort, shape.inputPorts.data[0]);
        // cmd.execute();
        this.getCommandStack().execute(cmd);

        if (thisTask.cssClass == 'BranchTask') {
            cmd.connection.showExpression();
        }

        return shape;
    },

    convertTaskType: function (thisTask, newTaskType, value) {

        var shape = eval("new com.chanjet.gzq.aflow."+newTaskType+"()");

        if(newTaskType == "UserTask") {
            shape.userData['userIds'] = value;
        }
        else if(newTaskType == "RoleTask") {
            shape.userData['roleIds'] = value;
        }
        else {
            console.log(value);
        }

        var command = new draw2d.command.CommandAdd(this, shape, thisTask.x, thisTask.y);
        this.getCommandStack().execute(command);

        thisTask.inputPorts.data.forEach(function (port, index) {
            port.connections.data.forEach(function (connection, i) {
                command = new draw2d.command.CommandReconnect(connection);
                command.setNewPorts(connection.sourcePort, shape.inputPorts.data[0]);
                app.canvas.getCommandStack().execute(command);
            });
        });

        command = new draw2d.command.CommandDelete(thisTask);
        this.getCommandStack().execute(command);

        return shape;
    },

    appendBranchTaskFromWizard: function (thisTask, value) {

        var padding = 50;
        var heightOfTaskFigure = 32;

        var shape = new com.chanjet.gzq.aflow.BranchTask();
        var emptyPort = null;
        thisTask.outputPorts.data.forEach(function (e, i) {
            if(e.connections.data.length == 0) {
                emptyPort = e;
            }
        });

        if(emptyPort == null) {
            return;
        }

        var x = thisTask.getBoundingBox().getTopLeft().getX() + 96 + 150;
        var y = thisTask.getBoundingBox().getCenter().getY();

        var command = new draw2d.command.CommandAdd(this, shape, x, y - shape.getHeight()/2);
        this.getCommandStack().execute(command);

        var cmd = new draw2d.command.CommandConnect(this, emptyPort, shape.inputPorts.data[0]);
        // cmd.execute();
        this.getCommandStack().execute(cmd);

        if (thisTask.cssClass == 'BranchTask') {
            cmd.connection.showExpression();
        }

        for(var i = value.length - 2; i > 0; i--) {
            shape.addCase();
        }

        var totalHeight = (heightOfTaskFigure + padding) * value.length;

        value.forEach(function (element, index) {

            app.canvas.appendTask(shape, 'UserTask', "", shape.getBoundingBox().getTopLeft().getX() + 250,
                shape.getBoundingBox().getTopLeft().getY() + totalHeight/2 - (heightOfTaskFigure + padding) * index);
        });

        shape.outputPorts.data.forEach(function (port, index) {
            port.connections.data.forEach(function (connection, i) {
                connection.userData['expression'] = value[index];
                connection.showExpression();
                return;
            });
        });

        return shape;
    },

    getLastTask: function () {

        var sourcePort;

        app.canvas.figures.data.forEach(function (e, i) {
            if (e.cssClass != "Connection")  {
                e.getOutputPorts().each( function (i, p) {
                    p.setMaxFanOut(1);
                    if(p.connections.data.length==0) {
                        sourcePort = p;
                    }
                });
            }
        });

        return sourcePort.parent;

    },

});

/***/ }),
/* 20 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.BranchTaskText = draw2d.shape.basic.Text.extend({
    NAME: "BranchTaskText",

    init: function(text){
        this._super();
        this.setText(text);
        this.setFontFamily("微软雅黑");
        this.setStroke(0);

        this.installEditor(new draw2d.ui.LabelInplaceEditor({
            onCommit: $.proxy(function(value){
                this.getParent().userData.name = value;
            },this),
            onCancel: function(){
            }
        }));
    }
});

com.chanjet.gzq.aflow.BranchTask = draw2d.shape.basic.Triangle.extend({
    NAME: "BranchTask",

    init: function(){
        this._super();

        this.setStroke(1);
        this.setDimension(64, 96);
        this.setBackgroundColor(new draw2d.util.Color("#ffffff"));
        this.setRadius(2);

        this.setResizeable(false);

        var BranchTaskText = new com.chanjet.gzq.aflow.BranchTaskText("条件");
        var BranchTaskTextLocation = new draw2d.layout.locator.CenterLocator();
        this.add(BranchTaskText, BranchTaskTextLocation,1);

        var leftLocator = new draw2d.layout.locator.InputPortLocator();
        this.createPort("input", leftLocator);

        var rightLocator0 = new draw2d.layout.locator.OutputPortLocator();
        var outputPort0 = this.createPort("output", rightLocator0);
        outputPort0.setBackgroundColor('#00FF00');
        outputPort0.setMaxFanOut(1);

        var rightLocator1 = new draw2d.layout.locator.OutputPortLocator();
        var outputPort1 = this.createPort("output", rightLocator1);
        outputPort1.setBackgroundColor('#00FF00');
        outputPort1.setMaxFanOut(1);


        this.userData = {
            name: "条件分支",
            id: this.id,
            type: "BranchTask",
            label: BranchTaskText.getText(),

            templateId: 'uuid',
            templateName: '表单模版名称',
            fieldId: 'uuid',
            fieldName: '表单字段名称',
            // caseNumber: 2,
        };

    },

    onDoubleClick: function() {},

    addCase: function () {
        var rightLocator = new draw2d.layout.locator.OutputPortLocator();
        var p = this.createPort("output",rightLocator);
        p.setBackgroundColor('#00FF00');
        p.setMaxFanOut(1);
        // this.userData['caseNumber'] += 1;
    },

    delCase: function () {

        var outputPorts = this.getOutputPorts();
        outputPorts.each(function (i, p) {
            if (p.getConnections().data.length == 0) {
                p.parent.removePort(p);
                return false;
            }
        });
        // this.userData['caseNumber'] -= 1;
        this.repaint();
    },


    /**
     *
     *  Called if the user drop this element onto the dropTarget.
     *
     *  will create a "smart insert" of an existing connection.
     * 	COOL and fast network editing.
     *
     * @param {draw2d.Figure} dropTarget The drop target.
     * @param {Number} x the x coordinate of the drop
     * @param {Number} y the y coordinate of the drop
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onDrop: function(dropTarget,x,y,shiftKey,ctrlKey){
        // Activate a "smart insert" If the user drop this figure on connection
        if(dropTarget instanceof draw2d.Connection){

            var oldSource = dropTarget.getSource();

            dropTarget.setSource(this.getOutputPort(0));

            var cmd = new draw2d.command.CommandConnect(this.getCanvas(),oldSource,this.getInputPort(0));
            this.getCanvas().getCommandStack().execute(cmd);
        }
    },

    onContextMenu:function(x,y){
        $.contextMenu({
            selector: "body",
            events:
            {
                hide:function(){ $.contextMenu( 'destroy' ); }
            },
            callback: $.proxy(function(key, options)
            {
                switch(key){
                    case "AddCase":
                        this.addCase();
                        break;
                    case "DelCase":
                        this.delCase();
                        break;
                    case "delete":
                        var cmd = new draw2d.command.CommandDelete(this);
                        this.getCanvas().getCommandStack().execute(cmd);
                        break;
                    default:
                        break;
                }

            },this),
            x:x,
            y:y,
            items:
            {
                "delete": {name: "Delete", icon: "delete"},
                "sep1":   "---------",
                "AddCase": {name: "AddCase", icon: "edit"},
                "DelCase": {name: "DelCase", icon: "delete"},
            }
        });
    },

    toProcessElement: function () {
        return '<exclusiveGateway id="BPMN_'+this.getId()+'" name="'+this.getUserData().name+'"></exclusiveGateway>';
    },

    toDiagramElement: function () {
        return '<bpmndi:BPMNShape bpmnElement="BPMN_'+this.getId()+'" id="BPMN_'+this.getId()+'">' +
            '<omgdc:Bounds height="'+this.getHeight()+'" width="'+this.getWidth()+'" x="'+this.getBoundingBox().getTopLeft().getX()+'" y="'+this.getBoundingBox().getTopLeft().getY()+'"></omgdc:Bounds>' +
            '</bpmndi:BPMNShape>';
    },

});












/***/ }),
/* 21 */
/***/ (function(module, exports) {

/**
 * Created by David on 2017/2/25.
 */

com.chanjet.gzq.aflow.ConnectionTEXT = draw2d.shape.basic.Text.extend({
    NAME: "ConnectionTEXT",

    init: function(text){
        this._super();
        this.setText(text);
        this.setFontFamily("微软雅黑");
        this.setStroke(0);
        // this.setWidth(100);
    }
});

com.chanjet.gzq.aflow.Connection = draw2d.Connection.extend({

    NAME: "Connection",

    init: function(){
        this._super();

        this.setStroke(2);

        var targetDecorator = new draw2d.decoration.connection.ArrowDecorator(12,12);
        targetDecorator.setBackgroundColor("#000000");
        this.setTargetDecorator(targetDecorator);

        var ConnectionTEXT = new com.chanjet.gzq.aflow.ConnectionTEXT("同意");
        var ConnectionTEXTLocation = new draw2d.layout.locator.ParallelMidpointLocator();
        this.add(ConnectionTEXT, ConnectionTEXTLocation, 1);


        // this.setRouter(new draw2d.layout.connection.DirectRouter());
        // this.setRouter(new draw2d.layout.connection.MuteableManhattanConnectionRouter());
        this.setRouter(new draw2d.layout.connection.SplineConnectionRouter());

        this.userData = {
            name: "连接线",
            id: this.id,
            type: "Connection",
            from: null,
            to: null,
        };

        this.installEditPolicy(new draw2d.policy.line.VertexSelectionFeedbackPolicy());
    },

    onDrag: function (dx, dy, dx2, dy2) {
        this._super(dx, dy, dx2, dy2);
    },

    onDragLeave: function (draggedFigure) {
   	    this.setGlow(false);
    },

    showExpression: function() {

        if(this.userData['expression'] != '') {
            this.setText(this.userData['expression']);
        }
        else {
            this.setText('设置条件');
        }

    },

    setText: function (text) {
        this.children.each( function (i, c) {
            if(c.figure.cssClass == 'ConnectionTEXT') {
                c.figure.setText(text);
            }
        })
    },

    onRightMouseDown: function (figure, x, y, shiftKey, ctrlKey) {
        //super.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
        this.onContextMenu(x, y);
    },

    onContextMenu:function(x,y){
        $.contextMenu({
            selector: "body",
            events:
                {
                    hide:function(){ $.contextMenu( 'destroy' ); }
                },
            callback: $.proxy(function(key, options)
            {
                switch(key){
                    case "delete":
                        var cmd = new draw2d.command.CommandDelete(this);
                        this.getCanvas().getCommandStack().execute(cmd);
                    case "insertUser":
                        app.canvas.insertTask(this, 'UserTask');
                    case "insertRole":
                        app.canvas.insertTask(this, 'RoleTask');
                    default:
                        break;
                }

            },this),
            x:x,
            y:y,
            items:
                {
                    "delete": {name: "删除", icon: ""},
                    "insertUser": {name: "插入固定人员", icon: ""},
                    "insertRole": {name: "插入上级主管", icon: ""},
                }
        });
    },

    toProcessElement: function () {
        var xml = '<sequenceFlow id="BPMN_'+this.getId()+'" name="'+this.getUserData().name+'" sourceRef="BPMN_'+this.getUserData().from+'" targetRef="BPMN_'+this.getUserData().to+'">';
        if(this.getSource().parent.cssClass == 'BranchTask') {
            xml += '<conditionExpression xsi:type="tFormalExpression">'+
                   '<![CDATA[${'+this.getSource().getParent().getUserData().templateId+'; '+this.getSource().getParent().getUserData().fieldId+'; '+this.userData['expression']+'}]]>'+
                   '</conditionExpression>';
        }
        xml += '</sequenceFlow>';

        return xml;
    },

    toDiagramElement: function () {
        return  '<bpmndi:BPMNShape bpmnElement="BPMN_'+this.getId()+'" id="BPMN_'+this.getId()+'">' +
                '<bpmndi:BPMNLabel>' +
                '<omgdc:Bounds height="'+this.getHeight()+'" width="'+this.getWidth()+'" x="'+this.getBoundingBox().getTopLeft().getX()+'" y="'+this.getBoundingBox().getTopLeft().getY()+'"></omgdc:Bounds>' +
                '</bpmndi:BPMNLabel>' +
                '</bpmndi:BPMNShape>';
    },
});

/***/ }),
/* 22 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.CountersignTEXT = draw2d.shape.basic.Text.extend({
    NAME: "CountersignTEXT",

    init: function(text){
        this._super();
        this.setText(text);
        this.setFontFamily("微软雅黑");
        this.setStroke(0);

        this.installEditor(new draw2d.ui.LabelInplaceEditor({
            onCommit: $.proxy(function(value){
                this.getParent().userData.name = value;
            },this),
            onCancel: function(){
            }
        }));
    }
});

com.chanjet.gzq.aflow.CountersignTask = draw2d.shape.basic.Diamond.extend({
	NAME: "CountersignTask",

	init: function(){
		this._super();

        this.setStroke(1);
        this.setDimension(64,64);
        this.setBackgroundColor(new draw2d.util.Color("#ffffcc"));
        this.setRadius(5);

        this.setResizeable(false);

		var CountersignTEXT = new com.chanjet.gzq.aflow.CountersignTEXT("会签");
		var CountersignTEXTLocation = new draw2d.layout.locator.CenterLocator();
		this.add(CountersignTEXT, CountersignTEXTLocation, 1);
		
		var leftLocator = new draw2d.layout.locator.InputPortLocator();
		this.createPort("input", leftLocator);

		var rightLocator = new draw2d.layout.locator.OutputPortLocator();
		var p = this.createPort("output", rightLocator);
        p.setMaxFanOut(1);

        this.userData = {
            name: "会签",
            id: this.id,
            type: "CountersignTask",
            label: CountersignTEXT.getText(),
            roleIds: '',
            userIds: '',
        };
	},

    onDoubleClick: function() {},
	
	 /**
     *
     *  Called if the user drop this element onto the dropTarget. 
     * 
     *  will create a "smart insert" of an existing connection.
     * 	COOL and fast network editing.
     * 
     * @param {draw2d.Figure} dropTarget The drop target.
     * @param {Number} x the x coordinate of the drop
     * @param {Number} y the y coordinate of the drop
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
	onDrop: function(dropTarget,x,y,shiftKey,ctrlKey){
		// Activate a "smart insert" If the user drop this figure on connection
    	if(dropTarget instanceof draw2d.Connection){
		
			var oldSource = dropTarget.getSource();
			
			dropTarget.setSource(this.getOutputPort(0));

			var cmd = new draw2d.command.CommandConnect(this.getCanvas(),oldSource,this.getInputPort(0));
			this.getCanvas().getCommandStack().execute(cmd);
			
    	}
	},
	
	onContextMenu:function(x,y){
		 $.contextMenu({
            selector: "body", 
            events:
            {  
               hide:function(){ $.contextMenu( 'destroy' ); }
            },
            callback: $.proxy(function(key, options) 
            {
               switch(key){
               case "delete":
                   // without undo/redo support
              //     this.getCanvas().remove(this);
                   
                   // with undo/redo support
                   var cmd = new draw2d.command.CommandDelete(this);
                   this.getCanvas().getCommandStack().execute(cmd);
               default:
                   break;
               }
            
            },this),
            x:x,
            y:y,
            items: 
            {
                "delete": {name: "Delete", icon: "delete"}
            }
        });
	}


	
});











/***/ }),
/* 23 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.End = draw2d.shape.basic.Circle.extend({
	NAME: "End",
	init: function(){
		this._super();
		
		this.setStroke(3);
		this.setRadius(15);
		this.setBackgroundColor(new draw2d.util.Color("#FF9999"));

        this.setResizeable(false);
		
		var leftLocator = new draw2d.layout.locator.InputPortLocator();
		this.createPort("input",leftLocator);

        this.userData = {
            name: "流程结束",
            id: this.id,
            type: "End",
            label: '流程结束',
        };
	},

    onDoubleClick: function() {},

    onContextMenu:function(x,y){
        $.contextMenu({
            selector: "body",
            events:
                {
                    hide:function(){ $.contextMenu( 'destroy' ); }
                },
            callback: $.proxy(function(key, options)
            {
                switch(key){
                    case "delete":
                        var cmd = new draw2d.command.CommandDelete(this);
                        this.getCanvas().getCommandStack().execute(cmd);
                    default:
                        break;
                }

            },this),
            x:x,
            y:y,
            items:
                {
                    "delete": {name: "Delete", icon: "delete"}
                }
        });
    },

    toProcessElement: function () {
        return '<endEvent id="BPMN_'+this.getId()+'" name="'+this.getUserData().name+'"></endEvent>';
    },

    toDiagramElement: function () {
        return '<bpmndi:BPMNShape bpmnElement="BPMN_'+this.getId()+'" id="BPMN_'+this.getId()+'">' +
            '<omgdc:Bounds height="'+this.getHeight()+'" width="'+this.getWidth()+'" x="'+this.getBoundingBox().getTopLeft().getX()+'" y="'+this.getBoundingBox().getTopLeft().getY()+'"></omgdc:Bounds>' +
            '</bpmndi:BPMNShape>';
    },
});

/***/ }),
/* 24 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.RoleTaskText = draw2d.shape.basic.Text.extend({
	NAME: "aflowRoleTaskText",
	
	init: function(text){
		this._super();
		this.setText(text);
		this.setFontFamily("微软雅黑");
		this.setStroke(0);
		
		this.installEditor(new draw2d.ui.LabelInplaceEditor({
		   onCommit: $.proxy(function(value){
			   this.getParent().userData.name = value;
		   },this),
		   onCancel: function(){
		   }
		}));
	}
});

com.chanjet.gzq.aflow.RoleTaskImage = draw2d.shape.basic.Image.extend({
    NAME: "RoleTaskImage",

    init: function(path){
        this._super();
        this.setPath(path);

        this.setDimension(60,60);

        this.on("contextmenu", function(emitterFunction){
            var parent = emitterFunction.parent;
            parent.onContextMenu(emitterFunction.x, emitterFunction.y);
        });
    }
});

com.chanjet.gzq.aflow.RoleTask = draw2d.shape.basic.Rectangle.extend({

	NAME: "RoleTask",
    IMAGE: null,

	init: function(){
		this._super();
		
		this.setStroke(1);
		this.setDimension(60,60);
		this.setBackgroundColor(new draw2d.util.Color("#ffffff"));
		// this.setRadius(32);


        this.setResizeable(false);
		
		var roleTaskText = new com.chanjet.gzq.aflow.RoleTaskText("管理角色");
		var roleTaskTextLocation = new draw2d.layout.locator.BottomLocator();
		this.add(roleTaskText, roleTaskTextLocation, 1);

        this.IMAGE = new com.chanjet.gzq.aflow.UserTaskImage("styles/icons/role.png");
        var userTaskImageLocation = new draw2d.layout.locator.CenterLocator();
        this.add(this.IMAGE, userTaskImageLocation,1);
		
		var leftLocator = new draw2d.layout.locator.InputPortLocator();
		this.createPort("input",leftLocator);
		
		
		var rightLocator = new draw2d.layout.locator.OutputPortLocator();
		p = this.createPort("output",rightLocator);
        p.setMaxFanOut(1);

        this.userData = {
            name: "管理角色",
            id: this.id,
            type: "RoleTask",
            label: roleTaskText.getText(),
            roleIds:'',
            avator:'',
        };
	},

    setImage: function(url) {
        this.IMAGE.setPath(url);
    },

    onDoubleClick: function() {},
	
	 /**
     *
     *  Called if the user drop this element onto the dropTarget. 
     * 
     *  will create a "smart insert" of an existing connection.
     * 	COOL and fast network editing.
     * 
     * @param {draw2d.Figure} dropTarget The drop target.
     * @param {Number} x the x coordinate of the drop
     * @param {Number} y the y coordinate of the drop
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
	onDrop: function(dropTarget,x,y,shiftKey,ctrlKey){
		// Activate a "smart insert" If the user drop this figure on connection
    	if(dropTarget instanceof draw2d.Connection){
		
			var oldSource = dropTarget.getSource();
			
			dropTarget.setSource(this.getOutputPort(0));
			
			var cmd = new draw2d.command.CommandConnect(this.getCanvas(),oldSource,this.getInputPort(0));
			this.getCanvas().getCommandStack().execute(cmd);
			
    	}
	},
	
	onContextMenu:function(x,y){
		 $.contextMenu({
            selector: "body", 
            events:
            {  
               hide:function(){ $.contextMenu( 'destroy' ); }
            },
             callback: $.proxy(function(key, options) {
                 switch(key){
                     case "delete":
                         var cmd = new draw2d.command.CommandDelete(this);
                         this.getCanvas().getCommandStack().execute(cmd);
                         break;
                     case "appendUserTask":
                         app.canvas.appendTask(this, 'UserTask');
                         break;
                     case "appendRoleTask":
                         app.canvas.appendTask(this, 'RoleTask');
                         break;
                     case "convertToUserTask":
                         app.canvas.convertTaskType(this, "UserTask");
                         break;
                     default:
                         break;
                 }

             },this),
            x:x,
            y:y,
            items: 
            {
                "delete": {name: "删除", icon: "delete"},
                "sep1":   "---------",
                "appendUserTask": {name: "添加一个固定审批人员节点", icon: ""},
                "appendRoleTask": {name: "添加一个上级主管节点", icon: ""},
                "sep2":   "---------",
                "convertToUserTask": {name: "节点变更为固定审批人员节点", icon: ""},
            }
        });
	},

    toProcessElement: function () {
        return '<userTask id="BPMN_'+this.getId()+'" name="'+this.getUserData().name+'" activiti:assignee="${userService.findManagerForEmployee('+this.getUserData().userIds+')}">' +
            '<extensionElements>'+
            '<activiti:taskListener event="create" class="com.chanjet.gongzuoquan.workflow.activiticustom.TaskCustomService"></activiti:taskListener>'+
            '</extensionElements>' +
            '</userTask>';
    },

    toDiagramElement: function () {
        return '<bpmndi:BPMNShape bpmnElement="BPMN_'+this.getId()+'" id="BPMN_'+this.getId()+'">' +
            '<omgdc:Bounds height="'+this.getHeight()+'" width="'+this.getWidth()+'" x="'+this.getBoundingBox().getTopLeft().getX()+'" y="'+this.getBoundingBox().getTopLeft().getY()+'"></omgdc:Bounds>' +
            '</bpmndi:BPMNShape>';
    },
	
});











/***/ }),
/* 25 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.Start = draw2d.shape.basic.Circle.extend({
	NAME: "Start",
	init: function(){
		this._super();
		
		this.setStroke(1);
		this.setRadius(15);
		this.setBackgroundColor(new draw2d.util.Color("#99FF99"));

        this.setResizeable(false);
		
		var rightLocator = new draw2d.layout.locator.OutputPortLocator();
		var p = this.createPort("output",rightLocator);
        p.setMaxFanOut(1);

        this.userData = {
            name: "流程开始",
            id: this.id,
            type: "Start",
            label: '流程开始',
        };
	},

    onDoubleClick: function() {},

    onContextMenu:function(x,y){
        $.contextMenu({
            selector: "body",
            events:
                {
                    hide:function(){ $.contextMenu( 'destroy' ); }
                },
            callback: $.proxy(function(key, options)
            {
                switch(key){
                    case "delete":
                        var cmd = new draw2d.command.CommandDelete(this);
                        this.getCanvas().getCommandStack().execute(cmd);
                    default:
                        break;
                }

            },this),
            x:x,
            y:y,
            items:
                {
                    "delete": {name: "Delete", icon: "delete"}
                }
        });
    },

    toProcessElement: function () {
        return '<startEvent id="BPMN_'+this.getId()+'" name="'+this.getUserData().name+'"></startEvent>';
    },

    toDiagramElement: function () {
        return '<bpmndi:BPMNShape bpmnElement="BPMN_'+this.getId()+'" id="BPMN_'+this.getId()+'">' +
            '<omgdc:Bounds height="'+this.getHeight()+'" width="'+this.getWidth()+'" x="'+this.getBoundingBox().getTopLeft().getX()+'" y="'+this.getBoundingBox().getTopLeft().getY()+'"></omgdc:Bounds>' +
            '</bpmndi:BPMNShape>';
    },
});

/***/ }),
/* 26 */
/***/ (function(module, exports) {

com.chanjet.gzq.aflow.UserTaskText = draw2d.shape.basic.Text.extend({
	NAME: "UserTaskText",
	
	init: function(text){
		this._super();
		this.setText(text);
		this.setFontFamily("微软雅黑");
		this.setStroke(0);

        this.installEditor(new draw2d.ui.LabelInplaceEditor({
            onCommit: $.proxy(function(value){
                this.getParent().userData.name = value;
            },this),
            onCancel: function(){
            }
        }));
	}
});

com.chanjet.gzq.aflow.UserTaskImage = draw2d.shape.basic.Image.extend({
    NAME: "UserTaskImage",

    init: function(path){
        this._super();
        this.setPath(path);
        this.setDimension(60, 60);

        this.on("contextmenu", function(emitterFunction){
            var parent = emitterFunction.parent;
            parent.onContextMenu(emitterFunction.x, emitterFunction.y);
        });

    },

});

com.chanjet.gzq.aflow.UserTask = draw2d.shape.basic.Rectangle.extend({

	NAME: "UserTask",

    IMAGE: null,

	init: function(){
		this._super();
		
		this.setStroke(1);
		this.setDimension(60,60);
		// this.setRadius(32);
		this.setBackgroundColor(new draw2d.util.Color("#ffffff"));
		this.setRadius(1);

        this.setResizeable(false);

		var userTaskText = new com.chanjet.gzq.aflow.UserTaskText("固定人员");
		var userTaskTextLocation = new draw2d.layout.locator.BottomLocator();
		this.add(userTaskText, userTaskTextLocation,1);

        this.IMAGE = new com.chanjet.gzq.aflow.UserTaskImage("styles/icons/user.png");
        var userTaskImageLocation = new draw2d.layout.locator.CenterLocator();
        this.add(this.IMAGE, userTaskImageLocation,1);
		
		var leftLocator = new draw2d.layout.locator.InputPortLocator();
		this.createPort("input",leftLocator);

		var rightLocator = new draw2d.layout.locator.OutputPortLocator();
		var p = this.createPort("output",rightLocator);
        p.setMaxFanOut(1);
		
		this.userData = {
			name: "固定人员",
			id: this.id,
			type: "UserTask",
            label: userTaskText.getText(),
            userIds:'',
            avator:'',
		};
	},

    setImage: function(url) {
        this.IMAGE.setPath(url);
    },

	onDrop: function(dropTarget,x,y,shiftKey,ctrlKey){
		// Activate a "smart insert" If the user drop this figure on connection
    	if(dropTarget instanceof draw2d.Connection){
		
			var oldSource = dropTarget.getSource();
			
			dropTarget.setSource(this.getOutputPort(0));

			var cmd = new draw2d.command.CommandConnect(this.getCanvas(),oldSource,this.getInputPort(0));
			this.getCanvas().getCommandStack().execute(cmd);
    	}
	},

    onDoubleClick: function() {
        this.onContextMenu(x, y);
	},
	
	onContextMenu:function(x,y){
		 $.contextMenu({
			 selector: "body",
			 events: {
               	hide:function(){ $.contextMenu( 'destroy' ); }
			 },
			 callback: $.proxy(function(key, options) {
				 switch(key){
					 case "delete":
               			var cmd = new draw2d.command.CommandDelete(this);
               			this.getCanvas().getCommandStack().execute(cmd);
                         break;
					 case "appendUserTask":
                   		app.canvas.appendTask(this, 'UserTask');
                         break;
                     case "appendRoleTask":
                         app.canvas.appendTask(this, 'RoleTask');
                         break;
					 case "convertToRoleTask":
					 	 app.canvas.convertTaskType(this, "RoleTask");
                         break;
                     default:
                        break;
                 }
            
             },this),
             x:x,
             y:y,
             items: {
                "delete": {name: "删除", icon: "delete"},
                 "sep1":   "---------",
                "appendUserTask": {name: "添加一个固定审批人员节点", icon: ""},
                "appendRoleTask": {name: "添加一个上级主管节点", icon: ""},
                 "sep2":   "---------",
                "convertToRoleTask": {name: "节点变更为上级主管节点", icon: ""},
             }
		 });
	},

    toProcessElement: function () {
        return '<userTask id="BPMN_'+this.getId()+'" name="'+this.getUserData().name+'" activiti:assignee="'+this.getUserData().userIds+'">' +
               '<extensionElements>'+
               '<activiti:taskListener event="create" class="com.chanjet.gongzuoquan.workflow.activiticustom.TaskCustomService"></activiti:taskListener>'+
               '</extensionElements>' +
               '</userTask>';
    },

    toDiagramElement: function () {
        return '<bpmndi:BPMNShape bpmnElement="BPMN_'+this.getId()+'" id="BPMN_'+this.getId()+'">' +
               '<omgdc:Bounds height="'+this.getHeight()+'" width="'+this.getWidth()+'" x="'+this.getBoundingBox().getTopLeft().getX()+'" y="'+this.getBoundingBox().getTopLeft().getY()+'"></omgdc:Bounds>' +
               '</bpmndi:BPMNShape>';
    },
	
});


/***/ }),
/* 27 */
/***/ (function(module, exports) {

/**
 * Created by David on 2017/3/28.
 */

var app;

$(window).load(function () {
    //-- 2. activiti-designer的连接器(全局)

    app = new com.chanjet.gzq.aflow.Application();
    load();

    app.canvas.getCommandStack().addEventListener(function (e) {
        if (e.isPostChangeEvent()) {
            // updatePreview(app.canvas);
            displayJSON(app.canvas);
            displayXML(app.canvas);
        }
    });

    app.canvas.on("select, click", function (e, i) {
        console.log("select, click" + i + e);

        if (e.selection.primary == null) {
            $('#propGrid').jqPropertyGrid(app.canvas.userData, options);
            return;
        }

        if(e.selection.primary.userData == null) {
            e.selection.primary.userData = {};
        }
        $('#propGrid').jqPropertyGrid(e.selection.primary.userData, options);
    });

    $('#propGrid').on("change blur", function (e) {

        var id = afterDigit(e.target.id);

        if( app.canvas.selection.primary != null) {
            //tasks
            if( app.canvas.selection.primary.userData != null) {
                app.canvas.selection.primary.userData[id] = e.target.value;

                if (app.canvas.selection.primary.userData['expression'] != null) {
                    app.canvas.selection.primary.showExpression();
                }

                if (app.canvas.selection.primary.userData['avator'] != null) {
                    app.canvas.selection.primary.setImage(e.target.value);
                }
            }
        }
        else {
            // canvas
            app.canvas.userData[id] = e.target.value;
        }
        displayJSON(app.canvas);
        displayXML(app.canvas);
    });

});

function afterDigit(str) {
    for (var i = str.length - 1; i >= 0; i--) {
        if (isDigit(str[i])) {
            return str.substring(i + 1, str.length);
        }
    }
    return str;
}

function isDigit(s)
{
    var patrn = /^[0-9]{1,20}$/;
    if (!patrn.exec(s))
        return false;
    return true;
}

function updatePreview(canvas) {

    var xCoords = [];
    var yCoords = [];
    canvas.getFigures().each(function (i, f) {
        var b = f.getBoundingBox();
        xCoords.push(b.x, b.x + b.w);
        yCoords.push(b.y, b.y + b.h);
    });

    var minX = Math.min.apply(Math, xCoords);
    var minY = Math.min.apply(Math, yCoords);
    var width = Math.max.apply(Math, xCoords) - minX;
    var height = Math.max.apply(Math, yCoords) - minY;

    var writer = new draw2d.io.png.Writer();

    writer.marshal(canvas, function (png) {
        $("#preview").attr("src", png);
    }, new draw2d.geo.Rectangle(minX, minY, width, height));

}
function displayJSON(canvas) {

    var writer = new draw2d.io.json.Writer();
    writer.marshal(canvas, function (json) {
        var jsonText = JSON.stringify(json, null, 2);
        $("#jsonOutput").text(jsonText);
    });
}

function displayXML(canvas) {
    //
    var writer = new draw2d.io.xml.Writer();
    writer.marshal(canvas, function (obj, xml) {
        $("#xmlOutput").text(xml);
    });
}

function save() {
    var jsonArgs;
    var writer = new draw2d.io.json.Writer();
    writer.marshal(app.canvas, function (json) {
        jsonArgs = JSON.stringify(json, null, 2);
    });
    $.post('http://127.0.0.1:8080/aflow/definition', {
        orgId:'123',
        userId:'456',
        name: app.canvas.userData['name'],
        json: jsonArgs ,
    }, function (result) {
        console.log(result);
    })
}

function load() {

    var json;
    $.getJSON("http://localhost:8888/", function (result) {
        json = result;
    }).fail(function () {

        var shape = new com.chanjet.gzq.aflow.Start();
        var command = new draw2d.command.CommandAdd(app.canvas, shape, 100, 300);
        app.canvas.getCommandStack().execute(command);// 放入堆栈，撤销或者重做
        json = null;
        var writer = new draw2d.io.json.Writer();
        writer.marshal(app.canvas, function (json) {
            json = JSON.stringify(json, null, 2);
        });

    }).always(function () {

        if (json != null) {
            app.loadFigure(json);
        }
        // displayJSON(app.canvas);
        updatePreview(app.canvas);
        displayXML(app.canvas);
    });
}

function showWizard() {
    myWizard.style.display="block";
}

function addCase() {
    $("#title").after("<input type='text' placeholder='表单字段' business-meta='case'><br />");
}



/***/ }),
/* 28 */
/***/ (function(module, exports) {

/**
 * jqPropertyGrid
 * https://github.com/ValYouW/jqPropertyGrid
 * Author: YuvalW (ValYouW)
 * License: MIT
 */

/**
 * @typedef {object} JQPropertyGridOptions
 * @property {object} meta - A metadata object describing the obj properties
 */

/* jshint -W089 */

(function($) { // jscs:ignore requireNamedUnassignedFunctions
	var OTHER_GROUP_NAME = 'Other';
	var GET_VALS_FUNC_KEY = 'pg.getValues';
	var pgIdSequence = 0;

	/**
	 * Generates the property grid
	 * @param {object} obj - The object whose properties we want to display
	 * @param {JQPropertyGridOptions} options - Options object for the component
	 */
	$.fn.jqPropertyGrid = function(obj, options) {
		// Check if the user called the 'get' function (to get the values back from the grid).
		if (typeof obj === 'string' && obj === 'get') {
			if (typeof this.data(GET_VALS_FUNC_KEY) === 'function') {
				return this.data(GET_VALS_FUNC_KEY)();
			}

			return null;
		} else if (typeof obj === 'string') {
			console.error('jqPropertyGrid got invalid option:', obj);
			return;
		} else if (typeof obj !== 'object' || obj === null) {
			console.error('jqPropertyGrid must get an object in order to initialize the grid.');
			return;
		}

		// Normalize options
		options = options && typeof options === 'object' ? options : {};
		options.meta = options.meta && typeof options.meta === 'object' ? options.meta : {};

		// Seems like we are ok to create the grid
		var meta = options.meta;
		var propertyRowsHTML = {OTHER_GROUP_NAME: ''};
		var groupsHeaderRowHTML = {};
		var postCreateInitFuncs = [];
		var getValueFuncs = {};
		var pgId = 'pg' + (pgIdSequence++);

		var currGroup;
		for (var prop in obj) {
			// Skip if this is not a direct property, a function, or its meta says it's non browsable
			if (!obj.hasOwnProperty(prop) || typeof obj[prop] === 'function' || (meta[prop] && meta[prop].browsable === false)) {
				continue;
			}

			// Check what is the group of the current property or use the default 'Other' group
			currGroup = (meta[prop] && meta[prop].group) || OTHER_GROUP_NAME;

			// If this is the first time we run into this group create the group row
			if (currGroup !== OTHER_GROUP_NAME && !groupsHeaderRowHTML[currGroup]) {
				groupsHeaderRowHTML[currGroup] = getGroupHeaderRowHtml(currGroup);
			}

			// Initialize the group cells html
			propertyRowsHTML[currGroup] = propertyRowsHTML[currGroup] || '';

			// Append the current cell html into the group html
			propertyRowsHTML[currGroup] += getPropertyRowHtml(pgId, prop, obj[prop], meta[prop], postCreateInitFuncs, getValueFuncs);
		}

		// Now we have all the html we need, just assemble it
		var innerHTML = '<table class="pgTable">';
		for (var group in groupsHeaderRowHTML) {
			// Add the group row
			innerHTML += groupsHeaderRowHTML[group];
			// Add the group cells
			innerHTML += propertyRowsHTML[group];
		}

		// Finally we add the 'Other' group (if we have something there)
		if (propertyRowsHTML[OTHER_GROUP_NAME]) {
			innerHTML += getGroupHeaderRowHtml(OTHER_GROUP_NAME);
			innerHTML += propertyRowsHTML[OTHER_GROUP_NAME];
		}

		// Close the table and apply it to the div
		innerHTML += '</table>';
		this.html(innerHTML);

		// Call the post init functions
		for (var i = 0; i < postCreateInitFuncs.length; ++i) {
			if (typeof postCreateInitFuncs[i] === 'function') {
				postCreateInitFuncs[i]();
				// just in case make sure we are not holding any reference to the functions
				postCreateInitFuncs[i] = null;
			}
		}

		// Create a function that will return tha values back from the property grid
		var getValues = function() {
			var result = {};
			for (var prop in getValueFuncs) {
				if (typeof getValueFuncs[prop] !== 'function') {
					continue;
				}

				result[prop] = getValueFuncs[prop]();
			}

			return result;
		};

		this.data(GET_VALS_FUNC_KEY, getValues);
	};

	/**
	 * Gets the html of a group header row
	 * @param {string} displayName - The group display name
	 */
	function getGroupHeaderRowHtml(displayName) {
		return '<tr class="pgGroupRow"><td colspan="2" class="pgGroupCell">' + displayName + '</td></tr>';
	}

	/**
	 * Gets the html of a specific property row
	 * @param {string} pgId - The property-grid id being rendered
	 * @param {string} name - The property name
	 * @param {*} value - The current property value
	 * @param {object} meta - A metadata object describing this property
	 * @param {function[]} [postCreateInitFuncs] - An array to fill with functions to run after the grid was created
	 * @param {object.<string, function>} [getValueFuncs] - A dictionary where the key is the property name and the value is a function to retrieve the propery selected value
	 */
	function getPropertyRowHtml(pgId, name, value, meta, postCreateInitFuncs, getValueFuncs) {
		if (!name) {
			return '';
		}

		meta = meta || {};
		// We use the name in the meta if available
		var displayName = meta.name || name;
		var type = meta.type || '';
		var elemId = pgId + name;

		var valueHTML;

		// If boolean create checkbox
		if (type === 'boolean' || (type === '' && typeof value === 'boolean')) {
			valueHTML = '<input type="checkbox" id="' + elemId + '" value="' + name + '"' + (value ? ' checked' : '') + ' />';
			if (getValueFuncs) {
				getValueFuncs[name] = function() {
					return $('#' + elemId).prop('checked');
				};
			}

			// If options create drop-down list
		} else if (type === 'options' && Array.isArray(meta.options)) {
			valueHTML = getSelectOptionHtml(elemId, value, meta.options);
			if (getValueFuncs) {
				getValueFuncs[name] = function() {
					return $('#' + elemId).val();
				};
			}

			// If number and a jqueryUI spinner is loaded use it
		} else if (typeof $.fn.spinner === 'function' && (type === 'number' || (type === '' && typeof value === 'number'))) {
			valueHTML = '<input type="text" id="' + elemId + '" value="' + value + '" style="width:50px" />';
			if (postCreateInitFuncs) {
				postCreateInitFuncs.push(initSpinner(elemId, meta.options));
			}

			if (getValueFuncs) {
				getValueFuncs[name] = function() {
					return $('#' + elemId).spinner('value');
				};
			}

			// If color and we have the spectrum color picker use it
		} else if (type === 'color' && typeof $.fn.spectrum === 'function') {
			valueHTML = '<input type="text" id="' + elemId + '" />';
			if (postCreateInitFuncs) {
				postCreateInitFuncs.push(initColorPicker(elemId, value, meta.options));
			}

			if (getValueFuncs) {
				getValueFuncs[name] = function() {
					return $('#' + elemId).spectrum('get').toHexString();
				};
			}

			// If label (for read-only)
		} else if (type === 'label') {
			if (typeof meta.description === 'string' && meta.description) {
				valueHTML = '<label for="' + elemId + '" title="' + meta.description + '">' + value + '</label>';
			} else {
				valueHTML = '<label for="' + elemId + '">' + value + '</label>';
			}

			// Default is textbox
		} else if (type == 'object') {
            valueHTML = '<div id="'+ value['name'] +'"></div>';
        }
		else {
			valueHTML = '<input type="text" id="' + elemId + '" value="' + value + '" />';
			if (getValueFuncs) {
				getValueFuncs[name] = function() {
					return $('#' + elemId).val();
				};
			}
		}

		if (typeof meta.description === 'string' && meta.description &&
			(typeof meta.showHelp === 'undefined' || meta.showHelp)) {
			displayName += '<span class="pgTooltip" title="' + meta.description + '">[?]</span>';
		}

		return '<tr class="pgRow"><td class="pgCell">' + displayName + '</td><td class="pgCell">' + valueHTML + '</td></tr>';
	}

	/**
	 * Gets a select-option (dropdown) html
	 * @param {string} id - The select element id
	 * @param {string} [selectedValue] - The current selected value
	 * @param {*[]} options - An array of option. An element can be an object with value/text pairs, or just a string which is both the value and text
	 * @returns {string} The select element html
	 */
	function getSelectOptionHtml(id, selectedValue, options) {
		id = id || '';
		selectedValue = selectedValue || '';
		options = options || [];

		var html = '<select';
		if (id) {
			html += ' id="' + id + '"';
		}

		html += '>';

		var text;
		var value;
		for (var i = 0; i < options.length; i++) {
			value = typeof options[i] === 'object' ? options[i].value : options[i];
			text = typeof options[i] === 'object' ? options[i].text : options[i];

			html += '<option value="' + value + '"' + (selectedValue === value ? ' selected>' : '>');
			html += text + '</option>';
		}

		html += '</select>';
		return html;
	}

	/**
	 * Gets an init function to a number textbox
	 * @param {string} id - The number textbox id
	 * @param {object} [options] - The spinner options
	 * @returns {function}
	 */
	function initSpinner(id, options) {
		if (!id) {
			return null;
		}
		// Copy the options so we won't change the user "copy"
		var opts = {};
		$.extend(opts, options);

		// Add a handler to the change event to verify the min/max (only if not provided by the user)
		opts.change = typeof opts.change === 'undefined' ? onSpinnerChange : opts.change;

		return function onSpinnerInit() {
			$('#' + id).spinner(opts);
		};
	}

	/**
	 * Gets an init function to a color textbox
	 * @param {string} id - The color textbox id
	 * @param {string} [color] - The current color (e.g #000000)
	 * @param {object} [options] - The color picker options
	 * @returns {function}
	 */
	function initColorPicker(id, color, options) {
		if (!id) {
			return null;
		}

		var opts = {};
		$.extend(opts, options);
		if (typeof color === 'string') {
			opts.color = color;
		}

		return function onColorPickerInit() {
			$('#' + id).spectrum(opts);
		};
	}

	/**
	 * Handler for the spinner change event
	 */
	function onSpinnerChange() {
		var $spinner = $(this);
		var value = $spinner.spinner('value');

		// If the value is null and the real value in the textbox is string we empty the textbox
		if (value === null && typeof $spinner.val() === 'string') {
			$spinner.val('');
			return;
		}

		// Now check that the number is in the min/max range.
		var min = $spinner.spinner('option', 'min');
		var max = $spinner.spinner('option', 'max');
		if (typeof min === 'number' && this.value < min) {
			this.value = min;
			return;
		}

		if (typeof max === 'number' && this.value > max) {
			this.value = max;
		}
	}
})(window.$);


/***/ }),
/* 29 */
/***/ (function(module, exports) {

/**
 * Created by David on 2017/2/27.
 */
var theOperators = [
    {
        text:'',
        value:0
    },
    {
        text:'>',
        value:1
    },
    {
        text:'>=',
        value:2
    },
    {
        text:'<',
        value:3
    },
    {
        text:'<=',
        value:4
    },
    {
        text:'等于',
        value:5
    },
    {
        text:'不等于',
        value:6
    },
    {
        text:'缺省',
        value:7
    },
];


/***/ }),
/* 30 */
/***/ (function(module, exports) {

/**
 * Created by David on 2017/2/20.
 */
var theMeta = {
    id: {
        browsable: true,
        group: "基本属性",
        type: 'text',
        name: "ID",
        readonly: "true",
    },
    type: {
        browsable: true,
        group: "基本属性",
        type: 'text',
        name: "类型",
        readonly: "true",
    },
    color: {
        browsable: true,
        group: "基本属性",
        type: 'color',
        name: "颜色",
        readonly: "true",
    },
    name: {
        browsable: true,
        group: "基本属性",
        type: 'label',
        name: "名称",
        readonly: "true",
    },
    label: {
        browsable: true,
        group: "基本属性",
        type: 'text',
        name: "标签",
        readonly: "true",
    },
    templateId: {
        browsable: true,
        group: "条件属性",
        type: 'text',
        name: "模版ID",
        readonly: "false",
    },
    templateName: {
        browsable: true,
        group: "条件属性",
        type: 'text',
        name: "模版名称",
        readonly: "false",
    },
    fieldId: {
        browsable: true,
        group: "条件属性",
        type: 'text',
        name: "字段ID",
        readonly: "false",
    },
    fieldName: {
        browsable: true,
        group: "条件属性",
        type: 'text',
        name: "字段名称",
        readonly: "false",
    },
    formTemplateName: {
        browsable: true,
        group: "条件属性",
        type: 'text',
        name: "表单模版",
        readonly: "false",
    },
    formTemplateId: {
        browsable: true,
        group: "条件属性",
        type: 'text',
        name: "表单模版ID",
        readonly: "false",
    },


    inputPorts: {
        browsable: true,
        group: "连接",
        type: 'object',
        name: "输入",
    },
    outputPorts: {
        browsable: true,
        group: "连接",
        type: 'outputPorts',
        name: "输出",
    },

    from: {
        browsable: true,
        group: "连接",
        type: 'text',
        name: "起点",
    },
    to: {
        browsable: true,
        group: "连接",
        type: 'text',
        name: "终点",
    },

    operator: {
        browsable: false,
        group: "条件设置",
        type: 'options',
        options: theOperators,
        name: "运算符",
    },
    expression: {
        browsable: true,
        group: "条件设置",
        type: 'text',
        name: "取值",
    },

    roleIds: {
        browsable: true,
        group: "审批人设置",
        type: 'text',
        name: "角色",
    },
    userIds: {
        browsable: true,
        group: "审批人设置",
        type: 'text',
        name: "审批人",
    },
    help: {
        browsable: true,
        group: "帮助",
        type: 'label',
        name: "帮助",
    },


};
var options = {
    meta: theMeta
};

/***/ }),
/* 31 */
/***/ (function(module, exports) {

/**
 * Define ToolBar For ProcessDesigner
 *
 * @author RanJi (����Ҳ����)
 * @date 2014-12-09
 */
 com.chanjet.gzq.aflow.ToolBar = Class.extend({
	toolBarName: 'com.chanjet.gzq.aflow.ToolBar',
	/**
	 * view: ��������Ҫ�����Ļ���
	 */
	init: function(view){
		this.view = view;
		
		this.editMenu = $('#edit-menu');
		this.undoMenuItem = $('#undoButton');
		this.redoMenuItem = $('#redoButton');
		
		view.getCommandStack().addEventListener(this);
		
		this.undoMenuItem.click($.proxy(function(){
			this.view.getCommandStack().undo();
			
		},this));
		this.redoMenuItem.click($.proxy(function(){
			this.view.getCommandStack().redo();
		},this));
		
	},

	stackChanged: function(event){
		 this.disableMenuItem(this.undoMenuItem, !event.getStack().canUndo());
		 this.disableMenuItem(this.redoMenuItem, !event.getStack().canRedo());
	},
	
	disableMenuItem: function(menuItem,flag){
		if(flag){
			this.editMenu.menu('disableItem',menuItem);
		}else{
			this.editMenu.menu('enableItem',menuItem);
		}
	}
 });

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(57);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./designer.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./designer.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(58);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./jqPropertyGrid.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./jqPropertyGrid.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(59);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./wizard.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./wizard.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(61);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../node_modules/css-loader/index.js!./icon.css", function() {
			var newContent = require("!!../../../node_modules/css-loader/index.js!./icon.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(62);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../node_modules/css-loader/index.js!./jquery.contextmenu.css", function() {
			var newContent = require("!!../../../../node_modules/css-loader/index.js!./jquery.contextmenu.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(63);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(2)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../node_modules/css-loader/index.js!./pace-theme-loading-bar.css", function() {
			var newContent = require("!!../../../../../node_modules/css-loader/index.js!./pace-theme-loading-bar.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 38 */
/***/ (function(module, exports) {

/*!
 * Bootstrap v3.3.6 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1||b[0]>2)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.6",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.6",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is('input[type="radio"]')||a(c.target).is('input[type="checkbox"]')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.6",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger(a.Event("hidden.bs.dropdown",f)))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.6",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger(a.Event("shown.bs.dropdown",h))}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.6",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.6",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");
d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.6",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);

/***/ }),
/* 39 */
/***/ (function(module, exports) {

/**
 * @class draw2d
 * global namespace declarations
 *
 * @private
 */
var draw2d =
    {
        geo: {},

        io: {
            json: {},
            png: {},
            svg: {},
            xml: {},
        },


        storage: {},

        util: {
            spline: {}
        },

        shape: {
            basic: {},
            composite: {},
            arrow: {},
            node: {},
            note: {},
            diagram: {},
            analog: {},
            icon: {},
            layout: {},
            pert: {},
            state: {},
            widget: {}
        },

        policy: {
            canvas: {},
            line: {},
            port: {},
            figure: {}
        },

        command: {},

        decoration: {
            connection: {}
        },

        layout: {
            connection: {},
            anchor: {},
            mesh: {},
            locator: {}
        },


        ui: {},

        isTouchDevice: (
            //Detect iPhone
            (navigator.platform.indexOf("iPhone") != -1) ||
            //Detect iPod
            (navigator.platform.indexOf("iPod") != -1) ||
            //Detect iPad
            (navigator.platform.indexOf("iPad") != -1)
        )

    };


// Production steps of ECMA-262, Edition 5, 15.4.4.21
// Reference: http://es5.github.io/#x15.4.4.21
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Browser_compatibility
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function (callback /*, initialValue*/) {
        'use strict';
        if (this == null) {
            throw new TypeError('Array.prototype.reduce called on null or undefined');
        }
        if (typeof callback !== 'function') {
            throw new TypeError(callback + ' is not a function');
        }
        var t = Object(this), len = t.length >>> 0, k = 0, value;
        if (arguments.length == 2) {
            value = arguments[1];
        } else {
            while (k < len && !k in t) {
                k++;
            }
            if (k >= len) {
                throw new TypeError('Reduce of empty array with no initial value');
            }
            value = t[k++];
        }
        for (; k < len; k++) {
            if (k in t) {
                value = callback(value, t[k], k, t);
            }
        }
        return value;
    };
}
draw2d.util.Base64 = {

    /**
     * Maps bytes to characters.
     * @type {Object}
     * @private
     */
    byteToCharMap_: null,


    /**
     * Maps characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMap_: null,


    /**
     * Maps bytes to websafe characters.
     * @type {Object}
     * @private
     */
    byteToCharMapWebSafe_: null,

    /**
     * Maps websafe characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMapWebSafe_: null,


    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type {string}
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',

    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type {string}
     */
    ENCODED_VALS: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + '+/=',


    /**
     * Our websafe alphabet.
     * @type {string}
     */
    ENCODED_VALS_WEBSAFE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + '-_.',


    encodeByteArray: function (input, opt_webSafe) {
        draw2d.util.Base64.init();

        var byteToCharMap = opt_webSafe ? draw2d.util.Base64.byteToCharMapWebSafe_ : draw2d.util.Base64.byteToCharMap_;

        var output = [];

        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;

            var outByte1 = byte1 >> 2;
            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);
            var outByte4 = byte3 & 0x3F;

            if (!haveByte3) {
                outByte4 = 64;

                if (!haveByte2) {
                    outByte3 = 64;
                }
            }

            output.push(byteToCharMap[outByte1],
                byteToCharMap[outByte2],
                byteToCharMap[outByte3],
                byteToCharMap[outByte4]);
        }

        return output.join('');
    },


    /**
     * @method
     * Base64-encode a string.
     *
     * @param {string} input A string to encode.
     * @param {boolean=} opt_webSafe If true, we should use the alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encode: function (input, opt_webSafe) {
        return draw2d.util.Base64.encodeByteArray(draw2d.util.Base64.stringToByteArray(input), opt_webSafe);
    },


    /**
     * @method
     * Base64-decode a string.
     *
     * @param {String} input to decode (length not required to be a multiple of 4).
     * @param {boolean=} opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return {Array} bytes representing the decoded value.
     */
    decode: function (input, opt_webSafe) {
        draw2d.util.Base64.init();

        var charToByteMap = opt_webSafe ? draw2d.util.Base64.charToByteMapWebSafe_ : draw2d.util.Base64.charToByteMap_;

        var output = [];

        for (var i = 0; i < input.length;) {
            var byte1 = charToByteMap[input.charAt(i++)];

            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;

            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 0;
            ++i;

            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 0;
            ++i;

            if (byte1 == null || byte2 == null ||
                byte3 == null || byte4 == null) {
                throw Error();
            }

            var outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);

            if (byte3 != 64) {
                var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);
                output.push(outByte2);

                if (byte4 != 64) {
                    var outByte3 = ((byte3 << 6) & 0xC0) | byte4;
                    output.push(outByte3);
                }
            }
        }

        return output;
    },

    /**
     * Turns a string into an array of bytes; a "byte" being a JS number in the
     * range 0-255.
     * @param {string} str String value to arrify.
     * @return {!Array.<number>} Array of numbers corresponding to the
     *     UCS character codes of each character in str.
     */
    stringToByteArray: function (str) {
        var output = [], p = 0;
        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            while (c > 0xff) {
                output[p++] = c & 0xff;
                c >>= 8;
            }
            output[p++] = c;
        }
        return output;
    },

    init: function () {
        if (!draw2d.util.Base64.byteToCharMap_) {
            draw2d.util.Base64.byteToCharMap_ = {};
            draw2d.util.Base64.charToByteMap_ = {};
            draw2d.util.Base64.byteToCharMapWebSafe_ = {};
            draw2d.util.Base64.charToByteMapWebSafe_ = {};

            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < draw2d.util.Base64.ENCODED_VALS.length; i++) {
                draw2d.util.Base64.byteToCharMap_[i] = draw2d.util.Base64.ENCODED_VALS.charAt(i);
                draw2d.util.Base64.charToByteMap_[draw2d.util.Base64.byteToCharMap_[i]] = i;
                draw2d.util.Base64.byteToCharMapWebSafe_[i] = draw2d.util.Base64.ENCODED_VALS_WEBSAFE.charAt(i);
                draw2d.util.Base64.charToByteMapWebSafe_[draw2d.util.Base64.byteToCharMapWebSafe_[i]] = i;
            }
        }
    }
};
/*!
 * JavaScript Debug - v0.4 - 6/22/2010
 * http://benalman.com/projects/javascript-debug-console-log/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 *
 * With lots of help from Paul Irish!
 * http://paulirish.com/
 */

// Script: JavaScript Debug: A simple wrapper for console.log
//
// *Version: 0.4, Last Updated: 6/22/2010*
//
// Tested with Internet Explorer 6-8, Firefox 3-3.6, Safari 3-4, Chrome 3-5, Opera 9.6-10.5
//
// Home       - http://benalman.com/projects/javascript-debug-console-log/
// GitHub     - http://github.com/cowboy/javascript-debug/
// Source     - http://github.com/cowboy/javascript-debug/raw/master/ba-debug.js
// (Minified) - http://github.com/cowboy/javascript-debug/raw/master/ba-debug.min.js (1.1kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Support and Testing
//
// Information about what browsers this code has been tested in.
//
// Browsers Tested - Internet Explorer 6-8, Firefox 3-3.6, Safari 3-4, Chrome
// 3-5, Opera 9.6-10.5
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Examples - http://benalman.com/code/projects/javascript-debug/examples/debug/
//
// About: Revision History
//
// 0.4 - (6/22/2010) Added missing passthrough methods: exception,
//       groupCollapsed, table
// 0.3 - (6/8/2009) Initial release
//
// Topic: Pass-through console methods
//
// assert, clear, count, dir, dirxml, exception, group, groupCollapsed,
// groupEnd, profile, profileEnd, table, time, timeEnd, trace
//
// These console methods are passed through (but only if both the console and
// the method exists), so use them without fear of reprisal. Note that these
// methods will not be passed through if the logging level is set to 0 via
// <debug.setLevel>.

window.debug = (function () {
    var window = this,

        // Some convenient shortcuts.
        aps = Array.prototype.slice,
        con = window.console,

        // Public object to be returned.
        that = {},

        callback_func,
        callback_force,

        // Default logging level, show everything.
        log_level = 9,

        // Logging methods, in "priority order". Not all console implementations
        // will utilize these, but they will be used in the callback passed to
        // setCallback.
        log_methods = ['error', 'warn', 'info', 'debug', 'log'],

        // Pass these methods through to the console if they exist, otherwise just
        // fail gracefully. These methods are provided for convenience.
        pass_methods = 'assert clear count dir dirxml exception group groupCollapsed groupEnd profile profileEnd table time timeEnd trace'.split(' '),
        idx = pass_methods.length,

        // Logs are stored here so that they can be recalled as necessary.
        logs = [];

    while (--idx >= 0) {
        (function (method) {

            // Generate pass-through methods. These methods will be called, if they
            // exist, as long as the logging level is non-zero.
            that[method] = function () {
                log_level !== 0 && con && con[method]
                && con[method].apply(con, arguments);
            };

        })(pass_methods[idx]);
    }

    idx = log_methods.length;
    while (--idx >= 0) {
        (function (idx, level) {

            // Method: debug.log
            //
            // Call the console.log method if available. Adds an entry into the logs
            // array for a callback specified via <debug.setCallback>.
            //
            // Usage:
            //
            //  debug.log( object [, object, ...] );                               - -
            //
            // Arguments:
            //
            //  object - (Object) Any valid JavaScript object.

            // Method: debug.debug
            //
            // Call the console.debug method if available, otherwise call console.log.
            // Adds an entry into the logs array for a callback specified via
            // <debug.setCallback>.
            //
            // Usage:
            //
            //  debug.debug( object [, object, ...] );                             - -
            //
            // Arguments:
            //
            //  object - (Object) Any valid JavaScript object.

            // Method: debug.info
            //
            // Call the console.info method if available, otherwise call console.log.
            // Adds an entry into the logs array for a callback specified via
            // <debug.setCallback>.
            //
            // Usage:
            //
            //  debug.info( object [, object, ...] );                              - -
            //
            // Arguments:
            //
            //  object - (Object) Any valid JavaScript object.

            // Method: debug.warn
            //
            // Call the console.warn method if available, otherwise call console.log.
            // Adds an entry into the logs array for a callback specified via
            // <debug.setCallback>.
            //
            // Usage:
            //
            //  debug.warn( object [, object, ...] );                              - -
            //
            // Arguments:
            //
            //  object - (Object) Any valid JavaScript object.

            // Method: debug.error
            //
            // Call the console.error method if available, otherwise call console.log.
            // Adds an entry into the logs array for a callback specified via
            // <debug.setCallback>.
            //
            // Usage:
            //
            //  debug.error( object [, object, ...] );                             - -
            //
            // Arguments:
            //
            //  object - (Object) Any valid JavaScript object.

            that[level] = function () {
                var args = aps.call(arguments),
                    log_arr = [level].concat(args);

                logs.push(log_arr);
                exec_callback(log_arr);

                if (!con || !is_level(idx)) {
                    return;
                }

                con.firebug ? con[level].apply(window, args)
                    : con[level] ? con[level](args)
                        : con.log(args);
            };

        })(idx, log_methods[idx]);
    }

    // Execute the callback function if set.
    function exec_callback(args) {
        if (callback_func && (callback_force || !con || !con.log)) {
            callback_func.apply(window, args);
        }
    }
    // Method: debug.setLevel
    //
    // Set a minimum or maximum logging level for the console. Doesn't affect
    // the <debug.setCallback> callback function, but if set to 0 to disable
    // logging, <Pass-through console methods> will be disabled as well.
    //
    // Usage:
    //
    //  debug.setLevel( [ level ] )                                            - -
    //
    // Arguments:
    //
    //  level - (Number) If 0, disables logging. If negative, shows N lowest
    //    priority levels of log messages. If positive, shows N highest priority
    //    levels of log messages.
    //
    // Priority levels:
    //
    //   log (1) < debug (2) < info (3) < warn (4) < error (5)

    that.setLevel = function (level) {
        log_level = typeof level === 'number' ? level : 9;
    };

    // Determine if the level is visible given the current log_level.
    function is_level(level) {
        return log_level > 0
            ? log_level > level
            : log_methods.length + log_level <= level;
    }
    // Method: debug.setCallback
    //
    // Set a callback to be used if logging isn't possible due to console.log
    // not existing. If unlogged logs exist when callback is set, they will all
    // be logged immediately unless a limit is specified.
    //
    // Usage:
    //
    //  debug.setCallback( callback [, force ] [, limit ] )
    //
    // Arguments:
    //
    //  callback - (Function) The aforementioned callback function. The first
    //    argument is the logging level, and all subsequent arguments are those
    //    passed to the initial debug logging method.
    //  force - (Boolean) If false, log to console.log if available, otherwise
    //    callback. If true, log to both console.log and callback.
    //  limit - (Number) If specified, number of lines to limit initial scrollback
    //    to.

    that.setCallback = function () {
        var args = aps.call(arguments),
            max = logs.length,
            i = max;

        callback_func = args.shift() || null;
        callback_force = typeof args[0] === 'boolean' ? args.shift() : false;

        i -= typeof args[0] === 'number' ? args.shift() : max;

        while (i < max) {
            exec_callback(logs[i++]);
        }
    };

    return that;
})();


/**
 * @class
 * Util class to handle colors in the draw2d enviroment.
 *
 *      // Create a new Color with RGB values
 *      var color = new draw2d.util.Color(127,0,0);
 *
 *      // of from a hex string
 *      var color2 = new draw2d.util.Color("#f00000");
 *
 *      // Create a little bit darker color
 *      var darkerColor = color.darker(0.2); // 20% darker
 *
 *      // create a optimal text color if 'color' the background color
 *      // (best in meaning of contrast and readability)
 *      var fontColor = color.getIdealTextColor();
 *
 */
draw2d.util.Color = Class.extend({

    /**
     * @constructor
     * Create a new Color object
     *
     * @param {Number|String|draw2d.util.Color|Array} red
     * @param {Number} green
     * @param {Number} blue
     */
    init: function (red, green, blue) {

        this.hashString = null;

        if (typeof red === "undefined" || red === null) {
            this.hashString = "none";
        }
        else if (red instanceof draw2d.util.Color) {
            if (red.hashString === "none") {
                this.hashString = "none";
            }
            else {
                this.red = red.red;
                this.green = red.green;
                this.blue = red.blue;
            }
        }
        else if (typeof red === "string") {
            if (red === "none") {
                this.hashString = "none";
            }
            else {
                var rgb = this.hex2rgb(red);
                this.red = rgb[0];
                this.green = rgb[1];
                this.blue = rgb[2];
            }
        }
        // JSON struct of {red:###, green:###, blue:### }
        else if (typeof red === "object" && typeof red.red === "number") {
            this.red = red.red;
            this.green = red.green;
            this.blue = red.blue;
        }
        // array detection 1
        else if (red instanceof Array && red.length === 3) {
            this.red = red[0];
            this.green = red[1];
            this.blue = red[2];
        }
        // array detection 2
        else if (typeof red === "object" && typeof red.length === "number" && red.length === 3) {
            this.red = red[0];
            this.green = red[1];
            this.blue = red[2];
        }
        else {
            this.red = parseInt(red);
            this.green = parseInt(green);
            this.blue = parseInt(blue);
        }
    },


    /**
     * @method
     * Convert the color object into a HTML CSS representation
     * @return {String} the color in rgb(##,##,##) representation
     **/
    getHTMLStyle: function () {
        return "rgb(" + this.red + "," + this.green + "," + this.blue + ")";
    },


    /**
     * @method
     * The red part of the color.
     *
     * @return {Number} the [red] part of the color.
     **/
    getRed: function () {
        return this.red;
    },


    /**
     * @method
     * The green part of the color.
     *
     * @return {Number} the [green] part of the color.
     **/
    getGreen: function () {
        return this.green;
    },


    /**
     * @method
     * The blue part of the color
     *
     * @return {Number} the [blue] part of the color.
     **/
    getBlue: function () {
        return this.blue;
    },

    /**
     * @method
     * Returns the ideal Text Color. Useful for font color selection by a given background color.
     *
     * @return {draw2d.util.Color} The <i>ideal</i> inverse color.
     **/
    getIdealTextColor: function () {
        var nThreshold = 105;
        var bgDelta = (this.red * 0.299) + (this.green * 0.587) + (this.blue * 0.114);
        return (255 - bgDelta < nThreshold) ? new draw2d.util.Color(0, 0, 0) : new draw2d.util.Color(255, 255, 255);
    },


    /**
     * @private
     */
    hex2rgb: function (/*:String */hexcolor) {
        hexcolor = hexcolor.replace("#", "");
        return (
            {
                0: parseInt(hexcolor.substr(0, 2), 16),
                1: parseInt(hexcolor.substr(2, 2), 16),
                2: parseInt(hexcolor.substr(4, 2), 16)
            }
        );
    },

    /**
     * @private
     **/
    hex: function () {
        return (this.int2hex(this.red) + this.int2hex(this.green) + this.int2hex(this.blue));
    },


    /**
     * @method
     * Convert the color object into a HTML CSS representation
     * @return {String} the color in #RRGGBB representation
     **/
    hash: function () {
        if (this.hashString === null) {
            this.hashString = "#" + this.hex();
        }
        return this.hashString;
    },

    /**
     * @private
     */
    int2hex: function (v) {
        v = Math.round(Math.min(Math.max(0, v), 255));
        return ("0123456789ABCDEF".charAt((v - v % 16) / 16) + "0123456789ABCDEF".charAt(v % 16));
    },

    /**
     * @method
     * Returns a darker color of the given one. The original color is unchanged.
     *
     * @param {Number} fraction  Darkness fraction between [0..1].
     * @return{draw2d.util.Color}        Darker color.
     */
    darker: function (fraction) {
        // we can "darker" a undefined color. In this case we return the undefnied color itself
        //
        if (this.hashString === "none")
            return this;

        var red = parseInt(Math.round(this.getRed() * (1.0 - fraction)));
        var green = parseInt(Math.round(this.getGreen() * (1.0 - fraction)));
        var blue = parseInt(Math.round(this.getBlue() * (1.0 - fraction)));

        if (red < 0) red = 0; else if (red > 255) red = 255;
        if (green < 0) green = 0; else if (green > 255) green = 255;
        if (blue < 0) blue = 0; else if (blue > 255) blue = 255;

        return new draw2d.util.Color(red, green, blue);
    },


    /**
     * @method
     * Make a color lighter. The original color is unchanged.
     *
     * @param {Number} fraction  lighter fraction between [0..1].
     * @return {draw2d.util.Color} Lighter color.
     */
    lighter: function (fraction) {
        // we can "lighter" a undefined color. In this case we return the undefined color itself
        //
        if (this.hashString === "none")
            return this;

        var red = parseInt(Math.round(this.getRed() * (1.0 + fraction)));
        var green = parseInt(Math.round(this.getGreen() * (1.0 + fraction)));
        var blue = parseInt(Math.round(this.getBlue() * (1.0 + fraction)));

        if (red < 0) red = 0; else if (red > 255) red = 255;
        if (green < 0) green = 0; else if (green > 255) green = 255;
        if (blue < 0) blue = 0; else if (blue > 255) blue = 255;

        return new draw2d.util.Color(red, green, blue);
    },

    /**
     * @method
     * Return a new color wich is faded to the given color.
     * @param {draw2d.util.Color} color
     * @param {Number} pc the fade percentage in [0..1]
     * @returns {draw2d.util.Color}
     *
     * @since 2.1.0
     */
    fadeTo: function (color, pc) {

        var r = Math.floor(this.red + (pc * (color.red - this.red)) + .5);
        var g = Math.floor(this.green + (pc * (color.green - this.green)) + .5);
        var b = Math.floor(this.blue + (pc * (color.blue - this.blue)) + .5);

        return new draw2d.util.Color(r, g, b);
    },

    /**
     * @method
     * Compares two color objects
     *
     * @param {draw2d.util.Color} o
     * @return {Boolean}
     **/
    equals: function (o) {
        if (!(o instanceof draw2d.util.Color)) {
            return false;
        }
        return this.hash() == o.hash();
    }

});


/**
 * @class draw2d.util.ArrayList
 *
 * An ArrayList stores a variable number of objects. This is similar to making an array of
 * objects, but with an ArrayList, items can be easily added and removed from the ArrayList
 * and it is resized dynamically. This can be very convenient, but it's slower than making
 * an array of objects when using many elements.
 */
draw2d.util.ArrayList = Class.extend({

    /**
     * @constructor
     * Initializes a new instance of the ArrayList class that is empty and has
     * the default initial capacity.
     *
     */
    init: function (a) {
        if ($.isArray(a)) {
            this.data = a;
        }
        else {
            this.data = [];
        }
    },


    /**
     * @method
     * Reverses the order of the elements in the ArrayList. The array will be modified!
     *
     */
    reverse: function () {
        this.data.reverse();

        return this;
    },

    /**
     * @method
     * The size/count of the stored objects.
     *
     * @return {Number}
     */
    getSize: function () {
        return this.data.length;
    },


    /**
     * @method
     * checks to see if the Vector has any elements.
     *
     * @return {Boolean} true if the list is empty
     **/
    isEmpty: function () {
        return this.getSize() === 0;
    },

    /**
     * @method
     * return the last element.
     *
     * @return {Object}
     */
    last: function () {
        return this.data[this.data.length - 1];
    },
    /* @deprecated */
    getLastElement: function () {
        return this.last();
    },


    /**
     * @method
     * Return a reference to the internal javascript native array.
     *
     * @return {Array}
     */
    asArray: function () {
        return this.data;
    },

    /**
     * @method
     * returns the first element
     *
     * @return {Object}
     */
    first: function () {
        if (this.data.length > 0) {
            return this.data[0];
        }
        return null;
    },
    /* @deprecated */
    getFirstElement: function () {
        return this.first();
    },


    /**
     * @method
     * returns an element at a specified index
     *
     * @param {Number} i
     * @return {Object}
     */
    get: function (i) {
        return this.data[i];
    },

    /**
     * @method
     * Adds a element at the end of the Vector.
     *
     * @param {Object} obj the object to add
     */
    add: function (obj) {
        this.data.push(obj);

        return this;
    },

    /**
     * @method
     *
     * The method removes items from an array as necessary so that all remaining items pass a
     * provided test. The test is a function that is passed an array item and the index of the
     * item within the array. Only if the test returns true will the item stay in the array.
     *
     * @param {Function} func the filter function
     * @param {Object} func.value value of the element in iteration.
     * @since 2.0.0
     */
    grep: function (func) {
        this.data = $.grep(this.data, func);

        return this;
    },

    /**
     * @method
     * Translate all items in the array into new items. The array list is modified after this call.
     * You must clone the array before if you want avoid this.
     *
     *     var labels = this.commands.clone().map(function(e){
      *          return e.getLabel();
      *     });
     *
     * @param {Function} func The function to process each item against. The first argument to the function is the value; the second argument is the index or key of the array or object property.
     * @param {Object} func.value value of the element in iteration.
     * @param {Number} func.i index of the element in iteration
     *
     * @since 4.0.0
     */
    map: function (func) {
        this.data = $.map(this.data, func);

        return this;
    },

    /**
     * @method
     * Removes any duplicate elements from the array. The array is modified after this call. You
     * must clone the array before if you want avoid this
     *
     * @since 4.0.0
     */
    unique: function () {
        this.data = $.unique(this.data);

        return this;
    },


    /**
     * @method
     * Add all elements into this array.
     *
     * @param {draw2d.util.ArrayList} list
     * @param {boolean} [avoidDuplicates] checks whenever the new elements exists before insert if the parameter is to [true]
     *
     */
    addAll: function (list, avoidDuplicates) {
        if (!(list instanceof draw2d.util.ArrayList)) {
            throw "Unable to handle unknown object type in ArrayList.addAll";
        }

        this.data = this.data.concat(list.data);
        if (avoidDuplicates) {
            this.unique();
        }
        return this;
    },

    /**
     * @method
     * You can use the Array list as Stack as well. this is the pop method to remove one element
     * at the top of the stack.
     *
     * @returns
     */
    pop: function () {
        return this.removeElementAt(this.data.length - 1);
    },

    /**
     * @method
     * Push one element at the top of the stack/array
     *
     * @param path
     */
    push: function (value) {
        this.add(value);
    },

    /**
     * @method
     * Remove the element from the list
     *
     * @param {Object} obj the object to remove
     *
     * @return {Object} the removed object or null
     */
    remove: function (obj) {
        var index = this.indexOf(obj);
        if (index >= 0) {
            return this.removeElementAt(index);
        }

        return null;
    },


    /**
     * @method
     * Inserts an element at a given position. Existing elements will be shifted
     * to the right.
     *
     * @param {Object} obj the object to insert.
     * @param {Number} index the insert position.
     *
     */
    insertElementAt: function (obj, index) {
        this.data.splice(index, 0, obj);

        return this;
    },

    /**
     * @method
     * Removes an element at a specific index.
     *
     * @param {Number} index the index of the element to remove
     * @return {Object} the removed object
     */
    removeElementAt: function (index) {
        var element = this.data[index];

        this.data.splice(index, 1);

        return element;
    },

    /**
     * @method
     * removes all given elements in the Vector
     *
     * @param {draw2d.util.ArrayList} elements The elements to remove
     */
    removeAll: function (elements) {
        $.each(elements, $.proxy(function (i, e) {
            this.remove(e);
        }, this));

        return this;
    },

    /**
     * @method
     * Return the zero based index of the given element or -1 if the element
     * not in the list.
     *
     * @param {Object} obj the element to check
     *
     * @return {Number} the index of the element or -1
     */
    indexOf: function (obj) {
        return this.data.indexOf(obj);
    },

    /**
     * @method
     * returns true if the element is in the Vector, otherwise false.
     *
     * @param {Object} obj the object to check
     *
     * @return {boolean}
     */
    contains: function (obj) {
        return this.indexOf(obj) !== -1;
    },


    /**
     * @method
     * Sorts the collection based on a field name or sort a function. See on http://www.w3schools.com/jsref/jsref_sort.asp
     * if you use a sort function.
     *
     * @param {String|Function} f the field name for the sorting or a sort function
     *
     * @return {draw2d.util.ArrayList} self
     */
    sort: function (f) {
        if (typeof f === "function") {
            this.data.sort(f);
        }
        else {
            this.data.sort(function (a, b) {
                if (a[f] < b[f])
                    return -1;
                if (a[f] > b[f])
                    return 1;
                return 0;
            });
        }
        return this;
    },

    /**
     * @method
     * Copies the contents of a Vector to another Vector returning the new Vector.
     *
     * @param {boolean} [deep] call "clone" of each elements and add the clone to the new ArrayList
     *
     * @returns {draw2d.util.ArrayList} the new ArrayList
     */
    clone: function (deep) {
        var newVector = new draw2d.util.ArrayList();


        if (deep) {
            for (var i = 0; i < this.data.length; i++) {
                newVector.data.push(this.data[i].clone());
            }
        }
        else {
            newVector.data = this.data.slice(0);
        }

        return newVector;
    },


    /**
     * @method
     * Iterates over the list of elements, yielding each in turn to an iterator
     * function.
     * Each invocation of iterator is called with two arguments: (index, element).
     *
     * @param {Function} func the callback function to call for each element
     * @param {Number} func.i index of the element in iteration
     * @param {Object} func.value value of the element in iteration.
     * @param {boolean} [reverse] optional parameter. Iterate the collection reverse if it set to <b>true</b>
     *
     */
    each: function (func, reverse) {
        if (typeof reverse !== "undefined" && reverse === true) {
            for (var i = this.data.length - 1; i >= 0; i--) {
                if (func(i, this.data[i]) === false)
                    break;
            }
        }
        else {
            for (var i = 0; i < this.data.length; i++) {
                if (func(i, this.data[i]) === false)
                    break;
            }
        }
    },

    // overwriteElementAt() - overwrites the element with an object at the specific index.
    overwriteElementAt: function (obj, index) {
        this.data[index] = obj;

        return this;
    },

    getPersistentAttributes: function () {
        return {data: this.data};
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes: function (memento) {
        this.data = memento.data;
    }


});

draw2d.util.ArrayList.EMPTY_LIST = new draw2d.util.ArrayList();


// extending raphael with a polygon function
Raphael.fn.polygon = function (pointString) {
    var poly = ['M'];
    var point = pointString.split(' ');

    for (var i = 0; i < point.length; i++) {
        var c = point[i].split(',');
        for (var j = 0; j < c.length; j++) {
            var d = parseFloat(c[j]);
            if (!isNaN(d))
                poly.push(d);
        }
        if (i == 0)
            poly.push('L');
    }
    poly.push('Z');

    return this.path(poly);
};
draw2d.util.JSON = {

    /**
     * @method
     * Given a dot deliminated string set will create an object
     * based on the structure of the string with the desired value
     *
     * @param {Object} data   the json object to modify
     * @param {String} path   path indicating where value should be placed
     * @param {Object} value  the value desired to be set at the location determined by path
     */
    set: function (data, path, value) {
        if (!path || path === '') {
            return;
        }

        var re = /[\w-]+|\[\]|([^\[[\w]\]]|["'](.*?)['"])/g;
        // parse path on dots, and brackets
        var pathList = path.match(re);
        var parent = data;
        var parentKey;
        var grandParent = null;
        var grandParentKey = null;

        var addObj = function (obj, key, data) {
            if (key === '[]') {
                obj.push(data);
            } else {
                obj[key] = data;
            }
        };

        while (pathList.length > 0) {
            parentKey = pathList.shift().replace(/["']/g, '');

            // Number, treat it as an array
            if (!isNaN(+parentKey) || parentKey === "[]") {
                if ($.type(parent) !== "array") {
                    parent = [];
                    addObj(grandParent, grandParentKey, parent);
                }
                // String, treat it as a key
            }
            else if ($.type(parentKey) === "string") {
                if (!$.isPlainObject(parent)) {
                    parent = {};
                    addObj(grandParent, grandParentKey, parent);
                }
            }
            // Next
            grandParent = parent;
            grandParentKey = parentKey;
            parent = parent[parentKey];
        }

        addObj(grandParent, grandParentKey, value);
    },

    /**
     * @method
     * Returns the value defined by the path passed in
     *
     * @param  {Object} data the JSON data object
     * @param  {String} path string leading to a desired value
     */
    get: function (data, path) {
        var regex = /[\w-]+|\[\]|([^\[[\w]\]]|["'](.*?)['"])/g;
        //check if path is truthy
        if (!path) {
            return undefined;
        }
        //parse path on dots and brackets
        var paths = path.match(regex);
        //step through data object until all keys in path have been processed
        while (data !== null && paths.length > 0) {
            if (data.propertyIsEnumerable(paths[0].replace(/"/g, ''))) {
                data = data[paths.shift().replace(/"/g, '')];
            }
            else {
                return undefined;
            }
        }
        return data;
    },

    /**
     * @method
     * calculates the diff between the given json objects
     *
     */
    diff: function (obj1, obj2) {
        var result = {};
        for (key in obj1) {
            var v1 = obj1[key];
            var v2 = obj2[key];
            if (v1 !== v2) {
                if (v1.equals) {
                    if (!v1.equals(v2)) {
                        result[key] = obj1[key];
                    }
                }
                else {
                    result[key] = obj1[key];
                }
            }
        }
        return result;
    }

};

/**
 * @class draw2d.util.UUID
 * Generates a (pseudo) UUID's
 *
 *      // a UUID in the format
 *      // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)
 *      var id = draw2d.util.UUID.create();
 *
 * @author Andreas Herz
 * @constructor
 * @private
 */
draw2d.util.UUID = function () {
};


/**
 * @method
 * Generates a unique id.<br>
 * But just for the correctness: <strong>this is no Global Unique Identifier</strong>, it is just a random generator
 * with the output that looks like a GUID. <br>
 * But may be also useful.
 *
 * @returns {String} the  UUID in the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)
 **/
draw2d.util.UUID.create = function () {
    var segment = function () {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    };
    return (segment() + segment() + "-" + segment() + "-" + segment() + "-" + segment() + "-" + segment() + segment() + segment());
};


/**
 * @class draw2d.util.spline.Spline
 *
 *  An abstract class defining a general spline object.
 */
draw2d.util.spline.Spline = Class.extend({

    NAME: "draw2d.util.spline.Spline",

    /**
     * @constructor
     */
    init: function () {
    },

    /**
     * Create a spline based on the given control points.
     * The generated curve starts in the first control point and ends
     * in the last control point.
     *
     * @param {Array} controlPoints  Control points of spline (x0,y0,z0,x1,y1,z1,...).
     * @param {Number} parts Number of parts to divide each leg into.
     **/
    generate: function (controlPoints, parts) {
        throw "inherit classes must implement the method 'draw2d.util.spline.Spline.generate()'";
    }

});
/**
 * @class draw2d.util.spline.CubicSpline
 *
 * A cubic spline object.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.util.spline.Spline
 */
draw2d.util.spline.CubicSpline = draw2d.util.spline.Spline.extend(
    {
        NAME: "draw2d.util.spline.CubicSpline",

        /**
         * @constructor
         */
        init: function () {
            this._super();
        },


        /**
         * Create a spline based on the given control points.
         * The generated curve starts in the first control point and ends
         * in the last control point.
         *
         * @param {Array} controlPoints  Control points of spline (x0,y0,z0,x1,y1,z1,...).
         * @param {Number} parts Number of parts to divide each leg into.
         *
         * @returns {Array} the new generated array with new draw2d.geo.Point
         */
        generate: function (controlPoints, parts) {
            // Endpoints are added twice to get them include in the
            // generated array
            var cp = new draw2d.util.ArrayList();
            cp.add(controlPoints.get(0));
            cp.addAll(controlPoints);
            cp.add(controlPoints.get(controlPoints.getSize() - 1));

            var n = cp.getSize();
            var spline = new draw2d.util.ArrayList();
            spline.add(controlPoints.get(0));
            spline.add(this.p(1, 0, cp));

            for (var i = 1; i < n - 2; i++) {
                for (var j = 1; j <= parts; j++) {
                    spline.add(this.p(i, j / parts, cp));
                }
            }
            spline.add(controlPoints.get(controlPoints.getSize() - 1));

            return spline;
        },


        p: function (i, t, cp) {
            var x = 0.0;
            var y = 0.0;

            var k = i - 1;
            for (var j = -2; j <= 1; j++) {
                var b = this.blend(j, t);
                var p = cp.get(k++);
                x += b * p.x;
                y += b * p.y;
            }

            return new draw2d.geo.Point(x, y);
        },


        blend: function (i, t) {
            if (i === -2)
                return (((-t + 3) * t - 3) * t + 1) / 6;
            else if (i === -1)
                return (((3 * t - 6) * t) * t + 4) / 6;
            else if (i === 0)
                return (((-3 * t + 3) * t + 3) * t + 1) / 6;

            return (t * t * t) / 6;
        }

    });

/**
 * @class draw2d.util.spline.CatmullRomSpline
 *
 * A catmull-rom spline object.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.util.spline.CubicSpline
 */
draw2d.util.spline.CatmullRomSpline = draw2d.util.spline.CubicSpline.extend(
    {
        NAME: "draw2d.util.spline.CatmullRomSpline",

        /**
         * @constructor
         */
        init: function () {
            this._super();
        },


        blend: function (i, t) {
            if (i == -2)
                return ((-t + 2) * t - 1) * t / 2;
            else if (i == -1)
                return (((3 * t - 5) * t) * t + 2) / 2;
            else if (i == 0)
                return ((-3 * t + 4) * t + 1) * t / 2;
            else
                return ((t - 1) * t * t) / 2;
        }

    });

/**
 * @class draw2d.util.spline.BezierSpline
 *
 * A bezier spline object.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.util.spline.Spline
 */
draw2d.util.spline.BezierSpline = draw2d.util.spline.Spline.extend(
    {
        NAME: "draw2d.util.spline.BezierSpline",

        /**
         * @constructor
         */
        init: function () {
            this._super();
        },


        /**
         * Create a spline based on the given control points.
         * The generated curve starts in the first control point and ends
         * in the last control point.
         *
         * @param {Array} controlPoints  Control points of spline (x0,y0,z0,x1,y1,z1,...).
         * @param {Number} parts Number of parts to divide each leg into.
         *
         * @returns {Array} the new generated array with new draw2d.geo.Point
         */
        generate: function (controlPoints, parts) {
            var n = controlPoints.getSize();
            var spline = new draw2d.util.ArrayList();

            spline.add(this.p(0, 0, controlPoints));

            for (var i = 0; i < n - 3; i += 3) {
                for (var j = 1; j <= parts; j++) {
                    spline.add(this.p(i, j / parts, controlPoints));
                }
            }

            //    spline.add(controlPoints.get(controlPoints.getSize()-1));

            return spline;
        },


        p: function (i, t, cp) {
            var x = 0.0;
            var y = 0.0;

            var k = i;
            for (var j = 0; j <= 3; j++) {
                var b = this.blend(j, t);
                var p = cp.get(k++);
                x += b * p.x;
                y += b * p.y;
            }

            return new draw2d.geo.Point(x, y);
        },


        blend: function (i, t) {
            if (i == 0) return (1 - t) * (1 - t) * (1 - t);
            else if (i == 1) return 3 * t * (1 - t) * (1 - t);
            else if (i == 2) return 3 * t * t * (1 - t);
            else             return t * t * t;
        }
    });


/**
 * @class draw2d.geo.PositionConstants
 * Static values for point orientation.
 *
 */
draw2d.geo.PositionConstants = function () {
};

draw2d.geo.PositionConstants.NORTH = 1;
draw2d.geo.PositionConstants.SOUTH = 4;
draw2d.geo.PositionConstants.WEST = 8;
draw2d.geo.PositionConstants.EAST = 16;


/**
 * @class draw2d.geo.Point Util class for geometrie handling.
 */
draw2d.geo.Point = Class.extend({

    NAME: "draw2d.geo.Point",

    /**
     * @constructor
     * Creates a new Point object with the hands over coordinates.
     * @param {Number} x
     * @param {Number} y
     */
    init: function (x, y) {
        if (x instanceof draw2d.geo.Point) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }

        // limit for the maxi/minimum boundary of this rectangle
        // It is not possible that the rect leave the boundary if set.
        this.bx = null;
        this.by = null;
        this.bw = null;
        this.bh = null;
    },


    /**
     * @method
     * Set the boundary of the rectangle. If set, the rectangle is always inside
     * the boundary. A setX or setY will always be adjusted.
     *
     */
    setBoundary: function (bx, by, bw, bh) {
        if (bx instanceof draw2d.geo.Rectangle) {
            this.bx = bx.x;
            this.by = bx.y;
            this.bw = bx.w;
            this.bh = bx.h;
        } else {
            this.bx = bx;
            this.by = by;
            this.bw = bw;
            this.bh = bh;
        }
        this.adjustBoundary();

        return this;
    },


    /**
     * @method
     * @private
     */
    adjustBoundary: function () {
        if (this.bx === null) {
            return;
        }
        this.x = Math.min(Math.max(this.bx, this.x), this.bw);
        this.y = Math.min(Math.max(this.by, this.y), this.bh);

        return this;
    },

    /**
     * @method
     * Moves this Rectangle horizontally by dx and vertically by dy, then returns
     * this Rectangle for convenience.<br>
     * <br>
     * The method return the object itself. This allows you to do command chaining, where
     * you can perform multiple methods on the same elements.
     *
     * @param {Number} dx  Shift along X axis
     * @param {Number} dy  Shift along Y axis
     *
     **/
    translate: function (dx, dy) {
        this.x += dx;
        this.y += dy;
        this.adjustBoundary();

        return this;
    },

    /**
     * @method
     * The X value of the point
     * @since 0.1
     * @return {Number}
     */
    getX: function () {
        return this.x;
    },

    /**
     * @method
     * The y value of the point
     *
     * @return {Number}
     */
    getY: function () {
        return this.y;
    },

    /**
     * @method
     * Set the new X value of the point
     *
     * @param {Number} x the new value
     */
    setX: function (x) {
        this.x = x;
        this.adjustBoundary();

        return this;
    },

    /**
     * @method
     * Set the new Y value of the point
     *
     * @param {Number}y the new value
     */
    setY: function (y) {
        this.y = y;
        this.adjustBoundary();

        return this;
    },

    /**
     * @method
     * Set the new x/y coordinates of this point
     *
     * @param {Number|draw2d.geo.Point} x
     * @param {Number} [y]
     */
    setPosition: function (x, y) {
        if (x instanceof draw2d.geo.Point) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }
        this.adjustBoundary();

        return this;
    },

    /**
     * @method
     * Calculates the relative position of the specified Point to this Point.
     *
     * @param {draw2d.geo.Point} p The reference Point
     * @return {draw2d.geo.PositionConstants} NORTH, SOUTH, EAST, or WEST, as defined in {@link draw2d.geo.PositionConstants}
     */
    getPosition: function (p) {
        var dx = p.x - this.x;
        var dy = p.y - this.y;
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx < 0)
                return draw2d.geo.PositionConstants.WEST;
            return draw2d.geo.PositionConstants.EAST;
        }
        if (dy < 0)
            return draw2d.geo.PositionConstants.NORTH;
        return draw2d.geo.PositionConstants.SOUTH;
    },

    /**
     * @method
     * Compares two points and return [true] if x and y are equals.
     *
     * @param {draw2d.geo.Point} p the point to compare with
     * @return boolean
     */
    equals: function (p) {
        return this.x === p.x && this.y === p.y;
    },

    /**
     * @method
     * Return the distance between this point and the hands over.
     *
     * @param {draw2d.geo.Point} other the point to use
     * @return {Number}
     */
    getDistance: function (other) {
        return Math.sqrt((this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y));
    },

    /**
     * @method
     * Return the th of the vector from [0,0]
     *
     * @return {Number}
     * @since 2.10.0
     */
    length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
     * @method
     * Return a new Point translated with the x/y values of the hands over point.
     *
     * @param {draw2d.geo.Point} other the offset to add for the new point.
     * @return {draw2d.geo.Point} The new translated point.
     */
    getTranslated: function (other) {
        return new draw2d.geo.Point(this.x + other.x, this.y + other.y);
    },

    /**
     * @method
     * Return a new Point scaled with the x/y values of the hands over point.
     *
     * @param {Number} factor the factor to scaled the new point.
     * @return {draw2d.geo.Point} The new translated point.
     */
    getScaled: function (factor) {
        return new draw2d.geo.Point(this.x * factor, this.y * factor);
    },

    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes: function () {
        return {
            x: this.x,
            y: this.y
        };
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes: function (memento) {
        this.x = memento.x;
        this.y = memento.y;
    },

    /**
     * @method
     * substract the given point and return the new point.
     *
     * @param that
     * @returns {draw2d.geo.Point}
     */
    subtract: function (that) {
        return new draw2d.geo.Point(this.x - that.x, this.y - that.y);
    },


    dot: function (that) {
        return this.x * that.x + this.y * that.y;
    },

    cross: function (that) {
        return this.x * that.y - this.y * that.x;
    },


    lerp: function (that, t) {
        return new draw2d.geo.Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
    },


    /**
     * @method
     * Clone the Point and return them
     *
     * @returns
     */
    clone: function () {
        return new draw2d.geo.Point(this.x, this.y);
    }

});
/**
 * @class draw2d.geo.Rectangle
 *
 * Util class for geometrie handling.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.geo.Point
 */
draw2d.geo.Rectangle = draw2d.geo.Point.extend({

    NAME: "draw2d.geo.Rectangle",

    /**
     * @constructor
     * Creates a new Point object with the hands over coordinates.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */
    init: function (x, y, w, h) {
        this._super(x, y);
        this.w = w;
        this.h = h;
    },


    /**
     * @method
     * @private
     */
    adjustBoundary: function () {
        if (this.bx === null) {
            return;
        }
        this.x = Math.min(Math.max(this.bx, this.x), this.bw - this.w);
        this.y = Math.min(Math.max(this.by, this.y), this.bh - this.h);
        this.w = Math.min(this.w, this.bw);
        this.h = Math.min(this.h, this.bh);
    },

    /**
     * @method
     * Resizes this Rectangle by the values supplied as input and returns this for
     * convenience. This Rectangle's width will become this.width + dw. This
     * Rectangle's height will become this.height + dh.
     * <br>
     * The method return the object itself. This allows you to do command chaining, where
     * you can perform multiple methods on the same elements.
     *
     *
     * @param {Number} dw  Amount by which width is to be resized
     * @param {Number} dh  Amount by which height is to be resized
     *
     * @return  {draw2d.geo.Rectangle} The method return the object itself
     **/
    resize: function (/*:int*/ dw, /*:int*/ dh) {
        this.w += dw;
        this.h += dh;
        this.adjustBoundary();
        return this;
    },

    /**
     * @method
     * Scale this Rectangle by the values supplied as input and returns this for
     * convenience. This Rectangle's width will become this.width + dw. This
     * Rectangle's height will become this.height + dh. The top left corner moves
     * -dw/2, -dh/2
     * <br>
     * The method return the object itself. This allows you to do command chaining, where
     * you can perform multiple methods on the same elements.
     *
     *
     * @param {Number} dw  Amount by which width is to be resized
     * @param {Number} dh  Amount by which height is to be resized
     *
     * @return  {draw2d.geo.Rectangle} The method return the object itself
     **/
    scale: function (dw, dh) {

        this.w += (dw);
        this.h += (dh);
        this.x -= (dw / 2);
        this.y -= (dh / 2);
        this.adjustBoundary();
        return this;
    },

    /**
     * Sets the parameters of this Rectangle from the Rectangle passed in and
     * returns this for convenience.<br>
     * <br>
     * The method return the object itself. This allows you to do command chaining, where
     * you can perform multiple methods on the same elements.
     *
     * @param {draw2d.geo.Rectangle} Rectangle providing the bounding values
     *
     * @return  {draw2d.geo.Rectangle} The method return the object itself
     */
    setBounds: function (rect) {
        this.setPosition(rect.x, rect.y);

        this.w = rect.w;
        this.h = rect.h;

        return this;
    },

    /**
     * @method
     * Returns <code>true</code> if this Rectangle's width or height is less than or
     * equal to 0.
     *
     * @return {Boolean}
     */
    isEmpty: function () {
        return this.w <= 0 || this.h <= 0;
    },

    /**
     * @method
     * The width of the dimension element.
     *
     * @return {Number}
     **/
    getWidth: function () {
        return this.w;
    },

    /**
     * @method
     * Set the new width of the rectangle.
     *
     * @param {Number} w the new width of the rectangle
     */
    setWidth: function (w) {
        this.w = w;
        this.adjustBoundary();
        return this;
    },

    /**
     * @method
     * The height of the dimension element.
     *
     * @return {Number}
     **/
    getHeight: function () {
        return this.h;
    },
    /**
     * @method
     * Set the new height of the rectangle.
     *
     * @param {Number} h the new height of the rectangle
     */
    setHeight: function (h) {
        this.h = h;
        this.adjustBoundary();
        return this;
    },

    /**
     * @method
     * The x coordinate of the left corner.
     *
     * @return {Number}
     **/
    getLeft: function () {
        return this.x;
    },

    /**
     * @method
     * The x coordinate of the right corner.
     *
     * @return {Number}
     **/
    getRight: function () {
        return this.x + this.w;
    },

    /**
     * @method
     * The y coordinate of the top.
     *
     *@return {Number}
     **/
    getTop: function () {
        return this.y;
    },

    /**
     * @method
     * The y coordinate of the bottom.
     *
     *@return {Number}
     **/
    getBottom: function () {
        return this.y + this.h;
    },

    /**
     * @method
     * The top left corner of the dimension object.
     *
     * @return {draw2d.geo.Point} a new point objects which holds the coordinates
     **/
    getTopLeft: function () {
        return new draw2d.geo.Point(this.x, this.y);
    },

    /**
     * @method
     * The top center coordinate of the dimension object.
     *
     * @return {draw2d.geo.Point} a new point objects which holds the coordinates
     **/
    getTopCenter: function () {
        return new draw2d.geo.Point(this.x + (this.w / 2), this.y);
    },

    /**
     * @method
     * The top right corner of the dimension object.
     *
     * @return {draw2d.geo.Point} a new point objects which holds the coordinates
     **/
    getTopRight: function () {
        return new draw2d.geo.Point(this.x + this.w, this.y);
    },

    /**
     * @method
     * The bottom left corner of the dimension object.
     *
     * @return {draw2d.geo.Point} a new point objects which holds the coordinates
     **/
    getBottomLeft: function () {
        return new draw2d.geo.Point(this.x, this.y + this.h);
    },

    /**
     * @method
     * The bottom center coordinate of the dimension object.
     *
     * @return {draw2d.geo.Point} a new point objects which holds the coordinates
     **/
    getBottomCenter: function () {
        return new draw2d.geo.Point(this.x + (this.w / 2), this.y + this.h);
    },

    /**
     * @method
     * The center of the dimension object
     *
     * @return {draw2d.geo.Point} a new point which holds the center of the object
     **/
    getCenter: function () {
        return new draw2d.geo.Point(this.x + this.w / 2, this.y + this.h / 2);
    },


    /**
     * @method
     * Bottom right corner of the object
     *
     * @return {draw2d.geo.Point} a new point which holds the bottom right corner
     **/
    getBottomRight: function () {
        return new draw2d.geo.Point(this.x + this.w, this.y + this.h);
    },

    /**
     * @method
     * Return all points of the rectangle as array. Starting at topLeft and the
     * clockwise.
     *
     * @return {draw2d.util.ArrayList} the points starting at top/left and the clockwise
     */
    getVertices: function () {
        var result = new draw2d.util.ArrayList();
        result.add(this.getTopLeft());
        result.add(this.getTopRight());
        result.add(this.getBottomRight());
        result.add(this.getBottomLeft());

        return result;
    },
    /* @deprecated */
    getPoints: function () {
        return this.getVertices();
    },

    /**
     * @method
     * Return a new rectangle which fits into this rectangle. <b>ONLY</b> the x/y coordinates
     * will be changed. Not the dimension of the given rectangle.
     *
     * @param {draw2d.geo.Rectangle} rect the rectangle to adjust
     * @return the new shifted rectangle
     */
    moveInside: function (rect) {
        var newRect = new draw2d.geo.Rectangle(rect.x, rect.y, rect.w, rect.h);
        // shift the coordinate right/down if coordinate not inside the rect
        //
        newRect.x = Math.max(newRect.x, this.x);
        newRect.y = Math.max(newRect.y, this.y);

        // ensure that the right border is inside this rect (if possible).
        //
        if (newRect.w < this.w) {
            newRect.x = Math.min(newRect.x + newRect.w, this.x + this.w) - newRect.w;
        }
        else {
            newRect.x = this.x;
        }

        // ensure that the bottom is inside this rectangle
        //
        if (newRect.h < this.h) {
            newRect.y = Math.min(newRect.y + newRect.h, this.y + this.h) - newRect.h;
        }
        else {
            newRect.y = this.y;
        }

        return newRect;
    },

    /**
     * @method
     * Return the minimum distance of this rectangle to the given {@link draw2d.geo.Point} or
     * {link draw2d.geo.Rectangle}.
     *
     * @param {draw2d.geo.Point} pointOrRectangle the reference point/rectangle for the distance calculation
     */
    getDistance: function (pointOrRectangle) {
        var cx = this.x;
        var cy = this.y;
        var cw = this.w;
        var ch = this.h;

        var ox = pointOrRectangle.getX();
        var oy = pointOrRectangle.getY();
        var ow = 1;
        var oh = 1;

        if (pointOrRectangle instanceof draw2d.geo.Rectangle) {
            ow = pointOrRectangle.getWidth();
            oh = pointOrRectangle.getHeight();
        }
        var oct = 9;

        // Determin Octant
        //
        // 0 | 1 | 2
        // __|___|__
        // 7 | 9 | 3
        // __|___|__
        // 6 | 5 | 4

        if (cx + cw <= ox) {
            if ((cy + ch) <= oy) {
                oct = 0;
            }
            else if (cy >= (oy + oh)) {
                oct = 6;
            }
            else {
                oct = 7;
            }
        }
        else if (cx >= ox + ow) {
            if (cy + ch <= oy) {
                oct = 2;
            }
            else if (cy >= oy + oh) {
                oct = 4;
            }
            else {
                oct = 3;
            }
        }
        else if (cy + ch <= oy) {
            oct = 1;
        }
        else if (cy >= oy + oh) {
            oct = 5;
        }
        else {
            return 0;
        }


        // Determin Distance based on Quad
        //
        switch (oct) {
            case 0:
                cx = (cx + cw) - ox;
                cy = (cy + ch) - oy;
                return -(cx + cy);
            case 1:
                return -((cy + ch) - oy);
            case 2:
                cx = (ox + ow) - cx;
                cy = (cy + ch) - oy;
                return -(cx + cy);
            case 3:
                return -((ox + ow) - cx);
            case 4:
                cx = (ox + ow) - cx;
                cy = (oy + oh) - cy;
                return -(cx + cy);
            case 5:
                return -((oy + oh) - cy);
            case 6:
                cx = (cx + cw) - ox;
                cy = (oy + oh) - cy;
                return -(cx + cy);
            case 7:
                return -((cx + cw) - ox);
        }

        throw "Unknown data type of parameter for distance calculation in draw2d.geo.Rectangle.getDistnace(..)";
    },


    /**
     * @method
     * Determin the octant of r2 in relation to this rectangle.
     * <pre>
     *
     *    0 | 1 | 2
     *    __|___|__
     *    7 | 8 | 3
     *    __|___|__
     *    6 | 5 | 4
     * </pre>
     *
     * @param {draw2d.geo.Rectangle} r2
     *
     */
    determineOctant: function (r2) {

        var HISTERESE = 3; // Tolleranz um diese vermieden wird, dass der Octant "8" zur?�ckgegeben wird

        var ox = this.x + HISTERESE;
        var oy = this.y + HISTERESE;
        var ow = this.w - (HISTERESE * 2);
        var oh = this.h - (HISTERESE * 2);

        var cx = r2.x;
        var cy = r2.y;
        var cw = 2;
        var ch = 2;
        if (r2 instanceof draw2d.geo.Rectangle) {
            cw = r2.w;
            ch = r2.h;
        }

        var oct = 0;

        if (cx + cw <= ox) {
            if ((cy + ch) <= oy) {
                oct = 0;
            }
            else if (cy >= (oy + oh)) {
                oct = 6;
            }
            else {
                oct = 7;
            }
        }
        else if (cx >= ox + ow) {
            if (cy + ch <= oy) {
                oct = 2;
            }
            else if (cy >= oy + oh) {
                oct = 4;
            }
            else {
                oct = 3;
            }
        }
        else if (cy + ch <= oy) {
            oct = 1;
        }
        else if (cy >= oy + oh) {
            oct = 5;
        }
        else {
            oct = 8;
        }

        return oct;
    },


    /**
     * @method
     * Returns the direction the point <i>p</i> is in relation to the given rectangle.
     * Util method for inherit router implementations.
     *
     * <p>
     * Possible values:
     * <ul>
     *   <li>up -&gt; 0</li>
     *   <li>right -&gt; 1</li>
     *   <li>down -&gt; 2</li>
     *   <li>left -&gt; 3</li>
     * </ul>
     * <p>
     *
     * @param {draw2d.geo.Point} p the point in relation to the given rectangle
     *
     * @return {Number} the direction from <i>r</i> to <i>p</i>
     */
    getDirection: function (other) {
        var current = this.getTopLeft();
        switch (this.determineOctant(other)) {
            case 0:
                if ((current.x - other.x) < (current.y - other.y))
                    return draw2d.geo.Rectangle.DIRECTION_UP;
                return draw2d.geo.Rectangle.DIRECTION_LEFT;
            case 1:
                return draw2d.geo.Rectangle.DIRECTION_UP;
            case 2:
                current = this.getTopRight();
                if ((other.x - current.x) < (current.y - other.y))
                    return draw2d.geo.Rectangle.DIRECTION_UP;
                return draw2d.geo.Rectangle.DIRECTION_RIGHT;
            case 3:
                return draw2d.geo.Rectangle.DIRECTION_RIGHT;
            case 4:
                current = this.getBottomRight();
                if ((other.x - current.x) < (other.y - current.y))
                    return draw2d.geo.Rectangle.DIRECTION_DOWN;
                return draw2d.geo.Rectangle.DIRECTION_RIGHT;
            case 5:
                return draw2d.geo.Rectangle.DIRECTION_DOWN;
            case 6:
                current = this.getBottomLeft();
                if ((current.x - other.x) < (other.y - current.y))
                    return draw2d.geo.Rectangle.DIRECTION_DOWN;
                return draw2d.geo.Rectangle.DIRECTION_LEFT;
            case 7:
                return draw2d.geo.Rectangle.DIRECTION_LEFT;
            case 8:
                if (other.y > this.y) {
                    return draw2d.geo.Rectangle.DIRECTION_DOWN;
                }
                return draw2d.geo.Rectangle.DIRECTION_UP;

        }
        return draw2d.geo.Rectangle.DIRECTION_UP;
    },


    /**
     * @method
     * Compares two rectangle objects
     *
     * @param {draw2d.geo.Rectangle} o
     * @return {Boolean}
     **/
    equals: function (o) {
        return this.x == o.x && this.y == o.y && this.w == o.w && this.h == o.h;
    },

    /**
     * @method
     * Detect whenever the hands over coordinate is inside the rectangle.
     *
     * @param {Number/draw2d.geo.Point} iX
     * @param {Number} iY
     * @returns {Boolean}
     */
    hitTest: function (iX, iY) {
        if (iX instanceof draw2d.geo.Point) {
            iY = iX.y;
            iX = iX.x;
        }
        var iX2 = this.x + this.getWidth();
        var iY2 = this.y + this.getHeight();
        return (iX >= this.x && iX <= iX2 && iY >= this.y && iY <= iY2);
    },

    /**
     * @method
     * return true if this rectangle inside the hand over rectangle
     *
     *
     * @param {draw2d.geo.Rectangle} rect
     * @returns {Boolean}
     */
    isInside: function (rect) {
        return rect.hitTest(this.getTopLeft())
            && rect.hitTest(this.getTopRight())
            && rect.hitTest(this.getBottomLeft())
            && rect.hitTest(this.getBottomRight());
    },

    /**
     * @method
     * return true if this rectangle contains the hand over rectangle.
     *
     *
     * @param {draw2d.geo.Rectangle} rect
     * @returns {Boolean}
     * @since 4.7.2
     */
    contains: function (rect) {
        return this.hitTest(rect.getTopLeft())
            && this.hitTest(rect.getTopRight())
            && this.hitTest(rect.getBottomLeft())
            && this.hitTest(rect.getBottomRight());
    },

    /**
     * @method
     * checks whenever the rectangles has an intersection.
     *
     * @param {draw2d.geo.Rectangle} rect
     * @returns {Boolean}
     */
    intersects: function (rect) {
        x11 = rect.x,
            y11 = rect.y,
            x12 = rect.x + rect.w,
            y12 = rect.y + rect.h,
            x21 = this.x,
            y21 = this.y,
            x22 = this.x + this.w,
            y22 = this.y + this.h;

        x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
        y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));

        return x_overlap * y_overlap !== 0;
    },

    /**
     * @method
     * Merge this rectangle with the given one.
     *
     * @param {draw2d.geo.Rectangle} rect
     * @since 4.8.0
     */
    merge: function (rect) {
        var r = Math.max(rect.getRight(), this.getRight());
        var b = Math.max(rect.getBottom(), this.getBottom());

        this.setPosition(Math.min(this.x, rect.x), Math.min(this.y, rect.y));

        this.w = r - this.x;
        this.h = b - this.y;

        return this;
    },

    /**
     * @method
     * returns the intersection points with the given line if any exists
     *
     * @param {draw2d.geo.Point} start
     * @param {draw2d.geo.Point} end
     */
    intersectionWithLine: function (start, end) {
        var result = new draw2d.util.ArrayList();
        var v = this.getVertices();
        v.add(v.first());
        var p1 = v.first();
        var p2 = null;
        for (var i = 1; i < 5; i++) {
            p2 = v.get(i);
            p1 = draw2d.shape.basic.Line.intersection(start, end, p1, p2);
            if (p1 !== null) {
                result.add(p1);
            }
            p1 = p2;
        }
        return result;
    },

    /**
     * @method
     * converts the rectangle to JSON representation. required for the draw2d.io.Writer
     *
     * @returns {Object}
     */
    toJSON: function () {
        return {
            width: this.w,
            height: this.h,
            x: this.x,
            y: this.y
        };
    }


});

/**
 * ENUM for Direction
 */
draw2d.geo.Rectangle.DIRECTION_UP = 0;
draw2d.geo.Rectangle.DIRECTION_RIGHT = 1;
draw2d.geo.Rectangle.DIRECTION_DOWN = 2;
draw2d.geo.Rectangle.DIRECTION_LEFT = 3;


/**
 * @class draw2d.geo.Ray
 * A ray is a line starting in [0,0,] with some additional
 * helper functions required for some router.
 *
 * @inheritable
 * @extends draw2d.geo.Point
 * @author Andreas Herz
 */
draw2d.geo.Ray = draw2d.geo.Point.extend({

    NAME: "draw2d.geo.Ray",

    /**
     * @constructor
     * Creates a ray object.
     *
     * @param {Number} x
     * @param {Number} y
     */
    init: function (x, y) {
        this._super(x, y);
    },


    isHorizontal: function () {
        return this.x != 0;
    },

    similarity: function (otherRay) {
        return Math.abs(this.dot(otherRay));
    },

    getAveraged: function (otherRay) {
        return new draw2d.geo.Ray((this.x + otherRay.x) / 2, (this.y + otherRay.y) / 2);
    }

});


/**
 * @class draw2d.command.CommandType
 *
 * EditPolicies should determine an Figures editing capabilities.
 * It is possible to implement an Figure such that it handles all editing
 * responsibility.<br>
 * However, it is much more flexible and object-oriented to use
 * EditPolicies. Using policies, you can pick and choose the editing behavior for
 * an Figure without being bound to its class hierarchy. Code reuse is increased,
 * and code management is easier.
 *
 * @author Andreas Herz
 */
draw2d.command.CommandType = Class.extend({

    NAME: "draw2d.command.CommandType",

    /**
     * @constructor
     * Create a new edit policy object
     *
     * @param {String} policy
     */
    init: function (policy) {
        this.policy = policy;
    },

    /**
     * @method
     * Return the String representation of the policy
     *
     * @return {String}
     **/
    getPolicy: function () {
        return this.policy;
    }
});

draw2d.command.CommandType.DELETE = "DELETE";
draw2d.command.CommandType.MOVE = "MOVE";
draw2d.command.CommandType.CONNECT = "CONNECT";
draw2d.command.CommandType.MOVE_BASEPOINT = "MOVE_BASEPOINT";
draw2d.command.CommandType.MOVE_VERTEX = "MOVE_VERTEX";
draw2d.command.CommandType.MOVE_VERTICES = "MOVE_VERTICES";
draw2d.command.CommandType.MOVE_GHOST_VERTEX = "MOVE_GHOST_VERTEX";
draw2d.command.CommandType.RESIZE = "RESIZE";
draw2d.command.CommandType.RESET = "RESET";


/**
 * @class draw2d.command.Command
 *
 * Commands are passed around throughout editing. They are used to encapsulate and combine
 * changes to the application's model. An application has a single command stack. Commands must
 * be executed using the command stack rather than directly calling execute.
 * <br>
 * This is requried for a deneric support for the undo/redo concept within draw2d.<br>
 *
 * @inheritable
 * @author Andreas Herz
 */
draw2d.command.Command = Class.extend({

    NAME: "draw2d.command.Command",

    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {String} label
     */
    init: function (label) {
        this.label = label;
    },


    /**
     * @method
     * Returns a label of the Command. e.g. "move figure".
     *
     * @return {String} the label for this command
     **/
    getLabel: function () {
        return this.label;
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
     * return false. The execution of this Command doesn't modify the model.
     *
     * @return {boolean} return try if the command modify the model or make any relevant changes
     **/
    canExecute: function () {
        return true;
    },

    /**
     * @method
     * Execute the command the first time.
     * Sup-classes must implement this method.
     *
     * @template
     **/
    execute: function () {
    },

    /**
     * @method
     * Will be called if the user cancel the operation.
     *
     * @template
     **/
    cancel: function () {
    },

    /**
     * @method
     * Undo the command.
     * Sup-classes must implement this method.
     *
     * @template
     **/
    undo: function () {
    },

    /**
     * @method
     * Redo the command after the user has undo this command.
     * Sup-classes must implement this method.
     *
     * @template
     **/
    redo: function () {
    }
});


/**
 * @class draw2d.command.CommandCollection
 *
 * A CommandCollection works as a single command. You can add more than one
 * Command to this CommandCollection and execute/undo them onto the CommandStack as a
 * single Command.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandCollection = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandCollection",

    /**
     * @constructor
     * Create a new CommandConnect objects which can be execute via the CommandStack.
     *
     * @param {String} commandLabel the label to show on the command stack for the undo/redo operation
     */
    init: function (commandLabel) {
        this._super((typeof commandLabel === 'undefined') ? draw2d.Configuration.i18n.command.collection : commandLabel);

        this.commands = new draw2d.util.ArrayList();
    },

    /**
     * @method
     * Returns a label of the Command. e.g. "move figure".
     *
     * @return {String} the label for this command
     **/
    getLabel: function () {
        //return the label of the one and only command
        //
        if (this.commands.getSize() === 1) {
            return this.commands.first().getLabel();
        }

        // return a common label if all commands have the same label.
        //
        if (this.commands.getSize() > 1) {
            var labels = this.commands.clone().map(function (e) {
                return e.getLabel();
            });
            labels.unique();
            if (labels.getSize() === 1) {
                return labels.first();
            }
        }

        // return the all purpose label.
        return this._super();
    },


    /**
     * @method
     * Add a command to the collection.
     *
     * @param {draw2d.command.Command} command
     */
    add: function (command) {
        this.commands.add(command);
    },

    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
     * return false. The execution of this Command doesn't modify the model.
     *
     * @return boolean
     **/
    canExecute: function () {
        // We ask all cmd's if they make any changes.
        // Keep in mind: the command will be execute if at least ONE command return [true]!!!!
        // doesn't matter if the other commands return [false].
        // The method should be renamed into: modifiesTheModel()....design flaw.
        var canExec = false;
        this.commands.each(function (i, cmd) {
            canExec = canExec || cmd.canExecute();
        });
        return canExec;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.commands.each(function (i, cmd) {
            cmd.execute();
        });
    },

    /**
     * @method
     * Redo the command after the user has undo this command.
     *
     **/
    redo: function () {
        this.commands.each(function (i, cmd) {
            cmd.redo();
        });
    },

    /**
     * @method
     * Undo the command.
     *
     **/
    undo: function () {
        // execute the undo operation in reverse direction.

        this.commands.reverse();
        this.commands.each(function (i, cmd) {
            cmd.undo();
        });
        this.commands.reverse();
    }
});


/**
 * @class draw2d.command.CommandStack
 * Stack for undo/redo operations
 */
draw2d.command.CommandStack = Class.extend({
    NAME: "draw2d.command.CommandStack",


    /**
     * @constructor
     * Create a new CommandStack objects which can be execute via the CommandStack.
     *
     */
    init: function () {
        this.undostack = [];
        this.redostack = [];
        this.maxundo = 50;
        this.transactionCommand = null;
        this.eventListeners = new draw2d.util.ArrayList();
    },


    /**
     * @method
     * Set the maximal undo stack size. Entries will be remove if the max. stack
     * size has been reached.
     *
     * @param {Number} count The maximal undo stack size.
     *
     **/
    setUndoLimit: function (count) {
        this.maxundo = count;

        return this;
    },

    /**
     * @method
     * Remove the undo / redo history. This is useful if the user has been save the
     * document.
     *
     **/
    markSaveLocation: function () {
        this.undostack = [];
        this.redostack = [];

        // fire an empty command to inform all listener that the stack has been changed
        this.notifyListeners(new draw2d.command.Command(), draw2d.command.CommandStack.POST_EXECUTE);

        return this;
    },

    /**
     * @method
     *
     * Executes the specified Command if possible. Prior to executing the command, a
     * draw2d.command.CommandStackEvent for {@link #PRE_EXECUTE} will be fired to event listeners.
     * Similarly, after attempting to execute the command, an event for {@link #POST_EXECUTE}
     * will be fired.
     *
     * @param {draw2d.command.Command} command The command to execute.
     *
     **/
    execute: function (command) {
        if (typeof command === "undefined")
            throw "Missing parameter [command] for method call CommandStack.execute";

        // nothing to do
        if (command === null)
            return; //silently

        // return if the command can't execute or it doesn't change the model
        // => Empty command
        if (command.canExecute() === false)
            return;

        // A command stack transaction is open.
        // The execution will be postpone until the transaction will commit
        //
        if (this.transactionCommand !== null) {
            this.transactionCommand.add(command);
            return;
        }

        this.notifyListeners(command, draw2d.command.CommandStack.PRE_EXECUTE);

        this.undostack.push(command);
        command.execute();

        // cleanup the redo stack if the user execute a new command.
        // I think this will create a "clean" behaviour of the unde/redo mechanism.
        //
        this.redostack = [];

        // monitor only the max. undo stack size
        //
        if (this.undostack.length > this.maxundo) {
            this.undostack = this.undostack.slice(this.undostack.length - this.maxundo);
        }
        this.notifyListeners(command, draw2d.command.CommandStack.POST_EXECUTE);

        return this;
    },

    /**
     * @method
     * Opens a transaction for further multiple commands. If you execute a command all
     * {@ #execute} calls will be ignored until you commit the current transaction.
     *
     * @param {String} commandLabel the label to show for the undo/redo operation
     *
     * @since 4.0.0
     */
    startTransaction: function (commandLabel) {
        this.transactionCommand = new draw2d.command.CommandCollection(commandLabel);

        return this;
    },

    /**
     * @method
     * Commit the running transaction. All commands between the start/end of a transaction
     * can be undo/redo in a single step.
     *
     * @since 4.0.0
     */
    commitTransaction: function () {
        if (this.transactionCommand === null) {
            return;//silently
        }

        var cmd = this.transactionCommand;
        this.transactionCommand = null;
        // we can drop the CommandCollection if the collection contains only one command.
        if (cmd.commands.getSize() === 1) {
            this.execute(cmd.commands.first());
        }
        else {
            this.execute(cmd);
        }

        return this;
    },

    /**
     * @method
     * Undo on command from the stack and store them on the redo command stack.
     *
     **/
    undo: function () {
        var command = this.undostack.pop();
        if (command) {
            this.notifyListeners(command, draw2d.command.CommandStack.PRE_UNDO);
            this.redostack.push(command);
            command.undo();
            this.notifyListeners(command, draw2d.command.CommandStack.POST_UNDO);
        }

        return this;
    },

    /**
     * @method
     * Redo a command after the user has undo a command
     *
     **/
    redo: function () {
        var command = this.redostack.pop();

        if (command) {
            this.notifyListeners(command, draw2d.command.CommandStack.PRE_REDO);
            this.undostack.push(command);
            command.redo();
            this.notifyListeners(command, draw2d.command.CommandStack.POST_REDO);
        }

        return this;
    },

    /**
     * @method
     * Return the label of the next REDO command.
     *
     * @return {String}
     **/
    getRedoLabel: function () {
        if (this.redostack.length === 0)
            return "";

        var command = this.redostack[this.redostack.length - 1];

        if (command) {
            return command.getLabel();
        }
        return "";
    },


    /**
     * @method
     * Return the label of the next UNDO command.
     *
     * @return {String}
     **/
    getUndoLabel: function () {
        if (this.undostack.length === 0)
            return "";

        var command = this.undostack[this.undostack.length - 1];

        if (command) {
            return command.getLabel();
        }
        return "";
    },


    /**
     * @method
     * Indicates whenever a REDO is possible.
     *
     * @return boolean <code>true</code> if it is appropriate to call {@link #redo()}.
     */
    canRedo: function () {
        return this.redostack.length > 0;
    },

    /**
     * @method
     * indicator whenever a undo is possible.
     *
     * @return {boolean} <code>true</code> if {@link #undo()} can be called
     **/
    canUndo: function () {
        return this.undostack.length > 0;
    },

    /**
     * @method
     * Adds a listener to the command stack, which will be notified whenever a command has been processed on the stack.
     *
     * @param {draw2d.command.CommandStackEventListener} listener the listener to add.
     */
    addEventListener: function (listener) {
        if (listener instanceof draw2d.command.CommandStackEventListener) {
            this.eventListeners.add(listener);
        }
        else if (typeof listener.stackChanged === "function") {
            this.eventListeners.add(listener);
        }
        else if (typeof listener === "function") {
            this.eventListeners.add({stackChanged: listener});
        }
        else {
            throw "Object doesn't implement required callback interface [draw2d.command.CommandStackListener]";
        }

        return this;
    },

    /**
     * @method
     * Removes a listener from the command stack.
     *
     * @param {draw2d.command.CommandStackEventListener} listener the listener to remove.
     */
    removeEventListener: function (listener) {
        for (var i = 0; i < size; i++) {
            var entry = this.eventListeners.get(i);
            if (entry === listener || entry.stackChanged === listener) {
                this.eventListeners.remove(entry);
                return;
            }
        }

        return this;
    },

    /**
     * @method
     * Notifies command stack event listeners that the command stack has changed to the
     * specified state.
     *
     * @param {draw2d.command.Command} command the command
     * @param {Number} state the current stack state
     *
     **/
    notifyListeners: function (command, state) {
        var event = new draw2d.command.CommandStackEvent(this, command, state);
        var size = this.eventListeners.getSize();

        for (var i = 0; i < size; i++) {
            this.eventListeners.get(i).stackChanged(event);
        }
    }
});


/** Constant indicating notification prior to executing a command (value is 1).*/
draw2d.command.CommandStack.PRE_EXECUTE = 1;
/** Constant indicating notification prior to redoing a command (value is 2).*/
draw2d.command.CommandStack.PRE_REDO = 2;
/** Constant indicating notification prior to undoing a command (value is 4).*/
draw2d.command.CommandStack.PRE_UNDO = 4;
/**  Constant indicating notification after a command has been executed (value is 8).*/
draw2d.command.CommandStack.POST_EXECUTE = 8;
/** Constant indicating notification after a command has been redone (value is 16).*/
draw2d.command.CommandStack.POST_REDO = 16;
/** Constant indicating notification after a command has been undone (value is 32).*/
draw2d.command.CommandStack.POST_UNDO = 32;
/** Constant indicating notification after the stack has been (re)init (value is 64).*/
draw2d.command.CommandStack.POST_INIT = 64;

draw2d.command.CommandStack.POST_MASK = draw2d.command.CommandStack.POST_EXECUTE | draw2d.command.CommandStack.POST_UNDO | draw2d.command.CommandStack.POST_REDO;
draw2d.command.CommandStack.PRE_MASK = draw2d.command.CommandStack.PRE_EXECUTE | draw2d.command.CommandStack.PRE_UNDO | draw2d.command.CommandStack.PRE_REDO;


/**
 * @class draw2d.command.CommandStackEvent
 * Event class which will be fired for every CommandStack operation. Required for CommandStackListener.
 */
draw2d.command.CommandStackEvent = Class.extend({
    NAME: "draw2d.command.CommandStackEvent",

    /**
     * @constructor
     * Create a new CommandStack objects which can be execute via the CommandStack.
     * @param {draw2d.command.Command} command the related command
     * @param {Number} details the current state of the command execution
     *
     */
    init: function (stack, command, details) {
        this.stack = stack;
        this.command = command;
        this.details = details;
    },


    /**
     * @method
     * Return the corresponding stack of the event.
     *
     * @return {draw2d.command.CommandStack}
     **/
    getStack: function () {
        return this.stack;
    },


    /**
     * @method
     * Returns null or a Command if a command is relevant to the current event.
     *
     * @return {draw2d.command.Command}
     **/
    getCommand: function () {
        return this.command;
    },

    /**
     * @method
     * Returns an integer identifying the type of event which has occurred.
     * Defined by {@link draw2d.command.CommandStack}.
     *
     * @return {Number}
     **/
    getDetails: function () {
        return this.details;
    },


    /**
     * @method
     * Returns true if this event is fired after the stack having changed.
     *
     * @return {boolean} true if post-change event
     **/
    isPostChangeEvent: function () {
        return 0 != (this.getDetails() & draw2d.command.CommandStack.POST_MASK);
    },

    /**
     * @method
     * Returns true if this event is fired prior to the stack changing.
     *
     * @return {boolean} true if pre-change event
     **/
    isPreChangeEvent: function () {
        return 0 != (this.getDetails() & draw2d.command.CommandStack.PRE_MASK);
    }
});

/**
 * @class draw2d.command.CommandStackEventListener
 *
 * Event class which will be fired for every CommandStack operation. Required for CommandStackListener.
 * @author Andreas Herz
 */
draw2d.command.CommandStackEventListener = Class.extend({
    NAME: "draw2d.command.CommandStackEventListener",

    /**
     * @constructor
     * Creates a new Listener Object
     *
     */
    init: function () {
    },

    /**
     * @method
     * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()
     * can be used to identify the type of event which has occurred.
     *
     * @template
     *
     * @param {draw2d.command.CommandStackEvent} event
     **/
    stackChanged: function (event) {
    }

});


/**
 * @class draw2d.command.CommandMove
 *
 * Command for the movement of figures.
 *
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandMove = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandMove",

    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Figure} figure the figure to move
     * @param {Number} [x] the current x position
     * @param {Number} [y] the current y position
     */
    init: function (figure, x, y) {
        this._super(draw2d.Configuration.i18n.command.moveShape);
        this.figure = figure;
        if (typeof x === "undefined") {
            this.oldX = figure.getX();
            this.oldY = figure.getY();
        }
        else {
            this.oldX = x;
            this.oldY = y;
        }
    },


    /**
     * @method
     * Set the initial position of the element
     *
     * @param {Number} x the new initial x position
     * @param {Number} y the new initial y position
     **/
    setStartPosition: function (x, y) {
        this.oldX = x;
        this.oldY = y;
    },

    /**
     * @method
     * Set the target/final position of the figure move command.
     *
     * @param {Number} x the new x position
     * @param {Number} y the new y position
     **/
    setPosition: function (x, y) {
        this.newX = x;
        this.newY = y;
    },

    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return this.newX != this.oldX || this.newY != this.oldY;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.figure.setPosition(this.oldX, this.oldY);
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.figure.setPosition(this.newX, this.newY);
    }
});

/**
 * @class draw2d.command.CommandMoveLine
 *
 * Command for the movement of figures.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandMoveLine = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandMoveLine",

    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Figure} figure the figure to move
     */
    init: function (figure) {
        this._super(draw2d.Configuration.i18n.command.moveLine);
        this.line = figure;
        this.dx = 0;
        this.dy = 0;
    },

    /**
     * @method
     * set the offset of the line translation
     *
     * @param {Number} dx
     * @param {Number} dy
     */
    setTranslation: function (dx, dy) {
        this.dx = dx;
        this.dy = dy;
    },

    /**
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @type boolean
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return this.dx !== 0 && this.dy !== 0;
    },

    /**
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * Undo the command
     *
     **/
    undo: function () {
        var _this = this;
        this.line.getVertices().each(function (i, e) {
            e.translate(-_this.dx, -_this.dy);
        });
        this.line.svgPathString = null;
        // required to update resize handles and the painting of the line
        this.line.setPosition(this.line.getStartPoint());
    },

    /**
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        var _this = this;
        this.line.getVertices().each(function (i, e) {
            e.translate(_this.dx, _this.dy);
        });
        this.line.svgPathString = null;

        // required to update resize handles and the painting of the line
        this.line.setPosition(this.line.getStartPoint());
    }
});

/**
 * @class draw2d.command.CommandMoveVertex
 *
 * Command for the vertex movement of a polyline/polygon.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandMoveVertex = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandMoveVertex",

    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.shape.basic.PolyLine} line the related line
     */
    init: function (line) {
        this._super(draw2d.Configuration.i18n.command.moveVertex);

        this.line = line;
        this.index = -1;
        this.newPoint = null;
    },


    /**
     * @method
     * Set the index of the vertex of the polyline/polygon to modify.
     *
     * @param {Number} index the related index of the vertex
     **/
    setIndex: function (index) {
        this.index = index;
        this.origPoint = this.line.getVertices().get(this.index).clone();
    },

    updatePosition: function (x, y) {
        this.newPoint = new draw2d.geo.Point(x, y);
    },

    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return this.index !== -1 && this.newPoint !== null;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.line.setVertex(this.index, this.origPoint.x, this.origPoint.y);
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.line.setVertex(this.index, this.newPoint.x, this.newPoint.y);
    }
});

/**
 * @class draw2d.command.CommandMoveVertices
 *
 * Command for the vertices movement of a polyline/polygon.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandMoveVertices = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandMoveVertices",

    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.shape.basic.PolyLine} line the related line
     */
    init: function (line) {
        this._super(draw2d.Configuration.i18n.command.moveVertices);

        this.line = line;
        this.oldVertices = line.getVertices().clone();
        this.newVertices = null;
    },


    updateVertices: function (newVertices) {
        this.newVertices = newVertices;
    },

    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return this.newVertices !== null;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.line.setVertices(this.oldVertices);
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.line.setVertices(this.newVertices);
    }
});

/**
 * @class draw2d.command.CommandResize
 * Resize command for figures. Can be execute/undo/redo via a CommandStack.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.command.Command
 */
draw2d.command.CommandResize = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandResize",

    /**
     * @constructor
     * Create a new resize Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Figure} figure the figure to resize
     * @param {Number} [width] the current width
     * @param {Number} [height] the current height
     */
    init: function (figure, width, height) {
        this._super(draw2d.Configuration.i18n.command.resizeShape);
        this.figure = figure;

        if (typeof width === "undefined") {
            this.oldWidth = figure.getWidth();
            this.oldHeight = figure.getHeight();
        }
        else {
            this.oldWidth = width;
            this.oldHeight = height;
        }
    },

    /**
     * @method
     * Set the new dimension of the element.
     *
     * @param {Number} width the new width.
     * @param {Number} height the new height of the element.
     **/
    setDimension: function (width, height) {
        this.newWidth = width | 0;
        this.newHeight = height | 0;
    },

    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return this.newWidth != this.oldWidth || this.newHeight != this.oldHeight;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        this.figure.setDimension(this.oldWidth, this.oldHeight);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        this.figure.setDimension(this.newWidth, this.newHeight);
    }
});

/**
 * @class draw2d.command.CommandRotate
 *
 * Set the rotation angle of the given figure
 *
 * @since 4.4.1
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.command.Command
 */
draw2d.command.CommandRotate = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandRotate",

    /**
     * @constructor
     * Create a new resize Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Figure} figure the figure to resize
     * @param {Number} [width] the current width
     * @param {Number} [height] the current height
     */
    init: function (figure, angle) {
        this._super(draw2d.Configuration.i18n.command.rotateShape);
        this.figure = figure;

        this.oldAngle = figure.getRotationAngle();
        this.newAngle = angle;
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return this.oldAngle != this.newAngle;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        this.rotate(this.oldAngle);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function (angle) {
        this.rotate(this.newAngle)
    },

    rotate: function (angle) {
        var w = this.figure.getWidth();
        var h = this.figure.getHeight();

        this.figure.setRotationAngle(angle);

        this.figure.setDimension(h, w);

        this.figure.portRelayoutRequired = true;
    }
});

/**
 * @class draw2d.command.CommandConnect
 *
 * Connects two ports with a connection.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandConnect = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandConnect",

    /**
     * @constructor
     * Create a new CommandConnect objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Canvas} canvas the canvas to user
     * @param {draw2d.Port} source the source port for the connection to create
     * @param {draw2d.Port} target the target port for the connection to create
     * @param {draw2d.Port} [dropTarget] the port who has initiate the connection creation. mainly the drop target
     */
    init: function (canvas, source, target, dropTarget) {
        this._super(draw2d.Configuration.i18n.command.connectPorts);
        this.canvas = canvas;
        this.source = source;
        this.target = target;
        this.connection = null;
        this.dropTarget = dropTarget; // optional
    },

    setConnection: function (connection) {
        this.connection = connection;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        var optionalCallback = $.proxy(function (conn) {
            this.connection = conn;
            this.connection.setSource(this.source);
            this.connection.setTarget(this.target);
            this.canvas.add(this.connection);
        }, this);

        // the createConnection must return either a connection or "undefined". If the method return "undefined"
        // the asynch callback must be called. Usefull if the createConnection shows a selection dialog
        //
        if (this.connection === null) {
            var result = draw2d.Connection.createConnection(this.source, this.target, optionalCallback, this.dropTarget);
            // well be handeld by the optional callback
            if (typeof result === "undefined") {
                return;
            }

            this.connection = result;
        }

        optionalCallback(this.connection);
    },

    /**
     * @method
     * Redo the command after the user has undo this command.
     *
     **/
    redo: function () {
        this.canvas.add(this.connection);
        this.connection.reconnect();
    },

    /**
     * @method
     * Undo the command.
     *
     **/
    undo: function () {
        this.canvas.remove(this.connection);
    }
});


/**
 * @class draw2d.command.CommandReconnect
 *
 * Reconnects two ports. This command is used during the DragDrop operation of a draw2d.Connection.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandReconnect = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandReconnect",


    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Connection} con the related Connection which is currently in the drag&drop operation
     */
    init: function (con) {
        this._super(draw2d.Configuration.i18n.command.connectPorts);
        this.con = con;
        this.oldSourcePort = con.getSource();
        this.oldTargetPort = con.getTarget();
//      this.oldRouter      = con.getRouter();
    },

    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return true;
    },

    /**
     * @method
     * The new ports to use during the execute of this command.
     *
     * @param {draw2d.Port} source
     * @param {draw2d.Port} target
     */
    setNewPorts: function (source, target) {
        this.newSourcePort = source;
        this.newTargetPort = target;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    cancel: function () {
        this.con.setSource(this.oldSourcePort);
        this.con.setTarget(this.oldTargetPort);

        // force a routing of the connection and DON'T set the old reouter again because this reset all manual added
        // vertices
        this.con.routingRequired = true;
        this.con.repaint();

//       this.con.setRouter(this.oldRouter);
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        this.con.setSource(this.oldSourcePort);
        this.con.setTarget(this.oldTargetPort);
        // force a routing of the connection and DON'T set the old reouter again because this reset all manual added
        // vertices
        this.con.routingRequired = true;
        this.con.repaint();
//      this.con.setRouter(this.oldRouter);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        this.con.setSource(this.newSourcePort);
        this.con.setTarget(this.newTargetPort);
        // force a routing of the connection and DON'T set the old reouter again because this reset all manual added
        // vertices
        this.con.routingRequired = true;
        this.con.repaint();
//      this.con.setRouter(this.oldRouter);
    }

});


/**
 * @class draw2d.command.CommandDelete
 * Command to remove a figure with CommandStack support.
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandDelete = draw2d.command.Command.extend({

    /**
     * @constructor
     * Create a delete command for the given figure.
     *
     * @param {draw2d.Figure} figure
     */
    init: function (figure) {
        this._super(draw2d.Configuration.i18n.command.deleteShape);

        this.parent = figure.getParent();
        this.figure = figure;
        this.canvas = figure.getCanvas();
        this.connections = null;
        this.removedParentEntry = null; // can be null if the figure didn't ave any parent shape assigned
        this.indexOfChild = -1;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        if (this.parent !== null) {
            this.parent.add(this.removedParentEntry.figure, this.removedParentEntry.locator, this.indexOfChild);
            this.canvas.setCurrentSelection(this.parent);
        }
        else {
            this.canvas.add(this.figure);
            this.canvas.setCurrentSelection(this.figure);
        }

        if (this.figure instanceof draw2d.Connection) {
            this.figure.reconnect();
        }


        for (var i = 0; i < this.connections.getSize(); ++i) {
            this.canvas.add(this.connections.get(i));
            this.connections.get(i).reconnect();
        }
    },

    /**
     * @method
     *
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        this.canvas.setCurrentSelection(null);

        // Collect all connections that are bounded to the figure to delete. This connections
        // must be deleted too.
        //
        if (this.connections === null) {
            if (this.figure instanceof draw2d.shape.node.Node) {
                this.connections = this.figure.getConnections();
            }
            else {
                this.connections = new draw2d.util.ArrayList();
            }
        }


        if (this.figure instanceof draw2d.Connection) {
            this.figure.disconnect();
        }

        // remove this figure from the parent
        //
        if (this.parent !== null) {
            // determine the index of the child before remove
            this.indexOfChild = this.parent.getChildren().indexOf(this.figure);
            this.removedParentEntry = this.parent.remove(this.figure);
        }
        // or from the canvas
        else {
            this.canvas.remove(this.figure);
        }

        for (var i = 0; i < this.connections.getSize(); ++i) {
            this.canvas.remove(this.connections.get(i));
        }
    }
});

/**
 * @class draw2d.command.CommandAdd
 *
 * Command to add a figure with CommandStack support.
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandAdd = draw2d.command.Command.extend({

    /**
     * @constructor
     * Create a add command for the given figure.
     *
     * @param {draw2d.Canvas} canvas the canvas to use
     * @param {draw2d.Figure} figure the figure to add
     * @param {Number|draw2d.geo.Point} x the x-coordinate or a complete point where to place the figure
     * @param {Number} [y] the y-coordinate if x is a number and not a complete point
     */
    init: function (canvas, figure, x, y) {
        this._super(draw2d.Configuration.i18n.command.addShape);
        this.figure = figure;
        this.canvas = canvas;
        this.pos = new draw2d.geo.Point(x, y);
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.canvas.add(this.figure, this.pos.x, this.pos.y);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        this.execute();
        this.figure.repaint();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        this.canvas.remove(this.figure);
    }

});

/**
 * @class draw2d.command.CommandGroup
 * Command to group a given set of figures
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandGroup = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandGroup",

    /**
     * @constructor
     * Create a group command for the given figure.
     *
     * @param {draw2d.util.ArrayList} figures the figures to group
     */
    init: function (canvas, figures) {
        this._super(draw2d.Configuration.i18n.command.groupShapes);
        if (figures instanceof draw2d.Selection) {
            this.figures = figures.getAll();
        }
        else {
            this.figures = figures;
        }

        // figures which already part of an non "Group" composite are removed from the set.
        // It is not possible to assign a figure to two different composite
        //
        this.figures.grep(function (figure) {
            return figure.getComposite() === null;
        });

        this.canvas = canvas;
        this.group = new draw2d.shape.composite.Group();
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
     * return false. The execution of this Command doesn't modify the model.
     *
     * @return {boolean} return try if the command modify the model or make any relevant changes
     **/
    canExecute: function () {
        return !this.figures.isEmpty();
    },


    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        var _this = this;
        this.figures.each(function (i, figure) {
            _this.group.unassignFigure(figure);
        });

        this.canvas.remove(this.group);
        this.canvas.setCurrentSelection(this.figures);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        var _this = this;
        this.figures.each(function (i, figure) {
            _this.group.assignFigure(figure);
        });

        this.canvas.add(this.group);
        this.canvas.setCurrentSelection(this.group);
    }
});

/**
 * @class draw2d.command.CommandUngroup
 * Command to ungroup a given group figures
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandUngroup = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandUngroup",

    /**
     * @constructor
     * Create a group command for the given figure.
     *
     * @param {draw2d.util.ArrayList} figures the figures to group
     */
    init: function (canvas, group) {
        this._super(draw2d.Configuration.i18n.command.ungroupShapes);
        if (group instanceof draw2d.Selection) {
            this.group = group.getAll().first();
        }
        else {
            this.group = group;
        }

        this.canvas = canvas;
        this.figures = this.group.getAssignedFigures().clone();
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
     * return false. The execution of this Command doesn't modify the model.
     *
     * @return {boolean} return try if the command modify the model or make any relevant changes
     **/
    canExecute: function () {
        return !this.figures.isEmpty();
    },


    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        var _this = this;
        this.figures.each(function (i, figure) {
            _this.group.assignFigure(figure);
        });
        this.canvas.add(this.group);
        this.canvas.setCurrentSelection(this.group);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        var _this = this;
        this.figures.each(function (i, figure) {
            _this.group.unassignFigure(figure);
        });

        this.canvas.setCurrentSelection(this.figures);
        this.canvas.remove(this.group);
    }
});

/**
 * @class draw2d.command.CommandAddVertex
 *
 * Add a vertex to a polyline or polygon
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandAddVertex = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandAddVertex",

    /**
     * @constructor
     * Create a new Command objects which add a vertex to a PolyLine / Polygon.
     *
     * @param {draw2d.shape.basic.PolyLine} line the related line
     * @param {Number} index the index where to add
     * @param {Number} x the x coordinate for the new vertex
     * @param {Number} y the y coordinate for the new vertex
     */
    init: function (line, index, x, y) {
        this._super(draw2d.Configuration.i18n.command.addVertex);

        this.line = line;
        this.index = index;
        this.newPoint = new draw2d.geo.Point(x, y);
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return true;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.line.removeVertexAt(this.index);
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.line.insertVertexAt(this.index, this.newPoint.x, this.newPoint.y);
    }
});

/**
 * @class draw2d.command.CommandAssignFigure
 *
 * Assign a figure to a compiste
 *
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 * @since 4.9.0
 */
draw2d.command.CommandAssignFigure = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandAssignFigure",

    /**
     * @constructor
     * Create a new Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Figure} figure the figure to assign
     * @param {draw2d.Figure} composite the composite where the figure should assign
     */
    init: function (figure, composite) {
        this._super(draw2d.Configuration.i18n.command.assignShape);

        this.figure = figure;
        this.composite = composite;
        this.assignedConnections = new draw2d.util.ArrayList();
        this.isNode = this.figure instanceof draw2d.shape.node.Node;
        this.oldBoundingBox = composite.getBoundingBox();
        this.newBoundingBox = null; // see execute/redo
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return true;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.composite.assignFigure(this.figure);
        this.newBoundingBox = this.composite.getBoundingBox();

        // get all connections of the shape and check if source/target node
        // part of the composite. In this case the connection will be part of
        // the composite as well
        if (this.isNode === true) {
            var connections = this.figure.getConnections();
            var _this = this;
            connections.each(function (i, connection) {
                if (connection.getSource().getParent().getComposite() === _this.composite && connection.getTarget().getParent().getComposite() === _this.composite) {
                    if (connection.getComposite() !== _this.composite) {
                        _this.assignedConnections.add({
                            oldComposite: connection.getComposite(),
                            connection: connection
                        });
                        _this.composite.assignFigure(connection);
                    }
                }
            });
        }
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.composite.unassignFigure(this.figure);
        this.assignedConnections.each(function (i, entry) {
            if (entry.oldComposite !== null) {
                entry.oldComposite.assignFigure(entry.connection);
            }
            else {
                entry.connection.getComposite().unassignFigure(entry.connection);
            }
        });
        this.composite.stickFigures = true;
        this.composite.setBoundingBox(this.oldBoundingBox);
        this.composite.stickFigures = false;
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.composite.setBoundingBox(this.oldBoundingBox);
        this.composite.assignFigure(this.figure);
        var _this = this;
        this.assignedConnections.each(function (i, entry) {
            _this.composite.assignFigure(entry.connection);
        });
    }
});


/**
 * @class draw2d.command.CommandBoundingBox
 * Set the bounding box of a figure with undo/redo support
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.command.Command
 */
draw2d.command.CommandBoundingBox = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandResize",

    /**
     * @constructor
     * Create a new resize Command objects which can be execute via the CommandStack.
     *
     * @param {draw2d.Figure} figure the figure to resize
     * @param {draw2d.geo.Rectangle} boundingBox the new bounding box of the figure
     */
    init: function (figure, boundingBox) {
        this._super(draw2d.Configuration.i18n.command.resizeShape);
        this.figure = figure;
        this.oldBoundingBox = this.figure.getBoundingBox();
        this.newBoundingBox = boundingBox;
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return !this.oldBoundingBox.equals(this.newBoundingBox);
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     * Undo the command
     *
     **/
    undo: function () {
        this.figure.setBoundingBox(this.oldBoundingBox);
    },

    /**
     * @method
     * Redo the command after the user has undo this command
     *
     **/
    redo: function () {
        this.figure.setBoundingBox(this.newBoundingBox);
    }
});

/**
 * @class draw2d.command.CommandRemoveVertex
 *
 * Remove a vertex from a polyline or polygon
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandRemoveVertex = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandRemoveVertex",

    /**
     * @constructor
     * Create a new Command objects which add a vertex to a PloyLine.
     *
     * @param {draw2d.shape.basic.PolyLine} line the related line
     * @param {Number} index the index where to add
     * @param {Number} x the x coordinate for the new vertex
     * @param {Number} y the y coordinate for the new vertex
     */
    init: function (line, index) {
        this._super(draw2d.Configuration.i18n.command.deleteVertex);

        this.line = line;
        this.index = index;
        this.oldPoint = line.getVertices().get(index).clone();
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return true;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.line.insertVertexAt(this.index, this.oldPoint.x, this.oldPoint.y);
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.line.removeVertexAt(this.index);
    }
});

/**
 * @class draw2d.command.CommandReplaceVertices
 *
 * Replace the vertices of a polyline.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
draw2d.command.CommandReplaceVertices = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandReplaceVertices",

    /**
     * @constructor
     * Create a new Command objects which add a segment to a PolyLine / Polygon.
     *
     * @param {draw2d.shape.basic.PolyLine} line the related line
     * @param {draw2d.util.ArrayList} originalVertices the original vertices of the polyline
     * @param {draw2d.util.ArrayList} newVertices the new vertices of the polyline
     */
    init: function (line, originalVertices, newVertices) {
        this._super(draw2d.Configuration.i18n.command.addSegment);

        this.line = line;
        this.originalVertices = originalVertices;
        this.newVertices = newVertices;
    },


    /**
     * @method
     * Returns [true] if the command can be execute and the execution of the
     * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
     * return false. <br>
     * the execution of the Command doesn't modify the model.
     *
     * @return {boolean}
     **/
    canExecute: function () {
        // return false if we doesn't modify the model => NOP Command
        return true;
    },

    /**
     * @method
     * Execute the command the first time
     *
     **/
    execute: function () {
        this.redo();
    },

    /**
     * @method
     *
     * Undo the move command
     *
     **/
    undo: function () {
        this.line.setVertices(this.originalVertices);
    },

    /**
     * @method
     *
     * Redo the move command after the user has undo this command
     *
     **/
    redo: function () {
        this.line.setVertices(this.newVertices);
    }
});

/**
 * @class draw2d.layout.connection.ConnectionRouter
 * Routes a {@link draw2d.Connection}, possibly using a constraint.
 *
 * @author Andreas Herz
 */
draw2d.layout.connection.ConnectionRouter = Class.extend({
    NAME: "draw2d.layout.connection.ConnectionRouter",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
    },


    /**
     * @method
     * Routes the Connection.
     *
     * @param {draw2d.Connection} connection The Connection to route
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     * @template
     */
    route: function (connection, oldVertices) {
        throw "subclasses must implement the method [ConnectionRouter.route]";
    },

    _paint: function (conn) {
        // calculate the path string for the SVG rendering
        // Important: to avoid subpixel error rendering we add 0.5 to each coordinate
        //            With this offset the canvas can paint the line on a "full pixel" instead
        //            of subpixel rendering.
        var ps = conn.getVertices();
        var p = ps.get(0);
        var distance = conn.getRadius();
        var path = ["M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5];
        var i = 1;
        if (distance > 0) {
            var lastP = p;
            var length = (ps.getSize() - 1);
            for (; i < length; i++) {
                p = ps.get(i);
                inset = this.insetPoint(p, lastP, distance);
                path.push("L", (inset.x | 0) + 0.5, ",", (inset.y | 0) + 0.5);

                p2 = ps.get(i + 1);
                inset = this.insetPoint(p, p2, distance);

                path.push("Q", p.x, ",", p.y, " ", (inset.x | 0) + 0.5, ", ", (inset.y | 0) + 0.5);
                lastP = p;
            }
            p = ps.get(i);
            path.push("L", (p.x | 0) + 0.5, ",", (p.y | 0) + 0.5);
        }
        else {
            var length = ps.getSize();
            for (; i < length; i++) {
                p = ps.get(i);
                path.push("L", (p.x | 0) + 0.5, ",", (p.y | 0) + 0.5);
            }
        }
        conn.svgPathString = path.join("");
    },

    insetPoint: function (start, end, distanceFromStart) {
        if (start.equals(end)) {
            return start;
        }
        var vx = start.x - end.x;
        var vy = start.y - end.y;
        var length = Math.sqrt(vx * vx + vy * vy);
        var localDistance = Math.min(length / 2, distanceFromStart);
        return {
            x: end.x + vx / length * (length - localDistance),
            y: end.y + vy / length * (length - localDistance)
        };

    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {

    },

    /**
     * @method
     * Callback method if the router has been removed from the connection.
     *
     * @param {draw2d.Connection} connection The related connection
     * @template
     * @since 2.7.2
     */
    onUninstall: function (connection) {

    },

    /**
     * @method
     * Callback method for the PolyLine or Connection to check if it possible to remove a vertex from
     * the list. The router can send an veto for this.
     * Per default it is not possible to remove any vertex from the PolyLine exceptional if any interactive
     * router is installed.
     *
     * @param index
     * @since 4.2.3
     */
    canRemoveVertexAt: function (index) {
        return false;
    },

    /**
     * Callback method for the PolyLine or Connection to verify that a segment is deletable.
     * @param index
     * @returns {Boolean}
     * @since 4.2.3
     */
    canRemoveSegmentAt: function (index) {
        return false;
    },

    /**
     * @method
     * Tweak or enrich the polyline persistence data with routing information
     *
     * @since 2.10.0
     * @param {draw2d.shape.basic.PolyLine} line
     * @param {Object} memento The memento data of the polyline
     * @returns {Object}
     */
    getPersistentAttributes: function (line, memento) {
        return memento;
    },

    /**
     * @method
     * set the attributes for the polyline with routing information
     *
     * @since 2.10.0
     * @param {Object} memento the JSON data to read
     */
    setPersistentAttributes: function (line, memento) {
    }

});

/**
 * @class draw2d.layout.connection.DirectRouter
 * Router for direct connections between two ports. Beeline
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // Override the default connection type. This is used during drag&drop operations of ports.
 *     //
 *     draw2d.Connection.createConnection=function(sourcePort, targetPort){
 *        // return my special kind of connection
 *        var con = new draw2d.Connection();
 *        con.setRouter(new draw2d.layout.connection.DirectRouter());
 *        return con;
 *     };
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // first Connection
 *     //
 *     var c = draw2d.Connection.createConnection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */
draw2d.layout.connection.DirectRouter = draw2d.layout.connection.ConnectionRouter.extend({

    NAME: "draw2d.layout.connection.DirectRouter",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    },

    /**
     * @method
     * Invalidates the given Connection
     */
    invalidate: function () {
    },

    /**
     * @method
     * Routes the Connection in air line (beeline).
     *
     * @param {draw2d.Connection} connection The Connection to route
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (connection, oldVertices) {
        var start = connection.getStartPoint();
        var end = connection.getEndPoint();

        // required for hit tests
        //
        connection.addPoint(start);
        connection.addPoint(end);

        // calculate the path
        var path = ["M", start.x, " ", start.y];
        path.push("L", end.x, " ", end.y);

        connection.svgPathString = path.join("");

    }
});


/**
 * @class draw2d.layout.connection.VertexRouter
 * Router for direct connections between two ports. Beeline
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // Override the default connection type. This is used during drag&drop operations of ports.
 *     //
 *     draw2d.Connection.createConnection=function(sourcePort, targetPort){
 *        // return my special kind of connection
 *        var con = new draw2d.Connection();
 *        con.setRouter(new draw2d.layout.connection.DirectRouter());
 *        return con;
 *     };
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // first Connection
 *     //
 *     var c = draw2d.Connection.createConnection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */
draw2d.layout.connection.VertexRouter = draw2d.layout.connection.ConnectionRouter.extend({

    NAME: "draw2d.layout.connection.VertexRouter",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.VertexSelectionFeedbackPolicy());
    },

    /**
     * @method
     * Invalidates the given Connection
     */
    invalidate: function () {
    },

    /**
     * @method
     * Routes the Connection in air line (beeline).
     *
     * @param {draw2d.Connection} connection The Connection to route
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (connection, oldVertices) {

        // required for hit tests
        //
        var count = oldVertices.getSize();
        for (var i = 0; i < count; i++) {
            connection.addPoint(oldVertices.get(i));
        }

        var ps = connection.getVertices();

        // respect the calculated anchor position if the start/end port has set any Anchor impl.
        var startAnchor = connection.getStartPoint(ps.get(1));
        var endAnchor = connection.getEndPoint(ps.get(ps.getSize() - 2));
        ps.first().setPosition(startAnchor);
        ps.last().setPosition(endAnchor);

        this._paint(connection);
    },

    /**
     * @method
     * Callback method for the PolyLine or Connection to check if it possible to remove a vertex from
     * the list. The router can send an veto for this.
     * Per default it is not possible to remove any vertex from the PolyLine exceptional if any interactive
     * router is installed.
     *
     * @param index
     * @since 4.2.3
     */
    canRemoveVertexAt: function (conn, index) {

        var count = conn.getVertices().getSize();

        return false;
    },

    /**
     * Callback method for the PolyLine or Connection to verify that a segment is deletable.
     * @param index
     * @returns {Boolean}
     * @since 4.2.3
     */
    canRemoveSegmentAt: function (conn, index) {

        var segmentCount = conn.getVertices().getSize() - 1; // segmentCount is one less than vertex count

        // The first and last segment isn't deletable
        //
        if ((index <= 0) || (index >= segmentCount)) {
            return false;
        }

        // a connection need at least one strokes
        //
        if (segmentCount < 2) {
            return false;
        }

        return true;
    },


    /**
     * @method
     * Tweak or enrich the polyline persistence data with routing information
     *
     * @since 2.10.0
     * @param {draw2d.shape.basic.PolyLine} line
     * @param {Object} memento The memento data of the polyline
     * @returns {Object}
     */
    getPersistentAttributes: function (line, memento) {
        memento.vertex = [];

        line.getVertices().each(function (i, e) {
            memento.vertex.push({x: e.x, y: e.y});
        });

        return memento;
    },

    /**
     * @method
     * set the attributes for the polyline with routing information
     *
     * @since 2.10.0
     * @param {Object} memento
     */
    setPersistentAttributes: function (line, memento) {
        // restore the points from the JSON data and add them to the polyline
        //
        if (typeof memento.vertex !== "undefined") {

            line.oldPoint = null;
            line.lineSegments = new draw2d.util.ArrayList();
            line.vertices = new draw2d.util.ArrayList();

            $.each(memento.vertex, function (i, e) {
                line.addPoint(e.x, e.y);
            });
        }
    }

});


/**
 * @class draw2d.layout.connection.ManhattanConnectionRouter
 * Provides a {@link draw2d.Connection} with an orthogonal route between the Connection's source
 * and target anchors.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // Override the default connection type. This is used during drag&drop operations of ports.
 *     //
 *     draw2d.Connection.createConnection=function(sourcePort, targetPort){
 *        // return my special kind of connection
 *        var con = new draw2d.Connection();
 *        con.setRouter(new draw2d.layout.connection.ManhattanConnectionRouter());
 *        return con;
 *     };
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // first Connection
 *     //
 *     var c = draw2d.Connection.createConnection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */
draw2d.layout.connection.ManhattanConnectionRouter = draw2d.layout.connection.ConnectionRouter.extend({
    NAME: "draw2d.layout.connection.ManhattanConnectionRouter",

    MINDIST: 20,
    TOL: 0.1,
    TOLxTOL: 0.01,
    TOGGLE_DIST: 5,

    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    },

    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection} conn
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        // calculate the lines between the two points.
        //
        this._route(conn, toPt, toDir, fromPt, fromDir);
        this._paint(conn);
    },

    /**
     * @method
     * Internal routing algorithm.
     *
     * @private
     * @param {draw2d.Connection} conn
     * @param {draw2d.geo.Point} fromPt
     * @param {Number} fromDir
     * @param {draw2d.geo.Point} toPt
     * @param {Number} toDir
     */
    _route: function (conn, fromPt, fromDir, toPt, toDir) {
        // fromPt is an x,y to start from.
        // fromDir is an angle that the first link must
        //
        var UP = draw2d.geo.Rectangle.DIRECTION_UP;
        var RIGHT = draw2d.geo.Rectangle.DIRECTION_RIGHT;
        var DOWN = draw2d.geo.Rectangle.DIRECTION_DOWN;
        var LEFT = draw2d.geo.Rectangle.DIRECTION_LEFT;

        var xDiff = fromPt.x - toPt.x;
        var yDiff = fromPt.y - toPt.y;
        var point;
        var dir;

        if (((xDiff * xDiff) < (this.TOLxTOL)) && ((yDiff * yDiff) < (this.TOLxTOL))) {
            conn.addPoint(new draw2d.geo.Point(toPt.x, toPt.y));
            return;
        }

        if (fromDir === LEFT) {
            if ((xDiff > 0) && ((yDiff * yDiff) < this.TOL) && (toDir === RIGHT)) {
                point = toPt;
                dir = toDir;
            }
            else {
                if (xDiff < 0) {
                    point = new draw2d.geo.Point(fromPt.x - this.MINDIST, fromPt.y);
                }
                else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) && (toDir === UP))) {
                    point = new draw2d.geo.Point(toPt.x, fromPt.y);
                }
                else if (fromDir == toDir) {
                    var pos = Math.min(fromPt.x, toPt.x) - this.MINDIST;
                    point = new draw2d.geo.Point(pos, fromPt.y);
                }
                else {
                    point = new draw2d.geo.Point(fromPt.x - (xDiff / 2), fromPt.y);
                }

                if (yDiff > 0) {
                    dir = UP;
                }
                else {
                    dir = DOWN;
                }
            }
        }
        else if (fromDir === RIGHT) {
            if ((xDiff < 0) && ((yDiff * yDiff) < this.TOL) && (toDir === LEFT)) {
                point = toPt;
                dir = toDir;
            }
            else {
                if (xDiff > 0) {
                    point = new draw2d.geo.Point(fromPt.x + this.MINDIST, fromPt.y);
                }
                else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) && (toDir === UP))) {
                    point = new draw2d.geo.Point(toPt.x, fromPt.y);
                }
                else if (fromDir === toDir) {
                    var pos = Math.max(fromPt.x, toPt.x) + this.MINDIST;
                    point = new draw2d.geo.Point(pos, fromPt.y);
                }
                else {
                    point = new draw2d.geo.Point(fromPt.x - (xDiff / 2), fromPt.y);
                }

                if (yDiff > 0) {
                    dir = UP;
                }
                else {
                    dir = DOWN;
                }
            }
        }
        else if (fromDir === DOWN) {
            if (((xDiff * xDiff) < this.TOL) && (yDiff < 0) && (toDir === UP)) {
                point = toPt;
                dir = toDir;
            }
            else {
                if (yDiff > 0) {
                    point = new draw2d.geo.Point(fromPt.x, fromPt.y + this.MINDIST);
                }
                else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) && (toDir === LEFT))) {
                    point = new draw2d.geo.Point(fromPt.x, toPt.y);
                }
                else if (fromDir === toDir) {
                    var pos = Math.max(fromPt.y, toPt.y) + this.MINDIST;
                    point = new draw2d.geo.Point(fromPt.x, pos);
                }
                else {
                    point = new draw2d.geo.Point(fromPt.x, fromPt.y - (yDiff / 2));
                }

                if (xDiff > 0) {
                    dir = LEFT;
                }
                else {
                    dir = RIGHT;
                }
            }
        }
        else if (fromDir === UP) {
            if (((xDiff * xDiff) < this.TOL) && (yDiff > 0) && (toDir === DOWN)) {
                point = toPt;
                dir = toDir;
            }
            else {
                if (yDiff < 0) {
                    point = new draw2d.geo.Point(fromPt.x, fromPt.y - this.MINDIST);
                }
                else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) && (toDir === LEFT))) {
                    point = new draw2d.geo.Point(fromPt.x, toPt.y);
                }
                else if (fromDir === toDir) {
                    var pos = Math.min(fromPt.y, toPt.y) - this.MINDIST;
                    point = new draw2d.geo.Point(fromPt.x, pos);
                }
                else {
                    point = new draw2d.geo.Point(fromPt.x, fromPt.y - (yDiff / 2));
                }

                if (xDiff > 0) {
                    dir = LEFT;
                }
                else {
                    dir = RIGHT;
                }
            }
        }
        this._route(conn, point, dir, toPt, toDir);
        conn.addPoint(fromPt);
    }

});

/**
 * @class draw2d.layout.connection.ManhattanBridgedConnectionRouter
 * Provides a {@link draw2d.Connection} with an orthogonal route between the Connection's source
 * and target anchors.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */
draw2d.layout.connection.ManhattanBridgedConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME: "draw2d.layout.connection.ManhattanBridgedConnectionRouter",

    BRIDGE_HORIZONTAL_LR: " r 0 0 3 -4 7 -4 10 0 13 0 ", // Left to right
    BRIDGE_HORIZONTAL_RL: " r 0 0 -3 -4 -7 -4 -10 0 -13 0 ", // right to left

    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    },

    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection} conn the connection to layout
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        // calculate the lines between the two points.
        //
        this._route(conn, toPt, toDir, fromPt, fromDir);

        // calculate the path string for the SVG rendering
        //
        var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
        var intersectionsDESC = intersectionsASC.clone().reverse();

        var intersectionForCalc = intersectionsASC;
        var i = 0;

        // ATTENTION: we cast all x/y coordinates to int and add 0.5 to avoid subpixel rendering of
        //            the connection. The 1px or 2px lines look much clearer than before.
        //
        var ps = conn.getVertices();
        var p = ps.get(0);
        var path = ["M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5];
        var oldP = p;
        for (i = 1; i < ps.getSize(); i++) {
            p = ps.get(i);

            // check for intersection and paint a bridge if required
            // line goes from left to right
            //
            var bridgeWidth = 5;
            var bridgeCode = this.BRIDGE_HORIZONTAL_LR;

            // line goes from right->left. Inverse the bridge and the bridgeWidth
            //
            if (oldP.x > p.x) {
                intersectionForCalc = intersectionsDESC;
                bridgeCode = this.BRIDGE_HORIZONTAL_RL;
                bridgeWidth = -bridgeWidth;
            }

            intersectionForCalc.each(function (ii, interP) {
                if (interP.justTouching == false && draw2d.shape.basic.Line.hit(1, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {
                    // we draw only horizontal bridges. Just a design decision
                    //
                    if (p.y === interP.y) {
                        path.push(" L", ((interP.x - bridgeWidth) | 0) + 0.5, " ", (interP.y | 0) + 0.5);
                        path.push(bridgeCode);
                    }
                }

            });

            path.push(" L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
            oldP = p;
        }
        conn.svgPathString = path.join("");
    }

});

/**
 * @class draw2d.layout.connection.InteractiveManhattanConnectionRouter
 * Route the connection in an Manhattan style and add resize handles to all vertex for interactive alignment of the
 * routing.
 *
 *
 * @author Andreas Herz
 * @since 4.0.2
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */
draw2d.layout.connection.InteractiveManhattanConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME: "draw2d.layout.connection.InteractiveManhattanConnectionRouter",


    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function () {
        this._super();

    },

    onInstall: function (conn) {
        conn.installEditPolicy(new draw2d.policy.line.OrthogonalSelectionFeedbackPolicy());
        if (!conn._routingMetaData) {
            conn._routingMetaData = {
                routedByUserInteraction: false,
                fromDir: -1,
                toDir: -1
            };
        }
    },

    onUninstall: function (conn) {
        delete conn._routingMetaData;
    },

    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection} conn the connection to layout
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        if (oldVertices.getSize() === 0 || conn._routingMetaData.routedByUserInteraction === false) {
            this._super(conn, oldVertices);
            conn._routingMetaData.fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());
            conn._routingMetaData.toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());
        }
        else {
            this.halfRoute(conn, oldVertices);
            this._paint(conn);
        }
    },

    /**
     * @method
     * The routing algorithm if the user has changed at least on of the vertices manually.
     * This kind of routing just align the start and end vertices to the new source/target port
     * location.
     * The vertices between keep untouched. Modification of this vertices are done by the
     * draw2d.policy.line.OrthogonalSelectionFeedbackPolicy
     *
     * @param {draw2d.Connection} conn the connection to route
     * @param {draw2d.util.ArrayList} oldVertices the vertices of the routing before
     */
    halfRoute: function (conn, oldVertices) {

        var vertexCount = oldVertices.getSize();

        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        var max = Math.max;
        var min = Math.min;

        // the port orientation has been changed. This can happen if the node rotates. In this case
        // we must recalculate the routing.
        if (conn._routingMetaData.fromDir !== fromDir || conn._routingMetaData.toDir !== toDir) {
            conn._routingMetaData.routedByUserInteraction = false;
            this.route(conn, oldVertices);
        }

        //  go back to the default if no routing is possible anymore
        //
        if ((fromDir === 1 ) && (toDir === 3) && (fromPt.x > toPt.x) && (vertexCount <= 4)) {
            conn._routingMetaData.routedByUserInteraction = false;
            this.route(conn, oldVertices);
        }

        // transfer the old vertices into the connection
        //
        oldVertices.each(function (i, vertex) {
            conn.addPoint(vertex);
        });


        // The SOURCE port (labeled with p0) has been moved/changed.
        //
        if (!fromPt.equals(oldVertices.get(0))) {
            var p1 = oldVertices.get(1);
            var p2 = oldVertices.get(2);
            conn.setVertex(0, fromPt);
            switch (fromDir) {
                //          .
                //   p0     . p1
                //   +------+
                //          .
                //          .
                //
                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                    conn.setVertex(1, max(fromPt.x + 10, p1.x), fromPt.y);// p1
                    conn.setVertex(2, max(fromPt.x + 10, p1.x), p2.y);    // p2
                    break;
                //   .
                //   . p1     p0
                //   +------+
                //   .
                //   .
                //
                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                    conn.setVertex(1, min(fromPt.x - 10, p1.x), fromPt.y);// p1
                    conn.setVertex(2, min(fromPt.x - 10, p1.x), p2.y);    // p2
                    break;
                //     ...+....
                //     p1 |
                //        |
                //        |
                //     p0 +
                //
                case draw2d.geo.Rectangle.DIRECTION_UP:
                    conn.setVertex(1, fromPt.x, min(fromPt.y - 10, p1.y)); // p1
                    conn.setVertex(2, p2.x, min(fromPt.y - 10, p1.y)); // p2
                    break;
                //        +
                //     p0 |
                //        |
                //     p1 |
                //    ....+....
                //
                case draw2d.geo.Rectangle.DIRECTION_DOWN:
                    conn.setVertex(1, fromPt.x, max(fromPt.y + 10, p1.y)); // p1
                    conn.setVertex(2, p2.x, max(fromPt.y + 10, p1.y));     // p2
                    break;
            }
        }
        //////////////////////////////////////////////////////////////////
        // the TARGET port ( labeled with p0) has moved
        //
        if (!toPt.equals(oldVertices.get(vertexCount - 1))) {
            var p1 = oldVertices.get(vertexCount - 2);
            var p2 = oldVertices.get(vertexCount - 3);
            conn.setVertex(vertexCount - 1, toPt);                        // p0

            switch (toDir) {
                //               .
                //      p0       . p1
                //    +----------+
                //               .
                //               .
                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                    conn.setVertex(vertexCount - 2, max(toPt.x + 10, p1.x), toPt.y);  // p1
                    conn.setVertex(vertexCount - 3, max(toPt.x + 10, p1.x), p2.y);    // p2
                    break;

                //    .
                //    .
                //    . p1         p0
                //    +----------+
                //    .
                //    .
                //
                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                    conn.setVertex(vertexCount - 2, min(toPt.x - 10, p1.x), toPt.y);  // p1
                    conn.setVertex(vertexCount - 3, min(toPt.x - 10, p1.x), p2.y);    // p2
                    break;

                //     ...+....
                //     p1 |
                //        |
                //        |
                //     p0 +
                //
                case draw2d.geo.Rectangle.DIRECTION_UP:
                    conn.setVertex(vertexCount - 2, toPt.x, max(toPt.y + 10, p1.y));  // p1
                    conn.setVertex(vertexCount - 3, p2.x, max(toPt.y + 10, p1.y));  // p2
                    break;

                //        +
                //     p0 |
                //        |
                //     p1 |
                //     ...+...
                //
                case draw2d.geo.Rectangle.DIRECTION_DOWN:
                    conn.setVertex(vertexCount - 2, toPt.x, max(toPt.y + 10, p1.y));  // p1
                    conn.setVertex(vertexCount - 3, p2.x, max(toPt.y + 10, p1.y));  // p2
                    break;
            }
        }
    },

    /**
     * Callback method for the PolyLine or Connection to verify that a segment is deletable.
     * @param index
     * @returns {Boolean}
     * @since 4.2.3
     */
    canRemoveSegmentAt: function (conn, index) {

        var segmentCount = conn.getVertices().getSize() - 1; // segmentCount is one less than vertex count

        // The first and last segment isn't deletable
        //
        if ((index <= 0) || (index >= segmentCount)) {
            return false;
        }

        // a connection need at least three strokes
        //
        if (segmentCount < 4) {
            return false;
        }

        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        if (segmentCount <= 5) {
            //     ___
            //    |   |      From
            //    | 1 |-----+
            //    |___|     |
            //              |
            //   +----------+
            //   |
            //   |    ___
            //   |   |   |
            //   +---| 2 |    To
            //       |___|
            // the connection needs at least 5 segments if the routing is like this above
            //
            if ((fromDir === draw2d.geo.Rectangle.DIRECTION_RIGHT) && ( toDir === draw2d.geo.Rectangle.DIRECTION_LEFT) && (fromPt.x >= toPt.x)) {
                return false;
            }


            //     ___
            //    |   |        To
            //    | 2 |-----+
            //    |___|     |
            //              |
            //   +----------+
            //   |
            //   |    ___
            //   |   |   |
            //   +---| 1 |    From
            //       |___|
            //
            if ((fromDir == draw2d.geo.Rectangle.DIRECTION_LEFT) & ( toDir == draw2d.geo.Rectangle.DIRECTION_RIGHT) && (fromPt.x <= toPt.x)) {
                return false;
            }

            //                          ___
            //      +_______           |   |
            //      | from  |          | 2 |
            //     _+_      |          |___|
            //    |   |     |       To   +
            //    | 1 |     |____________|
            //    |___|
            //
            if ((fromDir == draw2d.geo.Rectangle.DIRECTION_UP) & ( toDir == draw2d.geo.Rectangle.DIRECTION_DOWN) && (fromPt.y <= toPt.y)) {
                return false;
            }

            //                          ___
            //      +_______           |   |
            //      | to    |          | 1 |
            //     _+_      |          |___|
            //    |   |     |     from   +
            //    | 2 |     |____________|
            //    |___|
            //
            if ((fromDir == draw2d.geo.Rectangle.DIRECTION_DOWN) & ( toDir == draw2d.geo.Rectangle.DIRECTION_UP) && (fromPt.y >= toPt.y)) {
                return false;
            }

            // unable to make the decision on the easy way. calculate the route again and
            // check if the segment count of the new routed connection allows a removal
            //
            var tmpConn = new draw2d.Connection();
            tmpConn.lineSegments = new draw2d.util.ArrayList();
            tmpConn.vertices = new draw2d.util.ArrayList();
            tmpConn.sourcePort = conn.sourcePort;
            tmpConn.targetPort = conn.targetPort;
            tmpConn._routingMetaData = {routedByUserInteraction: false, fromDir: -1, toDir: -1};
            this.route(tmpConn, new draw2d.util.ArrayList());
            var curSegmentCount = conn.getVertices().getSize() - 1;
            var minSegmentCount = tmpConn.getVertices().getSize() - 1;
            if (curSegmentCount <= minSegmentCount) {
                return false;
            }
        }

        return true;
    },


    /**
     * @method
     * Tweak or enrich the polyline persistence data with routing information
     *
     * @since 2.10.0
     * @param {draw2d.shape.basic.PolyLine} line
     * @param {Object} memento The memento data of the polyline
     * @returns {Object}
     */
    getPersistentAttributes: function (line, memento) {
        memento.vertex = [];

        line.getVertices().each(function (i, e) {
            memento.vertex.push({x: e.x, y: e.y});
        });
        memento.routingMetaData = $.extend({}, line._routingMetaData);

        return memento;
    },

    /**
     * @method
     * set the attributes for the polyline with routing information of the interactive manhattan router.
     *
     * @since 4..0.0
     * @param {Object} memento
     */
    setPersistentAttributes: function (line, memento) {
        // restore the points from the JSON data and add them to the polyline
        //
        if (typeof memento.vertex !== "undefined") {

            line.oldPoint = null;
            line.lineSegments = new draw2d.util.ArrayList();
            line.vertices = new draw2d.util.ArrayList();

            $.each(memento.vertex, function (i, e) {
                line.addPoint(e.x, e.y);
            });
        }

        if (typeof memento.routingMetaData !== "undefinied") {
            line._routingMetaData = $.extend({}, memento.routingMetaData);
        }
    }

});

/**
 * @class draw2d.layout.connection.CircuitConnectionRouter
 * Provides a {@link draw2d.Connection} with an orthogonal route between the Connection's source
 * and target anchors.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */
draw2d.layout.connection.CircuitConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME: "draw2d.layout.connection.CircuitConnectionRouter",

    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function () {
        this._super();

        this.setBridgeRadius(4);
        this.setVertexRadius(2);

        // experimental
        this.abortRoutingOnFirstVertexNode = false;
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    },

    /**
     * @method
     * Callback method if the router has been removed from the connection. In the case of the CircuitRouter
     * all vertex nodes will be removed from the canvas.
     *
     * @param {draw2d.Connection} connection The related connection
     * @template
     * @since 2.7.2
     */
    onUninstall: function (connection) {
        if (typeof connection.vertexNodes !== "undefined" && connection.vertexNodes !== null) {
            connection.vertexNodes.remove();
            connection.vertexNodes = null;
        }
    },

    /**
     * @method
     * Set the radius of the vertex circle.
     *
     * @param {Number} radius
     * @deprecated
     */
    setVertexRadius: function (radius) {
        this.vertexRadius = radius;
    },
    /** deprecated
     * @private
     * **/
    setJunctionRadius: function (radius) {
        this.vertexRadius = radius;
    },

    /**
     * @method
     * Set the radius or span of the bridge. A bridge will be drawn if two connections are crossing and didn't have any
     * common port.
     *
     * @param {Number} radius
     */
    setBridgeRadius: function (radius) {
        this.bridgeRadius = radius;
        this.bridge_LR = [" r", 0.5, -0.5, radius - (radius / 2), -(radius - radius / 4), radius, -radius, radius + (radius / 2), -(radius - radius / 4), radius * 2, "0 "].join(" ");
        this.bridge_RL = [" r", -0.5, -0.5, -(radius - (radius / 2)), -(radius - radius / 4), -radius, -radius, -(radius + (radius / 2)), -(radius - radius / 4), -radius * 2, "0 "].join(" ");
    },

    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection} conn the connection to layout
     * @param {draw2d.util.ArrayList} oldVertePoints old/existing vertex of the Connection
     */
    route: function (conn, oldVertexPoints) {
        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        // calculate the lines between the two points with the standard ManhattanRouter.
        //
        this._route(conn, toPt, toDir, fromPt, fromDir);

        // get the intersections to the other connections
        //
        var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
        var intersectionsDESC = intersectionsASC.clone().reverse();

        var intersectionForCalc = intersectionsASC;
        var i = 0;

        // add a ArrayList of all added vertex nodes to the connection
        //
        if (typeof conn.vertexNodes !== "undefined" && conn.vertexNodes !== null) {
            conn.vertexNodes.remove();
        }
        conn.vertexNodes = conn.canvas.paper.set();

        // ATTENTION: we cast all x/y coordinates to integer and add 0.5 to avoid subpixel rendering of
        //            the connection. The 1px or 2px lines look much clearer than before.
        //
        var ps = conn.getVertices();
        var p = ps.get(0);
        var path = ["M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5];

        var oldP = p;
        var bridgeWidth = null;
        var bridgeCode = null;

        var lastVertexNode = null;

        for (i = 1; i < ps.getSize(); i++) {
            p = ps.get(i);

            // line goes from right->left.
            if (oldP.x > p.x) {
                intersectionForCalc = intersectionsDESC;
                bridgeCode = this.bridge_RL;
                bridgeWidth = -this.bridgeRadius;
            }
            // line goes from left->right
            else {
                intersectionForCalc = intersectionsASC;
                bridgeCode = this.bridge_LR;
                bridgeWidth = this.bridgeRadius;
            }

            // add a bridge or a vertex node depending to the intersection connection
            //
            // bridge   => the connections didn't have a common port
            // vertex => the connections did have a common source or target port
            //
            intersectionForCalc.each($.proxy(function (ii, interP) {
                if (draw2d.shape.basic.Line.hit(1, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {

                    // It is a vertex node..
                    //
                    if (conn.sharingPorts(interP.other)) {
                        var other = interP.other;
                        var otherZ = other.getZOrder();
                        var connZ = conn.getZOrder();
                        if (connZ < otherZ) {
                            var vertexNode = conn.canvas.paper.ellipse(interP.x, interP.y, this.vertexRadius, this.vertexRadius).attr({fill: conn.lineColor.hash()});
                            conn.vertexNodes.push(vertexNode);
                            // we found a vertex node. In this case an already existing connection did draw the connection.
                            //
                            if (this.abortRoutingOnFirstVertexNode === true) {
                                if (conn.getSource() == other.getSource() || conn.getSource() == other.getTarget()) {
                                    path = ["M", (interP.x | 0) + 0.5, " ", (interP.y | 0) + 0.5];
                                    if (lastVerteNode !== null) {
                                        lastVerteNode.remove();
                                        conn.vertexNodes.exclude(lastVerteNode);
                                    }
                                }
                                lastVerteNode = vertexNode;
                            }
                        }
                    }
                    // ..or a bridge. We draw only horizontal bridges. Just a design decision
                    //
                    else if (p.y === interP.y) {
                        path.push(" L", ((interP.x - bridgeWidth) | 0) + 0.5, " ", (interP.y | 0) + 0.5);
                        path.push(bridgeCode);
                    }
                }
            }, this));

            path.push(" L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
            oldP = p;
        }
        conn.svgPathString = path.join("");
    }
});
/**
 * @class draw2d.layout.connection.SplineConnectionRouter
 *
 * A MannhattanConnectionRouter with an spline interpolation between the bend points.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.connection.ManhattanConnectionRouter
 */
draw2d.layout.connection.SplineConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({

    NAME: "draw2d.layout.connection.SplineConnectionRouter",

    /**
     * @constructor Creates a new Router object
     */
    init: function () {
        this._super();

//        this.spline = new draw2d.util.spline.CatmullRomSpline();
        this.spline = new draw2d.util.spline.CubicSpline();
//        this.spline = new draw2d.util.spline.BezierSpline();

        this.MINDIST = 50,
            this.cheapRouter = null;
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());
    },

    /**
     * @method
     * Layout the hands over connection with the cubic spline calculation and manhattan routing
     *
     * @param {draw2d.Connection} conn
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        var i = 0;
        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        // calculate the manhatten bend points between start/end.
        //
        this._route(conn, toPt, toDir, fromPt, fromDir);

        var ps = conn.getVertices();

        conn.oldPoint = null;
        conn.lineSegments = new draw2d.util.ArrayList();
        conn.vertices = new draw2d.util.ArrayList();

        var splinePoints = this.spline.generate(ps, 8);
        splinePoints.each(function (i, e) {
            conn.addPoint(e);
        });

        // calculate the path string for the SVG rendering
        //
        var ps = conn.getVertices();
        length = ps.getSize();
        var p = ps.get(0);
        var path = ["M", p.x, " ", p.y];
        for (i = 1; i < length; i++) {
            p = ps.get(i);
            path.push("L", p.x, " ", p.y);
        }
        conn.svgPathString = path.join("");
    }
});
/**
 * @class draw2d.layout.connection.FanConnectionRouter
 *
 * Automatic router that spreads its  {@link draw2d.Connection Connections} in a fan-like fashion upon collision.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // Override the default connection type. This is used during drag&drop operations of ports.
 *     //
 *     draw2d.Connection.createConnection=function(sourcePort, targetPort){
 *        // return my special kind of connection
 *        var con = new draw2d.Connection();
 *        con.setRouter(new draw2d.layout.connection.FanConnectionRouter());
 *        return con;
 *     };
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // first Connection
 *     //
 *     var c = draw2d.Connection.createConnection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 *
 *     // second Connection
 *     //
 *     c = draw2d.Connection.createConnection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 *
 *     // third Connection
 *     //
 *     c = draw2d.Connection.createConnection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.layout.connection.DirectRouter
 */
draw2d.layout.connection.FanConnectionRouter = draw2d.layout.connection.DirectRouter.extend({
    NAME: "draw2d.layout.connection.FanConnectionRouter",

    /**
     * @constructor Creates a new Router object.
     */
    init: function () {
        this._super();

    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    },

    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection}  conn
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        var lines = conn.getSource().getConnections().clone();
        lines.grep(function (other) {
            return other.getTarget() === conn.getTarget() || other.getSource() === conn.getTarget();
        });

        if (lines.getSize() > 1) {
            this.routeCollision(conn, lines.indexOf(conn));
        }
        else {
            this._super(conn);
        }
    },

    /**
     * @method
     * route the connection if connections overlap. Two connections overlap if the combination
     * of source and target anchors are equal.
     *
     * @param {draw2d.Connection} conn
     * @param {Number} index
     */
    routeCollision: function (conn, index) {
        index = index + 1;
        var start = conn.getStartPoint();
        var end = conn.getEndPoint();

        var separation = 15;

        var midPoint = new draw2d.geo.Point((end.x + start.x) / 2, (end.y + start.y) / 2);
        var position = end.getPosition(start);
        var ray;
        if (position == draw2d.geo.PositionConstants.SOUTH || position == draw2d.geo.PositionConstants.EAST) {
            ray = new draw2d.geo.Point(end.x - start.x, end.y - start.y);
        }
        else {
            ray = new draw2d.geo.Point(start.x - end.x, start.y - end.y);
        }

        var length = Math.sqrt(ray.x * ray.x + ray.y * ray.y);

        var xSeparation = separation * ray.x / length;
        var ySeparation = separation * ray.y / length;

        var bendPoint;

        if (index % 2 === 0) {
            bendPoint = new draw2d.geo.Point(midPoint.x + (index / 2) * (-1 * ySeparation), midPoint.y + (index / 2) * xSeparation);
        }
        else {
            bendPoint = new draw2d.geo.Point(midPoint.x + (index / 2) * ySeparation, midPoint.y + (index / 2) * (-1 * xSeparation));
        }

        // required for hit tests
        conn.addPoint(start);
        conn.addPoint(bendPoint);
        conn.addPoint(end);

        // calculate the path string for the SVG rendering
        //
        this._paint(conn);
    }
});
/**
 * @class draw2d.layout.connection.MazeConnectionRouter
 * <b>BETA VERSION. Not for production!!!<br></b>
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */
var ROUTER_RECTS = null;

draw2d.layout.connection.MazeConnectionRouter = draw2d.layout.connection.ConnectionRouter.extend({
    NAME: "draw2d.layout.connection.MazeConnectionRouter",


    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function () {
        this._super();

        this.useSpline = false;
        this.useSimplify = true;
        this.useSimplifyValue = 2;
        this.useDebug = false;
        this.useShift = 4;
        this.portOutletOffset = 15;


//    	this.finder = new PF.AStarFinder();
//      this.finder = new PF.AStarFinder({ allowDiagonal: true, dontCrossCorners: true});
//      this.finder = new PF.AStarFinder({ allowDiagonal: false});
//      this.finder = new PF.BiBreadthFirstFinder({ allowDiagonal: false});
//      this.finder = new PF.BreadthFirstFinder({ allowDiagonal: false});
        this.finder = new PF.JumpPointFinder({allowDiagonal: false, dontCrossCorners: true});
    },


    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    },

    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection} conn
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        // calculate the lines between the two points.
        //
        this._route(conn, toPt, toDir, fromPt, fromDir);
        this._paint(conn);
    },

    /**
     * @method
     * Internal routing algorithm.
     *      * <p>
     * Possible values:
     * <ul>
     *   <li>up -&gt; 0</li>
     *   <li>right -&gt; 1</li>
     *   <li>down -&gt; 2</li>
     *   <li>left -&gt; 3</li>
     * </ul>
     * <p>

     * @private
     * @param {draw2d.Connection} conn
     * @param {draw2d.geo.Point} fromPt
     * @param {Number} fromDir
     * @param {draw2d.geo.Point} toPt
     * @param {Number} toDir
     */
    _route: function (conn, fromPt, fromDir, toPt, toDir) {
        var shift = this.useShift;

        oldToPt = toPt;
        oldFromPt = fromPt;

        // move the points with an offset in the prefered routing direction of the ports
        // to avoid that the routed connection is sticking on one side of the figure.
        //
        fromPt = this.getAddjustedPoint(fromPt, fromDir, this.portOutletOffset);
        toPt = this.getAddjustedPoint(toPt, toDir, this.portOutletOffset);

        var grid = this.generateNoGoGrid(conn, fromPt, fromDir, toPt, toDir);

        // 4. Calculate the shortest path from source to target based on the grid
        //
        var path = this.finder.findPath(
            fromPt.x >> shift, fromPt.y >> shift,
            toPt.x >> shift, toPt.y >> shift,
            grid);

        // transfer the path from the grid based coordinates back to the real coordinates
        //
        $.each(path, function (i, e) {
            e.x = e[0] = e[0] << shift;
            e.y = e[1] = e[1] << shift;
        });

        // 5. paint the "no go" area in read if we are in debug mode
        //
        if (this.useDebug) {
            if (ROUTER_RECTS !== null) {
                ROUTER_RECTS.remove();
            }
            ROUTER_RECTS = conn.canvas.paper.set();

            for (var i = 0; i < grid.width; i++) {
                for (var j = 0; j < grid.height; j++) {
                    if (!grid.isWalkableAt(i, j))
                        ROUTER_RECTS.push(conn.canvas.paper.rect(i << shift, j << shift, 1 << shift, 1 << shift).attr({
                            "fill": "red",
                            "opacity": "0.1"
                        }));
                }
            }
            ROUTER_RECTS.push(conn.canvas.paper.rect(fromPt.x - 3, fromPt.y - 3, 6, 6).attr({
                "fill": "#ff0000",
                "opacity": "0.8"
            }));
            ROUTER_RECTS.push(conn.canvas.paper.rect(toPt.x - 3, toPt.y - 3, 6, 6).attr({
                "fill": "#ff0000",
                "opacity": "0.8"
            }));

            // paint the original calculated path without any simplification in BLUE
            $.each(path, function (i, e) {
                ROUTER_RECTS.push(conn.canvas.paper.rect(e.x - 3, e.y - 3, 6, 6).attr({
                    "fill": "#0000ff",
                    "opacity": "0.8"
                }));
            });
            var p = path[0];
            var svgPathBefore = ["M", p.x, " ", p.y];
            for (var i = 1; i < path.length; i++) {
                p = path[i];
                svgPathBefore.push("L", p.x, " ", p.y);
            }
            svgPathBefore = svgPathBefore.join("");
            ROUTER_RECTS.push(conn.canvas.paper.path(svgPathBefore).attr({"stroke": "#0000ff"}));
        }


        this.adjustPath(fromPt, path, fromDir);
        path.reverse();
        this.adjustPath(toPt, path, toDir);
        path.reverse();

        $.each(path, function (i, e) {
            e.x = e[0];
            e.y = e[1];
        });


        if (this.useSpline) {
            var p = new draw2d.util.ArrayList();
            p.add(oldFromPt);
            $.each(path, function (i, e) {
                p.add(new draw2d.geo.Point(e[0], e[1]));
            });
            p.add(oldToPt);

            if (this.useDebug) {
                $.each(path, function (i, e) {
                    ROUTER_RECTS.push(conn.canvas.paper.rect(e.x - 3, e.y - 3, 6, 6).attr({
                        "fill": "#00ff00",
                        "opacity": "0.8"
                    }));
                });
                var pt = path[0];
                var svgPathBefore = ["M", pt.x, " ", pt.y];
                for (var i = 1; i < path.length; i++) {
                    pt = path[i];
                    svgPathBefore.push("L", pt.x, " ", pt.y);
                }
                svgPathBefore = svgPathBefore.join("");
                ROUTER_RECTS.push(conn.canvas.paper.path(svgPathBefore).attr({"stroke": "#00ff00"}));
            }

            this.spline = new draw2d.util.spline.CubicSpline();
            var splinePoints = this.spline.generate(p, 8);

            if (this.useSimplify) {
                path = [];
                splinePoints.each(function (i, e) {
                    path.push({x: e.x, y: e.y});
                });
                path = this.simplify(path, this.useSimplifyValue, true);

                $.each(path, function (i, e) {
                    conn.addPoint(e.x, e.y);
                });
            }
            else {
                splinePoints.each(function (i, e) {
                    conn.addPoint(e);
                });
            }
        }
        else {
            if (this.useSimplify) {
                path = this.simplify(path, this.useSimplifyValue, true);
            }

            if (this.useDebug) {
                $.each(path, function (i, e) {
                    ROUTER_RECTS.push(conn.canvas.paper.rect(e.x - 3, e.y - 3, 6, 6).attr({
                        "fill": "#00ff00",
                        "opacity": "0.8"
                    }));
                });
                var p = path[0];
                var svgPathBefore = ["M", p.x, " ", p.y];
                for (var i = 1; i < path.length; i++) {
                    p = path[i];
                    svgPathBefore.push("L", p.x, " ", p.y);
                }
                svgPathBefore = svgPathBefore.join("");
                ROUTER_RECTS.push(conn.canvas.paper.path(svgPathBefore).attr({"stroke": "#00ff00"}));
            }

            conn.addPoint(oldFromPt);
            $.each(path, function (i, e) {
                conn.addPoint(e[0], e[1]);
            });
            conn.addPoint(oldToPt);

        }

    },

    /**
     * @method
     * Generate a grid base no go map required for the path finding algorithm
     *
     * @param conn
     * @returns {PF.Grid}
     */
    generateNoGoGrid: function (conn, fromPt, fromDir, toPt, toDir) {
        var shift = this.useShift;
        var oneShift2 = (1 << shift) / 2;

        // 1. generate a map with all "no go" areas. The bounding box of the shapes defines
        //    the no go areas.
        //
        var canvasWidth = conn.getCanvas().paper.width >> shift;
        var canvasHeight = conn.getCanvas().paper.height >> shift;
        var grid = new PF.Grid(canvasWidth, canvasHeight);
        var figures = conn.getCanvas().getFigures();
        figures.each(function (i, e) {
            var box = e.getBoundingBox();
            // remove shapes which are hit by the input or output ports. It is not possible to route
            // out from a not walkable area
            if (box.hitTest(fromPt.x, fromPt.y) === true || box.hitTest(toPt.x, toPt.y)) {
                return;
            }

            var x = box.x >> shift;
            var y = box.y >> shift;
            if (x < 1 || y < 1) {
                return;
            }
            var r_orig = (box.x + box.w + oneShift2) >> shift;
            var b_orig = (box.y + box.h + oneShift2) >> shift;
            for (var i = x; i <= r_orig; i++) {
                for (var j = y; j <= b_orig; j++) {
                    grid.setWalkableAt(i, j, false);
                }
            }
        });


        // 3. make the are walkable on the edge of the port side. Otherwise we a
        //    an enclosed area around the port if we are very close to another shape
        //
        var box = conn.getSource().getParent().getBoundingBox();
        if (toDir === 1 || toDir === 3) {
            var y = box.y >> shift;
            if (y > 0) {
                var b_orig = box.y + box.h;
                var i = (toPt.x >> shift);

                for (var j = y - 1; j << shift <= b_orig; j++) {
                    grid.setWalkableAt(i, j, true);
                }
            }
        }
        else {
            var x = box.x >> shift;
            if (x > 0) {
                var r_orig = box.x + box.w;
                var j = (toPt.x >> shift);
                for (var i = x - 1; i << shift <= r_orig; i++) {
                    grid.setWalkableAt(i, j, true);
                }
            }
        }

        box = conn.getTarget().getParent().getBoundingBox();
        if (fromDir === 1 || fromDir === 3) {
            var y = box.y >> shift;
            if (y > 0) {
                var b_orig = box.y + box.h;
                var i = (fromPt.x >> shift);
                for (var j = y - 1; j << shift <= b_orig; j++) {
                    grid.setWalkableAt(i, j, true);
                }
            }
        }
        else {
            var x = box.x >> shift;
            if (x > 0) {
                var r_orig = box.x + box.w;
                var j = (fromPt.x >> shift);
                for (var i = x - 1; i << shift <= r_orig; i++) {
                    grid.setWalkableAt(i, j, true);
                }
            }
        }

        return grid;
    },

    /**
     * @method
     * move the point in the given direction with the given offset
     *
     * @param {draw2d.geo.Point} pt
     * @param {Number} direction
     * @param {Number} adjustment
     *
     * @returns {draw2d.geo.Point}
     */
    getAddjustedPoint: function (pt, direction, adjustment) {

        switch (direction) {
            case draw2d.geo.Rectangle.DIRECTION_UP:
                return new draw2d.geo.Point(pt.x, pt.y - adjustment);
            case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                return new draw2d.geo.Point(pt.x + adjustment, pt.y);
            case draw2d.geo.Rectangle.DIRECTION_DOWN:
                return new draw2d.geo.Point(pt.x, pt.y + adjustment);
            case draw2d.geo.Rectangle.DIRECTION_LEFT:
                return new draw2d.geo.Point(pt.x - adjustment, pt.y);
        }
    },

    adjustPath: function (pt, path, direction) {
        var shift = this.useShift;
        var x = pt.x >> shift;
        var y = pt.y >> shift;
        $.each(path, function (i, e) {
            if (y === (e[1] >> shift)) {
                e[1] = pt.y;
            }
            else {
                return false;
            }
        });
        $.each(path, function (i, e) {
            if (x === (e[0] >> shift)) {
                e[0] = pt.x;
            }
            else {
                return false;
            }
        });
    },


    getSquareDistance: function (p1, p2) { // square distance between 2 points

        var dx = p1.x - p2.x,
            dy = p1.y - p2.y;

        return dx * dx +
            dy * dy;
    },

    getSquareSegmentDistance: function (p, p1, p2) { // square distance from a point to a segment

        var x = p1.x,
            y = p1.y,

            dx = p2.x - x,
            dy = p2.y - y,

            t;

        if (dx !== 0 || dy !== 0) {

            t = ((p.x - x) * dx +
                (p.y - y) * dy) /
                (dx * dx +
                dy * dy);

            if (t > 1) {
                x = p2.x;
                y = p2.y;

            } else if (t > 0) {
                x += dx * t;
                y += dy * t;
            }
        }

        dx = p.x - x;
        dy = p.y - y;

        return dx * dx +
            dy * dy;
    },

    simplifyRadialDistance: function (points, sqTolerance) { // distance-based simplification

        var i,
            len = points.length,
            point = null,
            prevPoint = points[0],
            newPoints = [prevPoint];

        for (i = 1; i < len; i++) {
            point = points[i];

            if (this.getSquareDistance(point, prevPoint) > sqTolerance) {
                newPoints.push(point);
                prevPoint = point;
            }
        }

        if (prevPoint !== point) {
            newPoints.push(point);
        }

        return newPoints;
    },


    // simplification using optimized Douglas-Peucker algorithm with recursion elimination

    simplifyDouglasPeucker: function (points, sqTolerance) {

        var len = points.length,

            MarkerArray = (typeof Uint8Array !== undefined + '')
                ? Uint8Array
                : Array,

            markers = new MarkerArray(len),

            first = 0,
            last = len - 1,

            i,
            maxSqDist,
            sqDist,
            index,

            firstStack = [],
            lastStack = [],

            newPoints = [];

        markers[first] = markers[last] = 1;

        while (last) {

            maxSqDist = 0;

            for (i = first + 1; i < last; i++) {
                sqDist = this.getSquareSegmentDistance(points[i], points[first], points[last]);

                if (sqDist > maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }

            if (maxSqDist > sqTolerance) {
                markers[index] = 1;

                firstStack.push(first);
                lastStack.push(index);

                firstStack.push(index);
                lastStack.push(last);
            }

            first = firstStack.pop();
            last = lastStack.pop();
        }

        for (i = 0; i < len; i++) {
            if (markers[i]) {
                newPoints.push(points[i]);
            }
        }

        return newPoints;
    },


    simplify: function (points, tolerance, highestQuality) {

        var sqTolerance = (tolerance !== undefined)
            ? tolerance * tolerance
            : 1;

        if (!highestQuality) {
            points = this.simplifyRadialDistance(points, sqTolerance);
        }
        points = this.simplifyDouglasPeucker(points, sqTolerance);

        return points;
    }
});

/**
 * @class draw2d.layout.connection.MuteableManhattanConnectionRouter
 *
 * JUST FOR RESEARCH AT THE MOMENT!!!!!!
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */

draw2d.layout.connection.MuteableManhattanConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME: "draw2d.layout.connection.MuteableManhattanConnectionRouter",

    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    UP: new draw2d.geo.Ray(0, -1),
    DOWN: new draw2d.geo.Ray(0, 1),
    LEFT: new draw2d.geo.Ray(-1, 0),
    RIGHT: new draw2d.geo.Ray(1, 0),

    init: function () {
        this._super();

        this.rowsUsed = {};//new HashMap<Integer, Integer>();
        this.colsUsed = {};//new HashMap<Integer, Integer>();
        this.constraints = {};//new HashMap<Connection, Object>();
        this.reservedInfo = {};//new HashMap<Connection, ReservedInfo>();
    },


    /**
     * @method
     * Layout the hands over connection in a manhattan like layout
     *
     * @param {draw2d.Connection} conn
     * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
     */
    route: function (conn, oldVertices) {
        this.rowsUsed = {};//new HashMap<Integer, Integer>();
        this.colsUsed = {};//new HashMap<Integer, Integer>();
        this.constraints = {};//new HashMap<Connection, Object>();
        this.reservedInfo = {};//new HashMap<Connection, ReservedInfo>();

        var canvas = conn.getCanvas();
        var i;

        var startPoint = conn.getStartPoint();
        var endPoint = conn.getEndPoint();

        var start = new draw2d.geo.Ray(startPoint);
        var end = new draw2d.geo.Ray(endPoint);
        var average = new draw2d.geo.Ray((start.x + end.x) / 2, (start.y + end.y) / 2);

        var direction = new draw2d.geo.Ray(end.x - start.x, end.y - start.y);
        var startNormal = this.getStartDirection(conn);
        var endNormal = this.getEndDirection(conn);

        var positions = new draw2d.util.ArrayList();
        var horizontal = startNormal.isHorizontal();

        if (horizontal) {
            positions.add(start.y);
        }
        else {
            positions.add(start.x);
        }

        horizontal = !horizontal;

        // dot product is zero if the vector orthogonal (90�?)
        if (startNormal.dot(endNormal) === 0) {
            if ((startNormal.dot(direction) >= 0) && (endNormal.dot(direction) <= 0)) {
                // 0
            } else {

                // 2
                if (startNormal.dot(direction) < 0)
                    i = startNormal.similarity(start.getTranslated(startNormal.getScaled(10)));
                else {
                    if (horizontal)
                        i = average.y;
                    else
                        i = average.x;
                }

                positions.add(i);
                horizontal = !horizontal;

                if (endNormal.dot(direction) > 0) {
                    i = endNormal.similarity(end.getTranslated(endNormal.getScaled(10)));
                }
                else {
                    if (horizontal) {
                        i = average.y;
                    }
                    else {
                        i = average.x;
                    }
                }
                positions.add(i);
                horizontal = !horizontal;
            }
        } else {
            if (startNormal.dot(endNormal) > 0) {
                //1
                if (startNormal.dot(direction) >= 0)
                    i = startNormal.similarity(start.getTranslated(startNormal.getScaled(10)));
                else
                    i = endNormal.similarity(end.getTranslated(endNormal.getScaled(10)));
                positions.add(i);
                horizontal = !horizontal;
            } else {
                //3 or 1
                if (startNormal.dot(direction) < 0) {
                    i = startNormal.similarity(start.getTranslated(startNormal.getScaled(10)));
                    positions.add(i);
                    horizontal = !horizontal;
                }

                // my tweak to route SCA wires starts
                if (this.isCycle(conn)) {
                    if (horizontal)
                        i = conn.getSource().getParent().getBoundingBox().getTop() - 10;// * index;
                    else
                        i = conn.getSource().getParent().getBoundingBox().getRight() + 10;// * index;
                } else {
                    if (horizontal) {
                        var j = average.y;

                        var next = endNormal.similarity(end.getTranslated(endNormal.getScaled(10)));

                        var trial = new draw2d.geo.Ray((positions.get(positions.getSize() - 1)), j);
                        var figure = this.findFirstFigureAtStraightLine(canvas, trial, this.LEFT, draw2d.util.ArrayList.EMPTY_LIST);

                        while (figure != null && figure.getBoundingBox().x + figure.getBoundingBox().width > next) {
                            j = figure.getBoundingBox().y + figure.getBoundingBox().height + 5;
                            trial.y = j;
                            figure = this.findFirstFigureAtStraightLine(canvas, trial, this.LEFT, Collections.EMPTY_LIST);
                        }

                        i = j;

                    } else {
                        var figure = this.findFirstFigureAtStraightLine(canvas, start, this.RIGHT, this.getExcludingFigures(conn));
                        if (figure == null)
                            i = average.x;
                        else {
                            i = Math.min(average.x, start.getTranslated(new draw2d.geo.Ray(3 * (figure.getBoundingBox().x - start.x) / 4, 0)).x);
                            i = Math.max(start.x, i);
                        }
                        i = this.adjust(conn, i);
                    }
                }
                // my tweak to route SCA wires ends
                positions.add(i);
                horizontal = !horizontal;
                /*

                 if (startNormal.dot(direction) < 0) {
                 i = endNormal.similarity(end.getTranslated(endNormal.getScaled(10)));
                 positions.add( i);
                 horizontal = !horizontal;
                 } else {
                 // my tweak to route SCA wires starts
                 var reroute = false;

                 var j = end.y;

                 var figure = this.findFirstFigureAtStraightLine(canvas, new draw2d.geo.Ray(i, j), this.RIGHT, this.getExcludingFigures(conn));
                 while (figure != null && figure.getBoundingBox().x < end.x) {
                 reroute = true;
                 if (direction.dot(this.DOWN) > 0)
                 j = figure.getBoundingBox().y - 5;
                 else
                 j = figure.getBoundingBox().y + figure.getBoundingBox().height + 5;

                 figure = this.findFirstFigureAtStraightLine(canvas, new draw2d.geo.Ray(i, j), this.RIGHT, this.getExcludingFigures(conn));
                 }
                 if (reroute) {
                 i = j;
                 positions.add(i);
                 horizontal = !horizontal;

                 i = endNormal.similarity(end.getTranslated(endNormal.getScaled(10)));
                 positions.add( i);
                 horizontal = !horizontal;

                 }
                 // my tweak to route SCA wires ends

                 }
                 */
            }
        }
        if (horizontal)
            positions.add(end.y);
        else
            positions.add(end.x);

        this.processPositions(start, end, positions, startNormal.isHorizontal(), conn);


        this._paint(conn);
    },

    /**
     * @method
     *
     * @param {draw2d.Connection} connection
     * @param {Number} r
     * @param {Number} n
     * @param {Number} x
     *
     * @private
     */
    getColumnNear: function (connection, r, n, x) {
        var min = Math.min(n, x);
        var max = Math.max(n, x);

        if (min > r) {
            max = min;
            min = r - (min - r);
        }
        if (max < r) {
            min = max;
            max = r + (r - max);
        }

        var proximity = 0;
        var direction = -1;
        if (r % 6 != 0) {
            r = r - ( r % 6);
        }

        var i;
        while (proximity < r) {
            i = parseInt(r + proximity * direction);
            if (!(i in this.colsUsed)) {
                this.colsUsed[i] = i;
                this.reserveColumn(connection, i);
                return i;
            }

            if (i <= min) {
                return i + 6;
            }

            if (i >= max) {
                return i - 6;
            }

            if (direction === 1) {
                direction = -1;
            }
            else {
                direction = 1;
                proximity += 6;
            }
        }
        return r;
    },

    getRowNear: function (connection, r, n, x) {
        var min = Math.min(n, x);
        var max = Math.max(n, x);

        if (min > r) {
            max = min;
            min = r - (min - r);
        }
        if (max < r) {
            min = max;
            max = r + (r - max);
        }

        var proximity = 0;
        var direction = -1;
        if (r % 6 != 0) {
            r = r - ( r % 6);
        }

        var i;
        while (proximity < r) {
            i = parseInt(r + proximity * direction);
            if (!(i in this.rowsUsed)) {
                this.rowsUsed[i] = i;
                this.reserveRow(connection, i);
                return i;
            }
            if (i <= min)
                return i + 6;
            if (i >= max)
                return i - 6;
            if (direction == 1)
                direction = -1;
            else {
                direction = 1;
                proximity += 6;
            }
        }
        return r;
    },

    /**
     *   <li>up -&gt; 0</li>
     *   <li>right -&gt; 1</li>
     *   <li>down -&gt; 2</li>
     *   <li>left -&gt; 3</li>
     **/
    getEndDirection: function (conn) {
        var p = conn.getEndPoint();
        var rect = conn.getTarget().getParent().getBoundingBox();
        return this.getDirection(rect, p);
    },


    /**
     *   <li>up -&gt; 0</li>
     *   <li>right -&gt; 1</li>
     *   <li>down -&gt; 2</li>
     *   <li>left -&gt; 3</li>
     **/
    getStartDirection: function (conn) {
        var p = conn.getStartPoint();
        var rect = conn.getSource().getParent().getBoundingBox();
        return this.getDirection(rect, p);
    },

    /**
     * Returns the direction the point <i>p</i> is in relation to the given rectangle.
     * Possible values are LEFT (-1,0), RIGHT (1,0), UP (0,-1) and DOWN (0,1).
     *
     * @param r the rectangle
     * @param p the point
     * @return the direction from <i>r</i> to <i>p</i>
     */
    getDirection: function (r, p) {
        var i = Math.abs(r.y - p.y);
        var distance = Math.abs(r.x - p.x);
        var direction = this.LEFT;

        if (i <= distance) {
            distance = i;
            direction = this.UP;
        }

        i = Math.abs(r.getBottom() - p.y);
        if (i <= distance) {
            distance = i;
            direction = this.DOWN;
        }

        i = Math.abs(r.getRight() - p.x);
        if (i < distance) {
            distance = i;
            direction = this.RIGHT;
        }

        return direction;
    },

    processPositions: function (/*Ray*/ start, /*Ray*/ end, /*List*/ positions, /*boolean*/ horizontal, /*Connection*/ conn) {
        this.removeReservedLines(conn);

        var pos = [];
        if (horizontal)
            pos.push(start.x);
        else
            pos.oush(start.y);
        var i;
        for (i = 0; i < positions.getSize(); i++) {
            pos.push(positions.get(i));
        }

        if (horizontal == (positions.getSize() % 2 == 1)) {
            pos.push(end.x);
        }
        else {
            pos.push(end.y);
        }

        conn.addPoint(new draw2d.geo.Point(start.x, start.y));
        var p;
        var current, prev, min, max;
        var adjust;
        for (i = 2; i < pos.length - 1; i++) {
            horizontal = !horizontal;
            prev = pos[i - 1];
            current = pos[i];

            adjust = (i !== pos.length - 2);
            if (horizontal) {
                if (adjust) {
                    min = pos[i - 2];
                    max = pos[i + 2];
                    pos[i] = current = this.getRowNear(conn, current, min, max);
                }
                p = new draw2d.geo.Point(prev, current);
            } else {
                if (adjust) {
                    min = pos[i - 2];
                    max = pos[i + 2];
                    pos[i] = current = this.getColumnNear(conn, current, min, max);
                }
                p = new draw2d.geo.Point(current, prev);
            }
            conn.addPoint(p);
        }
        conn.addPoint(new draw2d.geo.Point(end.x, end.y));
    },


    removeReservedLines: function (connection) {
        var rInfo = this.reservedInfo[connection];
        if (typeof rInfo === "undefined" || rInfo === null)
            return;

        for (var i = 0; i < rInfo.reservedRows.getSize(); i++) {
            delete this.rowsUsed[rInfo.reservedRows.get(i)];
        }
        for (var i = 0; i < rInfo.reservedCols.getSize(); i++) {
            delete this.colsUsed[rInfo.reservedCols.get(i)];
        }
        delete this.reservedInfo[connection];
    },

    reserveColumn: function (connection, column) {
        var info = this.reservedInfo[connection];
        if (typeof info === "undefined" || info === null) {
            info = {reservedCols: new draw2d.util.ArrayList(), reservedRows: new draw2d.util.ArrayList()};
            this.reservedInfo[connection] = info;
        }
        info.reservedCols.add(column);
    },

    reserveRow: function (connection, row) {
        var info = this.reservedInfo[connection];
        if (typeof info === "undefined" || info === null) {
            info = {reservedCols: new draw2d.util.ArrayList(), reservedRows: new draw2d.util.ArrayList()};
            this.reservedInfo[connection] = info;
        }
        info.reservedRows.add(row);
    },

    getConstraint: function (connection) {
        return this.constraints[connection];
    },

    setConstraint: function (connection, constraint) {
        this.constraints[connection] = constraint;
    },

    isCycle: function (conn) {
        var source = conn.getSource().getParent();
        var target = conn.getTarget().getParent();

        return source.id === target.id;
    },

    getExcludingFigures: function (conn) {
        var excluding = new draw2d.util.ArrayList();

        excluding.add(conn.getSource().getParent());
        excluding.add(conn.getTarget().getParent());

        return excluding;
    },

    findFirstFigureAtStraightLine: function (canvas, /*Ray*/ start, /*Ray*/ direction, /*List*/ excluding) {
        var figure = null;

        var figures = canvas.getFigures();
        var _this = this;
        figures.each(function (i, child) {
            try {
                if (!excluding.contains(child)) {
                    var rect = child.getBoundingBox();
                    if (_this.LEFT.equals(direction)) {
                        if (start.x > rect.x && start.y >= rect.y && start.y <= rect.y + rect.h) {
                            if (figure === null || rect.x > figure.getBoundingBox().x)
                                figure = child;
                        }
                    } else if (_this.RIGHT.equals(direction)) {
                        if (start.x < rect.x + rect.w && start.y >= rect.y && start.y <= rect.y + rect.h) {
                            if (figure == null || rect.x < figure.getBoundingBox().x)
                                figure = child;
                        }
                    } else if (_this.UP.equals(direction)) {
                        if (start.y > rect.y && start.x >= rect.x && start.x <= rect.x + rect.w) {
                            if (figure === null || rect.y > figure.getBoundingBox().y)
                                figure = child;
                        }
                    } else if (_this.DOWN.equals(direction)) {
                        if (start.y < rect.y + rect.h && start.x >= rect.x && start.x <= rect.x + rect.w) {
                            if (figure === null || rect.y < figure.getBoundingBox().y)
                                figure = child;
                        }
                    }
                }
            }
            catch (exc) {
                console.log(exc);
            }
        });
        return figure;
    },

    adjust: function (connection, col) {
        var column = col;

        var start = connection.getSource().getPosition();

        var connections = connection.getCanvas().getLines();
        connections.each(function (i, conn) {
            try {
                if (conn === connection)
                    return;

                var end = conn.getTarget().getPosition();
                if (start.x < end.x && start.y == end.y) {
                    if (conn.getVertices().getMidpoint().x <= col)
                        column = conn.getVertices().getMidpoint().x - 5;
                }
            }
            catch (exc) {
                console.log(exc);
            }
        });
        return column;
    }


});

/**
 * @class draw2d.layout.connection.SketchBridgedConnectionRouter
 *
 * Provide a router which routes the connection in a hand drawn manner.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @since 2.7.2
 * @extends  draw2d.layout.connection.MazeConnectionRouter
 */
draw2d.layout.connection.SketchConnectionRouter = draw2d.layout.connection.MazeConnectionRouter.extend({
    NAME: "draw2d.layout.connection.SketchConnectionRouter",


    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function () {
        this._super();

        this.useSpline = true;
        this.useShift = 5;
        this.useSimplifyValue = 0.2;
        this.finder = new PF.JumpPointFinder({allowDiagonal: false, dontCrossCorners: true});
    },

    /**
     * @method
     * Callback method if the router has been assigned to a connection.
     *
     * @param {draw2d.Connection} connection The assigned connection
     * @template
     * @since 2.7.2
     */
    onInstall: function (connection) {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

    }

});

/**
 * @class draw2d.layout.mesh.MeshLayouter
 * Layouter for a mesh or grid.
 *
 * @author Andreas Herz
 */
draw2d.layout.mesh.MeshLayouter = Class.extend({

    /**
     * @constructor
     * Creates a new layouter object.
     */
    init: function () {
    },

    /**
     * @method
     * Return a changes list for an existing mesh/canvas to ensure that the element to insert
     * did have enough space.
     *
     * @param {draw2d.Canvas} canvas the canvas to use for the analytic
     * @param {draw2d.Figure} figure The figure to add to the exising canvas
     *
     *
     * @return {draw2d.util.ArrayList} a list of changes to apply if the user want to insert he figure.
     */
    add: function (canvas, figure) {
        return new draw2d.util.ArrayList();
    }
});

/**
 * @class draw2d.layout.mesh.ExplodeLayouter
 * Routes a {@link draw2d.Connection}, possibly using a constraint.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.mesh.MeshLayouter
 */
draw2d.layout.mesh.ExplodeLayouter = draw2d.layout.mesh.MeshLayouter.extend({

    MIN_MARGIN: 40,

    /**
     * @constructor
     * Creates a new layouter object.
     */
    init: function () {
    },

    /**
     * @method
     * Return a changes list for an existing mesh/canvas to ensure that the element to insert
     * did have enough space.
     *
     * @param {draw2d.Canvas} canvas the canvas to use for the analytic
     * @param {draw2d.Figure} figure The figure to add to the exising canvas
     * @param {Number} x requested x-position for the figure
     * @param {Number} y requested y-position for the figure
     *
     *
     * @return {draw2d.util.ArrayList} a list of changes to apply if the user want to insert he figure.
     */
    add: function (canvas, figureToAdd) {
        // changes for the differenct octant areas
        var changes = [];
        changes[0] = {x: 0, y: 0};
        changes[1] = {x: 0, y: 0};
        changes[2] = {x: 0, y: 0};
        changes[3] = {x: 0, y: 0};
        changes[4] = {x: 0, y: 0};
        changes[5] = {x: 0, y: 0};
        changes[6] = {x: 0, y: 0};
        changes[7] = {x: 0, y: 0};
        changes[8] = {x: 0, y: 0};

        var boundingBox = figureToAdd.getBoundingBox();

        var figures = canvas.getFigures();
        var figure = null;

        var dis = 0;
        var oct = 0;
        var currentOctChanges = null;
        var i = 0;
        for (i = 0; i < figures.getSize(); i++) {

            figure = figures.get(i);

            // calculate the distance of all corners in relation to the requested x/y coordinate
            //
            if (figure !== figureToAdd) {
                dis = figure.getBoundingBox().getDistance(boundingBox);
                // other figure is to close
                //
                if (dis < this.MIN_MARGIN) {
                    // determine the octant of the figure
                    oct = this.determineOctant(boundingBox, figure.getBoundingBox());

                    // all other relevant segments must be arranged too!!
                    //
                    switch (oct) {
                        case 2:
                            changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN - dis);
                            changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN - dis);
                            changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN - dis);
                            break;
                        case 3:
                            changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN - dis);
                            changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN - dis);
                            changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN - dis);
                            break;
                        case 4:
                            changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN - dis);
                            changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN - dis);
                            changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN - dis);
                            changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN - dis);
                            changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN - dis);
                            changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN - dis);
                            break;
                        case 5:
                            changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN - dis);
                            changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN - dis);
                            changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN - dis);
                            break;
                        case 6:
                            changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN - dis);
                            changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN - dis);
                            changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN - dis);
                            break;
                        case 8:
                            // overlapping
                            // we must determine the new distance with the border of the figures
                            dis = (boundingBox.getBottomRight().getDistance(figure.getBoundingBox().getTopLeft())) | 0;

                            changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN + dis);
                            changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN + dis);
                            changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN + dis);
                            changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN + dis);
                            changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN + dis);
                            changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN + dis);
                            changes[8].x = Math.max(changes[8].x, this.MIN_MARGIN + dis);
//        				changes[8].y =  Math.max(changes[8].y,this.MIN_MARGIN+dis);
                    }
                }
            }
            // Falls die minimale Distance zu den Objecten kleiner 80 ist, muss ein layout erfolgen
        }

        // calculate the adjustment for each figure
        //
        var result = new draw2d.util.ArrayList();
        for (i = 0; i < figures.getSize(); i++) {
            figure = figures.get(i);
            if (figure !== figureToAdd) {
                oct = this.determineOctant(boundingBox, figure.getBoundingBox());
                currentOctChanges = changes[oct];
                if (currentOctChanges.x !== 0 || currentOctChanges.y !== 0) {
                    result.add(new draw2d.layout.mesh.ProposedMeshChange(figure, currentOctChanges.x, currentOctChanges.y));
                }
            }
        }

        return result;
    },


    /**
     * @method
     * Determin Octant
     *
     *    0 | 1 | 2
     *    __|___|__
     *    7 | 8 | 3
     *    __|___|__
     *    6 | 5 | 4
     *
     * @param cx
     * @param cy
     * @param cw
     * @param ch
     * @param ox
     * @param oy
     * @param ow
     * @param oh
     * @returns {Number}
     */
    determineOctant: function (r1, r2) {
        var ox = r1.x;
        var oy = r1.y;
        var ow = r1.w;
        var oh = r1.h;

        var cx = r2.x;
        var cy = r2.y;
        var cw = r2.w;
        var ch = r2.h;
        var oct = 0;

        if (cx + cw <= ox) {
            if ((cy + ch) <= oy) {
                oct = 0;
            }
            else if (cy >= (oy + oh)) {
                oct = 6;
            }
            else {
                oct = 7;
            }
        }
        else if (cx >= ox + ow) {
            if (cy + ch <= oy) {
                oct = 2;
            }
            else if (cy >= oy + oh) {
                oct = 4;
            }
            else {
                oct = 3;
            }
        }
        else if (cy + ch <= oy) {
            oct = 1;
        }
        else if (cy >= oy + oh) {
            oct = 5;
        }
        else {
            oct = 8;
        }

        return oct;
    }
});

/**
 * @class draw2d.layout.mesh.ProposedMeshChange
 * Change proposal for grid/mesh layout changes.
 *
 * @author Andreas Herz
 */
draw2d.layout.mesh.ProposedMeshChange = Class.extend({

    /**
     * @constructor
     * Creates change object.
     */
    init: function (figure, x, y) {
        this.figure = figure;
        this.x = x;
        this.y = y;
    },

    /**
     * @method
     * Return the related figure.
     *
     * @return {draw2d.Figure} the figure to the related change proposal
     */
    getFigure: function () {
        return this.figure;
    },

    /**
     * @method
     * The proposed x-coordinate.
     *
     * @return {Number}
     */
    getX: function () {
        return this.x;
    },

    /**
     * @method
     * The proposed y-coordinate
     *
     * @return {Number}
     */
    getY: function () {
        return this.y;
    }

});
/**
 * @class draw2d.layout.locator.Locator
 *
 * Controls the location of an IFigure.
 *
 * @author Andreas Herz
 */
draw2d.layout.locator.Locator = Class.extend({
    NAME: "draw2d.layout.locator.Locator",

    /**
     * @constructor
     * Initial Constructor
     *
     */
    init: function () {
    },


    /**
     * @method
     * Controls the location of an I{@link draw2d.Figure}
     *
     * @param {Number} index child index of the figure
     * @param {draw2d.Figure} figure the figure to control
     *
     * @template
     **/
    relocate: function (index, figure) {
    },

    /**
     * @method
     * Return a clone of the locator object
     *
     * @returns
     */
    clone: function () {
        return eval("new " + this.NAME + "()");
    }
});
/**
 * @class draw2d.layout.locator.PortLocator
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.PortLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.PortLocator",

    /**
     * @constructor
     * Default constructor for a Locator which can layout a port in context of a
     * {@link grapiti.shape.node.Node}
     *
     */
    init: function () {
        this._super();
    },

    applyConsiderRotation: function (port, x, y) {
        var parent = port.getParent();

        // determine the width/height before manipulate the
        // matrix of the shape
        var halfW = parent.getWidth() / 2;
        var halfH = parent.getHeight() / 2;

        var rotAngle = parent.getRotationAngle();
        var m = Raphael.matrix();
        m.rotate(rotAngle, halfW, halfH);
        if (rotAngle === 90 || rotAngle === 270) {
            var ratio = parent.getHeight() / parent.getWidth();
            m.scale(ratio, 1 / ratio, halfW, halfH);
        }

        port.setPosition(m.x(x, y), m.y(x, y));
    }
});
/**
 * @class draw2d.layout.locator.XYAbsPortLocator
 *
 * Create a locator for fixed x/y coordinate position.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.PortLocator
 * @since 4.0.0
 */
draw2d.layout.locator.XYAbsPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME: "draw2d.layout.locator.XYAbsPortLocator",

    /**
     * @constructor
     *
     * {@link grapiti.shape.node.Node}
     *
     * @param {Number} x the x coordinate of the port relative to the left of the parent
     * @param {Number} y the y coordinate of the port relative to the top of the parent
     */
    init: function (x, y) {
        this._super();

        this.x = x;
        this.y = y;
    },

    /**
     * @method
     * Controls the location of an I{@link draw2d.Figure}
     *
     * @param {Number} index child index of the figure
     * @param {draw2d.Figure} figure the figure to control
     *
     * @template
     **/
    relocate: function (index, figure) {
        this.applyConsiderRotation(figure, this.x, this.y);
    }

});


/**
 * @class draw2d.layout.locator.XYRelPortLocator
 *
 * Create a locator for a relative x/y coordinate position. The coordinates are named in percentage
 * relative to the top/left corner of the parent node.<br>
 * <br>
 * <br>
 * Resize the shape in the example to see what happens.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.node.End({x:130,y:30,width:100,height:50});
 *     figure.add(new draw2d.shape.basic.Label({text:"x"}), new draw2d.layout.locator.XYRelPortLocator(20,20));
 *
 *     canvas.add(figure);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.PortLocator
 * @since 4.0.0
 */
draw2d.layout.locator.XYRelPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME: "draw2d.layout.locator.XYRelPortLocator",

    /**
     * @constructor
     *
     *
     * @param {Number} xPercentage the x coordinate in percent of the port relative to the left of the parent
     * @param {Number} yPercentage the y coordinate in percent of the port relative to the top of the parent
     */
    init: function (xPercentage, yPercentage) {
        this._super();

        this.x = xPercentage;
        this.y = yPercentage;
    },

    /**
     * @method
     * Controls the location of an I{@link draw2d.Figure}
     *
     * @param {Number} index child index of the figure
     * @param {draw2d.Figure} figure the figure to control
     *
     * @template
     **/
    relocate: function (index, figure) {
        var node = figure.getParent();
        var x = node.getWidth() / 100 * this.x;
        var y = node.getHeight() / 100 * this.y;

        this.applyConsiderRotation(figure, x, y);
    }

});


/**
 * @class draw2d.layout.locator.InputPortLocator
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.InputPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME: "draw2d.layout.locator.InputPortLocator",

    /**
     * @constructor
     * Default constructor for a Locator which can layout a port in context of a
     * {@link grapiti.shape.node.Node}
     *
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Controls the location of an I{@link draw2d.Figure}
     *
     * @param {Number} index port index of the figure
     * @param {draw2d.Figure} figure the figure to control
     *
     * @template
     **/
    relocate: function (index, figure) {
        var node = figure.getParent();

        var dividerFactor = 1;
        var thisNAME = this.NAME;
        var portIndex = 1;
        node.getPorts().each(function (i, p) {
            portIndex = (p === figure) ? dividerFactor : portIndex;
            dividerFactor += p.getLocator().NAME === thisNAME ? 1 : 0;
        });
        this.applyConsiderRotation(figure, 0, (node.getHeight() / dividerFactor) * portIndex);
    }

});

/**
 * @class draw2d.layout.locator.OutputPortLocator
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.OutputPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME: "draw2d.layout.locator.OutputPortLocator",

    /**
     * @constructor
     * Default constructor for a Locator which can layout a port in context of a
     * {@link grapiti.shape.node.Node}
     *
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Controls the location of an I{@link draw2d.Figure}
     *
     * @param {Number} index child index of the figure
     * @param {draw2d.Figure} figure the figure to control
     *
     * @template
     **/
    relocate: function (index, figure) {
        var node = figure.getParent();
        var dividerFactor = 1;
        var thisNAME = this.NAME;
        var portIndex = 1;
        node.getPorts().each(function (i, p) {
            portIndex = (p === figure) ? dividerFactor : portIndex;
            dividerFactor += p.getLocator().NAME === thisNAME ? 1 : 0;
        });
        this.applyConsiderRotation(figure, node.getWidth(), (node.getHeight() / dividerFactor) * portIndex);
    }

});

/**
 * @class draw2d.layout.locator.ExtendPortLocator
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.ExtendPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME: "draw2d.layout.locator.ExtendPortLocator",

    /**
     * @constructor
     * Default constructor for a Locator which can layout a port in context of a
     * {@link grapiti.shape.node.Node}
     *
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Controls the location of an I{@link draw2d.Figure}
     *
     * @param {Number} index child index of the figure
     * @param {draw2d.Figure} figure the figure to control
     *
     * @template
     **/
    relocate: function (index, figure) {
        var node = figure.getParent();
        var dividerFactor = 1;
        var thisNAME = this.NAME;
        var portIndex = 1;
        node.getPorts().each(function (i, p) {
            portIndex = (p === figure) ? dividerFactor : portIndex;
            dividerFactor += p.getLocator().NAME === thisNAME ? 1 : 0;
        });
        this.applyConsiderRotation(figure, (node.getWidth() / dividerFactor) * portIndex, node.getHeight());
    }

});


/**
 * @class draw2d.layout.locator.ConnectionLocator
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.ConnectionLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.ConnectionLocator",

    /**
     * @constructor
     * Default constructor for a Locator which can layout a figure in context of a
     * {@link grapiti.Connector}
     *
     * @param {draw2d.Figure} parentShape the base or parent figure for the locator
     */
    init: function (parentShape) {
        this._super(parentShape);
    }

});

/**
 * @class draw2d.layout.locator.ManhattanMidpointLocator
 *
 * A ManhattanMidpointLocator that is used to place figures at the midpoint of a Manhatten routed
 * connection. The midpoint is always in the center of an edge.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *     //create and add two Node which contains Ports (In and OUT)
 *     var start = new draw2d.shape.node.Start({x:50,y:50});
 *     var end   = new draw2d.shape.node.End({x:230,y:100});
 *
 *     canvas.add( start);
 *     canvas.add( end);
 *
 *     // Create a Connection and connect he Start and End node
 *     //
 *     var c = new draw2d.Connection();
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *     canvas.add(c);
 *
 *     // create a label which should attach to the connection
 *     //
 *     var label = new draw2d.shape.basic.Label({text:"I'm a Label"});
 *     label.setColor("#0d0d0d");
 *     label.setFontColor("#0d0d0d");
 *     label.setBackgroundColor("#f0f0f0");
 *
 *     // add the decoration to the connection with a ManhattanMidpointLocator.
 *     //
 *     c.add(label, new draw2d.layout.locator.ManhattanMidpointLocator());
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.ConnectionLocator
 */
draw2d.layout.locator.ManhattanMidpointLocator = draw2d.layout.locator.ConnectionLocator.extend({
    NAME: "draw2d.layout.locator.ManhattanMidpointLocator",

    /**
     * @constructor
     * Constructs a ManhattanMidpointLocator with associated Connection c.
     *
     * @param {draw2d.Connection} c the connection associated with the locator
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure always in the center of an edge.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var conn = target.getParent();
        var points = conn.getVertices();

        var segmentIndex = Math.floor((points.getSize() - 2) / 2);
        if (points.getSize() <= segmentIndex + 1)
            return;

        var p1 = points.get(segmentIndex);
        var p2 = points.get(segmentIndex + 1);

        var x = ((p2.x - p1.x) / 2 + p1.x - target.getWidth() / 2) | 0;
        var y = ((p2.y - p1.y) / 2 + p1.y - target.getHeight() / 2) | 0;

        target.setPosition(x, y);
    }
});


/**
 * @class draw2d.layout.locator.PolylineMidpointLocator
 *
 * A PolylineMidpointLocator is used to place figures at the midpoint of a routed
 * connection. <br>
 * If the connection did have an odd count of points the figure is located in the center vertex of the polyline.<br>
 * On an even count of junction point, the figure will be center on the middle segment of the ploy line.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.ManhattanMidpointLocator
 */
draw2d.layout.locator.PolylineMidpointLocator = draw2d.layout.locator.ManhattanMidpointLocator.extend({
    NAME: "draw2d.layout.locator.PolylineMidpointLocator",

    /**
     * @constructor
     * Constructs a ManhattanMidpointLocator with associated Connection c.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var conn = target.getParent();
        var points = conn.getVertices();

        // it has an event count of points -> use the manhattan algorithm...this is working
        // well in this case
        if (points.getSize() % 2 === 0) {
            this._super(index, target);
        }
        // odd count of points. take the center point as fulcrum
        else {

            var index = Math.floor(points.getSize() / 2);

            var p1 = points.get(index);


            target.setPosition(p1.x - (target.getWidth() / 2), p1.y - (target.getHeight() / 2));
        }
    }
});


/**
 * @class draw2d.layout.locator.ParallelMidpointLocator
 *
 * A ParallelMidpointLocator that is used to place label at the midpoint of a  routed
 * connection. The midpoint is always in the center of an edge.
 * The label is aligned to the connection angle.
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.ConnectionLocator
 * @since 4.4.4
 */
draw2d.layout.locator.ParallelMidpointLocator = draw2d.layout.locator.ConnectionLocator.extend({
    NAME: "draw2d.layout.locator.ParallelMidpointLocator",

    /**
     * @constructor
     * Constructs a ManhattanMidpointLocator with associated Connection c.
     *
     * if the parameter <b>distanceFromConnection</b> is less than zero the label is
     * placed above of the connection. Else the label is below the connection.
     *
     * @param {Number} distanceFromConnection the distance of the label to the connection.
     */
    init: function (distanceFromConnection) {
        this._super();

        if (typeof distanceFromConnection !== "undefined") {
            this.distanceFromConnection = parseFloat(distanceFromConnection);
        }
        else {
            this.distanceFromConnection = -5;
        }
    },


    /**
     * @method
     * Relocates the given Figure always in the center of an edge.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var conn = target.getParent();
        var points = conn.getVertices();

        var segmentIndex = Math.floor((points.getSize() - 2) / 2);
        if (points.getSize() <= segmentIndex + 1)
            return;

        var p1 = points.get(segmentIndex);
        var p2 = points.get(segmentIndex + 1);

        // calculate the distance of the label (above or below the connection)
        var distance = this.distanceFromConnection <= 0 ? this.distanceFromConnection - target.getHeight() : this.distanceFromConnection;

        // get the angle of the segment
        var nx = p1.x - p2.x;
        var ny = p1.y - p2.y;
        var length = Math.sqrt(nx * nx + ny * ny);
        var radian = -Math.asin(ny / length);
        var angle = (180 / Math.PI) * radian;
        if (radian < 0) {
            if (p2.x < p1.x) {
                radian = Math.abs(radian) + Math.PI;
                angle = 360 - angle;
                distance = -distance - target.getHeight();
            }
            else {
                radian = Math.PI * 2 - Math.abs(radian);
                angle = 360 + angle;
            }
        }
        else {
            if (p2.x < p1.x) {
                radian = Math.PI - radian;
                angle = 360 - angle;
                distance = -distance - target.getHeight();
            }
        }

        var rotAnchor = this.rotate(length / 2 - target.getWidth() / 2, distance, 0, 0, radian);

        // rotate the x/y coordinate with the calculated angle around "p1"
        //
        var rotCenterOfLabel = this.rotate(0, 0, target.getWidth() / 2, target.getHeight() / 2, radian);

        target.setRotationAngle(angle);
        target.setPosition(rotAnchor.x - rotCenterOfLabel.x + p1.x, rotAnchor.y - rotCenterOfLabel.y + p1.y);
    },

    rotate: function (x, y, xm, ym, radian) {
        var cos = Math.cos,
            sin = Math.sin;

        // Subtract midpoints, so that midpoint is translated to origin
        // and add it in the end again
        return {
            x: (x - xm) * cos(radian) - (y - ym) * sin(radian) + xm,
            y: (x - xm) * sin(radian) + (y - ym) * cos(radian) + ym
        };
    }

});


/**
 * @class draw2d.layout.locator.TopLocator
 *
 * A TopLocator  is used to place figures at the top/center of a parent shape.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.TopLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.TopLocator",

    /**
     * @constructor
     * Constructs a ManhattanMidpointLocator with associated Connection c.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var parent = target.getParent();
        var boundingBox = parent.getBoundingBox();

        var targetBoundingBox = target.getBoundingBox();
        if (target instanceof draw2d.Port) {
            target.setPosition(boundingBox.w / 2, 0);
        }
        else {
            target.setPosition(boundingBox.w / 2 - (targetBoundingBox.w / 2), -(targetBoundingBox.h + 2));
        }
    }
});


/**
 * @class draw2d.layout.locator.BottomLocator
 *
 * A bottomLocator is used to place figures at the bottom of a parent shape.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *     // create a basic figure and add a Label/child via API call
 *     //
 *     var circle = new draw2d.shape.basic.Circle({
 *         x:100,
 *         y:50,
 *         diameter:120,
 *         stroke: 3,
 *         color:"#A63343",
 *         bgColor:"#E65159"
 *     });
 *
 *     circle.add(new draw2d.shape.basic.Label({text:"Bottom Label"}), new draw2d.layout.locator.BottomLocator());
 *     canvas.add( circle);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.BottomLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.BottomLocator",

    /**
     * @constructor
     *
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var parent = target.getParent();
        var boundingBox = parent.getBoundingBox();

        var targetBoundingBox = target.getBoundingBox();
        if (target instanceof draw2d.Port) {
            target.setPosition(boundingBox.w / 2, boundingBox.h);
        }
        else {
            target.setPosition(boundingBox.w / 2 - targetBoundingBox.w / 2, 2 + boundingBox.h);
        }
    }
});


/**
 * @class draw2d.layout.locator.LeftLocator
 *
 * A LeftLocator is used to place figures to the left of a parent shape.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *     // create a basic figure and add a Label/child via API call
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     start.add(new draw2d.shape.basic.Label({text:"Left Label"}), new draw2d.layout.locator.LeftLocator());
 *     canvas.add( start, 100,50);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.LeftLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.LeftLocator",

    /**
     * @constructor
     * Constructs a locator with associated parent.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var parent = target.getParent();
        var boundingBox = parent.getBoundingBox();

        var targetBoundingBox = target.getBoundingBox();
        target.setPosition(-targetBoundingBox.w - 5, (boundingBox.h / 2) - (targetBoundingBox.h / 2));
    }
});


/**
 * @class draw2d.layout.locator.RightLocator
 *
 * A RightLocator is used to place figures to the right of a parent shape.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *     // create a basic figure and add a Label/child via API call
 *     //
 *     var end = new draw2d.shape.node.End();
 *     end.add(new draw2d.shape.basic.Label({text:"Right Label"}), new draw2d.layout.locator.RightLocator());
 *     canvas.add( end, 50,50);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.RightLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.RightLocator",

    /**
     * @constructor
     * Constructs a locator with associated parent.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var parent = target.getParent();
        var boundingBox = parent.getBoundingBox();

        var targetBoundingBox = target.getBoundingBox();
        target.setPosition(boundingBox.w + 5, (boundingBox.h / 2) - (targetBoundingBox.h / 2));
    }
});


/**
 * @class draw2d.layout.locator.CenterLocator
 *
 * A CenterLocator is used to place figures in the center of a parent shape.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *     // create a basic figure and add a Label/child via API call
 *     //
 *     var circle = new draw2d.shape.basic.Circle({diameter:120});
 *     circle.setStroke(3);
 *     circle.setColor("#A63343");
 *     circle.setBackgroundColor("#E65159");
 *     circle.add(new draw2d.shape.basic.Label({text:"Center Label"}), new draw2d.layout.locator.CenterLocator());
 *     canvas.add( circle, 100,50);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
draw2d.layout.locator.CenterLocator = draw2d.layout.locator.Locator.extend({
    NAME: "draw2d.layout.locator.CenterLocator",

    /**
     * @constructor
     * Constructs a locator with associated parent.
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Relocates the given Figure.
     *
     * @param {Number} index child index of the target
     * @param {draw2d.Figure} target The figure to relocate
     **/
    relocate: function (index, target) {
        var parent = target.getParent();
        var boundingBox = parent.getBoundingBox();

        // TODO: instanceof is always a HACK. ugly. Redirect the call to the figure instead of
        // determine the position with a miracle.
        //
        if (target instanceof draw2d.Port) {
            target.setPosition(boundingBox.w / 2, boundingBox.h / 2);
        }
        else {
            var targetBoundingBox = target.getBoundingBox();
            target.setPosition(boundingBox.w / 2 - targetBoundingBox.w / 2, boundingBox.h / 2 - (targetBoundingBox.h / 2));
        }
    }
});


/**
 * @class draw2d.policy.EditPolicy
 *
 * A pluggable contribution implementing a portion of an behavior.
 *
 *
 * EditPolicies should determine an Canvas or figure editing capabilities. It is possible to implement
 * an figure such that it handles all editing responsibility. However, it is much more flexible
 * and object-oriented to use EditPolicies. Using policies, you can pick and choose the editing
 * behavior for an figure/canvas without being bound to its class hierarchy. Code management is easier.
 *
 *
 * This interface is not intended to be implemented by clients. Clients should inherit from {@link draw2d.policy.figure.SelectionFeedbackPolicy}
 * or {@link draw2d.policy.canvas.SelectionPolicy}.
 *
 * @author Andreas Herz
 */
draw2d.policy.EditPolicy = Class.extend({

    NAME: "draw2d.policy.EditPolicy",

    /**
     * @constructor
     *
     */
    init: function () {
    },

    /**
     * @method
     * Called by the host if the policy has been installed.
     *
     * @param {draw2d.Canvas/draw2d.Figure} host
     */
    onInstall: function (host) {
    },

    /**
     * @method
     * Called by the host if the policy has been uninstalled.
     *
     * @param {draw2d.Canvas/draw2d.Figure} host
     */
    onUninstall: function (host) {
    }
});


/**
 * @class draw2d.policy.canvas.CanvasPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.EditPolicy
 */
draw2d.policy.canvas.CanvasPolicy = draw2d.policy.EditPolicy.extend({

    NAME: "draw2d.policy.canvas.CanvasPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },

    onInstall: function (canvas) {
    },

    onUninstall: function (canvas) {
    },

    /**
     * @method
     * Called by the canvas if the user click on a figure.
     *
     * @param {draw2d.Figure} the figure under the click event. Can be null
     * @param {Number} mouseX the x coordinate of the mouse during the click event
     * @param {Number} mouseY the y coordinate of the mouse during the click event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @since 3.0.0
     *
     * @template
     */
    onClick: function (figure, mouseX, mouseY, shiftKey, ctrlKey) {
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseMove: function (canvas, x, y, shiftKey, ctrlKey) {
    },

    /**
     * @method
     * Called by the canvas if the user double click on a figure.
     *
     * @param {draw2d.Figure} the figure under the double click event. Can be null
     * @param {Number} mouseX the x coordinate of the mouse during the click event
     * @param {Number} mouseY the y coordinate of the mouse during the click event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @since 4.1.0
     *
     * @template
     */
    onDoubleClick: function (figure, mouseX, mouseY, shiftKey, ctrlKey) {
    },


    /**
     * @method
     * Adjust the coordinates to the given constraint.
     *
     * @param figure
     * @param {draw2d.geo.Point} clientPos
     * @returns {draw2d.geo.Point} the contraint position of th efigure
     */
    snap: function (canvas, figure, clientPos) {
        return clientPos;
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {

    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
    },

    /**
     * @method
     *
     * @param {draw2d.Figure} figure the shape below the mouse or null
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseUp: function (figure, x, y, shiftKey, ctrlKey) {
    },


    /**
     * @method
     * Called if the user press the right mouse in the canvas.
     *
     * @param {draw2d.Figure|draw2d.shape.basic.Line} figure the figure below the mouse
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     * @since 4.4.0
     */
    onRightMouseDown: function (figure, x, y, shiftKey, ctrlKey) {
    },


    /**
     * @method
     * Helper method to make an monochrome GIF image WxH pixels big, first create a properly sized array: var pixels = new Array(W*H);.
     * Then, for each pixel X,Y that should be opaque, store a 1 at the proper location: pixels[X+Y*W] = 1;.
     * Finally, create the image: var my_glif = createGif(W, H, pixels, color);
     * "0" pixels are transparent.
     * The <b>color</b> defines the foreground color.
     *
     * Now, you can specify this image as the SRC attribute of an IMG tag: document.write("<IMG SRC=\"" + my_glif + "\">");
     * or for the canvas as background-image css attribute.
     *
     *
     * @param w
     * @param h
     * @param d
     * @param color
     * @returns {String}
     */
    createMonochromGif: function (w, h, d, color) {
        color = new draw2d.util.Color(color);
        var r = String.fromCharCode(w % 256) + String.fromCharCode(w / 256) + String.fromCharCode(h % 256) + String.fromCharCode(h / 256);
        var gif = "GIF89a" + r + "\xf0\0\0\xff\xff\xff" + String.fromCharCode(color.red) + String.fromCharCode(color.green) + String.fromCharCode(color.blue) + "\x21\xf9\4\1\0\0\0\0,\0\0\0\0" + r + "\0\2";

        // help method to generate uncompressed in memory GIF data structur without the usage of a canvas or any other
        // heavy weight stuff.
        var b = {
            bit: 1,
            byte_: 0,
            data: "",

            writeBit: function (b) {
                if (b) this.byte_ |= this.bit;
                this.bit <<= 1;
                if (this.bit == 256) {
                    this.bit = 1;
                    this.data += String.fromCharCode(this.byte_);
                    this.byte_ = 0;
                }
            },

            get: function () {
                var result = "";
                var data = this.data;
                if (this.bit != 1) {
                    data += String.fromCharCode(this.byte_);
                }
                for (var i = 0; i < data.length + 1; i += 255) {
                    chunklen = data.length - i;
                    if (chunklen < 0) chunklen = 0;
                    if (chunklen > 255) chunklen = 255;
                    result += String.fromCharCode(chunklen) + data.substring(i, i + 255);
                }
                return result + "\0";
            }
        };

        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                b.writeBit(d[x + w * y]);
                b.writeBit(0);
                b.writeBit(0);
                b.writeBit(0);
                b.writeBit(0);
                b.writeBit(1);
            }
        }
        gif += b.get() + ";";

        return "data:image/gif;base64," + draw2d.util.Base64.encode(gif);
    }

});

/**
 * @class draw2d.policy.canvas.ConnectionInterceptorPolicy
 * Connection interceptors are basically event handlers from which you can return a value
 * that tells draw2d to abort what it is that it was doing.<br>
 * <br>
 * Interceptors can be registered via the registerEditPolicy method on the draw2d canvas just like any other
 * edit policies.<br>
 * <br>
 * The <b>delegateDrop</b> method is responsible for all drop event especially to all connection and port handlings.
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 * @since 5.0.0
 */
draw2d.policy.canvas.ConnectionInterceptorPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.ConnectionInterceptorPolicy",

    /**
     * @constructor
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called if the user want drop a port over any draw2d.Figure.<br>
     * Return a non <b>null</b> value if the interceptor accept the drop event.<br>
     * <br>
     * It is possible to delegate the drop event to another figure if the policy
     * returns another figure. This is usefull if a figure want to accept a port
     * drop event and delegates this drop event to another port.<br>
     *
     *
     * @param {draw2d.Figure} draggedFigure the dragged figure
     * @param {draw2d.Figure} dropTarget the potential drop target determined by the framework
     */
    delegateDrop: function (draggedFigure, dropTarget) {

        // a composite accept any kind of figures exceptional ports
        //
        if (!(draggedFigure instanceof draw2d.Port) && dropTarget instanceof draw2d.shape.composite.StrongComposite) {
            return dropTarget;
        }

        // Ports accepts only Ports as DropTarget
        //
        if (!(dropTarget instanceof draw2d.Port) || !(draggedFigure instanceof draw2d.Port)) {
            return null;
        }

        // consider the max possible connections for this port
        //
        if (dropTarget.getConnections().getSize() >= dropTarget.getMaxFanOut()) {
            return null;
        }

        // It is not allowed to connect two output ports
        if (draggedFigure instanceof draw2d.OutputPort && dropTarget instanceof draw2d.OutputPort) {
            return null;
        }

        // It is not allowed to connect two input ports
        if (draggedFigure instanceof draw2d.InputPort && dropTarget instanceof draw2d.InputPort) {
            return null;
        }

        // It is not possible to create a loop back connection at the moment.
        // Reason: no connection router implemented for this case
        if ((draggedFigure instanceof draw2d.Port) && (dropTarget instanceof draw2d.Port)) {
            if (draggedFigure.getParent().getId() === dropTarget.getParent().getId()) {
                return null;
            }
        }

        // return the dropTarget determined by the framework or delegate it to another
        // figure.
        return dropTarget;
    }

});


/**
 * @class draw2d.policy.canvas.KeyboardPolicy
 * Default interface for keyboard interaction with the canvas.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
draw2d.policy.canvas.KeyboardPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.KeyboardPolicy",

    /**
     * @constructor
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Callback if the user release a key
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {Number} keyCode the pressed key
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onKeyUp: function (canvas, keyCode, shiftKey, ctrlKey) {
        // do nothing per default
    },

    /**
     * @method
     * Callback if the user press a key down
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {Number} keyCode the pressed key
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onKeyDown: function (canvas, keyCode, shiftKey, ctrlKey) {
        // do nothing per default
    }


});


/**
 * @class draw2d.policy.canvas.DefaultKeyboardPolicy
 * Standard keyboard policy. This is the standard installed keyboard policy.
 * <br>
 * <br>
 * Keyboard commands
 * <ul>
 *    <li>DEL    - delete selection</li>
 * </ul>
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.KeyboardPolicy
 */
draw2d.policy.canvas.DefaultKeyboardPolicy = draw2d.policy.canvas.KeyboardPolicy.extend({

    NAME: "draw2d.policy.canvas.DefaultKeyboardPolicy",

    /**
     * @constructor
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Callback if the user press a key.<br>
     * This implementation checks only if the <b>DEL</b> has been pressed and creates an
     * CommandDelete if this happens.
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {Number} keyCode the pressed key
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onKeyDown: function (canvas, keyCode, shiftKey, ctrlKey) {
        //
        if (keyCode === 46 && canvas.getCurrentSelection() !== null) {
            // create a single undo/redo transaction if the user delete more than one element.
            // This happens with command stack transactions.
            //
            canvas.getCommandStack().startTransaction(draw2d.Configuration.i18n.command.deleteShape);
            canvas.getSelection().each(function (index, figure) {
                var cmd = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE));
                if (cmd !== null) {
                    canvas.getCommandStack().execute(cmd);
                }
            });
            // execute all single commands at once.
            canvas.getCommandStack().commitTransaction();
        }
        else {
            this._super(canvas, keyCode, shiftKey, ctrlKey);
        }

    }


});


/**
 * @class draw2d.policy.canvas.ExtendedKeyboardPolicy
 * Extended keyboard policy to <b>delete</b> and <b>group</b> figures in the canvas.
 * <br>
 * Keyboard commands
 * <ul>
 *    <li>DEL    - delete selection</li>
 *    <li>Ctrl+G - group/ungroup selection</li>
 *    <li>Ctrl+B - send current selection in the background (toBack)</li>
 *    <li>Ctrl+F - send current selection in the foreground (toFront)</li>
 * </ul>
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.KeyboardPolicy
 */
draw2d.policy.canvas.ExtendedKeyboardPolicy = draw2d.policy.canvas.KeyboardPolicy.extend({

    NAME: "draw2d.policy.canvas.ExtendedKeyboardPolicy",

    /**
     * @constructor
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Callback if the user press a key
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {Number} keyCode the pressed key
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onKeyDown: function (canvas, keyCode, shiftKey, ctrlKey) {
        if (canvas.getCurrentSelection() !== null && ctrlKey === true) {
            switch (keyCode) {

                case 71: // G
                    if (canvas.getCurrentSelection() instanceof draw2d.shape.composite.Group && canvas.getSelection().getSize() === 1) {
                        canvas.getCommandStack().execute(new draw2d.command.CommandUngroup(canvas, canvas.getCurrentSelection()));
                    }
                    else {
                        canvas.getCommandStack().execute(new draw2d.command.CommandGroup(canvas, canvas.getSelection()));
                    }
                    break;
                case 66: // B
                    canvas.getCurrentSelection().toBack();
                    break;
                case 70: // F
                    canvas.getCurrentSelection().toFront();
            }
        }
        else {
            this._super(canvas, keyCode, shiftKey, ctrlKey);
        }
    }


});


/**
 * @class draw2d.policy.canvas.SelectionPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
draw2d.policy.canvas.SelectionPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.SelectionPolicy",

    /**
     * @constructor
     * Creates a new selection policy
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Unselect the given figure in the canvas and remove all resize handles
     *
     * @param {draw2d.Canvas} canvas
     * @param {draw2d.Figure} figure
     */
    unselect: function (canvas, figure) {
        canvas.getSelection().remove(figure);

        figure.unselect();

        canvas.fireEvent("select", null);
    }

});


/**
 * @class draw2d.policy.canvas.SingleSelectionPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SelectionPolicy
 */
draw2d.policy.canvas.SingleSelectionPolicy = draw2d.policy.canvas.SelectionPolicy.extend({

    NAME: "draw2d.policy.canvas.SingleSelectionPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
        this.mouseMovedDuringMouseDown = false;
        this.mouseDraggingElement = null;
        this.mouseDownElement = null;
    },

    /**
     * @inheritdoc
     */
    select: function (canvas, figure) {
        if (canvas.getSelection().contains(figure)) {
            return; // nothing to to
        }

        var oldSelection = canvas.getSelection().getPrimary();
        if (canvas.getSelection().getPrimary() !== null) {
            this.unselect(canvas, canvas.getSelection().getPrimary());
        }

        if (figure !== null) {
            figure.select(true); // primary selection
        }

        canvas.getSelection().setPrimary(figure);

        // inform all selection listeners about the new selection.
        //
        if (oldSelection !== figure) {
            canvas.fireEvent("select", figure);
        }
    },


    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {
        this.mouseMovedDuringMouseDown = false;
        var canDragStart = true;

        var figure = canvas.getBestFigure(x, y);

        // may the figure is assigned to a composite. In this case the composite can
        // override the event receiver
        while (figure !== null && figure.getComposite() !== null) {
            var delegate = figure.getComposite().delegateSelectionHandling(figure);
            if (delegate === figure) {
                break;
            }
            figure = delegate;
        }

        // check if the user click on a child shape. DragDrop and movement must redirect
        // to the parent
        // Exception: Port's
        while ((figure !== null && figure.getParent() !== null) && !(figure instanceof draw2d.Port)) {
            figure = figure.getParent();
        }

        if (figure !== null && figure.isDraggable()) {
            canDragStart = figure.onDragStart(x - figure.getAbsoluteX(), y - figure.getAbsoluteY(), shiftKey, ctrlKey);
            // Element send a veto about the drag&drop operation
            if (canDragStart === false) {
                this.mouseDraggingElement = null;
                this.mouseDownElement = figure;
            }
            else {
                this.mouseDraggingElement = figure;
                this.mouseDownElement = figure;
            }
        }

        if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
            this.select(canvas, figure);

            // its a line
            if (figure instanceof draw2d.shape.basic.Line) {
                // you can move a line with Drag&Drop...but not a connection.
                // A Connection is fixed linked with the corresponding ports.
                //
                if (!(figure instanceof draw2d.Connection)) {
                    canvas.draggingLineCommand = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
                    if (canvas.draggingLineCommand !== null) {
                        canvas.draggingLine = figure;
                    }
                }
            }
            else if (canDragStart === false) {
                figure.unselect();
            }
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
        this.mouseMovedDuringMouseDown = true;
        if (this.mouseDraggingElement !== null) {
            // Can be a ResizeHandle or a normal Figure
            //
            var sel = canvas.getSelection().getAll();
            if (!sel.contains(this.mouseDraggingElement)) {
                this.mouseDraggingElement.onDrag(dx, dy, dx2, dy2);
            }
            else {
                sel.each(function (i, figure) {
                    figure.onDrag(dx, dy, dx2, dy2);
                });
            }

            var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + (dx / canvas.zoomFactor), canvas.mouseDownY + (dy / canvas.zoomFactor));
            var target = canvas.getBestFigure(p.x, p.y, this.mouseDraggingElement);

            if (target !== canvas.currentDropTarget) {
                if (canvas.currentDropTarget !== null) {
                    canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                    canvas.currentDropTarget = null;
                }
                if (target !== null) {
                    canvas.currentDropTarget = target.onDragEnter(this.mouseDraggingElement);
                }
            }
        }
        // Connection didn't support panning at the moment. There is no special reason for that. Just an interaction
        // decision.
        //
        else if (this.mouseDownElement !== null && !(this.mouseDownElement instanceof draw2d.Connection)) {
            this.mouseDownElement.onPanning(dx, dy, dx2, dy2);
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseUp: function (canvas, x, y, shiftKey, ctrlKey) {
        if (this.mouseDraggingElement !== null) {
            var redrawConnection = new draw2d.util.ArrayList();
            if (this.mouseDraggingElement instanceof draw2d.shape.node.Node) {
                // TODO: don't add the connections with to check if a repaint is required
                //       may a moved connection didn't have an intersection with the named lines.
                //       in this case a redraw is useless
                canvas.lineIntersections.each(function (i, inter) {
                    if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
                    if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
                });
            }

            // start CommandStack transaction
            canvas.getCommandStack().startTransaction();

            var sel = canvas.getSelection().getAll();
            if (!sel.contains(this.mouseDraggingElement)) {
                this.mouseDraggingElement.onDragEnd(x, y, shiftKey, ctrlKey);
            }
            else {
                canvas.getSelection().getAll().each(function (i, figure) {
                    figure.onDragEnd(x, y, shiftKey, ctrlKey);
                });
            }

            if (canvas.currentDropTarget !== null && !this.mouseDraggingElement.isResizeHandle) {
                this.mouseDraggingElement.onDrop(canvas.currentDropTarget, x, y, shiftKey, ctrlKey);
                canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                canvas.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
                canvas.currentDropTarget = null;
            }

            // end command stack trans
            canvas.getCommandStack().commitTransaction();

            if (this.mouseDraggingElement instanceof draw2d.shape.node.Node) {
                canvas.lineIntersections.each(function (i, inter) {
                    if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
                    if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
                });
                redrawConnection.each(function (i, line) {
                    line.svgPathString = null;
                    line.repaint();
                });
            }

            this.mouseDraggingElement = null;
        }

        // Reset the current selection if the user click in the blank canvas.
        // Don't reset the selection if the user pan the canvas
        //
        if (this.mouseDownElement === null && this.mouseMovedDuringMouseDown === false) {
            this.select(canvas, null);
        }

        this.mouseDownElement = null;
        this.mouseMovedDuringMouseDown = false;
    }
});


/**
 * @class draw2d.policy.canvas.GhostMoveSelectionPolicy
 *
 * A drag&Drop feedback handler for the canvas. The policy didn't move the
 * shapes in real time rather it shows a ghost rectangle as feedback. <br>
 * <br>
 * The shapes are updated after the drag&drop operation.
 *
 *
 * See the example:
 *
 *       @example preview small frame
 *
 *       // install the policy to the canvas
 *       canvas.installEditPolicy(new draw2d.policy.canvas.GhostMoveSelectionPolicy());
 *
 *       // add some demo figure to the canvas
 *       canvas.add(new draw2d.shape.basic.Circle({diameter: 50, x: 10,  y: 30}));
 *       canvas.add(new draw2d.shape.basic.Circle({diameter: 30, x: 90,  y: 50}));
 *       canvas.add(new draw2d.shape.basic.Circle({diameter: 60, x: 110, y: 30}));
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"move the circle to see the drag&drop feedback"}),5,5);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SingleSelectionPolicy
 */
draw2d.policy.canvas.GhostMoveSelectionPolicy = draw2d.policy.canvas.SingleSelectionPolicy.extend({

    NAME: "draw2d.policy.canvas.GhostMoveSelectionPolicy",

    /**
     * @constructor
     */
    init: function () {

        this.clone = null;
        this.ghostRectangle1 = null;
        this.ghostRectangle2 = null;

        this._super();
    },


    /**
     * @inheritdoc
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
        this.mouseMovedDuringMouseDown = true;
        if (this.mouseDraggingElement !== null) {

            // if the figure not part of the selection it must be a ResizeHandle...
            var sel = canvas.getSelection().getAll();
            if (!sel.contains(this.mouseDraggingElement)) {
                this.mouseDraggingElement.onDrag(dx, dy, dx2, dy2);
            }
            // it is a normal draw2d.Figure
            else {
                // create the ghost handles for the figure to move and update the position
                //
                if (this.ghostRectangle1 === null) {
                    this.ghostRectangle1 = new draw2d.shape.basic.Rectangle(/*{bgColor:"#303030", alpha:0.1}*/); // new API with version 5.0.0
                    // old API
                    this.ghostRectangle1.setBackgroundColor("#303030");
                    this.ghostRectangle1.setAlpha(0.1);

                    this.ghostRectangle2 = new draw2d.shape.basic.Rectangle(/*{dash:"- ", stroke:1, color:"#5497DC", bgColor:null}*/);
                    this.ghostRectangle2.setDashArray("- ");
                    this.ghostRectangle2.setStroke(1);
                    this.ghostRectangle2.setColor("#5497DC");
                    this.ghostRectangle2.setBackgroundColor(null);

                    this.ghostRectangle1.setBoundingBox(this.mouseDraggingElement.getBoundingBox());
                    this.ghostRectangle2.setBoundingBox(this.mouseDraggingElement.getBoundingBox());

                    this.ghostRectangle1.setCanvas(canvas);
                    this.ghostRectangle1.toFront();

                    this.ghostRectangle2.setCanvas(canvas);
                    this.ghostRectangle2.toFront();

                    this.clone = this.mouseDraggingElement.clone();
                    if (this.clone instanceof draw2d.shape.node.Node) {
                        this.clone.resetPorts();
                    }
                    this.clone.setCanvas(canvas);
                    this.clone.getShapeElement();
                    this.clone.setAlpha(0.4);
                    this.clone.repaint();
                }
                else {
                    this.ghostRectangle1.translate(dx2, dy2);
                    this.ghostRectangle2.translate(dx2, dy2);
                    this.clone.translate(dx2, dy2);
                }

                sel.each(function (i, figure) {
                    // store the new location in a tmp var.
                    figure._newPos = new draw2d.geo.Point(figure.ox + dx, figure.oy + dy);

                    // don't move the figure. This will be done in the MouseUp event
                    //figure.onDrag(dx, dy, dx2, dy2);
                });
            }

            var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + (dx / canvas.zoomFactor), canvas.mouseDownY + (dy / canvas.zoomFactor));
            var target = canvas.getBestFigure(p.x, p.y, this.mouseDraggingElement);

            if (target !== canvas.currentDropTarget) {
                if (canvas.currentDropTarget !== null) {
                    canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                    canvas.currentDropTarget = null;
                }
                if (target !== null) {
                    canvas.currentDropTarget = target.onDragEnter(this.mouseDraggingElement);
                }
            }
        }
        // Connection didn't support panning at the moment. There is no special reason for that. Just an interaction
        // decision.
        //
        else if (this.mouseDownElement !== null && !(this.mouseDownElement instanceof draw2d.Connection)) {
            this.mouseDownElement.onPanning(dx, dy, dx2, dy2);
        }
    },

    /**
     * @inheritdoc
     */
    onMouseUp: function (canvas, x, y, shiftKey, ctrlKey) {

        if (this.ghostRectangle1 !== null) {
            this.ghostRectangle1.setCanvas(null);
            this.ghostRectangle1 = null;
            this.ghostRectangle2.setCanvas(null);
            this.ghostRectangle2 = null;
            this.clone.setCanvas(null);
            this.clone = null;
        }

        if (this.mouseDraggingElement !== null) {
            var redrawConnection = new draw2d.util.ArrayList();
            if (this.mouseDraggingElement instanceof draw2d.shape.node.Node) {
                canvas.lineIntersections.each(function (i, inter) {
                    if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
                    if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
                });
            }


            // start CommandStack transaction
            // Trigger an update of the connections if we have move a draw2d.shape.node.Node figure.
            // (only "nodes" can have ports and connections)
            //
            canvas.getCommandStack().startTransaction();


            var sel = canvas.getSelection().getAll();
            // We move a resize handle...
            //
            if (!sel.contains(this.mouseDraggingElement)) {

                this.mouseDraggingElement.onDragEnd(x, y, shiftKey, ctrlKey);
            }
            // ... or a real figure.
            //
            else {
                canvas.getSelection().getAll().each(function (i, figure) {
                    // set position and cleanup tmp variable
                    if (figure._newPos) {
                        figure.setPosition(figure._newPos);
                        delete figure._newPos;
                    }
                    // done
                    figure.onDragEnd(x, y, shiftKey, ctrlKey);
                });
            }

            // May we drop the figure onto another shape..handle this here
            //
            if (canvas.currentDropTarget !== null && !this.mouseDraggingElement.isResizeHandle) {
                this.mouseDraggingElement.onDrop(canvas.currentDropTarget, x, y, shiftKey, ctrlKey);
                canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                canvas.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
                canvas.currentDropTarget = null;
            }

            // end command stack trans
            canvas.getCommandStack().commitTransaction();

            if (this.mouseDraggingElement instanceof draw2d.shape.node.Node) {
                canvas.lineIntersections.each(function (i, inter) {
                    if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
                    if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
                });
                redrawConnection.each(function (i, line) {
                    line.svgPathString = null;
                    line.repaint();
                });
            }

            this.mouseDraggingElement = null;
        }

        // Reset the current selection if the user click in the blank canvas.
        // Don't reset the selection if the user is panning the canvas
        //
        if (this.mouseDownElement === null && this.mouseMovedDuringMouseDown === false) {
            this.select(canvas, null);
        }

        this.mouseDownElement = null;
        this.mouseMovedDuringMouseDown = false;
    }
});


/**
 * @class draw2d.policy.canvas.PanningSelectionPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SingleSelectionPolicy
 */
draw2d.policy.canvas.PanningSelectionPolicy = draw2d.policy.canvas.SingleSelectionPolicy.extend({

    NAME: "draw2d.policy.canvas.PanningSelectionPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {

        this._super(canvas, dx, dy, dx2, dy2);

        if (this.mouseDraggingElement === null && this.mouseDownElement === null) {
            var area = canvas.getScrollArea();
            area.scrollTop(area.scrollTop() + dy2);
            area.scrollLeft(area.scrollLeft() + dx2);
        }
    }
});


/**
 * @class draw2d.policy.canvas.BoundingboxSelectionPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SelectionPolicy
 */
draw2d.policy.canvas.BoundingboxSelectionPolicy = draw2d.policy.canvas.SingleSelectionPolicy.extend({

    NAME: "draw2d.policy.canvas.BoundingboxSelectionPolicy",

    /**
     * @constructor
     * Creates a new selection policy for a canvas.
     */
    init: function () {
        this.isInsideMode = function (rect1, rect2) {
            return rect1.isInside(rect2);
        };
        this.intersectsMode = function (rect1, rect2) {
            return rect1.intersects(rect2);
        };

        this.decision = this.isInsideMode;

        this._super();

        this.boundingBoxFigure1 = null;
        this.boundingBoxFigure2 = null;
        this.x = 0;
        this.y = 0;
    },

    /**
     * @inheritdoc
     */
    select: function (canvas, figure) {
        if (canvas.getSelection().contains(figure)) {
            return; // nothing to to
        }

        var oldSelection = canvas.getSelection().getPrimary();

        if (figure !== null) {
            figure.select(true); // primary selection
        }

        if (oldSelection !== figure) {
            canvas.getSelection().setPrimary(figure);

            // inform all selection listeners about the new selection.
            //
            canvas.fireEvent("select", figure);
        }
    },


    /**
     * @method
     * Set the selection handling mode to <b>intersection</b> or to <b>isInside</b>.
     * <ul>
     *   <li>true = intersection, shapes must only touch the selection bounding box </li>
     *   <li>false = isInside, shapes must complete inside the selection bounding box (default)</li>
     * </ul>
     *
     * @param {boolean} useIntersectionMode set true if the selection handle should use the alternative selection approach
     * @since 4.9.0
     */
    setDecisionMode: function (useIntersectionMode) {
        if (flag === true) {
            this.decision = this.intersectsMode;
        }
        else {
            this.decision = this.isInsideMode;
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {
        try {
            var _this = this;

            this.x = x;
            this.y = y;

            var currentSelection = canvas.getSelection().getAll();

            // COPY_PARENT
            // this code part is copied from the parent implementation. The main problem is, that
            // the sequence of unselect/select of elements is broken if we call the base implementation
            // in this case a wrong of events is fired if we select a figure if already a figure is selected!
            // WRONG: selectNewFigure -> unselectOldFigure
            // RIGHT: unselectOldFigure -> selectNewFigure
            // To ensure this I must copy the parent code and postpond the event propagation
            //
            this.mouseMovedDuringMouseDown = false;
            var canDragStart = true;

            var figure = canvas.getBestFigure(x, y);

            // may the figure is assigned to a composite. In this case the composite can
            // override the event receiver
            while (figure !== null && figure.getComposite() !== null) {
                var delegate = figure.getComposite().delegateSelectionHandling(figure);
                if (delegate === figure) {
                    break;
                }
                figure = delegate;
            }

            // check if the user click on a child shape. DragDrop and movement must redirect
            // to the parent
            // Exception: Port's
            while ((figure !== null && figure.getParent() !== null) && !(figure instanceof draw2d.Port)) {
                figure = figure.getParent();
            }

            if (figure !== null && figure.isDraggable()) {
                canDragStart = figure.onDragStart(x - figure.getAbsoluteX(), y - figure.getAbsoluteY(), shiftKey, ctrlKey);
                // Element send a veto about the drag&drop operation
                if (canDragStart === false) {
                    this.mouseDraggingElement = null;
                    this.mouseDownElement = figure;
                }
                else {
                    this.mouseDraggingElement = figure;
                    this.mouseDownElement = figure;
                }
            }

            // we click on an element which are not part of the current selection
            // => reset the "old" current selection if we didn't press the shift key
            if (shiftKey === false) {
                if (this.mouseDownElement !== null && this.mouseDownElement.isResizeHandle === false && !currentSelection.contains(this.mouseDownElement)) {
                    currentSelection.each(function (i, figure) {
                        _this.unselect(canvas, figure);
                    });
                }
            }

            if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
                this.select(canvas, figure);

                // its a line
                if (figure instanceof draw2d.shape.basic.Line) {
                    // you can move a line with Drag&Drop...but not a connection.
                    // A Connection is fixed linked with the corresponding ports.
                    //
                    if (!(figure instanceof draw2d.Connection)) {
                        canvas.draggingLineCommand = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
                        if (canvas.draggingLineCommand !== null) {
                            canvas.draggingLine = figure;
                        }
                    }
                }
                else if (canDragStart === false) {
                    figure.unselect();
                }
            }
            // END_COPY FROM PARENT


            // inform all figures that they have a new ox/oy position for the relative
            // drag/drop operation
            currentSelection = canvas.getSelection().getAll();
            currentSelection.each(function (i, figure) {
                var canDragStart = figure.onDragStart(figure.getAbsoluteX(), figure.getAbsoluteY(), shiftKey, ctrlKey);
                // its a line
                if (figure instanceof draw2d.shape.basic.Line) {

                }
                else if (canDragStart === false) {
                    _this.unselect(canvas, figure);
                }
            });
        }
        catch (exc) {
            console.log(exc);
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
        try {
            this._super(canvas, dx, dy, dx2, dy2);

            if (this.mouseDraggingElement === null && this.mouseDownElement === null && this.boundingBoxFigure1 === null) {
                this.boundingBoxFigure1 = new draw2d.shape.basic.Rectangle(1, 1);
                this.boundingBoxFigure1.setPosition(this.x, this.y);
                this.boundingBoxFigure1.setCanvas(canvas);
                this.boundingBoxFigure1.setBackgroundColor("#0f0f0f");
                this.boundingBoxFigure1.setAlpha(0.1);

                this.boundingBoxFigure2 = new draw2d.shape.basic.Rectangle(1, 1);
                this.boundingBoxFigure2.setPosition(this.x, this.y);
                this.boundingBoxFigure2.setCanvas(canvas);
                this.boundingBoxFigure2.setDashArray("- ");
                this.boundingBoxFigure2.setStroke(1);
                this.boundingBoxFigure2.setColor(new draw2d.util.Color(84, 151, 220));
                this.boundingBoxFigure2.setBackgroundColor(null);
            }

            if (this.boundingBoxFigure1 !== null) {
                this.boundingBoxFigure1.setDimension(Math.abs(dx), Math.abs(dy));
                this.boundingBoxFigure1.setPosition(this.x + Math.min(0, dx), this.y + Math.min(0, dy));
                this.boundingBoxFigure2.setDimension(Math.abs(dx), Math.abs(dy));
                this.boundingBoxFigure2.setPosition(this.x + Math.min(0, dx), this.y + Math.min(0, dy));
            }
        }
        catch (exc) {
            console.log(exc);
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseUp: function (canvas, x, y, shiftKey, ctrlKey) {
        try {
            var _this = this;
            // delete the current selection if you have clicked in the empty
            // canvas.
            if (this.mouseDownElement === null) {
                canvas.getSelection().getAll().each(function (i, figure) {
                    _this.unselect(canvas, figure);
                });
            }
            else if (this.mouseDownElement instanceof draw2d.ResizeHandle || (this.mouseDownElement instanceof draw2d.shape.basic.LineResizeHandle)) {
                // Do nothing
                // A click on a resize handle didn't change the selection of the canvas
                //
            }
            // delete the current selection if you click on another figure than the current
            // selection and you didn't drag the complete selection.
            else if (this.mouseDownElement !== null && this.mouseMovedDuringMouseDown === false) {
                var sel = canvas.getSelection().getAll();
                if (!sel.contains(this.mouseDownElement)) {
                    canvas.getSelection().getAll().each(function (i, figure) {
                        _this.unselect(canvas, figure);
                    });
                }
            }
            this._super(canvas, x, y, shiftKey, ctrlKey);

            if (this.boundingBoxFigure1 !== null) {
                // retrieve all figures which are inside the bounding box and select all of them
                //
                var selectionRect = this.boundingBoxFigure1.getBoundingBox();
                canvas.getFigures().each(function (i, figure) {
                    if (figure.isSelectable() === true && _this.decision(figure.getBoundingBox(), selectionRect)) {
                        var canDragStart = figure.onDragStart(figure.getAbsoluteX(), figure.getAbsoluteY(), shiftKey, ctrlKey);
                        if (canDragStart === true) {
                            _this.select(canvas, figure, false);
                        }
                    }
                });


                this.boundingBoxFigure1.setCanvas(null);
                this.boundingBoxFigure1 = null;
                this.boundingBoxFigure2.setCanvas(null);
                this.boundingBoxFigure2 = null;
            }

            // adding connections to the selection of the source and target port part of the current selection
            //
            var selection = canvas.getSelection();
            canvas.getLines().each(function (i, line) {
                if (line instanceof draw2d.Connection) {
                    if (selection.contains(line.getSource().getRoot()) && selection.contains(line.getTarget().getRoot())) {
                        _this.select(canvas, line, false);
                    }
                }
            });
        }
        catch (exc) {
            console.log(exc);
        }
    }

});


/**
 * @class draw2d.policy.canvas.ReadOnlySelectionPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SelectionPolicy
 */
draw2d.policy.canvas.ReadOnlySelectionPolicy = draw2d.policy.canvas.SelectionPolicy.extend({

    NAME: "draw2d.policy.canvas.ReadOnlySelectionPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Called by the host if the policy has been installed.
     *
     * @param {draw2d.Canvas/draw2d.Canvas} canvas
     */
    onInstall: function (canvas) {
        canvas.getAllPorts().each(function (i, port) {
            port.setVisible(false);
        });
    },

    /**
     * @method
     * Called by the host if the policy has been uninstalled.
     *
     * @param {draw2d.Canvas/draw2d.Canvas} canvas
     */
    onUninstall: function (canvas) {
        canvas.getAllPorts().each(function (i, port) {
            port.setVisible(true);
        });
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
        var area = canvas.getScrollArea();
        area.scrollTop(area.scrollTop() + dy2);
        area.scrollLeft(area.scrollLeft() + dx2);
    }

});


/**
 * @class draw2d.policy.canvas.DecorationPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
draw2d.policy.canvas.DecorationPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.DecorationPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    }

});


/**
 * @class draw2d.policy.canvas.FadeoutDecorationPolicy
 *
 * Install this edit policy in a canvas if you want fadeout all decorations like ports, resize handles
 * if the user didn't move the mouse. This is good for a clean representation of your diagram.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
draw2d.policy.canvas.FadeoutDecorationPolicy = draw2d.policy.canvas.DecorationPolicy.extend({

    NAME: "draw2d.policy.canvas.FadeoutDecorationPolicy",

    DEFAULT_FADEOUT_DURATION: 60,
    DEFAULT_ALPHA_DECREMENT: 0.05,

    /**
     * @constructor
     * Creates a new fade out policy. Don't forget to install them into the canvas.
     *
     */
    init: function () {
        this._super();
        this.alpha = 1.0;
        this.alphaDec = this.DEFAULT_ALPHA_DECREMENT;
        this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
        this.canvas = null;
        this.portDragging = false;
    },

    onInstall: function (canvas) {
        this.canvas = canvas;
        this.timerId = window.setInterval($.proxy(this.onTimer, this), 50);

        // initial hide all decorations after install of this policy
        //
        this.hidePortsCounter = 1;
        this.alpha = 0.1;
    },

    onUninstall: function (canvas) {
        window.clearInterval(this.timerId);
        this.canvas.getAllPorts().each(function (i, port) {
            port.setAlpha(1.0);
        });

    },

    onTimer: function () {
        this.hidePortsCounter--;
        var _this = this;
        if (this.hidePortsCounter <= 0 && this.alpha > 0) {
            this.alpha = Math.max(0, this.alpha - this.alphaDec);

            this.canvas.getAllPorts().each(function (i, port) {
                port.setAlpha(_this.alpha);
            });

            this.canvas.getSelection().getAll().each(function (i, figure) {
                figure.selectionHandles.each(function (i, handle) {
                    handle.setAlpha(_this.alpha);
                });
            });
        }
        else if (this.hidePortsCounter > 0 && this.alpha !== 1.0) {
            this.alpha = 1;// Math.min(1,this.alpha+0.1);
            this.alphaDec = this.DEFAULT_ALPHA_DECREMENT;
            this.duringHide = false;
            this.canvas.getAllPorts().each(function (i, port) {
                port.setAlpha(_this.alpha);
            });
            this.canvas.getSelection().getAll().each(function (i, figure) {
                figure.selectionHandles.each(function (i, handle) {
                    handle.setAlpha(_this.alpha);
                });
            });
        }
    },


    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {
        this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = (canvas.getBestFigure(x, y) instanceof draw2d.Port);
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseMove: function (canvas, x, y, shiftKey, ctrlKey) {
        this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = false;
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
        if (this.portDragging === false) {
            this.hidePortsCounter = 0;
            this.alphaDec = 0.1;
            this.onTimer();
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseUp: function (figure, x, y, shiftKey, ctrlKey) {
        this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = false;
    }

});


/**
 * @class draw2d.policy.canvas.CoronaDecorationPolicy
 * This decorations hides draw2d.Ports which are to far from the current cursor position.
 * This makes the canvas more clean if you have a lot of nodes on it.<br>
 * You didn't see a bunch of ports.
 *
 * See the example:
 *
 *       @example preview small frame
 *
 *       // install the policy to the canvas
 *
 *       // add some demo figure to the canvas
 *       canvas.add(new draw2d.shape.node.Start({x: 10,  y: 30}));
 *       canvas.add(new draw2d.shape.node.End({x: 90,  y: 90}));
 *       canvas.add(new draw2d.shape.node.Between({ x: 310, y: 30}));
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"move the mouse and you see that ports are hidden if the mouse far from it"}),5,5);
 *
 *       canvas.installEditPolicy(new draw2d.policy.canvas.CoronaDecorationPolicy());
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
draw2d.policy.canvas.CoronaDecorationPolicy = draw2d.policy.canvas.DecorationPolicy.extend({

    NAME: "draw2d.policy.canvas.CoronaDecorationPolicy",

    /**
     * @constructor
     *
     */
    init: function () {
        this._super();

        this.startDragX = 0;
        this.startDragY = 0;

        this.diameterToBeVissible = 150;
        this.diameterToBeFullVisible = 20;
        this.sumDiameter = this.diameterToBeVissible + this.diameterToBeFullVisible;

    },

    /**
     * @inheritdoc
     */
    onInstall: function (canvas) {
        var figures = canvas.getFigures();
        figures.each(function (i, figure) {
            figure.getPorts().each(function (i, p) {
                p.setVisible(false);
            });
        });
    },

    /**
     * @inheritdoc
     */
    onUninstall: function (canvas) {
        var figures = canvas.getFigures();
        figures.each(function (i, figure) {
            figure.getPorts().each(function (i, p) {
                if (p.__origAlpha) {
                    p.setAlpha(p.__origAlpha);
                    delete p.__origAlpha;
                }
                p.setVisible(true);
            });
        });
    },


    /**
     * @inheritdoc
     */
    onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {
        this.startDragX = x;
        this.startDragY = y;
    },

    /**
     * @inheritdoc
     */
    onMouseMove: function (canvas, x, y, shiftKey, ctrlKey) {
        this.updatePorts(canvas, x, y);
    },

    /**
     * @inheritdoc
     */
    onMouseDrag: function (canvas, dx, dy, dx2, dy2) {
        this.updatePorts(canvas, this.startDragX + dx, this.startDragY + dy);
    },


    /**
     * @method
     * Update all ports with the new calculated opacity in relation to the distance to the current
     * mouse position
     *
     * @param canvas
     * @param x
     * @param y
     * @private
     */
    updatePorts: function (canvas, x, y) {
        // 3.) Check now the common objects
        //
        var figures = canvas.getFigures();
        var _this = this;
        figures.each(function (i, figure) {
            if (figure instanceof draw2d.shape.node.Node) {
                if (figure.isVisible() === true && figure.hitTest(x, y, _this.sumDiameter) === true) {
                    figure.getPorts().each(function (i, p) {
                        if (p.isVisible() === false) {
                            p.__origAlpha = figure.getAlpha();
                        }
                        var dist = figure.getBoundingBox().getDistance(new draw2d.geo.Point(x, y));
                        var alpha = 1 - ((100 / (_this.diameterToBeVissible - _this.diameterToBeFullVisible)) * dist) / 100.0;

                        p.setAlpha(alpha);

                        p.setVisible(true);
                    });
                }
                else {
                    figure.getPorts().each(function (i, p) {
                        if (p.__origAlpha) {
                            p.setAlpha(p.__origAlpha);
                            delete p.__origAlpha;
                        }
                        p.setVisible(false);
                    });
                }
            }
        });
    }

});


/**
 * @class draw2d.policy.canvas.SnapToEditPolicy
 *
 * A helper used by Tools for snapping certain mouse interactions.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
draw2d.policy.canvas.SnapToEditPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.SnapToEditPolicy",

    /**
     * @constructor
     * Creates a new constraint policy for snap to grid
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Adjust the coordinates to the given constraint of the policy.
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {draw2d.Figure} figure the figure to adjust
     * @param {draw2d.geo.Point} clientPos
     * @returns {draw2d.geo.Point} the constraint position of the figure
     */
    snap: function (canvas, figure, clientPos) {
        return clientPos;
    }
});

/**
 * @class draw2d.policy.canvas.SnapToGridEditPolicy
 *
 * A helper used to perform snapping to a grid, which is specified on the canvas via the various
 * properties defined in this class.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.SnapToEditPolicy
 */
draw2d.policy.canvas.SnapToGridEditPolicy = draw2d.policy.canvas.SnapToEditPolicy.extend({

    NAME: "draw2d.policy.canvas.SnapToGridEditPolicy",

    GRID_COLOR: "#e0e0f0",
    GRID_WIDTH: 10,

    /**
     * @constructor
     * Creates a new constraint policy for snap to grid
     *
     * @param {Number} grid the grid width of the canvas
     */
    init: function (grid) {
        this.canvas = null;
        this.color = new draw2d.util.Color(this.GRID_COLOR);

        this._super();


        if (typeof grid === "undefined") {
            this.grid = this.GRID_WIDTH;
        }
        else {
            this.grid = grid;
        }

        this.generateBackgroundImage(this.grid, this.color);
    },

    onInstall: function (canvas) {
        this.canvas = canvas;
        this.oldBg = this.canvas.html.css("background-image");
        $(canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
    },

    onUninstall: function (canvas) {
        this.canvas = null;
        $(canvas.paper.canvas).css({"background-image": this.oldBg});
    },

    /**
     * @method
     * Set the grid color
     *
     * @param {draw2d.util.Color|String} color a color object or the CSS string declarion for a color
     * @since 5.0.3
     */
    setGridColor: function (color) {
        this.color = new draw2d.util.Color(color);
        this.generateBackgroundImage(this.grid, this.color);
        if (this.canvas !== null) {
            $(this.canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
        }
    },

    /**
     * @method
     * Set a new grid width/height
     *
     * @param {Number} grid
     * @since 5.0.3
     */
    setGrid: function (grid) {
        this.grid = Math.min(200, Math.max(2, grid));
        this.generateBackgroundImage(this.grid, this.color);
        if (this.canvas !== null) {
            $(this.canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
        }
    },


    /**
     * @method
     * Applies a snapping correction to the given result.
     *
     * @param figure
     * @param {draw2d.geo.Point} pos
     * @returns {draw2d.geo.Point} the contraint position of the figure
     * @since 2.3.0
     */
    snap: function (canvas, figure, pos) {

        var snapPoint = figure.getSnapToGridAnchor();

        pos.x = pos.x + snapPoint.x;
        pos.y = pos.y + snapPoint.y;


        pos.x = this.grid * Math.floor(((pos.x + this.grid / 2.0) / this.grid));
        pos.y = this.grid * Math.floor(((pos.y + this.grid / 2.0) / this.grid));

        pos.x = pos.x - snapPoint.x;
        pos.y = pos.y - snapPoint.y;

        return pos;
    },


    /**
     * @method
     * calculate the background image with the given grid width/height
     *
     * @param {Number} grid the grid width of the background decoration
     * @param {draw2d.util.Color} color the color of the grid lines
     * @private
     */
    generateBackgroundImage: function (grid, color) {
        // generate the background pattern with an data URL GIF image. This is much faster than draw
        // the pattern via the canvas and the raphael.line method
        //
        var mypixels = Array(grid * grid);
        // set the pixel at the coordinate [0,0] as opaque.
        for (var x = 0; x < grid; x++) {
            mypixels[x] = 1;
        }
        for (var y = 0; y < (grid * grid); y += grid) {
            mypixels[y] = 1;
        }
        this.imageDataURL = this.createMonochromGif(grid, grid, mypixels, color.hash());
    }

});

/**
 * @class draw2d.policy.canvas.ShowGridEditPolicy
 *
 * Just to paint a grid in the background.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
draw2d.policy.canvas.ShowGridEditPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.ShowGridEditPolicy",

    GRID_COLOR: "#e0e0f0",
    GRID_WIDTH: 10,

    /**
     * @constructor
     * Creates a new constraint policy for snap to grid
     *
     * @param {Number} grid the grid width of the canvas
     */
    init: function (grid) {
        this.color = new draw2d.util.Color(this.GRID_COLOR);
        this.canvas = null;

        this._super();

        if (typeof grid === "undefined") {
            this.grid = this.GRID_WIDTH;
        }
        else {
            this.grid = grid;
        }
        this.zoom = 1;


        this.generateBackgroundImage(this.grid / this.zoom, this.color);
        this.zoomListener = $.proxy(function (canvas, zoomData) {
            this.zoom = zoomData.factor;
            this.setGrid(this.grid);
        }, this);
    },

    onInstall: function (canvas) {
        this.canvas = canvas;
        this.zoom = canvas.getZoom();
        this.generateBackgroundImage(this.grid / this.zoom, this.color);
        this.oldBg = this.canvas.html.css("background-image");
        $(canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
//	    canvas.on("zoom", this.zoomListener);
    },

    onUninstall: function (canvas) {
//        canvas.off(this.zoomListener);
        this.canvas = null;
        $(canvas.paper.canvas).css({"background-image": this.oldBg});
    },

    /**
     * @method
     * Set the grid color
     *
     * @param {draw2d.util.Color|String} color a color object or the CSS string declaration for a color
     * @since 5.0.3
     */
    setGridColor: function (color) {
        this.color = new draw2d.util.Color(color);
        this.generateBackgroundImage(this.grid / this.zoom, this.color);
        if (this.canvas !== null) {
            $(this.canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
        }
    },

    /**
     * @method
     * Set a new grid width/height
     *
     * @param {Number} grid
     * @since 5.0.3
     */
    setGrid: function (grid) {
        this.grid = Math.min(200, Math.max(2, grid));
        this.generateBackgroundImage(this.grid / this.zoom, this.color);
        if (this.canvas !== null) {
            $(this.canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
        }
    },


    /**
     * @method
     * calculate the background image with the given grid width/height
     *
     * @param {Number} grid the grid width of the background decoration
     * @param {draw2d.util.Color} color the color of the grid lines
     * @private
     */
    generateBackgroundImage: function (grid, color) {
        grid = parseInt(Math.floor(grid));
        // generate the background pattern with an data URL GIF image. This is much faster than draw
        // the pattern via the canvas and the raphael.line method
        //
        var mypixels = Array(grid * grid);
        // set the pixel at the coordinate [0,0] as opaque.
        for (var x = 0; x < grid; x++) {
            mypixels[x] = 1;
        }
        for (var y = 0; y < (grid * grid); y += grid) {
            mypixels[y] = 1;
        }
        this.imageDataURL = this.createMonochromGif(grid, grid, mypixels, color.hash());
    }


});

/**
 * @class draw2d.policy.canvas.ShowDotEditPolicy
 *
 * Paint a dotted pattern in the background of the canvas.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.CanvasPolicy
 * @since 4.0.1
 */
draw2d.policy.canvas.ShowDotEditPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.ShowDotEditPolicy",

    DOT_COLOR: "#999999",
    DOT_RADIUS: 1,
    DOT_DISTANCE: 20,

    /**
     * @constructor
     * show a dot grid in the canvas for decoration.
     *
     * @param {Number} [dotDistance] the distance or grid width between the dots.
     * @param {Number} [dotRadius] the radius of the dots.
     * @param {draw2d.util.Color|String} [dotColor] the color for the dots.
     */
    init: function (dotDistance, dotRadius, dotColor) {
        this._super();
        this.canvas = null;

        this.dotDistance = dotDistance ? dotDistance : this.DOT_DISTANCE;
        this.dotRadius = dotRadius ? dotRadius : this.DOT_RADIUS;
        this.dotColor = new draw2d.util.Color(dotColor ? dotColor : this.DOT_COLOR);

        // generate the background pattern with an data URL GIF image. This is much faster than draw
        // the pattern via the canvas and the raphael.circle method
        //
        var mypixels = Array(this.dotDistance * this.dotDistance);
        // set the pixel at the coordinate [0,0] as opaque.
        mypixels[0] = 1;
        this.imageDataURL = this.createMonochromGif(this.dotDistance, this.dotDistance, mypixels, this.dotColor);
    },

    onInstall: function (canvas) {
        this.canvas = canvas;
        this.oldBg = this.canvas.html.css("background-image");
        $(canvas.paper.canvas).css({"background-image": "url('" + this.imageDataURL + "')"});
    },

    onUninstall: function (canvas) {
        this.canvas = null;
        $(canvas.paper.canvas).css({"background-image": this.oldBg});
    }


});

/**
 * @class draw2d.policy.canvas.ShowChessboardEditPolicy
 *
 * Just to paint a grid in the background.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
draw2d.policy.canvas.ShowChessboardEditPolicy = draw2d.policy.canvas.CanvasPolicy.extend({

    NAME: "draw2d.policy.canvas.ShowChessboardEditPolicy",

    GRID_COLOR: "#e0e0e0",
    GRID_WIDTH: 20,

    /**
     * @constructor
     * Creates a new constraint policy for snap to grid
     *
     * @param {Number} grid the grid width of the canvas
     */
    init: function (grid) {
        this._super();
        this.canvas = null;
        this.cells = null;
        if (grid) {
            this.grid = grid;
        }
        else {
            this.grid = this.GRID_WIDTH;
        }
    },

    onInstall: function (canvas) {
        this.canvas = canvas;
        this.showGrid();
    },

    onUninstall: function (canvas) {
        this.canvas = null;
        this.cells.remove();
    },

    /**
     * @method
     * paint the grid into the canvas
     *
     * @private
     * @since 2.3.0
     */
    showGrid: function () {
        // vertical lines
        var w = this.canvas.initialWidth;
        var h = this.canvas.initialHeight;
        this.cells = this.canvas.paper.set();

        var even = false;
        var xEven = even;
        for (var x = 0; x < w; x += this.grid) {
            for (var y = 0; y < h; y += this.grid) {
                if (even) {
                    var crect = this.canvas.paper.rect(x, y, this.grid, this.grid);
                    crect.attr({fill: this.GRID_COLOR, "stroke-width": 0});
                    this.cells.push(crect);
                }
                even = !even;
            }
            xEven = !xEven;
            even = xEven;
        }

        this.cells.toBack();
    }

});

draw2d.SnapToHelper = {};

draw2d.SnapToHelper.NORTH = 1;
draw2d.SnapToHelper.SOUTH = 4;
draw2d.SnapToHelper.WEST = 8;
draw2d.SnapToHelper.EAST = 16;
draw2d.SnapToHelper.CENTER = 32;

draw2d.SnapToHelper.NORTH_EAST = draw2d.SnapToHelper.NORTH | draw2d.SnapToHelper.EAST;
draw2d.SnapToHelper.NORTH_WEST = draw2d.SnapToHelper.NORTH | draw2d.SnapToHelper.WEST;
draw2d.SnapToHelper.SOUTH_EAST = draw2d.SnapToHelper.SOUTH | draw2d.SnapToHelper.EAST;
draw2d.SnapToHelper.SOUTH_WEST = draw2d.SnapToHelper.SOUTH | draw2d.SnapToHelper.WEST;
draw2d.SnapToHelper.NORTH_SOUTH = draw2d.SnapToHelper.NORTH | draw2d.SnapToHelper.SOUTH;
draw2d.SnapToHelper.EAST_WEST = draw2d.SnapToHelper.EAST | draw2d.SnapToHelper.WEST;
draw2d.SnapToHelper.NSEW = draw2d.SnapToHelper.NORTH_SOUTH | draw2d.SnapToHelper.EAST_WEST;

/**
 * @class draw2d.policy.canvas.SnapToGeometryEditPolicy
 *
 * Snapping is based on the existing children of a container. When snapping a shape,
 * the edges of the bounding box will snap to edges of other rectangles generated
 * from the children of the given canvas.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.SnapToEditPolicy
 */
draw2d.policy.canvas.SnapToGeometryEditPolicy = draw2d.policy.canvas.SnapToEditPolicy.extend({

    NAME: "draw2d.policy.canvas.SnapToGeometryEditPolicy",

    SNAP_THRESHOLD: 3,
    LINE_COLOR: "#1387E6",
    FADEOUT_DURATION: 300,

    /**
     * @constructor
     * Creates a new constraint policy for snap to grid
     *
     * @param {Number} grid the grid width of the canvas
     */
    init: function () {
        this._super();

        this.rows = null;
        this.cols = null;
        this.vline = null;
        this.hline = null;
        this.canvas = null;
    },

    onInstall: function (canvas) {
        this.canvas = canvas;
    },

    onUninstall: function (canvas) {
        this.canvas = null;
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseUp: function (figure, x, y, shiftKey, ctrlKey) {
        this.rows = null;
        this.cols = null;
        this.hideVerticalLine();
        this.hideHorizontalLine();
    },

    /**
     * @method
     * Adjust the coordinates to the canvas neighbours
     *
     * @param figure
     * @param {draw2d.geo.Point} pos
     * @returns {draw2d.geo.Point} the contraint position of th efigure
     */
    snap: function (canvas, figure, pos) {

        if (figure instanceof draw2d.ResizeHandle) {
            var snapPoint = figure.getSnapToGridAnchor();
            pos.x += snapPoint.x;
            pos.y += snapPoint.y;
            var result = new draw2d.geo.Point(pos.x, pos.y);

            var snapDirections = figure.getSnapToDirection();
            var direction = this.snapPoint(snapDirections, pos, result);

            // Show a vertical line if the snapper has modified the inputPoint
            //
            if ((snapDirections & draw2d.SnapToHelper.EAST_WEST) && !(direction & draw2d.SnapToHelper.EAST_WEST))
                this.showVerticalLine(result.x);
            else
                this.hideVerticalLine();

            // Show a horizontal line if the snapper has modified the inputPoint
            //
            if ((snapDirections & draw2d.SnapToHelper.NORTH_SOUTH) && !(direction & draw2d.SnapToHelper.NORTH_SOUTH))
                this.showHorizontalLine(result.y);
            else
                this.hideHorizontalLine();

            result.x -= snapPoint.x;
            result.y -= snapPoint.y;
            return result;
        }

        // The user drag&drop a normal figure
        var inputBounds = new draw2d.geo.Rectangle(pos.x, pos.y, figure.getWidth(), figure.getHeight());
        var result = new draw2d.geo.Rectangle(pos.x, pos.y, figure.getWidth(), figure.getHeight());

        var snapDirections = draw2d.SnapToHelper.NSEW;
        var direction = this.snapRectangle(inputBounds, result);

        // Show a vertical line if the snapper has modified the inputPoint
        //
        if ((snapDirections & draw2d.SnapToHelper.WEST) && !(direction & draw2d.SnapToHelper.WEST))
            this.showVerticalLine(result.x);
        else if ((snapDirections & draw2d.SnapToHelper.EAST) && !(direction & draw2d.SnapToHelper.EAST))
            this.showVerticalLine(result.getX() + result.getWidth());
        else
            this.hideVerticalLine();


        // Show a horizontal line if the snapper has modified the inputPoint
        //
        if ((snapDirections & draw2d.SnapToHelper.NORTH) && !(direction & draw2d.SnapToHelper.NORTH))
            this.showHorizontalLine(result.y);
        else if ((snapDirections & draw2d.SnapToHelper.SOUTH) && !(direction & draw2d.SnapToHelper.SOUTH))
            this.showHorizontalLine(result.getY() + result.getHeight());
        else
            this.hideHorizontalLine();

        return result.getTopLeft();
    },


    snapRectangle: function (/*:draw2d.Dimension*/ inputBounds, /*:draw2d.Dimension*/ resultBounds) {
        var topLeftResult = inputBounds.getTopLeft();
        var bottomRightResult = inputBounds.getBottomRight();

        var snapDirectionsTopLeft = this.snapPoint(draw2d.SnapToHelper.NORTH_WEST, inputBounds.getTopLeft(), topLeftResult);
        resultBounds.x = topLeftResult.x;
        resultBounds.y = topLeftResult.y;

        var snapDirectionsBottomRight = this.snapPoint(draw2d.SnapToHelper.SOUTH_EAST, inputBounds.getBottomRight(), bottomRightResult);
        // the first test (topLeft) has not modified the point. so we can modify them with the bottomRight adjustment
        //
        if (snapDirectionsTopLeft & draw2d.SnapToHelper.WEST)
            resultBounds.x = bottomRightResult.x - inputBounds.getWidth();

        // the first test (topLeft) has not modified the point. so we can modify them with the bottomRight adjustment
        //
        if (snapDirectionsTopLeft & draw2d.SnapToHelper.NORTH)
            resultBounds.y = bottomRightResult.y - inputBounds.getHeight();


        return snapDirectionsTopLeft | snapDirectionsBottomRight;
    },

    snapPoint: function (/*:int*/ snapOrientation, /*:draw2d.Point*/ inputPoint, /*:draw2d.Point*/ resultPoint) {
        if (this.rows === null || this.cols === null)
            this.populateRowsAndCols();

        if ((snapOrientation & draw2d.SnapToHelper.EAST) !== 0) {
            var rightCorrection = this.getCorrectionFor(this.cols, inputPoint.getX() - 1, 1);
            if (rightCorrection !== this.SNAP_THRESHOLD) {
                snapOrientation &= ~draw2d.SnapToHelper.EAST;
                resultPoint.x += rightCorrection;
            }
        }

        if ((snapOrientation & draw2d.SnapToHelper.WEST) !== 0) {
            var leftCorrection = this.getCorrectionFor(this.cols, inputPoint.getX(), -1);
            if (leftCorrection !== this.SNAP_THRESHOLD) {
                snapOrientation &= ~draw2d.SnapToHelper.WEST;
                resultPoint.x += leftCorrection;
            }
        }

        if ((snapOrientation & draw2d.SnapToHelper.SOUTH) !== 0) {
            var bottomCorrection = this.getCorrectionFor(this.rows, inputPoint.getY() - 1, 1);
            if (bottomCorrection !== this.SNAP_THRESHOLD) {
                snapOrientation &= ~draw2d.SnapToHelper.SOUTH;
                resultPoint.y += bottomCorrection;
            }
        }

        if ((snapOrientation & draw2d.SnapToHelper.NORTH) !== 0) {
            var topCorrection = this.getCorrectionFor(this.rows, inputPoint.getY(), -1);
            if (topCorrection !== this.SNAP_THRESHOLD) {
                snapOrientation &= ~draw2d.SnapToHelper.NORTH;
                resultPoint.y += topCorrection;
            }
        }

        return snapOrientation;
    },

    populateRowsAndCols: function () {
        var selection = this.canvas.getSelection();
        this.rows = [];
        this.cols = [];

        var figures = this.canvas.getFigures();
        var index = 0;
        for (var i = 0; i < figures.getSize(); i++) {
            var figure = figures.get(i);
            if (!selection.contains(figure)) {
                var bounds = figure.getBoundingBox();
                this.cols[index * 3] = {type: -1, location: bounds.getX()};
                this.rows[index * 3] = {type: -1, location: bounds.getY()};
                this.cols[index * 3 + 1] = {type: 0, location: bounds.x + (bounds.getWidth() - 1) / 2};
                this.rows[index * 3 + 1] = {type: 0, location: bounds.y + (bounds.getHeight() - 1) / 2};
                this.cols[index * 3 + 2] = {type: 1, location: bounds.getRight() - 1};
                this.rows[index * 3 + 2] = {type: 1, location: bounds.getBottom() - 1};
                index++;
            }
        }
    },

    getCorrectionFor: function (/*:Array*/ entries, /*:double*/ value, /*:int*/ side) {
        var resultMag = this.SNAP_THRESHOLD;
        var result = this.SNAP_THRESHOLD;

        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            var magnitude;

            if (entry.type === -1 && side !== 0) {
                magnitude = Math.abs(value - entry.location);
                if (magnitude < resultMag) {
                    resultMag = magnitude;
                    result = entry.location - value;
                }
            }
            else if (entry.type === 0 && side === 0) {
                magnitude = Math.abs(value - entry.location);
                if (magnitude < resultMag) {
                    resultMag = magnitude;
                    result = entry.location - value;
                }
            }
            else if (entry.type === 1 && side !== 0) {
                magnitude = Math.abs(value - entry.location);
                if (magnitude < resultMag) {
                    resultMag = magnitude;
                    result = entry.location - value;
                }
            }
        }
        return result;
    },

    showVerticalLine: function (x) {
        if (this.vline != null) {
            return; //silently
        }
        this.vline = this.canvas.paper
            .path("M " + x + " 0 l 0 " + this.canvas.getHeight())
            .attr({"stroke": this.LINE_COLOR, "stroke-width": 1});
    },

    hideVerticalLine: function () {
        if (this.vline == null) {
            return;
        }
        var tmp = this.vline;
        tmp.animate({
            opacity: 0.1
        }, this.FADEOUT_DURATION, function () {
            tmp.remove();
        });

        this.vline = null;
    },

    showHorizontalLine: function (y) {
        if (this.hline != null) {
            return;
        }

        this.hline = this.canvas.paper
            .path("M 0 " + y + " l " + this.canvas.getWidth() + " 0")
            .attr({"stroke": this.LINE_COLOR, "stroke-width": 1});
    },

    hideHorizontalLine: function () {
        if (this.hline == null) {
            return; //silently
        }
        var tmp = this.hline;
        tmp.animate({
            opacity: 0.1
        }, this.FADEOUT_DURATION, function () {
            tmp.remove();
        });
        this.hline = null;
    }

});

/**
 * @class draw2d.policy.figure.FigureEditPolicy
 *
 * Called by the framework if the user edit the position of a figure with a drag drop operation.
 * Sub class like SelectionEditPolicy or RegionEditPolicy cam adjust th e position of the figure or the selections handles.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.EditPolicy
 * @since 4.4.0
 */
draw2d.policy.figure.FigureEditPolicy = draw2d.policy.EditPolicy.extend({

    NAME: "draw2d.policy.figure.FigureEditPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Called if the user press the right mouse on the figure.<br>
     * You can either override the "onContextMenu" method of the figure or install an editor policy and override this method.
     * Booth is valid and possible.
     *
     * @param {draw2d.Figure|draw2d.shape.basic.Line} figure the figure below the mouse
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     * @since 4.4.0
     */
    onRightMouseDown: function (figure, x, y, shiftKey, ctrlKey) {
    }
});

/**
 * @class draw2d.policy.figure.DragDropEditPolicy
 *
 * Called by the framework if the user edit the position of a figure with a drag drop operation.
 * Sub class like SelectionEditPolicy or RegionEditPolicy can adjust the position of the figure or the selections handles.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.figure.FigureEditPolicy
 */
draw2d.policy.figure.DragDropEditPolicy = draw2d.policy.figure.FigureEditPolicy.extend({

    NAME: "draw2d.policy.figure.DragDropEditPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework if the related shape has init a drag&drop
     * operation
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onDragStart: function (canvas, figure, x, y, shiftKey, ctrlKey) {
        figure.shape.attr({cursor: "move"});

        // this happens if you drag&drop the shape outside of the screen and
        // release the mouse button outside the window. We restore the alpha
        // with the next drag&drop operation
        if (figure.isMoving === true) {
            figure.setAlpha(figure.originalAlpha);
        }

        figure.originalAlpha = figure.getAlpha();
        figure.isMoving = false;
    },

    /**
     * @method
     * Called by the framework during drag a figure.
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @template
     */
    onDrag: function (canvas, figure) {

        // enable the alpha blending of the first real move of the object
        //
        if (figure.isMoving === false) {
            figure.isMoving = true;
            figure.setAlpha(figure.originalAlpha * 0.4);
        }
    },

    /**
     * @method
     * Called by the framework if the drag drop operation ends.
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onDragEnd: function (canvas, figure, x, y, shiftKey, ctrlKey) {
        figure.shape.attr({cursor: "default"});
        figure.isMoving = false;
        figure.setAlpha(figure.originalAlpha);
    },

    /**
     * @method
     * Adjust the coordinates to the rectangle/region of this constraint.
     *
     * @param figure
     * @param {Number|draw2d.geo.Point} x
     * @param {number} [y]
     * @returns {draw2d.geo.Point} the constraint position of the figure
     *
     * @template
     */
    adjustPosition: function (figure, x, y) {
        // do nothing per default implementation
        if (x instanceof draw2d.geo.Point) {
            return x;
        }
        return new draw2d.geo.Point(x, y);
    },

    /**
     * @method
     * ensure that the dimension didn't goes outside the given restrictions
     *
     * @param figure
     * @param {Number} w
     * @param {number} h
     * @returns {draw2d.geo.Rectangle} the constraint position of the figure
     */
    adjustDimension: function (figure, w, h) {
        return new draw2d.geo.Rectangle(0, 0, w, h);
    },

    /**
     * @method
     * Callback if the figure has moved
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     *
     * @template
     */
    moved: function (canvas, figure) {
    }
});

/**
 * @class draw2d.policy.figure.RegionConstraintPolicy
 *
 * An EditPolicy for use with Figures. The constraint for RegionContraintPolicy is a Rectangle. It is
 * not possible to move the related figure outside this contrained area.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.figure.RegionEditPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({

    NAME: "draw2d.policy.figure.RegionEditPolicy",

    /**
     * @constructor
     * Creates a new constraint object
     *
     * @param {Number|draw2d.geo.Rectangle} x x coordinate or a rectangle as constraint for the assigned figure.
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */
    init: function (x, y, w, h) {
        this._super();
        if (x instanceof draw2d.geo.Rectangle) {
            this.constRect = x;
        }
        else if (typeof h === "number") {
            this.constRect = new draw2d.geo.Rectangle(x, y, w, h);
        }
        else {
            throw "Invalid parameter. RegionConstraintPolicy need a rectangle as parameter in the constructor";
        }
    },

    /**
     * @method
     * Update the constraint bounding box for the policy.
     *
     * @param {draw2d.geo.Rectangle} boundingBox the constraint rectangle
     * @since 4.8.2
     */
    setBoundingBox: function (boundingBox) {
        this.constRect = boundingBox;

        return this;
    },

    /**
     * @method
     * Adjust the coordinates to the rectangle/region of this constraint.
     *
     * @param figure
     * @param {Number|draw2d.geo.Point} x
     * @param {number} [y]
     *
     * @returns {draw2d.geo.Point} the constraint position of the figure
     */
    adjustPosition: function (figure, x, y) {
        var r = null;
        if (x instanceof draw2d.geo.Point) {
            r = new draw2d.geo.Rectangle(x.x, x.y, figure.getWidth(), figure.getHeight());
        }
        else {
            r = new draw2d.geo.Rectangle(x, y, figure.getWidth(), figure.getHeight());
        }
        r = this.constRect.moveInside(r);
        return r.getTopLeft();
    },

    /**
     * @method
     * Adjust the dimension of the rectangle to fit into the region of the policy
     *
     * @param {draw2d.Figure} figure
     * @param {Number} w
     * @param {Number} h
     *
     * @private
     */
    adjustDimension: function (figure, w, h) {
        var diffW = (figure.getAbsoluteX() + w) - this.constRect.getRight();
        var diffH = (figure.getAbsoluteY() + h) - this.constRect.getBottom();

        if (diffW > 0) {
            w = w - diffW;
        }
        if (diffH > 0) {
            h = h - diffH;
        }

        return {w: w, h: h};
    }
});

/**
 * @class draw2d.policy.figure.HorizontalEditPolicy
 *
 * An EditPolicy for use with Figures. With this edit policy you can move the shape only in a horizontal manner.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *       // add some demo figure to the canvas
 *       var circle =new draw2d.shape.basic.Circle({diameter:50, x:10, y:30});
 *       canvas.add(circle);
 *
 *       // add the edit policy to the shape. At this point you can move the shape only
 *       // horizontal
 *       circle.installEditPolicy(new draw2d.policy.figure.HorizontalEditPolicy());
 *
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.figure.HorizontalEditPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({

    NAME: "draw2d.policy.figure.HorizontalEditPolicy",

    /**
     * @constructor
     * Creates a new constraint object
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * It is only possible to drag&drop the element in a horizontal line
     *
     * @param figure
     * @param {Number|draw2d.geo.Point} x
     * @param {number} [y]
     * @returns {draw2d.geo.Point} the constraint position of the figure
     */
    adjustPosition: function (figure, x, y) {
        return new draw2d.geo.Point(x, figure.getY());
    }

});

/**
 * @class draw2d.policy.figure.VerticalEditPolicy
 *
 * An EditPolicy for use with Figures. With this edit policy you can move the shape only in a vertical manner.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *       // add some demo figure to the canvas
 *       var circle =new draw2d.shape.basic.Circle({diameter:50, x:10, y:30});
 *       canvas.add(circle);
 *
 *       // add the edit policy to the shape. At this point you can move the shape only
 *       // horizontal
 *       circle.installEditPolicy(new draw2d.policy.figure.VerticalEditPolicy());
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.figure.VerticalEditPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({

    NAME: "draw2d.policy.figure.VerticalEditPolicy",

    /**
     * @constructor
     * Creates a new constraint object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * It is only possible to drag&drop the element in a vertical line
     *
     * @param figure
     * @param {Number|draw2d.geo.Point} x
     * @param {number} [y]
     * @returns {draw2d.geo.Point} the constraint position of the figure
     */
    adjustPosition: function (figure, x, y) {
        return new draw2d.geo.Point(figure.getX(), y);
    }

});

/**
 * @class draw2d.policy.figure.SelectionFeedbackPolicy
 *
 * A draw2d.policy.SelectionFeedbackPolicy that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.figure.SelectionFeedbackPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({

    NAME: "draw2d.policy.figure.SelectionFeedbackPolicy",

    /**
     * @constructor
     *
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     *
     * @template
     * @param figure
     * @param isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        console.log("on select")
    },


    /**
     * @method
     *
     * @param {draw2d.Figure} figure the unselected figure
     */
    onUnselect: function (canvas, figure) {
        figure.selectionHandles.each(function (i, e) {
            e.hide();
        });
        figure.selectionHandles = new draw2d.util.ArrayList();
    },

    /**
     * @method
     * Called by the host if the policy has been installed.
     *
     * @param {draw2d.Figure} figure
     */
    onInstall: function (figure) {
        this._super(figure);

        var canvas = figure.getCanvas();
        if (canvas !== null) {
            if (canvas.getSelection().contains(figure)) {
                this.onSelect(canvas, figure, true);
            }
        }
    },


    /**
     * @method
     * Called by the host if the policy has been uninstalled.
     *
     * @param {draw2d.Figure} figure
     */
    onUninstall: function (figure) {
        this._super(figure);

        if (typeof figure.selectionHandles === "undefined") {
            return;
        }

        figure.selectionHandles.each(function (i, e) {
            e.hide();
        });
        figure.selectionHandles = new draw2d.util.ArrayList();
    }

});


/**
 * @class draw2d.policy.figure.ResizeSelectionFeedbackPolicy
 *
 * Selection feedback policy without "marching ant lines" or any other rectangle highlight. Just
 * some resize handles at each corner of the shape.
 *
 * See the example:
 *
 *     @example preview small frame
 *       circle =new draw2d.shape.basic.Circle();
 *       circle.installEditPolicy(new draw2d.policy.ResizeSelectionFeedbackPolicy());
 *       canvas.add(circle,90,50);
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @since 4.0.0
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 *
 */
draw2d.policy.figure.ResizeSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.ResizeSelectionFeedbackPolicy",
    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {

        if (figure.selectionHandles.isEmpty()) {
            // create standard Resize handles for the figure
            //
            var r1 = draw2d.Configuration.factory.createResizeHandle(figure, 1); // 1 = LEFT TOP
            var r2 = draw2d.Configuration.factory.createResizeHandle(figure, 2); // 2 = CENTER_TOP
            var r3 = draw2d.Configuration.factory.createResizeHandle(figure, 3); // 3 = RIGHT_TOP
            var r4 = draw2d.Configuration.factory.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
            var r5 = draw2d.Configuration.factory.createResizeHandle(figure, 5); // 5 = RIGHT_BOTTOM
            var r6 = draw2d.Configuration.factory.createResizeHandle(figure, 6); // 6 = CENTER_BOTTOM
            var r7 = draw2d.Configuration.factory.createResizeHandle(figure, 7); // 7 = LEFT_BOTTOM
            var r8 = draw2d.Configuration.factory.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE

            // and add them to the figure. We need the reference to the ResizeHandles
            // to remove the resize handles if the figure will be unselect. Just a simple
            // refrence store
            //
            figure.selectionHandles.add(r1);
            figure.selectionHandles.add(r2);
            figure.selectionHandles.add(r3);
            figure.selectionHandles.add(r4);
            figure.selectionHandles.add(r5);
            figure.selectionHandles.add(r6);
            figure.selectionHandles.add(r7);
            figure.selectionHandles.add(r8);

            // show the default top/left, top/right, bottom/right and bottom/left
            // resize handles
            //
            r1.show(canvas);
            r3.show(canvas);
            r5.show(canvas);
            r7.show(canvas);

            // The corner ResizeHandles are only draggable fi the figure is
            // resizeable. But the Resize handles are visible
            //

            // change the look&feel of the corner resizehandles if the
            // figure isn't resizeable
            //
            if (figure.isResizeable() === false) {
                r1.setBackgroundColor(null);
                r3.setBackgroundColor(null);
                r5.setBackgroundColor(null);
                r7.setBackgroundColor(null);
                r1.setDraggable(false);
                r3.setDraggable(false);
                r5.setDraggable(false);
                r7.setDraggable(false);
            }

            // show only the additional resizehandles if the figure is resizeable
            //
            if ((!figure.getKeepAspectRatio()) && figure.isResizeable()) {
                r2.show(canvas);
                r4.show(canvas);
                r6.show(canvas);
                r8.show(canvas);
            }
        }
        this.moved(canvas, figure);
    },

    /**
     * @method
     * Callback if the figure has been moved. In this case we must update the position of the
     * resize handles.
     *
     * @param figure
     *
     * @template
     */
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }

        var objHeight = figure.getHeight();
        var objWidth = figure.getWidth();
        var xPos = figure.getX();
        var yPos = figure.getY();

        var r1 = figure.selectionHandles.get(0);
        var r3 = figure.selectionHandles.get(2);
        var r5 = figure.selectionHandles.get(4);
        var r7 = figure.selectionHandles.get(6);
        r1.setPosition(xPos - r1.getWidth(), yPos - r1.getHeight());
        r3.setPosition(xPos + objWidth, yPos - r3.getHeight());
        r5.setPosition(xPos + objWidth, yPos + objHeight);
        r7.setPosition(xPos - r7.getWidth(), yPos + objHeight);

        if (!figure.getKeepAspectRatio()) {
            var r2 = figure.selectionHandles.get(1);
            var r4 = figure.selectionHandles.get(3);
            var r6 = figure.selectionHandles.get(5);
            var r8 = figure.selectionHandles.get(7);

            r2.setPosition(xPos + (objWidth / 2) - (r2.getWidth() / 2), yPos - r2.getHeight());
            r4.setPosition(xPos + objWidth, yPos + (objHeight / 2) - (r4.getHeight() / 2));
            r6.setPosition(xPos + (objWidth / 2) - (r6.getWidth() / 2), yPos + objHeight);
            r8.setPosition(xPos - r8.getWidth(), yPos + (objHeight / 2) - (r8.getHeight() / 2));
        }
    }


});


/**
 * @class draw2d.policy.figure.RectangleSelectionFeedbackPolicy
 *
 * See the example:
 *
 *     @example preview small frame
 *       circle =new draw2d.shape.basic.Circle({diameter:50});
 *       circle.installEditPolicy(new draw2d.policy.RectangleSelectionFeedbackPolicy());
 *       canvas.add(circle,90,50);
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.RectangleSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.RectangleSelectionFeedbackPolicy",
    /**
     * @constructor
     * Creates a selection feedback for a shape.
     */
    init: function () {
        this._super();

    },


    /**
     * @inheritdoc
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        if (figure.selectionHandles.isEmpty()) {
            // Add a dotted line rectangle to the figure. Override the show/hide method of the standard
            // figure to avoid adding these element to the hit test of the canvas. In this case the element
            // is just visible but not part of the model or responsible for any drag/drop operation
            //
            var box = new draw2d.shape.basic.Rectangle({bgColor: null, dashArray: "- ", color: "#2096fc", stroke: 0.5});
            box.hide = function () {
                // IMPORTANT
                // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
                // dragDrop operation
                //canvas.resizeHandles.remove(box);
                box.setCanvas(null);
            };
            box.show = function (canvas) {
                box.setCanvas(canvas);
                // IMPORTANT
                // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
                // dragDrop operation
                //canvas.resizeHandles.remove(box);
                //canvas.resizeHandles.add(box);
                box.toFront(figure);
            };
            // create standard Resize handles for the figure
            //
            var r1 = draw2d.Configuration.factory.createResizeHandle(figure, 1); // 1 = LEFT TOP
            var r2 = draw2d.Configuration.factory.createResizeHandle(figure, 2); // 2 = CENTER_TOP
            var r3 = draw2d.Configuration.factory.createResizeHandle(figure, 3); // 3 = RIGHT_TOP
            var r4 = draw2d.Configuration.factory.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
            var r5 = draw2d.Configuration.factory.createResizeHandle(figure, 5); // 5 = RIGHT_BOTTOM
            var r6 = draw2d.Configuration.factory.createResizeHandle(figure, 6); // 6 = CENTER_BOTTOM
            var r7 = draw2d.Configuration.factory.createResizeHandle(figure, 7); // 7 = LEFT_BOTTOM
            var r8 = draw2d.Configuration.factory.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE

            // and add them to the figure. We need the reference to the ResizeHandles
            // to remove the resize handles if the figure will be unselect. Just a simple
            // reference store
            //
            figure.selectionHandles.add(r1);
            figure.selectionHandles.add(r2);
            figure.selectionHandles.add(r3);
            figure.selectionHandles.add(r4);
            figure.selectionHandles.add(r5);
            figure.selectionHandles.add(r6);
            figure.selectionHandles.add(r7);
            figure.selectionHandles.add(r8);

            // show the default top/left, top/right, bottom/right and bottom/left
            // resize handles
            //
            r1.show(canvas);
            r3.show(canvas);
            r5.show(canvas);
            r7.show(canvas);


            // change the look&feel of the corner resizehandles if the
            // figure isn't resizeable
            //
            if (figure.isResizeable() === false) {
                r1.setBackgroundColor(null);
                r3.setBackgroundColor(null);
                r5.setBackgroundColor(null);
                r7.setBackgroundColor(null);
                r1.setDraggable(false);
                r3.setDraggable(false);
                r5.setDraggable(false);
                r7.setDraggable(false);
            }

            // show only the additional resizehandles if the figure is resizeable and didn't care about
            // the aspect ration
            //
            if ((!figure.getKeepAspectRatio()) && figure.isResizeable()) {
                r2.show(canvas);
                r4.show(canvas);
                r6.show(canvas);
                r8.show(canvas);
            }

            // add the reference of the "ant box" to the figure as well. But wee add them
            // to the end of the array because inherit classes expect the resizehandles
            // on index 0-7.
            //
            figure.selectionHandles.add(box);

            // call the box.show() at last to ensure that the resize handles are above the
            // rectangle. The rectangle did a toFront(parentShape);
            box.show(canvas);
        }
        this.moved(canvas, figure);
    },

    /**
     * @inheritdoc
     */
    onUnselect: function (canvas, figure) {
        this._super(canvas, figure);
    },


    /**
     * @method
     * Callback if the figure has been moved. In this case we must update the position of the
     * resize handles and the "ant" box.
     *
     * @param figure
     *
     * @template
     */
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }

        var objHeight = figure.getHeight();
        var objWidth = figure.getWidth();
        var xPos = figure.getX();
        var yPos = figure.getY();

        var r1 = figure.selectionHandles.get(0);
        var r3 = figure.selectionHandles.get(2);
        var r5 = figure.selectionHandles.get(4);
        var r7 = figure.selectionHandles.get(6);
        r1.setPosition(xPos - r1.getWidth(), yPos - r1.getHeight());
        r3.setPosition(xPos + objWidth, yPos - r3.getHeight());
        r5.setPosition(xPos + objWidth, yPos + objHeight);
        r7.setPosition(xPos - r7.getWidth(), yPos + objHeight);

        if (!figure.getKeepAspectRatio()) {
            var r2 = figure.selectionHandles.get(1);
            var r4 = figure.selectionHandles.get(3);
            var r6 = figure.selectionHandles.get(5);
            var r8 = figure.selectionHandles.get(7);

            r2.setPosition(xPos + (objWidth / 2) - (r2.getWidth() / 2), yPos - r2.getHeight());
            r4.setPosition(xPos + objWidth, yPos + (objHeight / 2) - (r4.getHeight() / 2));
            r6.setPosition(xPos + (objWidth / 2) - (r6.getWidth() / 2), yPos + objHeight);
            r8.setPosition(xPos - r8.getWidth(), yPos + (objHeight / 2) - (r8.getHeight() / 2));
        }
        var box = figure.selectionHandles.get(8);
        box.setPosition(figure.getPosition().translate(-2, -2));
        box.setDimension(figure.getWidth() + 4, figure.getHeight() + 4);
        box.setRotationAngle(figure.getRotationAngle());
    }


});


/**
 * @class draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy
 *
 * See the example:
 *
 *     @example preview small frame
 *       circle =new draw2d.shape.basic.Circle();
 *       circle.installEditPolicy(new draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy());
 *       canvas.add(circle,90,50);
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy = draw2d.policy.figure.RectangleSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {

        this._super(canvas, figure, isPrimarySelection);

        if (!figure.selectionHandles.isEmpty()) {
            figure.selectionHandles.each(function (i, e) {
                e.setDimension(15, 15);
            });
        }
        this.moved(canvas, figure);
    }
});


/**
 * @class draw2d.policy.figure.RoundRectangleSelectionFeedbackPolicy
 *
 * See the example:
 *
 *       @example preview small frame
 *       circle =new draw2d.shape.basic.Circle();
 *       circle.installEditPolicy(new draw2d.policy.RoundRectangleSelectionFeedbackPolicy());
 *       canvas.add(circle,90,50);
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.RectangleSelectionFeedbackPolicy
 */
draw2d.policy.figure.RoundRectangleSelectionFeedbackPolicy = draw2d.policy.figure.RectangleSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.RoundRectangleSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {

        this._super(canvas, figure, isPrimarySelection);

        if (!figure.selectionHandles.isEmpty()) {
            figure.selectionHandles.each(function (i, e) {
                e.setDimension(12, 12);
                e.setRadius(4);
            });
        }
        this.moved(canvas, figure);
    }
});


/**
 * @class draw2d.policy.figure.BusSelectionFeedbackPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.BusSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.BusSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        if (figure.selectionHandles.isEmpty()) {
            var r2 = draw2d.Configuration.factory.createResizeHandle(figure, 2); // 2 = CENTER_TOP
            var r4 = draw2d.Configuration.factory.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
            var r6 = draw2d.Configuration.factory.createResizeHandle(figure, 6); // 6 = CENTER_BOTTOM
            var r8 = draw2d.Configuration.factory.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE

            figure.selectionHandles.add(r2);
            figure.selectionHandles.add(r4);
            figure.selectionHandles.add(r6);
            figure.selectionHandles.add(r8);

            r2.setDraggable(figure.isResizeable());
            r4.setDraggable(figure.isResizeable());
            r6.setDraggable(figure.isResizeable());
            r8.setDraggable(figure.isResizeable());

            r2.show(canvas);
            r4.show(canvas);
            r6.show(canvas);
            r8.show(canvas);
        }
        this.moved(canvas, figure);
    },


    /**
     * @method
     * Callback if the figure has been moved
     *
     * @param figure
     *
     * @template
     */
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }
        var r2 = figure.selectionHandles.get(0);
        var r4 = figure.selectionHandles.get(1);
        var r6 = figure.selectionHandles.get(2);
        var r8 = figure.selectionHandles.get(3);

        var objHeight = figure.getHeight();
        var objWidth = figure.getWidth();

        var xPos = figure.getX();
        var yPos = figure.getY();
        r2.setPosition(xPos + (objWidth / 2) - (r2.getWidth() / 2), yPos - r2.getHeight());
        r4.setPosition(xPos + objWidth, yPos + (objHeight / 2) - (r4.getHeight() / 2));
        r6.setPosition(xPos + (objWidth / 2) - (r6.getWidth() / 2), yPos + objHeight);
        r8.setPosition(xPos - r8.getWidth(), yPos + (objHeight / 2) - (r8.getHeight() / 2));
    }


});


/**
 * @class draw2d.policy.figure.WidthSelectionFeedbackPolicy
 * This selection shows only selection handles for the width. It is only possible to change the width
 * of an shaped. The height stays always the same or is recalculated by the figure itself.
 *
 *     @example preview small frame
 *
 *
 *       // add some demo figure to the canvas
 *       //
 *       var shape =new draw2d.shape.basic.Rectangle({width:50, height:100, x:10, y:30});
 *       canvas.add(shape);
 *
 *       // At this point you can only change the width of the shape
 *       //
 *       shape.installEditPolicy(new draw2d.policy.figure.WidthSelectionFeedbackPolicy());
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.WidthSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.BusSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        if (figure.selectionHandles.isEmpty()) {
            var r4 = draw2d.Configuration.factory.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
            var r8 = draw2d.Configuration.factory.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE

            r4.installEditPolicy(new draw2d.policy.figure.HorizontalEditPolicy());
            r8.installEditPolicy(new draw2d.policy.figure.HorizontalEditPolicy());
            figure.selectionHandles.add(r4);
            figure.selectionHandles.add(r8);

            r4.setDraggable(figure.isResizeable());
            r8.setDraggable(figure.isResizeable());

            r4.show(canvas);
            r8.show(canvas);
        }
        this.moved(canvas, figure);
    },


    /**
     * @method
     * Callback if the figure has been moved
     *
     * @param figure
     *
     * @template
     */
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }
        var r4 = figure.selectionHandles.first();
        var r8 = figure.selectionHandles.last();

        var objWidth = figure.getWidth();

        var xPos = figure.getX();
        var yPos = figure.getY();
        r4.setDimension(r4.getWidth(), figure.getHeight());
        r8.setDimension(r8.getWidth(), figure.getHeight());
        r4.setPosition(xPos + objWidth, yPos);
        r8.setPosition(xPos - r8.getWidth(), yPos);
    }


});


/**
 * @class draw2d.policy.figure.VBusSelectionFeedbackPolicy
 *
 * Selection feedback policy for vertical bus figures.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.BusSelectionFeedbackPolicy
 */
draw2d.policy.figure.VBusSelectionFeedbackPolicy = draw2d.policy.figure.BusSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.VBusSelectionFeedbackPolicy",
    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Callback if the figure has been moved
     *
     * @param figure
     *
     **/
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }
        var r2 = figure.selectionHandles.get(0);
        var r6 = figure.selectionHandles.get(2);
        var objWidth = figure.getWidth();
        // adjust the resize handles on the left/right to the new dimension of the shape
        //
        r2.setDimension(objWidth, r2.getHeight());
        r6.setDimension(objWidth, r6.getHeight());

        this._super(canvas, figure);
    }


});


/**
 * @class draw2d.policy.figure.HBusSelectionFeedbackPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.BusSelectionFeedbackPolicy
 */
draw2d.policy.figure.HBusSelectionFeedbackPolicy = draw2d.policy.figure.BusSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.HBusSelectionFeedbackPolicy",
    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Callback if the figure has been moved
     *
     * @param figure
     *
     * @template
     */
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }
        var r4 = figure.selectionHandles.get(1);
        var r8 = figure.selectionHandles.get(3);

        r4.setDimension(r4.getWidth(), figure.getHeight());
        r8.setDimension(r4.getWidth(), figure.getHeight());

        this._super(canvas, figure);
    }


});


/**
 * @class draw2d.policy.figure.AntSelectionFeedbackPolicy
 *
 * Provide support for selecting and positioning a non-resizable figure.
 * Selection is indicated via rectangular handle that outlines the figure with a 1-pixel black
 * dotted line.
 *
 * See the example:
 *
 *     @example preview small frame
 *       circle =new draw2d.shape.basic.Circle({diameter:50, x:90, y:50});
 *       circle.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
 *       canvas.add(circle);
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.AntSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.AntSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {draw2d.Figure} figure the figure to decorate with a selection feedback
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        if (figure.selectionHandles.isEmpty()) {
            var box = new draw2d.shape.basic.Rectangle();
            box.setBackgroundColor(null);
            box.setDashArray("- ");
            box.setColor("#00bdee");
            box.hide = function () {
                // IMPORTANT
                // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
                // dragDrop operation
                //canvas.resizeHandles.remove(box);
                box.setCanvas(null);
            };
            box.show = function (canvas) {
                box.setCanvas(canvas);
                // IMPORTANT
                // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
                // dragDrop operation
                //canvas.resizeHandles.remove(box);
                //canvas.resizeHandles.add(box);
                box.shape.toFront();
            };
            box.show(canvas);
            figure.selectionHandles.add(box);
        }
        this.moved(canvas, figure);
    },


    /**
     * @method
     * Callback if the figure has been moved
     *
     * @param figure
     *
     * @template
     */
    moved: function (canvas, figure) {
        if (figure.selectionHandles.isEmpty()) {
            return; // silently
        }
        var box = figure.selectionHandles.get(0);
        box.setPosition(figure.getPosition().translate(-2, -2));
        box.setDimension(figure.getWidth() + 4, figure.getHeight() + 4);
        box.setRotationAngle(figure.getRotationAngle());
    }
});

/**
 * @class draw2d.policy.figure.GlowSelectionFeedbackPolicy
 *
 * See the example:
 *
 *     @example preview small frame
 *       circle =new draw2d.shape.basic.Circle();
 *       circle.installEditPolicy(new draw2d.policy.figure.GlowSelectionFeedbackPolicy());
 *       canvas.add(circle,90,50);
 *
 *       canvas.add(new draw2d.shape.basic.Label("Click on the circle to see the selection feedback"),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.GlowSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.GlowSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        figure.setGlow(true);
        this.moved(canvas, figure);
    },


    /**
     * @method
     *
     * @param {draw2d.Figure} figure the unselected figure
     */
    onUnselect: function (canvas, figure) {
        this._super(canvas, figure);
        figure.setGlow(false);
    }

});

/**
 * @class draw2d.policy.figure.SlimSelectionFeedbackPolicy
 * Add only very small resize handles to the figure.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *       circle =new draw2d.shape.basic.Circle();
 *       circle.installEditPolicy(new draw2d.policy.SlimSelectionFeedbackPolicy());
 *       canvas.add(circle,90,50);
 *
 *       canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.RectangleSelectionFeedbackPolicy
 */
draw2d.policy.figure.SlimSelectionFeedbackPolicy = draw2d.policy.figure.RectangleSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.SlimSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {

        this._super(canvas, figure, isPrimarySelection);

        if (!figure.selectionHandles.isEmpty()) {
            // resize the standard resize handles to the half on the normal size
            //
            figure.selectionHandles.each(function (i, e) {
                e.setDimension(6, 6);
                e.setRadius(0);
            });
        }
        this.moved(canvas, figure);
    }
});


/**
 * @class draw2d.policy.figure.VertexSelectionFeedbackPolicy
 *
 * Called by the framework if the user edit the position of a figure with a drag drop operation.
 * Sub class like SelectionEditPolicy or RegionEditPolicy cam adjust th e position of the figure or the selections handles.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.figure.VertexSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.figure.VertexSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     *
     * @template
     * @param {draw2d.Connection} connection the selected figure
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, connection, isPrimarySelection) {
//    	this._super(canvas, connection, isPrimarySelection);

        var points = connection.getVertices();
        for (var i = 0; i < points.getSize(); i++) {
            var handle = new draw2d.shape.basic.VertexResizeHandle(connection, i);
            connection.selectionHandles.add(handle);
            handle.setDraggable(connection.isResizeable());
            handle.show(canvas);

            if (i !== 0) {
                var handle = new draw2d.shape.basic.GhostVertexResizeHandle(connection, i - 1);
                connection.selectionHandles.add(handle);
                handle.setDraggable(connection.isResizeable());
                handle.show(canvas);
            }
        }

        this.moved(canvas, connection);
    },

    /**
     * @method
     * Callback method if the figure has been moved.
     *
     * @template
     */
    moved: function (canvas, figure) {
        figure.selectionHandles.each(function (i, e) {
            e.relocate();
        });
    }


});

/**
 * @class draw2d.policy.line.LineSelectionFeedbackPolicy
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
draw2d.policy.line.LineSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.line.LineSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new selection feedback policy for a line or connection
     */
    init: function () {
        this._super();
    },


    /**
     * @method
     * Called by the framework of the Policy should show a resize handle for the given shape
     *
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {
        if (figure.selectionHandles.isEmpty()) {
            figure.selectionHandles.add(new draw2d.shape.basic.LineStartResizeHandle(figure));
            figure.selectionHandles.add(new draw2d.shape.basic.LineEndResizeHandle(figure));

            figure.selectionHandles.each(function (i, e) {
                e.setDraggable(figure.isResizeable());
                e.show(canvas);
            });
        }
        this.moved(canvas, figure);

        if(this.onSelectCallBack != null) {
            this.onSelectCallBack(canvas, figure, isPrimarySelection);
        }

    },

    /**
     * @method
     * Callback method if the figure has been moved.
     *
     * @template
     */
    moved: function (canvas, figure) {
        figure.selectionHandles.each(function (i, e) {
            e.relocate();
        });
    }

});


/**
 * @class draw2d.policy.line.VertexSelectionFeedbackPolicy
 *
 * Feedback and edit policy for the VertexRouter.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.line.LineSelectionFeedbackPolicy
 */
draw2d.policy.line.VertexSelectionFeedbackPolicy = draw2d.policy.line.LineSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.line.VertexSelectionFeedbackPolicy",

    /**
     * @constructor
     *
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     *
     * @template
     * @param {draw2d.Connection} connection the selected figure
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, figure, isPrimarySelection) {

        var startHandle = new draw2d.shape.basic.LineStartResizeHandle(figure);
        var endHandle = new draw2d.shape.basic.LineEndResizeHandle(figure);
        figure.selectionHandles.add(startHandle);
        figure.selectionHandles.add(endHandle);

        var points = figure.getVertices();
        var count = points.getSize() - 1;
        var i = 1;
        for (; i < count; i++) {
            figure.selectionHandles.add(new draw2d.shape.basic.VertexResizeHandle(figure, i));
            figure.selectionHandles.add(new draw2d.shape.basic.GhostVertexResizeHandle(figure, i - 1));
        }

        figure.selectionHandles.add(new draw2d.shape.basic.GhostVertexResizeHandle(figure, i - 1));

        figure.selectionHandles.each(function (i, e) {
            e.setDraggable(figure.isResizeable());
            e.show(canvas);
        });

        this.moved(canvas, figure);

    }

});

/**
 * @class draw2d.policy.line.OrthogonalSelectionFeedbackPolicy
 *
 * Feedback and edit policy for the InteractiveMannhattanRouter.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.line.LineSelectionFeedbackPolicy
 */
draw2d.policy.line.OrthogonalSelectionFeedbackPolicy = draw2d.policy.line.LineSelectionFeedbackPolicy.extend({

    NAME: "draw2d.policy.line.OrthogonalSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();

        // The ResizeHandle for the Policy. This is inline to avoid that a user want to use them without
        // the right installed policy.
        //
        this.ResizeHandle = draw2d.ResizeHandle.extend({
            NAME: "#ResizeHandle",

            init: function (figure, index) {
                this._super(figure);
                this.index = index;
            },


            /**
             * @method
             * Called if a drag&drop operation starts.<br>
             * @param {Number} x the x-coordinate of the mouse up event
             * @param {Number} y the y-coordinate of the mouse up event
             * @param {Boolean} shiftKey true if the shift key has been pressed during this event
             * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
             *
             * @private
             **/
            onDragStart: function (xs, y, shiftKey, ctrlKey) {
                this._super();
                this.command = this.getCanvas().getCurrentSelection().createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE_VERTICES));

                // Vertex is a reference and not a copy of the point
                this.vertex = this.owner.getVertices().get(this.index).clone();
            },

            /**
             * @method
             * Called from the framework during a drag&drop operation of the ResizeHandles
             *
             * @param {Number} dx the x difference between the start of the drag drop operation and now
             * @param {Number} dy the y difference between the start of the drag drop operation and now
             * @param {Number} dx2 The x diff since the last call of this dragging operation
             * @param {Number} dy2 The y diff since the last call of this dragging operation
             * @return {boolean}
             **/
            onDrag: function (dx, dy, dx2, dy2) {
                if (this.command == null) {
                    return false;
                }

                var fromDir = this.owner.getSource().getConnectionDirection(this.owner, this.owner.getTarget());
                var toDir = this.owner.getTarget().getConnectionDirection(this.owner, this.owner.getSource());

                this.vertex.translate(dx2, dy2);

                var vertices = this.owner.getVertices();
                var count = vertices.getSize();
                //shortcut for math operations
                var max = Math.max;
                var min = Math.min;


                // Keep in mind: "p1" is always the dragged handle in the coding below
                //               marked with an '*' in the diagram
                //

                // FIRST handle of the connection
                //
                if (this.index === 1) {
                    var p0 = vertices.get(this.index - 1); // first vertex of the connection
                    var p1 = vertices.get(this.index); // dragged vertex
                    var p2 = vertices.get(this.index + 1); // additional neighbor

                    // vertex alignment to handle:
                    //
                    //      p0 +-----* p1       p1 *------+ p0
                    //               |             |
                    //               |             |
                    //               + p2       p2 +
                    if ((p1.x == p2.x) && (p0.y == p1.y)) {
                        switch (fromDir) {
                            case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                                // p0 is on the left of p1
                                //
                                this.owner.setVertex(1, max(p0.x + 10, this.vertex.x), p1.y); // p1
                                this.owner.setVertex(2, max(p0.x + 10, this.vertex.x), p2.y); // p2
                                break;
                            // p0 is on the right of p2
                            //
                            case draw2d.geo.Rectangle.DIRECTION_LEFT:
                                this.owner.setVertex(1, min(p0.x - 10, this.vertex.x), p1.y); // p1
                                this.owner.setVertex(2, min(p0.x - 10, this.vertex.x), p2.y); // p2
                                break;
                        }
                    }

                    // vertices alignment to handle:
                    //
                    //      p0 +              p1 *--------+ p2
                    //         |                 |
                    //         |                 |
                    //      p1 *-----+ p2     p0 +
                    else {
                        switch (fromDir) {
                            case draw2d.geo.Rectangle.DIRECTION_UP:
                                // p0 is below of p1
                                //
                                this.owner.setVertex(1, p1.x, min(p0.y - 10, this.vertex.y)); // p1
                                this.owner.setVertex(2, p2.x, min(p0.y - 10, this.vertex.y)); // p2
                                break;
                            // p0 is above of p2
                            //
                            case draw2d.geo.Rectangle.DIRECTION_DOWN:
                                this.owner.setVertex(1, p1.x, max(p0.y + 10, this.vertex.y)); // p1
                                this.owner.setVertex(2, p2.x, max(p0.y + 10, this.vertex.y)); // p2
                                break;
                        }
                    }
                }

                // LAST handle: Only the left hand side sibling can be changed
                //
                else if (this.index === (count - 2)) {
                    var p2 = vertices.get(this.index - 1);  // neighbor of the dragged vertex
                    var p1 = vertices.get(this.index);  // dragged vertex
                    var p0 = vertices.get(this.index + 1);  // last vertex of the connection

                    // vertices with this alignment.
                    //
                    //      p2 +-----* p1                 + p0
                    //               |                    |
                    //               |                    |
                    //               + p0     p2 +--------* p1
                    if ((p0.x === p1.x) && (p2.y === p1.y)) {
                        switch (toDir) {
                            // p0 is below of p1
                            case draw2d.geo.Rectangle.DIRECTION_UP:
                                this.owner.setVertex(count - 2, p1.x, min(p0.y - 10, this.vertex.y)); // p1
                                this.owner.setVertex(count - 3, p2.x, min(p0.y - 10, this.vertex.y)); // p2
                                break;
                            // p0 is above p2
                            case draw2d.geo.Rectangle.DIRECTION_DOWN:
                                this.owner.setVertex(count - 2, p1.x, max(p0.y + 10, this.vertex.y)); // p1
                                this.owner.setVertex(count - 3, p2.x, max(p0.y + 10, this.vertex.y)); // p2
                                break;
                        }
                    }

                    // vertices with this alignment.
                    //
                    //      p2 +              p0 +--------* p1
                    //         |                          |
                    //         |                          |
                    //      p1 *-----+ p0              p2 +
                    else {
                        switch (toDir) {
                            case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                                // p0 is on the left of p1
                                //
                                this.owner.setVertex(count - 2, max(p0.x + 10, this.vertex.x), p1.y); // p1
                                this.owner.setVertex(count - 3, max(p0.x + 10, this.vertex.x), p2.y); // p2
                                break;
                            // p0 is on the right of p2
                            //
                            case draw2d.geo.Rectangle.DIRECTION_LEFT:
                                this.owner.setVertex(count - 2, min(p0.x - 10, this.vertex.x), p1.y); // p1
                                this.owner.setVertex(count - 3, min(p0.x - 10, this.vertex.x), p2.y); // p2
                                break;
                        }
                    }
                }
                // The resize handle is in the middle of the connection.
                // -> In this case the connection MUST HAVE at least 5 vertices
                //
                else {
                    var p_m1 = vertices.get(this.index - 2);
                    var p0 = vertices.get(this.index - 1);
                    var p1 = vertices.get(this.index);
                    var p2 = vertices.get(this.index + 1);
                    var p3 = vertices.get(this.index + 2);

                    // vertices alignment to handle
                    //
                    //               .              .
                    //               .              .
                    //   p1 *------->+  p0      p0  +<---------* p1
                    //      |        .              .          |
                    //      |        .              .          |
                    //   p2 |                                  | p2
                    //   ...+...                         ......+.....
                    //
                    if ((p1.x === p2.x) && (p1.y === p0.y)) {
                        // Exception handling if the dragged handle (p1) is near by the start of the connection
                        // p_m1 is the start of the connection
                        // p0 must be the immediate neighbor of p_m1
                        //
                        if (this.index - 2 === 0) {
                            switch (fromDir) {
                                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                                    this.owner.setVertex(this.index - 1, p0.x, max(this.vertex.y, p_m1.y - 10));          // p0
                                    this.owner.setVertex(this.index, this.vertex.x, max(this.vertex.y, p_m1.y - 10)); // p1
                                    this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                         // p2
                                    break;
                                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                                    this.owner.setVertex(this.index - 1, p0.x, min(this.vertex.y, p_m1.y + 10));          // p0
                                    this.owner.setVertex(this.index, this.vertex.x, this.vertex.y); // p1
                                    this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                         // p2
                                    break;
                                case draw2d.geo.Rectangle.DIRECTION_UP:
                                    this.owner.setVertex(this.index - 1, p0.x, min(this.vertex.y, p_m1.y - 10));          // p0
                                    this.owner.setVertex(this.index, this.vertex.x, min(this.vertex.y, p_m1.y - 10)); // p1
                                    this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                         // p2
                                    break;
                                case draw2d.geo.Rectangle.DIRECTION_DOWN:
                                    this.owner.setVertex(this.index - 1, p0.x, max(this.vertex.y, p_m1.y + 10));          // p0
                                    this.owner.setVertex(this.index, this.vertex.x, max(this.vertex.y, p_m1.y + 10)); // p1
                                    this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                        // p2
                                    break;
                            }
                        }
                        // Exception handling if the dragged handle (p1L) near by the end of the connection
                        // p3 is the end of the connection
                        //
                        else if ((this.index - count + 3) === 0) {
                            switch (toDir) {
                                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                                    this.owner.setVertex(this.index - 1, p0.x, this.vertex.y);                       // p0
                                    this.owner.setVertex(this.index, max(this.vertex.x, p3.x + 10), this.vertex.y); // p1
                                    this.owner.setVertex(this.index + 1, max(this.vertex.x, p3.x + 10), p2.y);          // p2
                                    break;
                                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                                    this.owner.setVertex(this.index - 1, p0.x, this.vertex.y);                       // p0
                                    this.owner.setVertex(this.index, min(this.vertex.x, p3.x - 10), this.vertex.y); // p1
                                    this.owner.setVertex(this.index + 1, min(this.vertex.x, p3.x - 10), p2.y);          // p2
                                    break;
                            }
                        }
                        else {
                            this.owner.setVertex(this.index - 1, p0.x, this.vertex.y);                          // p0
                            this.owner.setVertex(this.index, this.vertex);                                 // p1
                            this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                          // p2
                        }
                    }
                    // vertices alignment to handle
                    //
                    //  ...+...                            ...+...
                    //  p0 |                        .         | p0
                    //     |          .             .         |
                    //     |          .             .         |
                    //  p1 *----------+ p2      p2  +---------* p1
                    //                .             .
                    //                .             .
                    else if ((p0.x === p1.x) && (p1.y === p2.y)) {
                        // p_m1 is the start of the analyzed segment
                        // p0 must be the immediate neighbor of p_m1
                        //
                        if (this.index - 2 === 0) {
                            switch (fromDir) {
                                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                                    this.owner.setVertex(this.index - 1, max(this.vertex.x, p_m1.x + 10), p0.y);          // p0
                                    this.owner.setVertex(this.index, max(this.vertex.x, p_m1.x + 10), this.vertex.y); // p1
                                    this.owner.setVertex(this.index + 1, p2.x, this.vertex.y);                         // p2
                                    break;
                                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                                    this.owner.setVertex(this.index - 1, min(this.vertex.x, p_m1.x - 10), p0.y);          // p0
                                    this.owner.setVertex(this.index, min(this.vertex.x, p_m1.x - 10), this.vertex.y); // p1
                                    this.owner.setVertex(this.index + 1, p2.x, this.vertex.y);                         // p2
                                    break;
                            }
                        }
                        // p3 ist der Endpunkt
                        //
                        else if ((this.index - count + 3) === 0) {
                            switch (toDir) {
                                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                                    this.owner.setVertex(this.index - 1, p0.x, min(this.vertex.y, p3.y + 10));            // p0
                                    this.owner.setVertex(this.index, this.vertex.x, min(this.vertex.y, p3.y + 10));   // p1
                                    this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                         // p2
                                    break;
                                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                                    this.owner.setVertex(this.index - 1, p0.x, max(this.vertex.y, p3.y - 10));            // p0
                                    this.owner.setVertex(this.index, this.vertex.x, max(this.vertex.y, p3.y - 10));   // p1
                                    this.owner.setVertex(this.index + 1, this.vertex.x, p2.y);                         // p2
                                    break;
                            }
                        }
                        else {
                            this.owner.setVertex(this.index - 1, this.vertex.x, p0.y);                            // p0
                            this.owner.setVertex(this.index, this.vertex);                                   // p1
                            this.owner.setVertex(this.index + 1, p2.x, this.vertex.y);                            // p2
                        }
                    }
                }

                this.relocate();

                // update the command for the undo/redo stuff
                //
                if (this.command !== null) {
                    this.command.updateVertices(this.owner.getVertices().clone());
                }

                // note that the user has changed the routing manually.
                // This skips the automatic routing.
                this.owner._routingMetaData.routedByUserInteraction = true;
                return true;
            },

            /**
             * @method Called after a drag and drop action.<br>
             *         Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
             *
             * @param {Number} x the x-coordinate of the mouse event
             * @param {Number} y the y-coordinate of the mouse event
             * @param {Boolean} shiftKey true if the shift key has been pressed during this event
             * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
             *
             * @return {boolean}
             */
            onDragEnd: function (x, y, shiftKey, ctrlKey) {
                var stack = this.getCanvas().getCommandStack();

                stack.execute(this.command);
                this.command = null;

                return true;
            },


            /**
             * @method
             * Controls the location of the resize handle
             *
             * @template
             **/
            relocate: function () {

                var resizeWidthHalf = this.getWidth() / 2;
                var resizeHeightHalf = this.getHeight() / 2;

                var anchor = this.owner.getVertices().get(this.index);
                if (anchor)
                    this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);
            }

        });
    },


    /**
     * @method
     *
     * @template
     * @param {draw2d.Connection} connection the selected figure
     * @param {boolean} isPrimarySelection
     */
    onSelect: function (canvas, connection, isPrimarySelection) {
        this._super(canvas, connection, isPrimarySelection);

        var points = connection.getVertices();
        var i = 1;
        for (; i < (points.getSize() - 1); i++) {
            var handle = new this.ResizeHandle(connection, i);
            connection.selectionHandles.add(handle);
            handle.setDraggable(connection.isResizeable());
            handle.show(canvas);
        }

        this.moved(canvas, connection);
        console.log("selected");

    },


    /**
     * @method
     * remove the segment with the given index.
     * You must check if it possible to remove the segment before. The method didn'T do any consistency checks.
     *
     * @param conn
     * @param segmentIndex
     */
    removeSegment: function (conn, segmentIndex) {
        var PADDING = 10;

        var segmentCount = conn.getVertices().getSize() - 1;

        var fromPt = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection(conn, conn.getTarget());

        var toPt = conn.getEndPoint();
        var toDir = conn.getTarget().getConnectionDirection(conn, conn.getSource());

        var p0 = conn.getVertex(segmentIndex - 1);
        var p1 = conn.getVertex(segmentIndex);
        var p2 = conn.getVertex(segmentIndex + 1);
        var p3 = conn.getVertex(segmentIndex + 2);

        //                                             p0 .
        // Es wird ein Horizontales Segment               .
        // geloescht. Es muessen somit die Punkte         .
        // p0 und p3 neu gesetzt werden.               p1 +------*-----+ p2
        // Ihre neue X-Koordinate ist somit in der               ^     .
        // Mitte des geloeschten Segmentes                      newX   .
        //                                                             . p3
        //
        if (p1.y === p2.y) {
            var newX = (p1.x + p2.x) / 2;
            // Die neue X-Koordinate muss auf jeden Falls zwischen p-1 und p4 liegen
            //
            if (segmentIndex === 1) {
                if (fromDir === draw2d.geo.Rectangle.DIRECTION_RIGHT) {
                    newX = Math.max(newX, fromPt.x + PADDING);
                }
                else if (fromDir === draw2d.geo.Rectangle.DIRECTION_LEFT) {
                    newX = Math.min(newX, fromPt.x - PADDING);
                }
            }

            if (segmentIndex === segmentCount - 2) {
                if (toDir === draw2d.geo.Rectangle.DIRECTION_RIGHT) {
                    newX = Math.max(newX, toPt.x + PADDING);
                }
                else if (toDir === draw2d.geo.Rectangle.DIRECTION_LEFT) {
                    newX = Math.min(newX, toPt.x - PADDING);
                }
            }

            conn.setVertex(segmentIndex - 1, new draw2d.geo.Point(newX, p0.y));
            conn.setVertex(segmentIndex + 2, new draw2d.geo.Point(newX, p3.y));

            conn.removeVertexAt(segmentIndex);
            conn.removeVertexAt(segmentIndex);
            conn._routingMetaData.routedByUserInteraction = true;
        }

        //                                                         p2       p3
        // Es wird ein vertikales Segment                        +..........+
        // geloescht. Es muessen somit die Punkte                |
        // p0 und p3 neu gesetzt werden.                         |
        // Ihre neue Y-Koordinate ist somit in der               |
        // Mitte des geloeschten Segmentes              p0       | p1
        //                                              +........+
        //
        else if (p1.x === p2.x) {
            var newY = (p1.y + p2.y) / 2;
            // Die neue Y-Koordinate muss auf jeden Falls zwischen p-1 und p4 liegen
            //
            if (segmentIndex === 1) {
                if (fromDir === draw2d.geo.Rectangle.DIRECTION_RIGHT) {
                    newY = fromPt.y;
                }
                else if (fromDir === draw2d.geo.Rectangle.DIRECTION_LEFT) {
                    newY = fromPt.y;
                }
            }

            if (segmentIndex === segmentCount - 2) {
                if (toDir === draw2d.geo.Rectangle.DIRECTION_RIGHT) {
                    newY = toPt.y;
                }
                else if (toDir === draw2d.geo.Rectangle.DIRECTION_LEFT) {
                    newY = toPt.y;
                }
            }

            conn.setVertex(segmentIndex - 1, new draw2d.geo.Point(p0.x, newY));
            conn.setVertex(segmentIndex + 2, new draw2d.geo.Point(p3.x, newY));

            conn.removeVertexAt(segmentIndex);
            conn.removeVertexAt(segmentIndex);
            conn._routingMetaData.routedByUserInteraction = true;
        }
    },


    /**
     * @method
     * split the segment with the given index and insert a new segment.
     *
     * @param conn
     * @param segmentIndex
     */
    splitSegment: function (conn, segmentIndex, x, y) {
        var segmentCount = conn.getVertices().getSize() - 1;
        var p1 = conn.getVertex(segmentIndex);
        var p2 = conn.getVertex(segmentIndex + 1);
        var length = 40;

        // the selected segment is vertical
        //
        if (p1.x == p2.x) {
            conn._routingMetaData.routedByUserInteraction = true;
            // edge case of an ManhattanRouter: One segment. This happens if the source/target on the same x - coordinate
            //
            if (segmentCount === 1) {
                //     + p1
                //     |
                // np1 +-----+ np2
                //           |
                //           |
                // np3 +-----+ np3
                //     |
                //     |
                //     + p2
                //
                var newSegLength = (p1.getDistance(p2) / 4) / 2;
                var np1 = new draw2d.geo.Point(p1.x, y - newSegLength);
                var np2 = new draw2d.geo.Point(p2.x + length, y - newSegLength);
                var np3 = new draw2d.geo.Point(p2.x + length, y + newSegLength);
                var np4 = new draw2d.geo.Point(p2.x, y + newSegLength);

                conn.insertVertexAt(segmentIndex + 1, np1);
                conn.insertVertexAt(segmentIndex + 2, np2);
                conn.insertVertexAt(segmentIndex + 3, np3);
                conn.insertVertexAt(segmentIndex + 4, np4);
            }
            else {
                //       p2 +
                //          .
                // np1 +----+ np2
                //     .
                //     .
                //     + p1
                var np1 = new draw2d.geo.Point(p1.x - (length / 2), y);
                var np2 = new draw2d.geo.Point(p2.x + (length / 2), y);

                conn.setVertex(segmentIndex, new draw2d.geo.Point(np1.x, p1.y));
                conn.setVertex(segmentIndex + 1, new draw2d.geo.Point(np2.x, p2.y));
                conn.insertVertexAt(segmentIndex + 1, np1);
                conn.insertVertexAt(segmentIndex + 2, np2);
            }
        }
        // the selected segment is horizontal
        //
        else if (p1.y == p2.y) {
            conn._routingMetaData.routedByUserInteraction = true;
            // edge case of an ManhattanRouter: One segment. This happens if the source/target on the same y - coordinate
            //
            if (segmentCount === 1) {
                //     np2 +---------+ np3
                //         |         |
                // --------+np1   np4+--------
                //
                var newSegLength = (p1.getDistance(p2) / 4) / 2;
                var np1 = new draw2d.geo.Point(x - newSegLength, p1.y);
                var np2 = new draw2d.geo.Point(x - newSegLength, p1.y - length);
                var np3 = new draw2d.geo.Point(x + newSegLength, p1.y - length);
                var np4 = new draw2d.geo.Point(x + newSegLength, p1.y);

                conn.insertVertexAt(segmentIndex + 1, np1);
                conn.insertVertexAt(segmentIndex + 2, np2);
                conn.insertVertexAt(segmentIndex + 3, np3);
                conn.insertVertexAt(segmentIndex + 4, np4);
            }
            else {
                //     p1        np1
                //   +.........+
                //             |
                //             |
                //             | np2       p2
                //             +.........+
                var np1 = new draw2d.geo.Point(0, 0);
                var np2 = new draw2d.geo.Point(0, 0);

                // p1 ist der Startpunkt und darf somit nicht verschoben werden
                //
                if (segmentIndex === 0) {
                    np1.x = x;
                    np1.y = p1.y;
                    np2.x = x;
                    np2.y = p2.y + length;
                    conn.setVertex(segmentIndex + 1, new draw2d.geo.Point(p2.x, np2.y));
                }
                // p2 ist der Schlusspunkt und darf somit nicht veaendert werden
                //
                else if (segmentIndex === segmentCount - 1) {
                    np1.x = x;
                    np1.y = p1.y - length;
                    np2.x = x;
                    np2.y = p2.y;
                    conn.setVertex(segmentIndex, new draw2d.geo.Point(p1.x, np1.y));
                }
                else {
                    np1.x = x;
                    np1.y = p1.y - (length / 2);
                    np2.x = x;
                    np2.y = p2.y + (length / 2);
                    conn.setVertex(segmentIndex, new draw2d.geo.Point(p1.x, np1.y));
                    conn.setVertex(segmentIndex + 1, new draw2d.geo.Point(p2.x, np2.y));
                }
                conn.insertVertexAt(segmentIndex + 1, np1);
                conn.insertVertexAt(segmentIndex + 2, np2);
            }
        }
    },

    /**
     * @method
     * Called if the user press the right mouse on the figure.<br>
     * You can either override the "onContextMenu" method of the figure or install an editor policy and override this method.
     * Booth is valid and possible.
     *
     * @param {draw2d.shape.basic.Line} conn the polyline below the mouse
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     * @since 4.4.0
     */
    onRightMouseDown: function (conn, x, y, shiftKey, ctrlKey) {
        var segment = conn.hitSegment(x, y);
        var items = {"split": {name: draw2d.Configuration.i18n.menu.addSegment}};

        if (segment === null) {
            return;
        }

        if (conn.getRouter().canRemoveSegmentAt(conn, segment.index)) {
            items.remove = {name: draw2d.Configuration.i18n.menu.deleteSegment};
        }

        $.contextMenu({
            selector: 'body',
            events: {
                hide: function () {
                    $.contextMenu('destroy');
                }
            },
            callback: $.proxy(function (key, options) {
                switch (key) {
                    case "remove":
                        // deep copy of the vertices of the connection for the command stack to avoid side effects
                        var originalVertices = conn.getVertices().clone(true);
                        this.removeSegment(conn, segment.index);
                        var newVertices = conn.getVertices().clone(true);
                        conn.getCanvas().getCommandStack().execute(new draw2d.command.CommandReplaceVertices(conn, originalVertices, newVertices));
                        break;
                    case "split":
                        // deep copy of the vertices of the connection for the command stack to avoid side effects
                        var originalVertices = conn.getVertices().clone(true);
                        this.splitSegment(conn, segment.index, x, y);
                        var newVertices = conn.getVertices().clone(true);
                        conn.getCanvas().getCommandStack().execute(new draw2d.command.CommandReplaceVertices(conn, originalVertices, newVertices));
                        break;
                    default:
                        break;
                }

            }, this),
            x: x,
            y: y,
            items: items
        });
    }


});

/**
 * @class draw2d.policy.port.PortFeedbackPolicy
 *
 * A draw2d.policy.SelectionFeedbackPolicy that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.port.PortFeedbackPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({


    NAME: "draw2d.policy.port.PortFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
    },

    /**
     * @method
     * Called if the dragged port hove another port
     *
     * @param {draw2d.Canvas} canvas
     * @param {draw2d.Port}   draggedFigure
     * @param {draw2d.Figure} hoverFigure
     */
    onHoverEnter: function (canvas, draggedFigure, hoverFigure) {

    },

    onHoverLeave: function (canvas, draggedFigure, hoverFigure) {
    }


});


/**
 * @class draw2d.policy.port.ElasticStrapFeedbackPolicy
 *
 * A draw2d.policy.SelectionFeedbackPolicy that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.port.ElasticStrapFeedbackPolicy = draw2d.policy.port.PortFeedbackPolicy.extend({

    NAME: "draw2d.policy.port.ElasticStrapFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
        this.connectionLine = null;
    },

    /**
     * @method
     * Called by the framework if the related shape has init a drag&drop
     * operation
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onDragStart: function (canvas, figure, x, y, shiftKey, ctrlKey) {
        this.connectionLine = new draw2d.shape.basic.Line();
        this.connectionLine.setCanvas(canvas);
        this.connectionLine.getShapeElement();

        this.onDrag(canvas, figure);
    },


    /**
     * @method
     * Called by the framework during drag a figure.
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @template
     */
    onDrag: function (canvas, figure) {
        var x1 = figure.ox + figure.getParent().getAbsoluteX();
        var y1 = figure.oy + figure.getParent().getAbsoluteY();

        this.connectionLine.setStartPoint(x1, y1);
        this.connectionLine.setEndPoint(figure.getAbsoluteX(), figure.getAbsoluteY());
    },

    /**
     * @method
     * Called by the framework if the drag drop operation ends.
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onDragEnd: function (canvas, figure, x, y, shiftKey, ctrlKey) {
        this.connectionLine.setCanvas(null);
        this.connectionLine = null;
    },

    onHoverEnter: function (canvas, draggedFigure, hoverFiger) {
        this.connectionLine.setGlow(true);
        hoverFiger.setGlow(true);
    },

    onHoverLeave: function (canvas, draggedFigure, hoverFiger) {
        hoverFiger.setGlow(false);
        this.connectionLine.setGlow(false);
    }


});


/**
 * @class draw2d.policy.port.IntrusivePortsFeedbackPolicy
 *
 * A draw2d.policy.SelectionFeedbackPolicy that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
draw2d.policy.port.IntrusivePortsFeedbackPolicy = draw2d.policy.port.PortFeedbackPolicy.extend({

    NAME: "draw2d.policy.port.IntrusivePortsFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object
     */
    init: function () {
        this._super();
        this.connectionLine = null;
        this.tweenable = null;
    },

    /**
     * @method
     * Called by the framework if the related shape has init a drag&drop
     * operation
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onDragStart: function (canvas, figure, x, y, shiftKey, ctrlKey) {
        var start = 0;
        var allPorts = canvas.getAllPorts().clone();
        allPorts.each(function (i, element) {
            element.__beforeInflate = element.getWidth();
            start = element.__beforeInflate;
        });

        // animate the resize of the ports
        //
        allPorts.grep(function (p) {
            return (p.NAME != figure.NAME && p.parent !== figure.parent) || (p instanceof draw2d.HybridPort) || (figure instanceof draw2d.HybridPort);
        });
        this.tweenable = new Tweenable();
        this.tweenable.tween({
            from: {'size': start / 2},
            to: {'size': start},
            duration: 200,
            easing: "easeOutSine",
            step: function (params) {
                allPorts.each(function (i, element) {
                    // IMPORTANT shortcut to avoid rendering errors!!
                    // performance shortcut to avoid a lot of events and recalculate/routing of all related connections
                    // for each setDimension call. Additional the connection is following a port during Drag&Drop operation
                    element.shape.attr({rx: params.size, ry: params.size});
                    element.width = element.height = params.size * 2;
                    //element.setDimension(params.size, params.size);
                });
            }
        });

        this.connectionLine = new draw2d.shape.basic.Line();
        this.connectionLine.setCanvas(canvas);
        this.connectionLine.getShapeElement();
        this.connectionLine.setDashArray("- ");
        this.connectionLine.setColor("#30c48a");

        this.onDrag(canvas, figure);
    },


    /**
     * @method
     * Called by the framework during drag a figure.
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @template
     */
    onDrag: function (canvas, figure) {
        var x1 = figure.ox + figure.getParent().getAbsoluteX();
        var y1 = figure.oy + figure.getParent().getAbsoluteY();

        this.connectionLine.setStartPoint(x1, y1);
        this.connectionLine.setEndPoint(figure.getAbsoluteX(), figure.getAbsoluteY());
    },

    /**
     * @method
     * Called by the framework if the drag drop operation ends.
     *
     * @param {draw2d.Canvas} canvas The host canvas
     * @param {draw2d.Figure} figure The related figure
     * @template
     */
    onDragEnd: function (canvas, figure, x, y, shiftKey, ctrlKey) {
        this.tweenable.stop(false);
        this.tweenable = null;
        canvas.getAllPorts().each(function (i, element) {
            // IMPORTANT shortcut to avoid rendering errors!!
            // performance shortcut to avoid a lot of events and recalculate/routing of all related connections
            // for each setDimension call. Additional the connection is following a port during Drag&Drop operation
            element.shape.attr({rx: element.__beforeInflate / 2, ry: element.__beforeInflate / 2});
            element.width = element.height = element.__beforeInflate;
            //element.setDimension(element.__beforeInflate, element.__beforeInflate);
        });
        this.connectionLine.setCanvas(null);
        this.connectionLine = null;
    },

    onHoverEnter: function (canvas, draggedFigure, hoverFiger) {
        this.connectionLine.setGlow(true);
        hoverFiger.setGlow(true);
    },

    onHoverLeave: function (canvas, draggedFigure, hoverFiger) {
        hoverFiger.setGlow(false);
        this.connectionLine.setGlow(false);
    }


});

draw2d.Configuration = {
    version: "5.2.0",
    i18n: {
        command: {
            move: "Move Shape",
            assignShape: "Add Shapes to Composite",
            groupShapes: "Group Shapes",
            ungroupShapes: "Ungroup Shapes",
            deleteShape: "Delete Shape",
            moveShape: "Move Shape",
            moveLine: "Move Line",
            addShape: "Add Shape",
            moveVertex: "Move Vertex",
            moveVertices: "Move Vertices",
            deleteVertex: "Delete Vertex",
            resizeShape: "Resize Shape",
            collection: "Execute Commands",
            addVertex: "Add Vertex",
            connectPorts: "Connect Ports"
        },
        menu: {
            deleteSegment: "Delete Segment",
            addSegment: "Add Segment"
        },
        dialog: {
            filenamePrompt: "Enter Filename:"
        }
    },

    factory: {
        // all selection policies calles this method to create a ResizeHandle.
        // It is possible to replace this method with a custom implementation
        // @since 5.2.0
        createResizeHandle: function (forShape, type) {
            return new draw2d.ResizeHandle(forShape, type);
        }
    }
};

/**
 * @class draw2d.Canvas
 * Interactive paint area of the draw2d library.
 * <br>
 * <strong>Usage</strong>
 *
 *
 *      $(window).load(function () {
 *
 *          var canvas = new draw2d.Canvas("gfx_holder");
 *
 *          var figure1 = new draw2d.shape.basic.Oval();
 *          var figure2 = new draw2d.shape.basic.Rectangle();
 *          canvas.add(figure1,100,100);
 *          canvas.add(figure2,120,150);
 *      });
 *
 *
 * @inheritable
 * @author Andreas Herz
 */
draw2d.Canvas = Class.extend(
    {
        NAME: "draw2d.Canvas",

        /**
         * @constructor
         * Create a new canvas with the given HTML DOM references.
         *
         * @param {String} canvasId the id of the DOM element to use a parent container
         */
        init: function (canvasId, width, height) {
            var _this = this;
            // Hook the canvas calculation for IE8
            //
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent;
                var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null) {
                    rv = parseInt(RegExp.$1);
                    if (rv === 8) {
                        this.fromDocumentToCanvasCoordinate = this._fromDocumentToCanvasCoordinate_IE8_HACK;
                    }
                }
            }

            this.setScrollArea(document.body);
            this.canvasId = canvasId;
            this.html = $("#" + canvasId);
            this.html.css({"cursor": "default"});
            if (typeof width !== "undefined") {
                this.initialWidth = width;
                this.initialHeight = height;
            }
            else {
                this.initialWidth = this.getWidth();
                this.initialHeight = this.getHeight();
            }

            // avoid the "highlighting" in iPad, iPhone if the user tab/touch on the canvas.
            // .... I don't like this.
            this.html.css({"-webkit-tap-highlight-color": "rgba(0,0,0,0)"});

            // Drag&Drop Handling from foreign DIV into the Canvas
            // Only available in combination with jQuery-UI
            //
            // Create the droppable area for the css class "draw2d_droppable"
            // This can be done by a palette of toolbar or something else.
            // For more information see : http://jqueryui.com/demos/droppable/
            //
            if (typeof this.html.droppable !== "undefined") {
                this.html.droppable({
                    accept: '.draw2d_droppable',
                    over: function (event, ui) {
                        _this.onDragEnter(ui.draggable);
                    },
                    out: function (event, ui) {
                        _this.onDragLeave(ui.draggable);
                    },
                    drop: function (event, ui) {
                        event = _this._getEvent(event);
                        var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                        _this.onDrop(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
                    }
                });

                // Create the jQuery-Draggable for the palette -> canvas drag&drop interaction
                //
                $(".draw2d_droppable").draggable({
                    appendTo: "body",
                    stack: "body",
                    zIndex: 27000,
                    helper: "clone",
                    drag: function (event, ui) {
                        event = _this._getEvent(event);
                        var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                        _this.onDrag(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
                    },
                    stop: function (e, ui) {
                    },
                    start: function (e, ui) {
                        $(ui.helper).addClass("shadow");
                    }
                });
            }

            // painting stuff
            //
            if (typeof height !== "undefined") {
                this.paper = Raphael(canvasId, width, height);
            }
            else {
                this.paper = Raphael(canvasId, this.getWidth(), this.getHeight());
            }
            this.paper.canvas.style.position = "absolute";

            // Status handling
            //
            this.zoomFactor = 1.0; // range [0.001..10]
            this.selection = new draw2d.Selection();
            this.currentDropTarget = null;
            this.currentHoverFigure = null;

            // eventhandling since version 5.0.0
            this.eventSubscriptions = {};

            this.editPolicy = new draw2d.util.ArrayList();

            // internal document with all figures, ports, ....
            //
            this.figures = new draw2d.util.ArrayList();
            this.lines = new draw2d.util.ArrayList(); // crap - why are connections not just figures. Design by accident
            this.commonPorts = new draw2d.util.ArrayList();
            this.dropTargets = new draw2d.util.ArrayList();

            // all visible resize handles which can be drag&drop around. Selection handles like AntRectangleSelectionFeedback
            // are not part of this collection. Required for hitTest only
            this.resizeHandles = new draw2d.util.ArrayList();

            // The CommandStack for undo/redo operations
            //
            this.commandStack = new draw2d.command.CommandStack();

            // INTERSECTION/CROSSING handling for connections and lines
            //
            this.linesToRepaintAfterDragDrop = new draw2d.util.ArrayList();
            this.lineIntersections = new draw2d.util.ArrayList();

            this.installEditPolicy(new draw2d.policy.canvas.DefaultKeyboardPolicy());      // Handles the ke3yboard interaction
            this.installEditPolicy(new draw2d.policy.canvas.BoundingboxSelectionPolicy()); // Responsible for selection handling
            this.installEditPolicy(new draw2d.policy.canvas.ConnectionInterceptorPolicy());// Responsible for port, connection and drop operations

            // Calculate all intersection between the different lines
            //
            this.commandStack.addEventListener(function (event) {
                if (event.isPostChangeEvent() === true) {
                    _this.calculateConnectionIntersection();
                    _this.linesToRepaintAfterDragDrop.each(function (i, line) {
                        line.svgPathString = null;
                        line.repaint();
                    });
                    _this.linesToRepaintAfterDragDrop = new draw2d.util.ArrayList();
                }
            });

            // DragDrop status handling
            //
            this.mouseDown = false;
            this.mouseDownX = 0;
            this.mouseDownY = 0;
            this.mouseDragDiffX = 0;
            this.mouseDragDiffY = 0;

            this.html.bind("mouseup touchend", function (event) {
                if (_this.mouseDown === false) {
                    return;
                }

                event = _this._getEvent(event);
                _this.calculateConnectionIntersection();

                _this.mouseDown = false;
                var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                _this.editPolicy.each(function (i, policy) {
                    policy.onMouseUp(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
                });

                _this.mouseDragDiffX = 0;
                _this.mouseDragDiffY = 0;
            });

            this.html.bind("mousemove touchmove", function (event) {
                event = _this._getEvent(event);
                if (_this.mouseDown === false) {
                    var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    // mouseEnter/mouseLeave events for Figures. Don't use the Raphael or DOM native functions.
                    // Raphael didn't work for Rectangle with transparent fill (events only fired for the border line)
                    // DOM didn't work well for lines. No eclipse area - you must hit the line exact to retrieve the event.
                    // In this case I implement my own stuff...again and again.
                    //
                    // don't break the main event loop if one element fires an error during enter/leave event.
                    try {
                        var hover = _this.getBestFigure(pos.x, pos.y);
                        if (hover !== _this.currentHoverFigure && _this.currentHoverFigure !== null) {
                            _this.currentHoverFigure.onMouseLeave();
                        }
                        if (hover !== _this.currentHoverFigure && hover !== null) {
                            hover.onMouseEnter();
                        }
                        _this.currentHoverFigure = hover;
                    }
                    catch (exc) {
                        // just write it to the console
                        console.log(exc);
                    }

                    _this.editPolicy.each(function (i, policy) {
                        policy.onMouseMove(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
                    });
                }
                else {
                    var diffXAbs = (event.clientX - _this.mouseDownX) * _this.zoomFactor;
                    var diffYAbs = (event.clientY - _this.mouseDownY) * _this.zoomFactor;
                    _this.editPolicy.each(function (i, policy) {
                        policy.onMouseDrag(_this, diffXAbs, diffYAbs, diffXAbs - _this.mouseDragDiffX, diffYAbs - _this.mouseDragDiffY);
                    });
                    _this.mouseDragDiffX = diffXAbs;
                    _this.mouseDragDiffY = diffYAbs;
                }
            });

            this.html.bind("mousedown touchstart", function (event) {
                try {
                    var pos = null;
                    switch (event.which) {
                        case 1: //touch pressed
                        case 0: //Left mouse button pressed
                            event.preventDefault();
                            event = _this._getEvent(event);
                            _this.mouseDownX = event.clientX;
                            _this.mouseDownY = event.clientY;
                            _this.mouseDragDiffX = 0;
                            _this.mouseDragDiffY = 0;
                            pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                            _this.mouseDown = true;
                            _this.editPolicy.each(function (i, policy) {
                                policy.onMouseDown(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
                            });
                            break;
                        case 3: //Right mouse button pressed
                            event.preventDefault();
                            event = _this._getEvent(event);
                            pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                            _this.onRightMouseDown(pos.x, pos.y, event.shiftKey, event.ctrlKey);
                            break;
                        case 2:
                            //Middle mouse button pressed
                            break;
                        default:
                        //You have a strange mouse
                    }
                }
                catch (exc) {
                    console.log(exc);
                }
            });


            // Catch the dblclick and route them to the Canvas hook.
            //
            this.html.bind("dblclick", function (event) {
                event = _this._getEvent(event);

                _this.mouseDownX = event.clientX;
                _this.mouseDownY = event.clientY;
                var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                _this.onDoubleClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
            });


            // Catch the click event and route them to the canvas hook
            //
            this.html.bind("click", function (event) {
                event = _this._getEvent(event);

                // fire only the click event if we didn't move the mouse (drag&drop)
                //
                if (_this.mouseDownX === event.clientX || _this.mouseDownY === event.clientY) {
                    var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    _this.onClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
                }
            });

            // Catch the keyUp and CTRL-key and route them to the Canvas hook.
            //
            this.keyupCallback = function (event) {
                // don't initiate the delete command if the event comes from an INPUT field. In this case the user want delete
                // a character in the input field and not the related shape
                var target = $(event.target);
                if (!target.is("input") && !target.is("textarea")) {
                    _this.editPolicy.each(function (i, policy) {
                        if (policy instanceof draw2d.policy.canvas.KeyboardPolicy) {
                            policy.onKeyUp(_this, event.keyCode, event.shiftKey, event.ctrlKey);
                        }
                    });
                }
            };
            $(document).bind("keyup", this.keyupCallback);

            // Catch the keyDown and CTRL-key and route them to the Canvas hook.
            //
            this.keydownCallback = function (event) {
                // don't initiate the delete command if the event comes from an INPUT field. In this case the user want delete
                // a character in the input field and not the related shape
                var target = $(event.target);
                if (!target.is("input") && !target.is("textarea")) {
                    _this.editPolicy.each(function (i, policy) {
                        if (policy instanceof draw2d.policy.canvas.KeyboardPolicy) {
                            policy.onKeyDown(_this, event.keyCode, event.shiftKey, event.ctrlKey);
                        }
                    });
                }
            };
            $(document).bind("keydown", this.keydownCallback);

        },

        /**
         * @method
         * Call this method if you didn't need the canvas anymore. The method unregister all even handlers
         * and free all resources. The canvas is unusable after this call
         *
         * @since. 4.7.4
         */
        destroy: function () {
            this.clear();
            $(document).unbind("keydown", this.keydownCallback);
            $(document).unbind("keyup", this.keyupCallback);
            // reset the event handlers of the canvas without any notice
            //
            this.eventSubscriptions = {};

            try {
                this.paper.remove();
            } catch (exc) {
                // breaks in some ie7 version....don't care about this because ie7/8 isn't a state of the art browser  ;-)
            }
        },

        /**
         * @method
         * Reset the canvas and delete all model elements.<br>
         * You can now reload another model to the canvas with a {@link draw2d.io.Reader}
         *
         * @since 1.1.0
         */
        clear: function () {
            // notice all listener that the canvas will be cleared
            this.fireEvent("clear");

            var _this = this;

            this.lines.clone().each(function (i, e) {
                _this.remove(e);
            });

            this.figures.clone().each(function (i, e) {
                _this.remove(e);
            });

            this.zoomFactor = 1.0;
            this.selection.clear();
            this.currentDropTarget = null;

            // internal document with all figures, ports, ....
            //
            this.figures = new draw2d.util.ArrayList();
            this.lines = new draw2d.util.ArrayList();
            this.commonPorts = new draw2d.util.ArrayList();
            this.dropTargets = new draw2d.util.ArrayList();

            this.commandStack.markSaveLocation();

            // INTERSECTION/CROSSING handling for connections and lines
            //
            this.linesToRepaintAfterDragDrop = new draw2d.util.ArrayList();
            this.lineIntersections = new draw2d.util.ArrayList();

            // Inform all listener that the selection has been cleanup. Normally this will be done
            // by the edit policies of the canvas..but exceptional this is done in the clear method as well -
            // Design flaw.
            this.fireEvent("select", null);

            return this;
        },

        /**
         * @method
         * Callback for any kind of image export tools to trigger the canvas to hide all unwanted
         * decorations. The method is called e.g. from the draw2d.io.png.Writer
         *
         * @since 4.0.0
         * @template
         */
        hideDecoration: function () {

        },

        /**
         * @method
         * callback method for any image export writer to reactivate the decoration
         * of the canvas. e.g. grids, rulers,...
         *
         *
         * @since 4.0.0
         * @template
         */
        showDecoration: function () {

        },

        /**
         * @method
         * Calculate all connection intersection of the canvas.
         * Required for "bridging" or "crossing decoration"
         *
         * @private
         */
        calculateConnectionIntersection: function () {

            var _this = this;
            this.lineIntersections = new draw2d.util.ArrayList();
            var lines = this.getLines().clone();
            while (lines.getSize() > 0) {
                var l1 = lines.removeElementAt(0);
                lines.each(function (ii, l2) {
                    var partInter = l1.intersection(l2);
                    if (partInter.getSize() > 0) {
                        _this.lineIntersections.add({line: l1, other: l2, intersection: partInter});
                        _this.lineIntersections.add({line: l2, other: l1, intersection: partInter});
                    }
                });
            }

            return this;
        },


        /**
         * @method
         *
         * Install a new selection and edit policy into the canvas
         *
         * @since 2.2.0
         * @param {draw2d.policy.EditPolicy} policy
         */
        installEditPolicy: function (policy) {
            var _this = this;
            // a canvas can handle only one selection policy
            //
            if (policy instanceof draw2d.policy.canvas.SelectionPolicy) {
                // reset old selection before install new selection strategy
                this.getSelection().getAll().each(function (i, figure) {
                    figure.unselect();
                });

                // remove existing selection policy
                this.editPolicy.grep(function (p) {
                    var stay = !(p instanceof draw2d.policy.canvas.SelectionPolicy);
                    if (stay === false) {
                        p.onUninstall(_this);
                    }
                    return stay;
                });
            }
            // only one SnapToXYZ edit policy at once
            else if (policy instanceof draw2d.policy.canvas.SnapToEditPolicy) {
                // remove existing snapTo policy
                this.editPolicy.grep(function (p) {
                    var stay = !(p instanceof draw2d.policy.canvas.SnapToEditPolicy);
                    if (stay === false) {
                        p.onUninstall(_this);
                    }
                    return stay;
                });
            }
            else if (policy instanceof draw2d.policy.canvas.ConnectionInterceptorPolicy) {
                // think about if I allow to install move than one
            }

            policy.onInstall(this);
            this.editPolicy.add(policy);

            return this;
        },

        /**
         * @method
         *
         * UnInstall the selection and edit policy from the canvas.
         *
         * @since 2.2.0
         * @param {draw2d.policy.EditPolicy} policy
         */
        uninstallEditPolicy: function (policy) {
            if (!(policy instanceof draw2d.policy.EditPolicy)) {
                return this; // silently
            }

            // either remove exact the policy instance...
            //
            var removed = this.editPolicy.remove(policy);
            if (removed !== null) {
                removed.onUninstall(this);
            }
            else {
                // ..or all of the same class if the policy isn't installed before
                // With this kind of behaviour it is possible to deinstall all policies with
                // the same class at once
                //
                var _this = this;
                this.editPolicy.grep(function (p) {
                    if (p.NAME === policy.NAME) {
                        p.onUninstall(_this);
                        return false;
                    }
                    return true;
                });
            }
            return this;
        },

        getInterceptorPolicies: function () {
            return this.editPolicy.clone().grep(function (p) {
                return (p instanceof draw2d.policy.canvas.ConnectionInterceptorPolicy);
            });
        },

        /**
         * @method
         * Set the new zoom factor for the canvas. The value must be between [0.01..10]
         *
         *      // you can register an eventhandler if the zoom factor did change
         *      canvas.on("zoom", function(emitterFigure, zoomData){
     *          alert("canvas zoomed to:"+zoomData.factor);
     *      });
         *
         * @param {Number} zoomFactor new zoom factor.
         * @param {boolean} [animated] set it to true for smooth zoom in/out
         */
        setZoom: function (zoomFactor, animated) {
            var _this = this;
            var _zoom = function (z) {
                _this.zoomFactor = Math.min(Math.max(0.01, z), 10);

                var viewBoxWidth = (_this.initialWidth * (_this.zoomFactor)) | 0;
                var viewBoxHeight = (_this.initialHeight * (_this.zoomFactor)) | 0;

                _this.paper.setViewBox(0, 0, viewBoxWidth, viewBoxHeight);

                _this.fireEvent("zoom", {factor: _this.zoomFactor});

                // BUG: raphael didn't handle setViewBox AND setSize correct
//            var paintArea =this.html.children(":first");
//            this.paper.setSize(this.html.width(), this.html.height());

                // didn't work too....   :-(
//            paintArea.width(this.initialWidth * this.zoomFactor);
//            paintArea.height(this.initialHeight * this.zoomFactor);
            };

            if (animated) {
                var myTweenable = new Tweenable();
                myTweenable.tween({
                    from: {'x': this.zoomFactor},
                    to: {'x': zoomFactor},
                    duration: 300,
                    easing: "easeOutSine",
                    step: function (params) {
                        _zoom(params.x);
                    }
                });
            }
            else {
                _zoom(zoomFactor);
            }
        },

        /**
         * @method
         * Return the current zoom factor of the canvas.
         *
         * @returns {Number}
         */
        getZoom: function () {
            return this.zoomFactor;
        },

        /**
         * @method
         * Return the dimension of the drawing area
         *
         * @since 4.4.0
         * @returns {draw2d.geo.Rectangle}
         */
        getDimension: function () {
            return new draw2d.geo.Rectangle(0, 0, this.initialWidth, this.initialHeight);
        },

        /**
         * @method
         * Tells the canvas to resize. If you do not specific any parameters
         * the canvas will attempt to determine the height and width by the enclosing bounding box
         * of all elements and set the dimension accordingly. If you would like to set the dimension
         * explicitly pass in an draw2d.geo.Rectangle or an object with <b>height</b> and <b>width</b> properties.
         *
         * @since 4.4.0
         * @param {draw2d.geo.Rectangle} [dim] the dimension to set or null for autodetect
         */
        setDimension: function (dim) {
            if (typeof dim === "undefined") {
                var widths = this.getFigures().clone().map(function (f) {
                    return f.getAbsoluteX() + f.getWidth();
                });
                var heights = this.getFigures().clone().map(function (f) {
                    return f.getAbsoluteY() + f.getHeight();
                });
                this.initialHeight = Math.max.apply(Math, heights.asArray());
                this.initialWidth = Math.max.apply(Math, widths.asArray());
            }
            else if (dim instanceof draw2d.geo.Rectangle) {
                this.initialWidth = dim.w;
                this.initialHeight = dim.h;
            }
            else if (typeof dim.width === "number" && typeof dim.height === "number") {
                this.initialWidth = dim.width;
                this.initialHeight = dim.height;
            }
            this.html.css({"width": this.initialWidth + "px", "height": this.initialHeight + "px"});
            this.paper.setSize(this.initialWidth, this.initialHeight);
            this.setZoom(this.zoomFactor, false);

            return this;
        },


        /**
         * @method
         * Transforms a document coordinate to canvas coordinate.
         *
         * @param {Number} x the x coordinate relative to the window
         * @param {Number} y the y coordinate relative to the window
         *
         * @returns {draw2d.geo.Point} The coordinate in relation to the canvas [0,0] position
         */
        fromDocumentToCanvasCoordinate: function (x, y) {
            return new draw2d.geo.Point(
                (x - this.getAbsoluteX() + this.getScrollLeft()) * this.zoomFactor,
                (y - this.getAbsoluteY() + this.getScrollTop()) * this.zoomFactor);
        },

        _fromDocumentToCanvasCoordinate_IE8_HACK: function (x, y) {
            return new draw2d.geo.Point(
                (x - this.getAbsoluteX()) * this.zoomFactor,
                (y - this.getAbsoluteY()) * this.zoomFactor);
        },

        /**
         * @method
         * Transforms a canvas coordinate to document coordinate.
         *
         * @param {Number} x the x coordinate in the canvas
         * @param {Number} y the y coordinate in the canvas
         *
         * @returns {draw2d.geo.Point} the coordinate in relation to the document [0,0] position
         */
        fromCanvasToDocumentCoordinate: function (x, y) {
            return new draw2d.geo.Point(
                ((x * (1 / this.zoomFactor)) + this.getAbsoluteX() - this.getScrollLeft()),
                ((y * (1 / this.zoomFactor)) + this.getAbsoluteY() - this.getScrollTop()));
        },

        /**
         * @method
         * The DOM host of the canvas
         *
         * @returns {HTMLElement}
         */
        getHtmlContainer: function () {
            return this.html;
        },


        /**
         * @method
         * Return a common event object independed if we run on an iPad or desktop.
         *
         * @param event
         * @return
         * @private
         */
        _getEvent: function (event) {
            // check for iPad, Android touch events
            //
            if (typeof event.originalEvent !== "undefined") {
                if (event.originalEvent.touches && event.originalEvent.touches.length) {
                    return event.originalEvent.touches[0];
                } else if (event.originalEvent.changedTouches && event.originalEvent.changedTouches.length) {
                    return event.originalEvent.changedTouches[0];
                }
            }
            return event;
        },

        /**
         * @method
         *
         * Set the area which are scrolling the canvas. This can be a jquery selector or
         * a jQuery node.
         *
         * @param {String/HTMLElement} elementSelector
         **/
        setScrollArea: function (elementSelector) {
            this.scrollArea = $(elementSelector);

            return this;
        },

        /**
         * @method
         *
         * return the scrolling area of the canvas. This is jQuery object
         *
         * @return {HTMLElement}
         **/
        getScrollArea: function () {
            return this.scrollArea;
        },

        /**
         * @method
         * The left scroll position.
         *
         * @return {Number} the left scroll offset of the canvas
         **/
        getScrollLeft: function () {
            return this.scrollArea.scrollLeft();
        },

        /**
         * @method
         * The top scroll position
         *
         * @return {Number} the top scroll offset of the cnavas.
         **/
        getScrollTop: function () {
            return this.scrollArea.scrollTop();
        },

        /**
         * @method
         * The absolute document x offset.
         *
         * @return {Number}
         **/
        getAbsoluteX: function () {
            return this.html.offset().left;
        },

        /**
         * @method
         * The absolute document y offset.
         *
         * @return {Number}
         **/
        getAbsoluteY: function () {
            return this.html.offset().top;
        },


        /**
         * @method
         * Return the width of the canvas
         *
         * @return {Number}
         **/
        getWidth: function () {
            return this.html.width();
        },


        /**
         * @method
         * Return the height of the canvas.
         *
         * @return {Number}
         **/
        getHeight: function () {
            return this.html.height();
        },


        /**
         * @method
         * Add a figure at the given x/y coordinate. This method fires an event.
         *
         * Example:
         *
         *      canvas.on("figure:add", function(emitter, event){
     *         alert("figure added:");
     *      });
         *
         *      // or more general if you want catch all figure related events
         *      //
         *      canvas.on("figure", function(emitter, event){
     *         // use event.figure.getCanvas()===null to determine if the
     *         // figure part of the canvas
     *
     *         alert("figure added or removed:");
     *      });
         *
         * @param {draw2d.Figure} figure The figure to add.
         * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure or the x/y coordinate if it is an draw2d.geo.Point
         * @param {Number} [y] The y position.
         **/
        add: function (figure, x, y) {
            if (figure.getCanvas() === this) {
                return;
            }

            if (figure instanceof draw2d.shape.basic.Line) {
                this.lines.add(figure);
                this.linesToRepaintAfterDragDrop = this.lines;
            }
            else {
                this.figures.add(figure);
                if (typeof y !== "undefined") {
                    figure.setPosition(x, y);
                }
                else if (typeof x !== "undefined") {
                    figure.setPosition(x);
                }
            }
            figure.setCanvas(this);

            // important inital call
            figure.getShapeElement();

            // init a repaint of the figure. This enforce that all properties
            // ( color, dim, stroke,...) will be set.
            figure.repaint();
            // fire the figure:add event before the "move" event and after the figure.repaint() call!
            //   - the move event can only be fired if the figure part of the canvas.
            //     and in this case the notification event should be fired to the listener before
            this.fireEvent("figure:add", {figure: figure});

            // ...now we can fire the initial move event
            figure.fireEvent("move");

            return this;
        },

        /**
         * @method
         * Deprecated since version 5.0.0
         * @deprecated use draw2d.Canvas.add() instead
         */
        addFigure: function (figure, x, y) {
            return this.add(figure, x, y);
        },


        /**
         * @method
         * Remove a figure or connection from the Canvas. This method fires an event
         * which can be catched.
         *
         * Example:
         *
         *      canvas.on("figure:remove", function(emitter, event){
     *         alert("figure removed:");
     *      });
         *
         *      // or more general if you want catch all figure related events
         *      //
         *      canvas.on("figure", function(emitter, event){
     *         // use event.figure.getCanvas()===null to determine if the
     *         // figure part of the canvas
     *
     *         alert("figure added or removed:");
     *      });
         *
         *
         * @param {draw2d.Figure} figure The figure to remove
         **/
        remove: function (figure) {
            // remove the figure from a selection handler as well and cleanup the
            // selection feedback
            var _this = this;
            this.editPolicy.each(function (i, policy) {
                if (typeof policy.unselect === "function") {
                    policy.unselect(_this, figure);
                }
            });

            if (figure instanceof draw2d.shape.basic.Line) {
                this.lines.remove(figure);
            }
            else {
                this.figures.remove(figure);
            }
            figure.setCanvas(null);

            if (figure instanceof draw2d.Connection) {
                figure.disconnect();
            }

            this.fireEvent("figure:remove", {figure: figure});

            return this;
        },

        /**
         * @method
         * Deprecated since 5.0.0
         * @deprecated use draw2d.Canvas.remove()
         * @param figure
         */
        removeFigure: function (figure) {
            return this.remove(figure);
        },

        /**
         * @method
         * Returns all lines/connections in this workflow/canvas.<br>
         *
         * @protected
         * @return {draw2d.util.ArrayList}
         **/
        getLines: function () {
            return this.lines;
        },

        /**
         * @method
         * Returns the internal figures.<br>
         *
         * @protected
         * @return {draw2d.util.ArrayList}
         **/
        getFigures: function () {
            return this.figures;
        },

        /**
         * @method
         * Returns the line or connection with the given id.
         *
         * @param {String} id The id of the line.
         *
         * @type draw2d.shape.basic.Line
         **/
        getLine: function (id) {
            var count = this.lines.getSize();
            for (var i = 0; i < count; i++) {
                var line = this.lines.get(i);
                if (line.getId() === id) {
                    return line;
                }
            }
            return null;
        },

        /**
         * @method
         * Returns the figure with the given id.
         *
         * @param {String} id The id of the figure.
         * @return {draw2d.Figure}
         **/
        getFigure: function (id) {
            var figure = null;
            this.figures.each(function (i, e) {
                if (e.id === id) {
                    figure = e;
                    return false;
                }
            });
            return figure;
        },

        /**
         * @method
         * Return all intersections draw2d.geo.Point between the given line and all other
         * lines in the canvas.
         *
         * @param {draw2d.shape.basic.Line} line the line for the intersection test
         * @return {draw2d.util.ArrayList}
         */
        getIntersection: function (line) {
            var result = new draw2d.util.ArrayList();

            this.lineIntersections.each(function (i, entry) {
                if (entry.line === line) {
                    entry.intersection.each(function (i, p) {
                        result.add({x: p.x, y: p.y, justTouching: p.justTouching, other: entry.other});
                    });
                }
            });

            return result;
        },


        /**
         * @method
         *  Adjust the coordinate with the installed SnapToHelper.
         *
         * @param  {draw2d.Figure} figure The related figure
         * @param  {draw2d.geo.Point} pos The position to adjust
         *
         * @return {draw2d.geo.Point} the adjusted position
         * @private
         **/
        snapToHelper: function (figure, pos) {
            var _this = this;
            this.editPolicy.each(function (i, policy) {
                pos = policy.snap(_this, figure, pos);
            });

            return pos;
        },


        /**
         * @method
         * Register a port to the canvas. This is required for other ports to find a valid drop target.
         *
         * @param {draw2d.Port} port The new port which has been added to the Canvas.
         **/
        registerPort: function (port) {
            // All elements have the same drop targets.
            //
            if (!this.commonPorts.contains(port)) {
                this.commonPorts.add(port);
            }

            return this;
        },

        /**
         * @method
         * Remove a port from the internal cnavas registration. Now other ports can't find the
         * port anymore as drop target. The port itself is still visible.
         *
         * @param {draw2d.Port} p The port to unregister as potential drop target
         * @private
         **/
        unregisterPort: function (port) {
            this.commonPorts.remove(port);

            return this;
        },

        /**
         * @method
         * Return all ports in the canvas
         *
         */
        getAllPorts: function () {
            return this.commonPorts;
        },

        /**
         * @method
         * Returns the command stack for the Canvas. Required for undo/redo support.
         *
         * @return {draw2d.command.CommandStack}
         **/
        getCommandStack: function () {
            return this.commandStack;
        },

        /**
         * @method
         * Returns the current selected figure in the Canvas.
         *
         * @return {draw2d.Figure}
         * @deprecated
         **/
        getCurrentSelection: function () {
            return this.selection.getPrimary();
        },

        /**
         * @method
         * Returns the current selection.
         *
         * @return {draw2d.Selection}
         **/
        getSelection: function () {
            return this.selection;
        },

        /**
         * @method
         * Set the current selected figure or figures in the canvas.<br>
         * <br>
         * You can hand over a draw2d.util.ArrayList since version 4.8.0 for multiple selection.
         *
         * @param {draw2d.Figure| draw2d.util.ArrayList} object The figure or list of figures to select.
         **/
        setCurrentSelection: function (object) {
            var _this = this;

            // multiple selection
            if (object instanceof draw2d.util.ArrayList) {
                this.selection.each(function (i, e) {
                    _this.editPolicy.each(function (i, policy) {
                        if (typeof policy.unselect === "function") {
                            policy.unselect(_this, e);
                        }
                    });
                });
                this.addSelection(object);
            }
            // single selection
            else {
                var figure = object;
                this.selection.getAll().each(function (i, e) {
                    _this.editPolicy.each(function (i, policy) {
                        if (typeof policy.unselect === "function") {
                            policy.unselect(_this, e);
                        }
                    });
                });

                this.editPolicy.each(function (i, policy) {
                    if (typeof policy.select === "function") {
                        policy.select(_this, figure);
                    }
                });
            }


            return this;
        },

        /**
         * @method
         * Add the current figure to the selection. If a single selection policy is installed in the
         * canvas the selection before is reseted and the figure is the one and only selection.
         *
         * @param {draw2d.Figure| draw2d.util.ArrayList} object The figure(s) to add to the selection
         * @since 4.6.0
         **/
        addSelection: function (object) {
            var _this = this;

            var add = function (i, figure) {
                _this.editPolicy.each(function (i, policy) {
                    if (typeof policy.select === "function") {
                        policy.select(_this, figure);
                    }
                });
            };

            if (object instanceof draw2d.util.ArrayList) {
                object.each(add);
            }
            else {
                add(0, object);
            }

            return this;

        },


        /**
         * @method
         * Register a listener to the Canvas. The listener must provide a function "onSelectionChanged".
         *
         *      // since version 5.0.0 use this method to register an listener
         *      //
         *      canvas.on("select", function(canvas, selectedFigureOrNull){
      *          alert("object selected/unselected");
      *      });
         *
         * @param {Object/Function} w an object which implements the 'onSelectionChanged' method or a callback function
         * @deprecated use draw2d.Canvas.on() instead
         **/
        addSelectionListener: function (w) {
            if (w !== null) {
                if (typeof w === "function") {
                    this.on("select", w);
                }
                else if (typeof w.onSelectionChanged === "function") {
                    this.on("select", $.proxy(w.onSelectionChanged, w));
                }
                else {
                    throw "Object doesn't implement required callback method [onSelectionChanged]";
                }
            }

            return this;
        },

        /**
         * @method
         * unregister the listener from the canvas.
         *
         * @param {Object/Function} w The object which will be removed from the selection eventing
         * @deprecated use draw2d.Canvas.off() instead
         **/
        removeSelectionListener: function (/*:Object*/ w) {
            this.off("select", w);

            return this;
        },


        /**
         * @method
         * Returns the best figure at the location [x,y]. It is a simple hit test. Keep in mind that only visible objects
         * are returned.
         *
         * @param {Number} x The x position.
         * @param {Number} y The y position.
         * @param {draw2d.Figure|Array} [figureToIgnore] The figures which should be ignored.
         **/
        getBestFigure: function (x, y, figureToIgnore) {
            if (!$.isArray(figureToIgnore)) {
                if (figureToIgnore instanceof draw2d.Figure) {
                    figureToIgnore = [figureToIgnore];
                }
                else {
                    figureToIgnore = [];
                }
            }

            var result = null;
            var testFigure = null;
            var i = 0;
            var children = null;

            // ResizeHandles first
            for (i = 0, len = this.resizeHandles.getSize(); i < len; i++) {
                testFigure = this.resizeHandles.get(i);
                if (testFigure.isVisible() === true && testFigure.hitTest(x, y) === true && $.inArray(testFigure, figureToIgnore) === -1) {
                    return testFigure;
                }
            }

            // Checking ports
            for (i = 0, len = this.commonPorts.getSize(); i < len; i++) {
                testFigure = this.commonPorts.get(i);
                if ($.inArray(testFigure, figureToIgnore) === -1) {
                    if (testFigure.isVisible() === true && testFigure.hitTest(x, y) === true) {
                        return testFigure;
                    }
                }
            }

            // tool method to check recursive a figure for hitTest
            //
            var checkRecursive = function (children) {
                children.each(function (i, e) {
                    var c = e.figure;
                    checkRecursive(c.children);
                    if (result === null && c.isVisible() === true && c.hitTest(x, y) === true && $.inArray(c, figureToIgnore) === -1) {
                        result = c;
                    }
                    return result === null; // break the each-loop if we found an element
                });
            };

            //  Check now the common objects.
            //  run reverse to aware the z-oder of the figures
            for (i = (this.figures.getSize() - 1); i >= 0; i--) {
                var figure = this.figures.get(i);
                // check first a children of the figure
                //
                checkRecursive(figure.children);

                // ...and the figure itself
                //
                if (result === null && figure.isVisible() === true && figure.hitTest(x, y) === true && $.inArray(figure, figureToIgnore) === -1) {
                    result = figure;
                }

                if (result !== null) {
                    return result;
                }
            }

            // Check the children of the lines as well
            // Not selectable/draggable. But should receive onClick/onDoubleClick events
            // as well.
            var count = this.lines.getSize();
            for (i = 0; i < count; i++) {
                var line = this.lines.get(i);
                // check first a children of the figure
                //
                checkRecursive(line.children);

                if (result !== null) {
                    return result;
                }
            }

            // A line is the last option in the priority queue for a "Best" figure
            //
            result = this.getBestLine(x, y, figureToIgnore);
            if (result !== null) {
                return result;
            }

            return result;
        },


        /**
         * @method
         * Return the line which match the hands over coordinate
         *
         * @param {Number} x the x-coordinate for the hit test
         * @param {Number} y the x-coordinate for the hit test
         * @param {draw2d.shape.basic.Line} [lineToIgnore] a possible line which should be ignored for the hit test
         *
         * @private
         * @return {draw2d.shape.basic.Line}
         **/
        getBestLine: function (x, y, lineToIgnore) {
            if (!$.isArray(lineToIgnore)) {
                if (lineToIgnore instanceof draw2d.Figure) {
                    lineToIgnore = [lineToIgnore];
                }
                else {
                    lineToIgnore = [];
                }
            }
            var count = this.lines.getSize();

            for (var i = 0; i < count; i++) {
                var line = this.lines.get(i);
                if (line.isVisible() === true && line.hitTest(x, y) === true && $.inArray(line, lineToIgnore) === -1) {
                    return line;
                }
            }
            return null;
        },


        /**
         * @private
         **/
        hideSnapToHelperLines: function () {
            this.hideSnapToHelperLineHorizontal();
            this.hideSnapToHelperLineVertical();
        },

        /**
         * @private
         **/
        hideSnapToHelperLineHorizontal: function () {
        },

        /**
         * @private
         **/
        hideSnapToHelperLineVertical: function () {

        },


        /**
         * @method
         * Called by the framework during drag&drop operations.<br>
         * Droppable can be setup with:
         * <pre>
         *     $(".draw2d_droppable").draggable({
     *          appendTo:"#container",
     *          stack:"#container",
     *          zIndex: 27000,
     *          helper:"clone",
     *          start: function(e, ui){$(ui.helper).addClass("shadow");}
     *     });
         * </pre>
         * Graphiti use the jQuery draggable/droppable lib. Please inspect
         * http://jqueryui.com/demos/droppable/ for further information.
         *
         * @param {HTMLElement} draggedDomNode The DOM element which is currently dragging
         *
         * @template
         **/
        onDragEnter: function (draggedDomNode) {
        },


        /**
         * @method
         * Called if the DragDrop object is moving around.<br>
         * <br>
         * Graphiti use the jQuery draggable/droppable lib. Please inspect
         * http://jqueryui.com/demos/droppable/ for further information.
         *
         * @param {HTMLElement} draggedDomNode The dragged DOM element.
         * @param {Number} x the x coordinate of the drag
         * @param {Number} y the y coordinate of the drag
         *
         * @template
         **/
        onDrag: function (draggedDomNode, x, y) {
        },


        /**
         * @method
         * Called if the DragDrop object leaving the current hover figure.<br>
         * <br>
         * Graphiti use the jQuery draggable/droppable lib. Please inspect
         * http://jqueryui.com/demos/droppable/ for further information.
         *
         * @param {HTMLElement} draggedDomNode The figure which is currently dragging
         *
         * @template
         **/
        onDragLeave: function (draggedDomNode) {
        },


        /**
         * @method
         * Called if the user drop the droppedDomNode onto the canvas.<br>
         * <br>
         * Draw2D use the jQuery draggable/droppable lib. Please inspect
         * http://jqueryui.com/demos/droppable/ for further information.
         *
         * @param {HTMLElement} droppedDomNode The dropped DOM element.
         * @param {Number} x the x-coordinate of the mouse up event
         * @param {Number} y the y-coordinate of the mouse up event
         * @param {Boolean} shiftKey true if the shift key has been pressed during this event
         * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
         *
         * @template
         **/
        onDrop: function (droppedDomNode, x, y, shiftKey, ctrlKey) {
        },


        /**
         * @method
         * Callback method for the double click event. The x/y coordinates are relative to the top left
         * corner of the canvas.
         *
         * @private
         **/
        onDoubleClick: function (x, y, shiftKey, ctrlKey) {
            this.fireEvent("dblclick", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey});

            // check if a line has been hit
            //
            var figure = this.getBestFigure(x, y);

            if (figure !== null) {
                figure.fireEvent("dblclick", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey});
                figure.onDoubleClick();
            }

            // forward the event to all install policies as well.
            // (since 4.0.0)
            this.editPolicy.each(function (i, policy) {
                policy.onDoubleClick(figure, x, y, shiftKey, ctrlKey);
            });
        },

        /**
         *
         * @param {Number} x the x coordinate of the event
         * @param {Number} y the y coordinate of the event
         * @param {Boolean} shiftKey true if the shift key has been pressed during this event
         * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
         * @private
         **/
        onClick: function (x, y, shiftKey, ctrlKey) {
            this.fireEvent("click", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey});

            // check if a figure has been hit
            //
            var figure = this.getBestFigure(x, y);

            // or a line/connection. May we should test the line before a figure..?
            // (since 4.0.0)
            if (figure === null) {
                figure = this.getBestLine(x, y);
            }

            if (figure !== null) {
                figure.fireEvent("click", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey}); // since 5.0.0
                figure.onClick();          // backward compatiblity
            }

            // forward the event to all install policies as well.
            // (since 3.0.0)
            this.editPolicy.each(function (i, policy) {
                policy.onClick(figure, x, y, shiftKey, ctrlKey);
            });

        },

        /**
         * @method
         * The user has triggered a right click. Redirect them to a responsible figure.
         *
         * @param {Number} x The x-coordinate of the click
         * @param {Number} y The y-coordinate of the click
         * @param {Boolean} shiftKey true if the shift key has been pressed during this event
         * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
         *
         * @private
         * @since 1.1.0
         **/
        onRightMouseDown: function (x, y, shiftKey, ctrlKey) {
            this.fireEvent("contextmenu", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey});

            var figure = this.getBestFigure(x, y);
            if (figure !== null) {
                figure.fireEvent("contextmenu", {x: x, y: y});
                figure.onContextMenu(x, y);

                // forward the event to all installed policies of the figure
                // soft migration from onHookXYZ to Policies.
                // since 4.4.0
                figure.editPolicy.each(function (i, policy) {
                    policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
                });
            }

            // forward the event to all install policies as well.
            // (since 4.4.0)
            this.editPolicy.each(function (i, policy) {
                policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
            });

        },

        // NEW EVENT HANDLING SINCE VERSION 5.0.0
        /**
         * @method
         * Execute all handlers and behaviors attached to the canvas for the given event type.
         *
         *
         * @param {String} event the event to trigger
         * @param {Object} [args] optional parameters for the triggered event callback
         *
         * @since 5.0.0
         */
        fireEvent: function (event, args) {
            if (typeof this.eventSubscriptions[event] === 'undefined') {
                return;
            }

            var subscribers = this.eventSubscriptions[event];
            for (var i = 0; i < subscribers.length; i++) {
                try {
                    subscribers[i](this, args);
                }
                catch (exc) {
                    console.log(exc);
                    console.log(subscribers[i]);
                }
            }
        },

        /**
         * @method
         * Attach an event handler function for one or more events to the canvas.
         * To remove events bound with .on(), see {@link #off}.
         *
         * possible events are:<br>
         * <ul>
         *   <li>reset</li>
         *   <li>select</li>
         * </ul>
         *
         * Example:
         *
         *      canvas.on("clear", function(emitter){
     *         alert("canvas.clear() called.");
     *      });
         *
         *      canvas.on("select", function(emitter,figure){
     *          if(figure!==null){
     *              alert("figure selected");
     *          }
     *          else{
     *              alert("selection cleared");
     *          }
     *      });
         *
         * @param {String}   event One or more space-separated event types
         * @param {Function} callback A function to execute when the event is triggered.
         * @param {draw2d.Canvas} callback.emitter the emitter of the event
         * @param {Object} [callback.obj] optional event related data
         *
         * @since 5.0.0
         */
        on: function (event, callback) {
            var events = event.split(" ");
            for (var i = 0; i < events.length; i++) {
                if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
                    this.eventSubscriptions[events[i]] = [];
                }
                this.eventSubscriptions[events[i]].push(callback);
            }
            return this;
        },

        /**
         * @method
         * The .off() method removes event handlers that were attached with {@link #on}.<br>
         * Calling .off() with no arguments removes all handlers attached to the canvas.<br>
         * <br>
         * If a simple event name such as "reset" is provided, all events of that type are removed from the canvas.
         *
         *
         * @param {String|Function} eventOrFunction the event name of the registerd function
         * @since 5.0.0
         */
        off: function (eventOrFunction) {
            if (typeof eventOrFunction === "undefined") {
                this.eventSubscriptions = {};
            }
            else if (typeof eventOrFunction === 'string') {
                this.eventSubscriptions[eventOrFunction] = [];
            }
            else {
                for (var event in this.eventSubscriptions) {
                    this.eventSubscriptions[event] = $.grep(this.eventSubscriptions[event], function (callback) {
                        return callback !== eventOrFunction;
                    });
                }
            }

            return this;
        }
    });

/**
 * @class draw2d.Selection
 *
 * Represents the current selection in the canvas. The selection element is a pure passive element which
 * manage/store the selection.
 *
 *
 * @author Andreas Herz
 */
draw2d.Selection = Class.extend({

    NAME: "draw2d.Selection",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     */
    init: function () {
        this.primary = null;
        this.all = new draw2d.util.ArrayList();
    },

    /**
     * Reset the current selection
     *
     */
    clear: function () {
        this.primary = null;
        this.all = new draw2d.util.ArrayList();
    },

    /**
     * @method
     * Return the primary selection. This can only one figure at once.
     *
     * @return {draw2d.Figure} the primary selected figure
     */
    getPrimary: function () {
        return this.primary;
    },

    /**
     * @method
     * Set the primary selection.
     *
     * @param {draw2d.Figure} figure The new primary selection
     */
    setPrimary: function (figure) {
        this.primary = figure;
        this.add(figure);
    },

    /**
     * @method
     * Remove the given figure from the selection (primary,all)
     *
     * @param {draw2d.Figure} figure
     */
    remove: function (figure) {
        this.all.remove(figure);
        if (this.primary === figure) {
            this.primary = null;
        }
    },

    /**
     * @method
     * Add a figure to the selection. No events are fired or update the selection handle. This method just
     * add the figure to the internal management data structure.
     *
     * @param figure
     * @private
     */
    add: function (figure) {
        if (figure !== null && !this.all.contains(figure)) {
            this.all.add(figure);
        }
    },


    /**
     * @method
     * return true if the given figure part of the selection
     *
     * @param {draw2d.Figure} figure The figure to check
     * @since 2.2.0
     */
    contains: function (figure) {
        return this.all.contains(figure);
    },

    /**
     * @method
     * Return the size of the selection
     *
     * @since 4.8.0
     */
    getSize: function () {
        return this.all.getSize();
    },

    /**
     * @method
     * Return the complete selection - including the primary selection.
     *
     */
    getAll: function () {
        return this.all.clone();
    },

    /**
     * @method
     * @param func
     */
    each: function (func) {
        this.all.each(func);
    }
});
/**
 * @class draw2d.Figure
 * A lightweight graphical object. Figures are rendered to a {@link draw2d.Canvas} object.
 *
 * @inheritable
 * @author Andreas Herz
 */
draw2d.Figure = Class.extend({

    NAME: "draw2d.Figure",

    MIN_TIMER_INTERVAL: 50, // minimum timer interval in milliseconds

    // special attributes that should be get/set via method calls

    /**
     * @constructor
     * Creates a new figure element which is not assigned to any canvas.
     *
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this.setterWhitelist = $.extend({
            /** @attr {Number} x the x offset of the figure in relation to the parent figure or canvas */
            x: this.setX,
            /** @attr {Number} y the y offset of the figure in relation to the parent figure or canvas */
            y: this.setY,
            /** @attr {Number} width the new width of the figure. Considering the minWidth of the shape */
            width: this.setWidth,
            /** @attr {Number} height the new height of the figure. Considering the minHeight of the shape */
            height: this.setHeight,
            /** @attr {Number} minWidth the new min width of the figure. */
            minWidth: this.setMinWidth,
            /** @attr {Number} minHeight the new min height of the figure. */
            minHeight: this.setMinHeight,
            /** @attr {String} cssClass the css class of the shape. can be used to style the shape via CSS3 (SVG only) */
            cssClass: this.setCssClass,
            /** @attr {Object} userData additional custom data which can be stored by the shape */
            userData: this.setUserData,
            /** @attr {Boolean} resizeable drives the resizeable behaviour of the shape */
            resizeable: this.setResizeable,
            /** @attr {Number} angle the rotation angle of the shape. At the moment only 90 degree increments are possible */
            angle: this.setRotationAngle,
            /** @attr {Number} alpha the the alpha/opacity of the shape. value must be between [0..1] */
            alpha: this.setAlpha,
            /** @attr {Number} opacity the the alpha/opacity of the shape. value must be between [0..1] */
            opacity: this.setAlpha,
            /** @attr {Boolean} glow the glow flag for the shape. The representation of the "glow" depends on the shape */
            glow: this.setGlow,
            /** @attr {Boolean} visible set the visibility flag of the shape */
            visible: this.setVisible,
            /** @attr {Boolean} keepAspectRatio indicate if the shape should keep the aspect ratio during resize */
            keepAspectRatio: this.setKeepAspectRatio

        }, setter);

        this.getterWhitelist = $.extend({
            visible: this.isVisible,
            angle: this.getRotationAngle,
            x: this.getX,
            y: this.getY,
            width: this.getWidth,
            height: this.getHeight,
            resizeable: this.isResizeable,
            alpha: this.getAlpha,
            opacity: this.getAlpha
        }, getter);

        // all figures has an unique id. Required for figure get and persistence storage
        this.id = draw2d.util.UUID.create();

        // required for the SelectionEditPolicy to indicate the type of figure
        // which the user clicks
        this.isResizeHandle = false;

        // for undo/redo operation. It holds the command during a drag/drop operation
        // and execute it on the CommandStack if the user drop the figure.
        this.command = null;

        // the assigned canvas
        this.canvas = null;

        // the RaphaelJS element reference
        this.shape = null;

        // possible decorations ( e.g. a Label) of the Connection
        // children are fixed bounded the figure. Most of the events of the child will bee
        // routed to the parent
        this.children = new draw2d.util.ArrayList();

        // behavior flags
        //
        this.selectable = true;
        this.deleteable = true;
        this.resizeable = true;
        this.draggable = true;
        this.visible = true;
        // since 4.1.0.
        this.keepAspectRatio = false;


        this.canSnapToHelper = true;
        this.snapToGridAnchor = new draw2d.geo.Point(0, 0);    // hot spot for snap to grid
        this.editPolicy = new draw2d.util.ArrayList();

        // timer for animation or automatic update
        //
        this.timerId = -1;
        this.timerInterval = 0;

        // possible parent of the figure.
        // @see: this.children
        this.parent = null;

        // a figure can be part of a StrongComposite like a group, ...
        //
        this.composite = null;

        // generic handle for the JSON read/write of user defined data
        this.userData = null;

        // appearance, position and dim properties
        //
        this.x = 0;
        this.y = 0;
        this.minHeight = 5;
        this.minWidth = 5;
        this.rotationAngle = 0;
        // add the name of the class to the css attribute
        this.cssClass = this.NAME.replace(new RegExp("[.]", "g"), "_");

        this.width = this.getMinWidth();
        this.height = this.getMinHeight();

        this.alpha = 1.0;

        // internal status flags for the Drag&Drop operation handling and other stuff
        //
        this.isInDragDrop = false;
        this.ox = 0;
        this.oy = 0;
        this.repaintBlocked = false;
        this.lastAppliedAttributes = {};
        this.selectionHandles = new draw2d.util.ArrayList();

        // eventhandling since version 5.0.0
        this.eventSubscriptions = {};

        // install default selection handler. Can be overridden or replaced
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());

        // the new style attr call with object attributes
        this.attr(attr);
    },

    /**
     * @method
     * Read or set shape attributes.<br>
     * When no value is given, reads specified attribute from the element.<br>
     * When value is given, sets the attribute to that value.
     * Multiple attributes can be set by passing an object with name-value pairs.
     *
     *     var figure = new draw2d.shape.basic.Rectangle();
     *     figure.attr('x');      //=> read value
     *     figure.attr('x', 30);  //=> set value
     *
     *     // multiple attributes:
     *     figure.attr({
     *       x: 30,
     *       y: 40,
     *       width : 200,
     *       height: 50,
     *       cssClass: "red_border_figure"
     *     });
     *
     * Additional you can set the user defined values (userData) with this method
     * using the dot-notation. User defined values are always part of the exported
     * JSON data.
     *
     *     // setting multiple attributes:
     *     figure.attr({
     *       userData.my.property.x: 30,
     *       userData.my.property.y: 40
     *     });
     *
     * Also set using array notation is possible for the userData:
     *
     *     // dot notation and array brackets:
     *     figure.attr({
     *       userData.my.names[0]: "John",
     *       userData.my.names[1]: "Doe"
     *     });
     *
     *
     * The Object returned should be the equivalent structured object:
     *
     *     var obj = figure.getUserData();
     *
     * That is, where obj is equivalent to:
     *
     *     var obj = {
     *         my:{
     *             property:{
     *                 x: 30,
     *                 y: 40
     *            },
     *            names:  ["John", "Doe"]
     *        }
     *    };
     *
     *
     * @param {String/Object} name
     * @param {Object} [value]
     * @since 5.0.1
     * @experimental
     * @returns
     **/
    attr: function (name, value) {
        this.repaintBlocked = true;
        try {
            // call of attr as setter method with {name1:val1, name2:val2 }  argument list
            //
            if ($.isPlainObject(name)) {
                for (key in name) {
                    // user can set the "userData" with path notation. In this case we
                    // expand the path to a real JSON object and set the data.
                    // index/brackets are allowed too.
                    //
                    if (key.substring(0, 9) === "userData.") {
                        draw2d.util.JSON.set({userData: this.userData}, key, name[key]);
                    }
                    else {
                        var func = this.setterWhitelist[key];
                        if (func) {
                            func.call(this, name[key]);
                        }
                    }
                }
            }
            else if (typeof name === "string") {
                // call attr as getter
                //
                if (typeof value === "undefined") {
                    var getter = this.getterWhitelist[name];
                    if ($.isFunction(getter)) {
                        return getter.call(this);
                    }
                    // or it is a userData path notation like "userData.any.path.value"
                    else if (name.substring(0, 9) === "userData.") {
                        var data = {userData: this.userData};
                        return draw2d.util.JSON.get(data, name);
                    }
                    return; // undefined
                }
                // call attr as simple setter with (key , value)
                //

                // the value can be a function. In this case we must call the value().
                if ($.isFunction(value)) {
                    value = value();
                }
                if (name.substring(0, 9) === "userData.") {
                    draw2d.util.JSON.set({userData: this.userData}, name, value);
                }
                else {
                    var setter = this.setterWhitelist[name];
                    if (setter) {
                        setter.call(this, value);
                    }
                }
            }
            // generic getter of all registered attributes
            else if (typeof name === "undefined") {
                var result = {};
                for (key in this.getterWhitelist) {
                    result[key] = this.getterWhitelist[key].call(this);
                }
                return result;
            }
        }
        finally {
            this.repaintBlocked = false;
        }
        this.repaint();

        return this;
    },

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     * @deprecated
     */
    pick: function (obj, var_keys) {
        var keys = typeof arguments[1] !== 'string' ? arguments[1] : Array.prototype.slice.call(arguments, 1);
        var out = {}, key;
        for (key in keys) {
            if (typeof obj[key] !== "undefined")
                out[key] = obj[key];
        }
        return out;
    },

    /**
     * @method
     * Add the figure to the current selection and propagate this to all edit policies.
     *
     * @param {boolean} [isPrimarySelection] true if the element should be the primary selection
     * @private
     */
    select: function (asPrimarySelection) {
        if (typeof asPrimarySelection === "undefined") {
            asPrimarySelection = true;
        }

        // apply all EditPolicy for select Operations
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                e.onSelect(_this.canvas, _this, asPrimarySelection);
            }
        });

        if (this.canvas !== null) {
            this.canvas.getSelection().add(this);
        }

        return this;
    },

    /**
     * @method
     * Unselect the figure and propagete this event to all edit policies.
     *
     * @private
     **/
    unselect: function () {
        var _this = this;
        // apply all EditPolicy for select Operations
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                e.onUnselect(_this.canvas, _this);
            }
        });

        if (this.canvas !== null) {
            this.canvas.getSelection().remove(this);
        }

        return this;
    },

    /**
     * @method
     * Allows a user to attach (or remove) data to an element, without needing to create a custom figure or shape.
     * The data must be a valid JSON object.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *        userData: object
     *      });
     *
     * @since 2.7.2
     * @param {Object} object
     */
    setUserData: function (object) {
        this.userData = object;
        this.fireEvent("change:userData");
        return this;
    },

    /**
     * @method
     * Returns any user data set previously on the given figure by setUserData.
     *
     * @since 2.7.2
     * @returns {Object}
     */
    getUserData: function () {
        return this.userData;
    },

    /**
     * @method
     * Return the UUID of this element.
     *
     * @return {String}
     */
    getId: function () {
        return this.id;
    },


    /**
     * @method
     * Set the id of this element.
     *
     *     // Alternatively you can use the attr method:
     *     figure.attr({
     *       id: newId
     *     });
     *
     * @param {String} newId the new id for this figure
     */
    setId: function (newId) {
        this.id = newId;

        return this;
    },


    /**
     * @method
     * Return the css styling class name of the element.
     *
     *
     * @return {String}
     */
    getCssClass: function () {
        return this.cssClass;
    },

    /**
     * @method
     * Set the css class of the node.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *        "cssClass": "red_border_figure"
     *      });
     *
     * @param {String} cssClass the new css class name of the node
     * @since 2.9.0
     */
    setCssClass: function (cssClass) {
        this.cssClass = cssClass === null ? null : $.trim(cssClass);

        if (this.shape === null) {
            return this;
        }

        if (this.cssClass === null) {
            this.shape.node.removeAttribute("class");
        }
        else {
            this.shape.node.setAttribute("class", this.cssClass);
        }
        this.fireEvent("change:userData");

        return this;
    },

    /**
     * @method
     * The method will return true if the class is assigned to the element, even if other classes also are.
     *
     * @param {String} className the class name to check
     * @since 2.9.0
     */
    hasCssClass: function (className) {
        if (this.cssClass === null) {
            return false;
        }

        return new RegExp(' ' + $.trim(className) + ' ').test(' ' + this.cssClass + ' ');
    },

    /**
     * @method
     * Add a CSS class to the figure.<br>
     * It's important to note that this method does not replace a class. It simply adds the class,
     * appending it to any which may already be assigned to the elements.
     *
     * @param {String} className
     * @since 2.9.0
     */
    addCssClass: function (className) {
        className = $.trim(className);
        if (!this.hasCssClass(className)) {
            if (this.cssClass === null) {
                this.setCssClass(className);
            }
            else {
                this.setCssClass(this.cssClass + ' ' + className);
            }
            this.fireEvent("change:cssClass");
        }

        return this;
    },

    /**
     * @method
     *
     * Remove the given css class name from the figure
     *
     * @param {String} className the css class name to add
     */
    removeCssClass: function (className) {
        className = $.trim(className);
        var newClass = ' ' + this.cssClass.replace(/[\t\r\n]/g, ' ') + ' ';
        if (this.hasCssClass(className)) {
            while (newClass.indexOf(' ' + className + ' ') >= 0) {
                newClass = newClass.replace(' ' + className + ' ', ' ');
            }
            this.setCssClass(newClass.replace(/^\s+|\s+$/g, ''));
            this.fireEvent("change:cssClass");
        }

        return this;
    },

    /**
     * @method
     *
     * Add or remove the given css class name from the figure
     *
     * @param {String} className the class name to toggle
     */
    toggleCssClass: function (className) {
        className = $.trim(className);
        var newClass = ' ' + this.cssClass.replace(/[\t\r\n]/g, ' ') + ' ';
        if (this.hasCssClass(className)) {
            while (newClass.indexOf(' ' + className + ' ') >= 0) {
                newClass = newClass.replace(' ' + className + ' ', ' ');
            }
            this.setCssClass(newClass.replace(/^\s+|\s+$/g, ''));
        } else {
            this.setCssClass(this.cssClass + ' ' + className);
        }
        this.fireEvent("change:cssClass");

        return this;
    },

    /**
     * @method
     * Set the canvas element of this figures. This can be used to determine whenever an element
     * is added or removed to the canvas.
     *
     * @param {draw2d.Canvas} canvas the new parent of the figure or null
     */
    setCanvas: function (canvas) {
        // remove the shape if we reset the canvas and the element
        // was already drawn
        if (canvas === null && this.shape !== null) {
            this.unselect();
            this.shape.remove();
            this.shape = null;
        }

        this.canvas = canvas;

        if (this.canvas !== null) {
            this.getShapeElement();
        }

        if (canvas === null) {
            this.stopTimer();
        }
        else {
            if (this.timerInterval >= this.MIN_TIMER_INTERVAL) {
                this.startTimer(this.timerInterval);
            }
        }

        this.children.each(function (i, e) {
            e.figure.setCanvas(canvas);
        });

        return this;
    },

    /**
     * @method
     * Return the current assigned canvas container.
     *
     * @return {draw2d.Canvas}
     */
    getCanvas: function () {
        return this.canvas;
    },


    /**
     * @method
     * Start a timer which calls the onTimer method in the given interval.
     *
     * @param {Number} milliSeconds
     */
    startTimer: function (milliSeconds) {
        this.stopTimer();
        this.timerInterval = Math.max(this.MIN_TIMER_INTERVAL, milliSeconds);

        if (this.canvas !== null) {
            this.timerId = window.setInterval($.proxy(function () {
                this.onTimer();
                this.fireEvent("timer");
            }, this), this.timerInterval);
        }

        return this;
    },

    /**
     * @method
     * Stop the internal timer.
     *
     */
    stopTimer: function () {
        if (this.timerId >= 0) {
            window.clearInterval(this.timerId);
            this.timerId = -1;
        }

        return this;
    },

    /**
     * @method
     * Callback method for the internal timer handling<br>
     * Inherit classes must override this method if they want use the timer feature.
     *
     *      // Alternatively you can register for this event with
     *      figure.on("timer", function(emitterFigure){
      *          alert("timer fired");
      *      });
     *
     * @template
     */
    onTimer: function () {
    },

    /**
     * @method
     * Moves the element so it is the closest to the viewer?��s eyes, on top of other elements. Additional
     * the internal model changed as well.
     *
     * Optional: Inserts current object in front of the given one.
     *
     * @param {draw2d.Figure} [figure] move current object in front of the given one.
     * @since 3.0.0
     */
    toFront: function (figure) {
        // ensure that the z-oder is still correct if the figure is assigned
        // to a StrongComposite
        //
        if (this.composite instanceof draw2d.shape.composite.StrongComposite && (typeof figure !== "undefined")) {
            var indexFigure = figure.getZOrder();
            var indexComposite = this.composite.getZOrder();
            if (indexFigure < indexComposite) {
                figure = this.composite;
            }
        }

        if (typeof figure === "undefined") {
            this.getShapeElement().toFront();

            if (this.canvas !== null) {
                var figures = this.canvas.getFigures();
                var lines = this.canvas.getLines();
                if (figures.remove(this) !== null) {
                    figures.add(this);
                } else if (lines.remove(this) !== null) {
                    lines.add(this);
                }
            }
        }
        else {
            this.getShapeElement().insertAfter(figure.getTopLevelShapeElement());

            if (this.canvas !== null) {
                var figures = this.canvas.getFigures();
                var lines = this.canvas.getLines();
                if (figures.remove(this) !== null) {
                    var index = figures.indexOf(figure);
                    figures.insertElementAt(this, index + 1);
                } else if (lines.remove(this) !== null) {
                    lines.add(this);
                }
            }
        }

        // bring all children figures in front of the parent
        this.children.each(function (i, child) {
            child.figure.toFront(figure);
        });

        return this;
    },

    /**
     * @method
     * Moves the element to the background. Additional
     * the internal model changed as well.
     *
     * @since 4.7.2
     */
    toBack: function (figure) {
        // it is not allowed that a figure is behind an assinged composite
        //
        if (this.composite instanceof draw2d.shape.composite.StrongComposite) {
            this.toFront(this.composite);
            return;
        }

        if (this.canvas !== null) {
            var figures = this.canvas.getFigures();
            var lines = this.canvas.getLines();
            if (figures.remove(this) !== null) {
                figures.insertElementAt(this, 0);
            } else if (lines.remove(this) !== null) {
                lines.insertElementAt(this, 0);
            }
        }

        // bring all children figures in front of the parent
        // run reverse to the collection to care about the z-order of the children)
        this.children.each(function (i, child) {
            child.figure.toBack(figure);
        }, true);

        if (typeof figure !== "undefined") {
            this.getShapeElement().insertBefore(figure.getShapeElement());
        }
        else {
            this.getShapeElement().toBack();
        }

        return this;
    },


    /**
     * @method
     * Install a new edit policy to the figure. Each editpolicy is able to focus on a single editing
     * task or group of related tasks. This also allows editing behavior to be selectively reused across
     * different figure implementations. Also, behavior can change dynamically, such as when the layouts
     * or routing methods change.
     *
     * Example for limited DragDrop behavior can be a draw2d.layout.constraint.RegionConstriantPolicy.
     *
     * @param {draw2d.policy.EditPolicy} policy
     */
    installEditPolicy: function (policy) {
        // it is only possible to install one SelectionFeedbackPolicy at once
        //
        if (policy instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
            var _this = this;
            this.editPolicy.grep(function (p) {
                var stay = !(p instanceof draw2d.policy.figure.SelectionFeedbackPolicy);
                if (!stay) {
                    p.onUninstall(_this);
                }
                return stay;
            });
        }
        policy.onInstall(this);
        this.editPolicy.add(policy);

        return this;
    },

    /**
     * @method
     *
     * UnInstall the edit policy from the figure. Either the instance itself if found
     * or all kind of the given edit policies.
     *
     *
     * @param {draw2d.policy.EditPolicy} policy
     * @since 4.81
     */
    uninstallEditPolicy: function (policy) {
        var removedPolicy = this.editPolicy.remove(policy);

        // we found the policy and we are happy
        //
        if (removedPolicy !== null) {
            removedPolicy.onUninstall(this);
            return;
        }

        // The policy isn'T part of the figure. In this case we "think" the user want
        // deinstall all instances of the policy
        //
        var _this = this;
        this.editPolicy.grep(function (p) {
            if (p.NAME === policy.NAME) {
                p.onUninstall(_this);
                return false;
            }
            return true;
        });
    },

    /**
     * @method
     * Add a child figure to the figure. The hands over figure doesn't support drag&drop
     * operations. It's only a decorator for the connection.<br>
     * Mainly for labels or other decorations
     *
     *
     *     var start = new draw2d.shape.node.Start({x:80, y:150});
     *     start.add(new draw2d.shape.basic.Label({text:"Test Label"}), new draw2d.layout.locator.TopLocator());
     *
     *     canvas.add( start);
     *
     * @param {draw2d.Figure} figure the figure to add as decoration to the connection.
     * @param {draw2d.layout.locator.Locator} locator the locator for the child.
     * @param {Number} [index] optional index where to insert the figure
     **/
    add: function (child, locator, index) {
        if (typeof locator === "undefined" || locator === null) {
            throw "Second parameter 'locator' is requried for method 'Figure#add'";
        }

        // the child is now a slave of the parent
        //
        child.setDraggable(false);
        child.setSelectable(false);
        child.setParent(this);

        if ($.isNumeric(index)) {
            this.children.insertElementAt({figure: child, locator: locator}, index);
        }
        else {
            this.children.add({figure: child, locator: locator});
        }

        if (this.canvas !== null) {
            child.setCanvas(this.canvas);
        }

        this.repaint();

        return this;
    },
    /**
     * @method
     * @deprecated use draw2d.Figure.add()
     */
    addFigure: function (child, locator) {
        return this.add(child, locator);
    },

    /**
     * @method
     * Remove the child figure from this figure and the canvas
     *
     * @param {draw2d.Figure} child the figure to remove.
     *
     * @return {Object} the removed tupple of figure/locator or null if the child isn't found
     * @return {draw2d.Figure} return.figure The removed figure
     * @return {draw2d.shape.layout.Layout} return.locator The used locator of the figure
     *
     * @since 5.0.0
     **/
    remove: function (child) {
        if (typeof child === "undefined" || child === null) {
            debug.warn("The parameter child is required for Figure.remove");
            return null; // silently
        }

        var removed = null;
        this.children.grep(function (e) {
            var stay = e.figure !== child;
            if (!stay) {
                removed = e;
            }
            return stay;
        });

        if (removed !== null) {
            child.setParent(null);
            child.setCanvas(null);

            this.repaint();
            return removed;
        }

        return null;
    },
    /**
     * @method
     * @deprecated use draw2d.Figure.remove()
     */
    removeFigure: function (child) {
        return this.remove(child);
    },


    /**
     * @method
     * Return all children/decorations of this shape which has been added with
     * draw2d.Figure.add
     */
    getChildren: function () {
        return this.children.clone().map(function (e) {
            return e.figure;
        });
    },


    /**
     * @method
     * Remove all children/decorations of this shape
     *
     */
    resetChildren: function () {
        this.children.each(function (i, e) {
            e.figure.setCanvas(null);
        });
        this.children = new draw2d.util.ArrayList();
        this.repaint();

        return this;
    },


    /**
     * @method
     * return the current SVG shape element or create it on demand.
     *
     * @private
     */
    getShapeElement: function () {
        if (this.shape !== null) {
            return this.shape;
        }

        this.shape = this.createShapeElement();

        // add CSS class to enable styling of the element with CSS rules/files
        //
        if (this.cssClass !== null) {
            this.shape.node.setAttribute("class", this.cssClass);
        }

        return this.shape;
    },

    /**
     * @method
     * Get the top level shape element. May the figure has a set of SVG elements. In this case this
     * method must return the top level node.<br>
     * This method is used for the toFron/toBack method to order the nodes in the correct way.
     *
     * @since 5.0.0
     * @private
     */
    getTopLevelShapeElement: function () {
        return this.getShapeElement();
    },


    /**
     * @method
     * Inherited classes must override this method to implement it's own draw functionality.
     *
     * @template
     * @abstract
     */
    createShapeElement: function () {
        throw "Inherited class [" + this.NAME + "] must override the abstract method createShapeElement";
    },


    /**
     * @method
     * propagate all attributes like color, stroke,... to the shape element
     *
     * @param {Object} attributes the style attributes for the SVG shape
     * @private
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return this;
        }


        if (this.visible === true) {
            this.shape.show();
        }
        else {
            this.shape.hide();
            return this;
        }


        // enrich with common properties
        attributes.opacity = this.alpha;

        // performance improvement
        // Only apply attributes which has changed. This end in a big performance improvement
        // because the raphael shape isn't redraw at all.
        //
        var diff = function (obj1, obj2) {
            var result = {};
            for (key in obj1) {
                if (obj1[key] !== obj2[key]) {
                    result[key] = obj1[key];
                }
            }
            return result;
        };
        attributes = diff(attributes, this.lastAppliedAttributes);
        this.lastAppliedAttributes = attributes;


        this.shape.attr(attributes);

        this.applyTransformation();

        /* moved to setDimension.
         * Locator is only called if the dimension of the figure has been changed
         * Performance
         */
        // Relocate all children of the figure.
        // This means that the Locater can calculate the new Position of the child.
        //
        this.children.each(function (i, e) {
            e.locator.relocate(i, e.figure);
        });

        return this;
    },

    /**
     * @method
     * apply a transformation to the shape like rotation, translate,..
     *
     * @private
     * @template
     */
    applyTransformation: function () {
        return this;
    },

    /**
     * @method
     * Highlight the element or remove the highlighting
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
      *        glow: flag
      *      });
     *
     * @param {Boolean} flag indicates glow/noGlow
     * @template
     */
    setGlow: function (flag) {
        // do nothing in the base class.
        // Subclasses must implement this method.

        return this;
    },


    /**
     * @method
     * Called if the drag and drop action begins. You can return [false] if you
     * want avoid that the figure can be move.
     *
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean} true if the figure accepts dragging
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {
        this.isInDragDrop = false;

        this.command = this.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));

        if (this.command !== null) {
            this.ox = this.getX();
            this.oy = this.getY();
            this.isInDragDrop = true;

            // notify all installed policies
            //
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                    e.onDragStart(_this.canvas, _this, x, y, shiftKey, ctrlKey);
                }
            });

            return true;
        }

        return false;
    },

    /**
     * @method
     * Don't call them manually. This will be done by the framework.<br>
     * Will be called if the object are moved via drag and drop.
     * Sub classes can override this method to implement additional stuff. Don't forget to call
     * the super implementation via <code>this._super(dx, dy, dx2, dy2);</code>
     *
     * @private
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        var _this = this;

        // apply all EditPolicy for DragDrop Operations
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                var newPos = e.adjustPosition(_this, _this.ox + dx, _this.oy + dy);
                dx = newPos.x - _this.ox;
                dy = newPos.y - _this.oy;
            }
        });

        var newPos = new draw2d.geo.Point(this.ox + dx, this.oy + dy);

        // Adjust the new location if the object can snap to a helper
        // like grid, geometry, ruler,...
        //
        if (this.getCanSnapToHelper()) {
            newPos = this.getCanvas().snapToHelper(this, newPos);
        }

        this.setPosition(newPos);

        // notify all installed policies
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.onDrag(_this.canvas, _this);
            }
        });

        this.fireEvent("move");
        this.fireEvent("change:x");
        this.fireEvent("change:y");
    },

    /**
     * @method
     * Called by the framework if the figure returns false for the drag operation. In this
     * case we send a "panning" event - mouseDown + mouseMove. This is very useful for
     * UI-Widget like slider, spinner,...
     *
     * @param {Number} dx the x difference between the mouse down operation and now
     * @param {Number} dy the y difference between the mouse down operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onPanning: function (dx, dy, dx2, dy2) {

    },


    /**
     * @method
     * Will be called after a drag and drop action.<br>
     * Sub classes can override this method to implement additional stuff. Don't forget to call
     * the super implementation via <code>this._super();</code>
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @template
     **/
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        var _this = this;

        // Element ist zwar schon an seine Position, das Command muss aber trotzdem
        // in dem CommandStack gelegt werden damit das Undo funktioniert.
        //
        this.command.setPosition(this.x, this.y);
        this.isInDragDrop = false;

        this.canvas.getCommandStack().execute(this.command);
        this.command = null;

        // notify all installed policies
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.onDragEnd(_this.canvas, _this, x, y, shiftKey, ctrlKey);
            }
        });

        this.fireEvent("move");
        this.fireEvent("change:x");
        this.fireEvent("change:y");
    },

    /**
     * @method
     * Called by the framework during drag&drop operations if the user drag a figure over this figure
     *
     * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
     *
     * @return {draw2d.Figure} the figure which should receive the drop event or null if the element didn't want a drop event
     * @template
     **/
    onDragEnter: function (draggedFigure) {
        var _this = this;
        var delegate = draggedFigure;
        this.getCanvas().getInterceptorPolicies().each(function (i, policy) {
            delegate = policy.delegateDrop(draggedFigure, _this);
            if (delegate !== null) {
                return false; // break the loop
            }
        });

        return delegate;
    },

    /**
     * @method
     * Called if the DragDrop object leaving the current hover figure.
     *
     * @param {draw2d.Figure} figure The figure which is currently dragging
     * @template
     **/
    onDragLeave: function (draggedFigure) {
    },


    /**
     * @method
     * Called if the user drop this element onto the dropTarget. This event is ONLY fired if the
     * shape return "this" in the {@link draw2d.Figure#onDragEnter} method.
     *
     *
     * @param {draw2d.Figure} dropTarget The drop target.
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     **/
    onDrop: function (dropTarget, x, y, shiftKey, ctrlKey) {
    },

    /**
     * @method
     * Called if the user dropped an figure onto this element. This event is ONLY fired if the
     * in the canvas installed {@link draw2d.policy.canvas.ConnectionInterceptorPolicy} allow this.
     *
     *
     * @param {draw2d.Figure} droppedFigure The dropped figure.
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     * @since 4.8.0
     **/
    onCatch: function (droppedFigure, x, y, shiftKey, ctrlKey) {
    },


    /**
     * @method
     * Callback method for the mouse enter event. Usefull for mouse hover-effects.
     * Override this method for your own effects. Don't call them manually.
     *
     * @template
     **/
    onMouseEnter: function () {
    },


    /**
     * @method
     * Callback method for the mouse leave event. Useful for mouse hover-effects.
     *
     * @template
     **/
    onMouseLeave: function () {
    },

    /**
     * @method
     * Called when a user dbl clicks on the element
     *
     *      // Alternatively you register for this event with:
     *      figure.on("dblclick", function(emitterFunction){
     *          alert("user dbl click on the figure");
     *      });
     *
     * @template
     */
    onDoubleClick: function () {
    },


    /**
     * @method
     * Called when a user clicks on the element.
     *
     *      // Alternatively you register for this event with:
     *      figure.on("click", function(emitterFunction){
     *          alert("user click on the figure");
     *      });
     *
     * @template
     * @deprecated
     */
    onClick: function () {
    },

    /**
     * @method
     * called by the framework if the figure should show the context menu.<br>
     * The strategy to show the context menu depends on the platform. Either looong press or
     * right click with the mouse.
     *
     *      // Alternatively you register for this event with:
     *      figure.on("contextmenu", function(emitterFunction){
     *          alert("user press the right mouse button for a context menu");
     *      });
     *
     * @param {Number} x the x-coordinate to show the menu
     * @param {Number} y the y-coordinate to show the menu
     * @since 1.1.0
     * @template
     */
    onContextMenu: function (x, y) {
    },

    /**
     * @method
     * Set the alpha blending of this figure.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *        "alpha": percent
     *      });
     *
     *      // ...or:
     *      figure.attr({
     *        "opacity": percent
     *      });
     *
     * @param {Number} percent value between [0..1].
     * @template
     **/
    setAlpha: function (percent) {
        percent = Math.min(1, Math.max(0, parseFloat(percent)));
        if (percent === this.alpha) {
            return;
        }

        this.alpha = percent;
        this.repaint();
        this.fireEvent("change:opacity");

        return this;
    },


    /**
     * @method
     * Return the alpha blending of the figure
     *
     * @return {Number} the current alpha blending
     */
    getAlpha: function () {
        return this.alpha;
    },


    /**
     * @method
     * Set the rotation angle in degree [0..356]<br>
     * <b>Only steps of 90 degree is working well</b>
     * <br>
     *      // Alternatively you can use the attr method:
     *      figure.attr({
      *        angle: angle
      *      });
     *
     * @param {Number} angle the rotation angle in degree
     */
    setRotationAngle: function (angle) {
        var _this = this;

        this.rotationAngle = angle;

        // Update the resize handles if the user change the position of the element via an API call.
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("change:angle");
        this.repaint();

        return this;
    },

    /**
     * @method
     * return the rotation angle of the figure in degree of [0..356].
     *
     * <br>
     * <b>NOTE: this method is pre alpha and not for production. Only steps of 90 degree is working well</b>
     * <br>
     * @returns {Number}
     */
    getRotationAngle: function () {
        return this.rotationAngle;
    },


    /**
     * @method
     * Show/hide the element. The element didn't receive any mouse events (click, dblclick) if you hide the
     * figure.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
      *        visible: flag
      *      });
     *
     * @param {Boolean} flag
     * @since 1.1.0
     */
    setVisible: function (flag) {
        flag = !!flag;
        if (flag === this.visible) {
            return;
        }
        this.visible = flag;

        this.repaint();

        if (this.visible) {
            this.fireEvent("show");
        } else {
            this.fireEvent("hide");
        }
        this.fireEvent("change:visibility");

        return this;
    },

    /**
     * @method
     * Return true if the figure visible.
     *
     * @return {Boolean}
     * @since 1.1.0
     */
    isVisible: function () {
        return this.visible && this.shape !== null;
    },

    /**
     * @method
     * Guarantee, that the figure width/height will not be distorted. Applicable before calling setDimension().
     * It is false by default.
     *
     * @since 4.1.0
     * @param {Boolean} flag boolean flag if the figure should respect the aspect ratio
     */
    setKeepAspectRatio: function (flag) {
        this.keepAspectRatio = flag;

        return this;
    },

    /**
     * @method
     * Return the flag if the shape keep the aspect ratio.
     *
     * @since 4.1.0
     */
    getKeepAspectRatio: function () {
        return this.keepAspectRatio;
    },

    /**
     * @method
     * Return the current z-index of the element. Currently this is an expensive method. The index will be calculated
     * all the time. Caching is not implemented at the moment.
     *
     * @return {Number}
     */
    getZOrder: function () {
        if (this.shape === null) {
            return -1;
        }

        var i = 0;
        var child = this.shape.node;
        while ((child = child.previousSibling) !== null) {
            i++;
        }
        return i;
    },

    /**
     * @method
     * Set the flag if this object can snap to grid or geometry.
     * A window of dialog should set this flag to false.
     *
     * @param {Boolean} flag The snap to grid/geometry enable flag.
     *
     **/
    setCanSnapToHelper: function (flag) {
        this.canSnapToHelper = !!flag;

        return this;
    },

    /**
     * @method
     * Returns true if the figure can snap to any helper like a grid, guide, geometrie
     * or something else.
     *
     * @return {boolean}
     **/
    getCanSnapToHelper: function () {
        return this.canSnapToHelper;
    },

    /**
     *
     * @return {draw2d.geo.Point}
     **/
    getSnapToGridAnchor: function () {
        return this.snapToGridAnchor;
    },

    /**
     * @method
     * Set the hot spot for all snapTo### operations.
     * (deprecated? Todo: check references in existing projects)
     *
     * @param {draw2d.geo.Point} point
     **/
    setSnapToGridAnchor: function (point) {
        this.snapToGridAnchor = point;

        return this;
    },

    /**
     * @method
     * Set the width of the figure and consider the minWidth attribute
     *
     * @param {Number} width the new width of the figure
     * @since 5.1.0
     */
    setWidth: function (width) {
        this.setDimension(parseFloat(width), this.getHeight());
        this.fireEvent("change:width");
    },

    /**
     * @method
     * The current width of the figure.
     *
     * @type {Number}
     **/
    getWidth: function () {
        return this.width;
    },

    /**
     * @method
     * Set the heigth of the figure and consider the minWidth attribute
     *
     * @param {Number} width the new width of the figure
     * @since 5.1.0
     */
    setHeight: function (height) {
        this.setDimension(this.getWidth(), parseFloat(height));
        this.fireEvent("change:height");
    },

    /**
     * @method
     * The current height of the figure.
     *
     * @type {Number}
     **/
    getHeight: function () {
        return this.height;
    },


    /**
     * @method
     * This value is relevant for the interactive resize of the figure.
     *
     * @return {Number} Returns the min. width of this object.
     */
    getMinWidth: function () {
        return this.minWidth;
    },

    /**
     * @method
     * Set the minimum width of this figure
     *
     * @param {Number} w
     */
    setMinWidth: function (w) {
        this.minWidth = parseFloat(w);
        this.fireEvent("change:minWidth");

        // fit the width with the new constraint
        this.setWidth(this.getWidth());

        return this;
    },

    /**
     * @method
     * This value is relevant for the interactive resize of the figure.
     *
     * @return {Number} Returns the min. height of this object.
     */
    getMinHeight: function () {
        return this.minHeight;

        return this;
    },

    /**
     * @method
     * Set the minimum heigth of the figure.
     *
     * @param {Number} h
     */
    setMinHeight: function (h) {
        this.minHeight = parseFloat(h);
        this.fireEvent("change:minHeight");

        // fit the height with the new constraint
        this.setHeight(this.getHeight());

        return this;
    },

    /**
     * @method
     * the the x-offset related to the parent figure or canvas
     *
     * @param {Number} x the new x offset of the figure
     * @since 5.0.8
     */
    setX: function (x) {
        this.setPosition(parseFloat(x), this.y);
        this.fireEvent("change:x");
    },

    /**
     * @method
     * The x-offset related to the parent figure or canvas.
     *
     * @return {Number} the x-offset to the parent figure
     **/
    getX: function () {
        return this.x;
    },

    /**
     * @method
     * the the y-offset related to the parent figure or canvas
     *
     * @param {Number} x the new x offset of the figure
     * @since 5.0.8
     */
    setY: function (y) {
        this.setPosition(this.x, parseFloat(y));
        this.fireEvent("change:y");
    },


    /**
     * @method
     * The y-offset related to the parent figure or canvas.
     *
     * @return {Number} The y-offset to the parent figure.
     **/
    getY: function () {
        return this.y;
    },


    /**
     * @method
     * The x-offset related to the canvas.
     *
     * @return {Number} the x-offset to the canvas
     **/
    getAbsoluteX: function () {
        if (!this.parent) {
            return this.getX();
        }
        return this.getX() + this.parent.getAbsoluteX();
    },


    /**
     * @method
     * The y-offset related to the canvas.
     *
     * @return {Number} The y-offset to the canvas.
     **/
    getAbsoluteY: function () {
        if (!this.parent) {
            return this.getY();
        }
        return this.getY() + this.parent.getAbsoluteY();
    },


    /**
     * @method
     * Returns the absolute y-position of the port.
     *
     * @type {draw2d.geo.Point}
     **/
    getAbsolutePosition: function () {
        return new draw2d.geo.Point(this.getAbsoluteX(), this.getAbsoluteY());
    },

    /**
     * @method
     * Returns the absolute y-position of the port.
     *
     * @return {draw2d.geo.Rectangle}
     **/
    getAbsoluteBounds: function () {
        return new draw2d.geo.Rectangle(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
    },


    /**
     * @method
     * Set the position of the object.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
      *        x: x,
      *        y: y
      *      });
     *
     * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure or the x/y coordinate if it is an draw2d.geo.Point
     * @param {Number} [y] The new y coordinate of the figure
     **/
    setPosition: function (x, y) {
        if (x instanceof draw2d.geo.Point) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }

        var oldPos = {x: this.x, y: this.y};

        var _this = this;

        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                var newPos = e.adjustPosition(_this, _this.x, _this.y);
                _this.x = newPos.x;
                _this.y = newPos.y;
            }
        });

        var diffPos = {x: oldPos.x - this.x, y: oldPos.y - this.y};
        this.repaint();

        this.children.each(function (i, e) {
            if (e.locator.translate) {
                // new method since 5.2.0 to support faster rendering of draw2d.shape.layout.Layout shapes
                e.locator.translate(e.figure, diffPos);
            }
            else {
                e.locator.relocate(i, e.figure);
            }
        });

        // Update the resize handles if the user change the position of the
        // element via an API call.
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("move");
        this.fireEvent("change:x");
        this.fireEvent("change:y");

        return this;
    },


    /**
     * @method
     * Get the current position of the figure
     *
     * @return {draw2d.geo.Point}
     * @since 2.0.0
     */
    getPosition: function () {
        return new draw2d.geo.Point(this.getX(), this.getY());
    },

    /**
     * @method
     * Translate the figure with the given x/y offset.
     *
     * @param {Number} dx The x offset to translate
     * @param {Number} dy The y offset to translate
     **/
    translate: function (dx, dy) {
        this.setPosition(this.getX() + dx, this.getY() + dy);

        return this;
    },


    /**
     * @method
     * Set the new width and height of the figure.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *         width:  w,
     *         height: h
     *      });
     *
     * @param {Number} w The new width of the figure
     * @param {Number} h The new height of the figure
     **/
    setDimension: function (w, h) {
        var _this = this;
        w = Math.max(this.getMinWidth(), w);
        h = Math.max(this.getMinHeight(), h);

        if (this.width === w && this.height === h) {
            // required if an inherit figure changed the w/h to a given constraint.
            // In this case the Resize handles must be informed that the shape didn't resized.
            // because the minWidth/minHeight did have a higher prio.
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                    e.moved(_this.canvas, _this);
                }
            });
            return this;
        }


        // apply all EditPolicy to adjust/modify the new dimension
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                var newDim = e.adjustDimension(_this, w, h);
                w = newDim.w;
                h = newDim.h;
            }
        });

        // respect the aspect ratio if required
        //
        if (this.keepAspectRatio === true) {
            if (w >= this.getMinWidth()) {
                // scale the height to the given ratio
                h = this.getHeight() * (w / this.getWidth());
                // and apply the new dimension only if the values are in range of the given constraints
                if (h >= this.getMinHeight()) {
                    this.width = w;
                    this.height = h;
                }
            }
        }
        else {
            this.width = Math.max(this.getMinWidth(), w);
            this.height = Math.max(this.getMinHeight(), h);
        }


        this.repaint();

        this.fireEvent("resize");
        this.fireEvent("change:dimension");

        // Update the resize handles if the user change the position of the element via an API call.
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        return this;
    },


    /**
     * @method
     * Set the bounding box of the figure
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *        width: w,
     *        height: h,
     *        x: x,
     *        y: y
     *      });
     *
     * @param {draw2d.geo.Rectangle} rect
     * @since 4.8.0
     */
    setBoundingBox: function (rect) {
        this.repaintBlocked = true;
        this.setPosition(rect.x, rect.y);
        this.repaintBlocked = false;
        this.setDimension(rect.w, rect.h);

        return this;
    },

    /**
     * @method
     * Return the bounding box of the figure in absolute position to the canvas.
     *
     * @return {draw2d.geo.Rectangle}
     **/
    getBoundingBox: function () {
        return new draw2d.geo.Rectangle(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
    },

    /**
     * @method
     * Detect whenever the hands over coordinate is inside the figure.
     * The default implementation is a simple bounding box test.
     *
     * @param {Number} iX
     * @param {Number} iY
     * @param {Number} [corona]
     *
     * @returns {Boolean}
     */
    hitTest: function (iX, iY, corona) {
        if (typeof corona === "number") {
            return this.getBoundingBox().scale(corona, corona).hitTest(iX, iY);
        }
        return this.getBoundingBox().hitTest(iX, iY);
    },


    /**
     * @method
     * Switch on/off the drag drop behaviour of this object
     *
     * @param {Boolean} flag The new drag drop indicator
     **/
    setDraggable: function (flag) {
        this.draggable = !!flag;

        return this;
    },

    /**
     * @method
     * Get the Drag drop enable flag
     *
     * @return {boolean} The new drag drop indicator
     **/
    isDraggable: function () {
        // delegate to the composite if given
        if (this.composite !== null) {
            return this.composite.isMemberDraggable(this, this.draggable);
        }

        return this.draggable;
    },


    /**
     * @method
     * Returns the true if the figure can be resized.
     *
     * @return {boolean}
     **/
    isResizeable: function () {
        return this.resizeable;
    },

    /**
     * @method
     * You can change the resizeable behaviour of this object. Hands over [false] and
     * the figure has no resizehandles if you select them with the mouse.<br>
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *        resizeable: flag
     *      });
     *
     * @param {boolean} flag The resizeable flag.
     **/
    setResizeable: function (flag) {
        this.resizeable = !!flag;
        this.fireEvent("change:resizeable");

        return this;
    },

    /**
     * @method
     * Indicates whenever the element is selectable by user interaction or API.
     *
     * @return {boolean}
     **/
    isSelectable: function () {
        // delegate to the composite if given
        if (this.composite !== null) {
            return this.composite.isMemberSelectable(this, this.selectable);
        }

        return this.selectable;
    },


    /**
     * @method
     * You can change the selectable behavior of this object. Hands over [false] and
     * the figure has no selection handles if you try to select them with the mouse.<br>
     *
     * @param {boolean} flag The selectable flag.
     **/
    setSelectable: function (flag) {
        this.selectable = !!flag;
        this.fireEvent("change:selectable");

        return this;
    },

    /**
     * @method
     * Return true if the object doesn't care about the aspect ratio.
     * You can change the height and width independent.<br>
     *
     * Replaced with "getKeepAspectRatio"
     * @return {boolean}
     * @deprecated
     */
    isStrechable: function () {
        return !this.getKeepAspectRatio();
    },

    /**
     * @method
     * Return false if you avoid that the user can delete your figure.
     * Sub class can override this method.
     *
     * @return {boolean}
     **/
    isDeleteable: function () {
        return this.deleteable;
    },

    /**
     * @method
     * Set the flag if the shape is deleteable.
     *
     * @param {boolean} flag enable or disable flag for the delete operation
     **/
    setDeleteable: function (flag) {
        this.deleteable = !!flag;
        this.fireEvent("change:deleteable");

        return this;
    },

    /**
     * @method
     * Set the parent of this figure.
     * Don't call them manually.
     *
     * @param {draw2d.Figure} parent The new parent of this figure
     * @private
     **/
    setParent: function (parent) {
        this.parent = parent;

        return this;
    },

    /**
     * @method
     * Get the parent of this figure.
     *
     * @return {draw2d.Figure}
     **/
    getParent: function () {
        return this.parent;
    },

    /**
     * @method
     * Get the top most parent of this figure. This can be an layout figure or parent container
     *
     * @return {draw2d.Figure}
     * @since 5.0.6
     **/
    getRoot: function () {
        var root = this.parent;
        while (root !== null && root.parent !== null) {
            root = root.parent;
        }
        return root;
    },

    /**
     * @method
     * Set the assigned composite of this figure.
     *
     * @param {draw2d.shape.composite.StrongComposite} composite The assigned composite of this figure
     * @private
     * @since 4.8.0
     **/
    setComposite: function (composite) {
        if (composite !== null && !(composite instanceof draw2d.shape.composite.StrongComposite)) {
            throw "'composite must inherit from 'draw2d.shape.composite.StrongComposite'";
        }

        this.composite = composite;

        return this;
    },

    /**
     * @method
     * Get the assigned composite of this figure.
     *
     * @return {draw2d.shape.composite.StrongComposite}
     * @since 4.8.0
     **/
    getComposite: function () {
        return this.composite;
    },

    // NEW EVENT HANDLING SINCE VERSION 5.0.0
    /**
     * @method
     * Execute all handlers and behaviors attached to the figure for the given event type.
     *
     *
     * @param {String} event the event to trigger
     * @param {Object} [args] optional parameters for the triggered event callback
     *
     * @since 5.0.0
     */
    fireEvent: function (event, args) {
        try {
            if (typeof this.eventSubscriptions[event] === 'undefined') {
                return;
            }

            // avoid recursion
            if (this._inEvent === true) {
                return;
            }
            this._inEvent = true;
            var subscribers = this.eventSubscriptions[event];
            for (var i = 0; i < subscribers.length; i++) {
                subscribers[i](this, args);
            }
        }
        finally {
            this._inEvent = false;

            // fire a generic change event if an attribute has changed
            // required for some DataBinding frameworks or for the Backbone.Model compatibility
            // the event "change" with the corresponding attribute name as additional parameter
            if (event.substring(0, 7) === "change:") {
                this.fireEvent("change", event.substring(7));
            }
        }
    },

    /**
     * @method
     * Attach an event handler function for one or more events to the figure.
     * To remove events bound with .on(), see {@link #off}.
     *
     * possible events are:<br>
     * <ul>
     *   <li>click</li>
     *   <li>dblclick</li>
     *   <li>move</li>
     *   <li>resize</li>
     *   <li>timer</li>
     *   <li>contextmenu</li>
     *   <li>show</li>
     *   <li>hide</li>
     *   <li>change:[attr]</li>
     * </ul>
     *
     * @param {String}   event One or more space-separated event types
     * @param {Function} callback A function to execute when the event is triggered.
     * @param {draw2d.Figure} callback.emitter the emitter of the event
     * @param {Object} [callback.obj] optional event related data
     * @param {Object} [context] optional context of the fucntion callback.
     * @since 5.0.0
     */
    on: function (event, callback, context) {
        var events = event.split(" ");
        // the "context" param is add to be compatible with Backbone.Model.
        // The project "backbone.ModelBinder" used this signature and we want use this
        if (context) {
            callback = $.proxy(callback, context);
            callback.___originalCallback = callback;
        }

        for (var i = 0; i < events.length; i++) {
            if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
                this.eventSubscriptions[events[i]] = [];
            }
            this.eventSubscriptions[events[i]].push(callback);
        }
        return this;
    },

    /**
     * @method
     * The .off() method removes event handlers that were attached with {@link #on}.<br>
     * Calling .off() with no arguments removes all handlers attached to the elements.<br>
     * <br>
     * If a simple event name such as "move" is provided, all events of that type are removed from the figure.
     *
     *
     * @param {String|Function} eventOrFunction the event name of the registerd function or the function itself
     * @since 5.0.0
     */
    off: function (eventOrFunction) {
        if (typeof eventOrFunction === "undefined") {
            this.eventSubscriptions = {};
        }
        else if (typeof eventOrFunction === 'string') {
            this.eventSubscriptions[eventOrFunction] = [];
        }
        else {
            for (var event in this.eventSubscriptions) {
                this.eventSubscriptions[event] = $.grep(this.eventSubscriptions[event], function (callback) {
                    if (typeof callback.___originalCallback !== "undefined") {
                        return callback.___originalCallback !== eventOrFunction;
                    }
                    return callback !== eventOrFunction;
                });
            }
        }

        return this;
    },

    /**
     * @method
     * Returns the Command to perform the specified Request or null.
     *
     * @param {draw2d.command.CommandType} request describes the Command being requested
     * @return {draw2d.command.Command} null or a Command
     * @private
     **/
    createCommand: function (request) {
        if (request === null) {
            return null;
        }

        if (request.getPolicy() === draw2d.command.CommandType.MOVE) {
            if (!this.isDraggable()) {
                return null;
            }
            return new draw2d.command.CommandMove(this);
        }

        if (request.getPolicy() === draw2d.command.CommandType.DELETE) {
            if (!this.isDeleteable()) {
                return null;
            }
            return new draw2d.command.CommandDelete(this);
        }

        if (request.getPolicy() === draw2d.command.CommandType.RESIZE) {
            if (!this.isResizeable()) {
                return null;
            }
            return new draw2d.command.CommandResize(this);
        }

        return null;
    },

    /**
     * @method
     * Clone the figure. <br>
     * You must override and implement the methods <b>getPersistentAttributes</b> and <b>setPersistentAttributes</b> for your custom
     * figures if the have special attributes.
     *
     * @since 4.1.0
     * @experimental
     */
    clone: function () {
        var clone = eval("new " + this.NAME + "();");
        var initialId = clone.id;

        clone.setPersistentAttributes(this.getPersistentAttributes());

        clone.id = initialId;

        // add all decorations to the memento
        //
        clone.resetChildren();
        this.children.each(function (i, entry) {
            var child = entry.figure.clone();
            var locator = eval("new " + entry.locator.NAME + "();");
            clone.add(child, locator);
        });

        return clone;
    },

    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @return
     */
    getPersistentAttributes: function () {
        // force deep copy of userData to avoid side effects in the clone method.
        //
        var memento = {
            type: this.NAME,
            id: this.id,
            x: this.getX(),
            y: this.getY(),
            width: this.width,
            height: this.height,
            alpha: this.alpha,
            userData: $.extend(true, {}, this.userData)
        };


        if (this.cssClass !== null) {
            memento.cssClass = this.cssClass;
        }

        if (this.composite !== null) {
            memento.composite = this.composite.getId();
        }

        if (typeof memento.alpha !== "undefined") {
            this.setAlpha(parseFloat(memento.alpha));
        }

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     */
    setPersistentAttributes: function (memento) {
        this.id = memento.id;
        this.x = parseFloat(memento.x);
        this.y = parseFloat(memento.y);

        // width and height are optional parameter for the JSON stuff.
        // We use the defaults if the attributes not present
        if (typeof memento.width !== "undefined") {
            this.width = parseFloat(memento.width);
        }

        if (typeof memento.height !== "undefined") {
            this.height = parseFloat(memento.height);
        }

        if (typeof memento.userData !== "undefined") {
            this.userData = memento.userData;
        }

        if (typeof memento.cssClass !== "undefined") {
            this.setCssClass(memento.cssClass);
        }

        if (typeof memento.alpha !== "undefined") {
            this.setAlpha(parseFloat(memento.alpha));
        }
        return this;
    }

});

/**
 * @class draw2d.shape.node.Node
 *
 * A Node is the base class for all figures which can have {@link draw2d.Port}s. A {@link draw2d.Port} is the
 * anchor for a {@link draw2d.Connection} line.<br><br>A {@link draw2d.Port} is a green dot which can
 * be dragged and dropped over another port.<br>
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.Figure
 */
draw2d.shape.node.Node = draw2d.Figure.extend({

    NAME: "draw2d.shape.node.Node",

    /**
     * @constructor
     * Creates a new Node element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.inputPorts = new draw2d.util.ArrayList();
        this.outputPorts = new draw2d.util.ArrayList();
        this.hybridPorts = new draw2d.util.ArrayList();

        // flag which indicates if the figure should read/write ports to
        // JSON
        this.persistPorts = true;

        // Flags just for performance reasons
        //
        this.portRelayoutRequired = true;

        // just for performance reasons
        //
        this.cachedPorts = null;

        this._super(
            $.extend({width: 50, height: 50}, attr),
            $.extend({
                /** @attr {Number} radius the radius to render the line edges */
                persistPorts: this.setPersistPorts
            }, setter),
            $.extend({
                persistPorts: this.getPersistPorts
            }, getter));
    },


    /**
     * @method
     * Indicates if the node should read/write the ports via the draw2d.Figure.getPersistenAttributes
     * to the JSON object
     *
     * @param {Boolean} flag
     * @since 5.0.4
     */
    setPersistPorts: function (flag) {
        this.persistPorts = flag;
        this.fireEvent("change:persistPorts");

        return this;
    },

    /**
     * @method
     * Indicates if the figure writes the ports to the JSON structore too.
     * Default is "false"
     *
     * @returns {Boolean}
     */
    getPersistPorts: function () {
        return this.persistPorts;
    },

    /**
     * @inheritdoc
     */
    onDoubleClick: function () {
        this.canvas.getCommandStack().execute(new draw2d.command.CommandRotate(this, (this.getRotationAngle() + 90) % 360));
    },

    /**
     * @inheritdoc
     */
    toFront: function (figure) {
        this._super(figure);

        var _this = this;
        this.getPorts().each(function (i, port) {
            port.getConnections().each(function (i, connection) {
                connection.toFront(figure);
            });
            // a port should always be in front of the shape dosn't matter what the
            // "figure" parameter says.
            //
            port.toFront(_this);
        });

        return this;
    },

    /**
     * @inheritdoc
     */
    toBack: function (figure) {

        this.getPorts().each(function (i, port) {
            port.getConnections().each(function (i, connection) {
                connection.toBack(figure);
            });
            port.toBack(figure);
        });

        this._super(figure);

        return this;
    },

    /**
     * @inheritdoc
     */
    setVisible: function (flag) {
        // adjust the visibility of the ports to the parent state
        //
        if (!flag) {
            this.getPorts().each(function (i, port) {
                port.__initialVisibilityState = port.isVisible();
                port.setVisible(false);
            });
        }
        else {
            this.getPorts().each(function (i, port) {
                if (typeof port.__initialVisibilityState !== "undefined") {
                    port.setVisible(port.__initialVisibilityState);
                }
                else {
                    port.setVisible(true);
                }
                delete port.__initialVisibilityState;
            });
        }
        this._super(flag);
    },


    /**
     * @method
     * Return all ports of the node.
     *
     * @return  {draw2d.util.ArrayList}
     **/
    getPorts: function () {
        // TODO: expensive! Find another solution.
        if (this.cachedPorts === null) {
            this.cachedPorts = new draw2d.util.ArrayList();
            this.cachedPorts.addAll(this.inputPorts);
            this.cachedPorts.addAll(this.outputPorts);
            this.cachedPorts.addAll(this.hybridPorts);

            var _this = this;
            this.children.each(function (i, e) {
                _this.cachedPorts.addAll(e.figure.getPorts());
            });
        }

        return this.cachedPorts;
    },


    /**
     * @method
     * Return all input ports of the node.
     *
     * @return {draw2d.util.ArrayList}
     **/
    getInputPorts: function () {
        return this.inputPorts
            .clone()
            .addAll(this.hybridPorts);
    },

    /**
     * @method
     * Return all output ports of the node.
     *
     * @return {draw2d.util.ArrayList}
     **/
    getOutputPorts: function () {
        return this.outputPorts
            .clone()
            .addAll(this.hybridPorts);
    },


    /**
     * @inheritdoc
     */
    clone: function () {
        var clone = this._super();

        // remove all ports of the clone. the "init" method can have create some. but this must
        // removed because we want a clone of an existing figure
        //
        clone.resetPorts();
        var ports = this.getPorts();

        ports.each(function (i, port) {
            var clonePort = port.clone();
            var locator = port.getLocator().clone();
            clone.addPort(clonePort, locator);
        });

        return clone;
    },

    /**
     * @method
     * Return the port with the corresponding name.
     *
     *
     * @param {String} portName The name of the port to return.
     * @return {draw2d.Port} Returns the port with the hands over name or null.
     **/
    getPort: function (portName) {
        var port = null;

        this.getPorts().each(function (i, e) {

            if (e.getName() === portName) {
                port = e;
                return false;
            }
        });

        return port;
    },

    /**
     * @method
     * Return the input port with the corresponding name.
     *
     *
     * @param {String/Number} portNameOrIndex The name or numeric index of the port to return.
     * @return {draw2d.InputPort} Returns the port with the hands over name or null.
     **/
    getInputPort: function (portNameOrIndex) {
        if (typeof portNameOrIndex === "number") {
            return this.inputPorts.get(portNameOrIndex);
        }

        for (var i = 0; i < this.inputPorts.getSize(); i++) {
            var port = this.inputPorts.get(i);
            if (port.getName() === portNameOrIndex) {
                return port;
            }
        }

        return null;
    },

    /**
     * @method
     * Return the output port with the corresponding name.
     *
     * @param {String/Number} portNameOrIndex The name or the numeric index of the port to return.
     * @return {draw2d.OutputPort} Returns the port with the hands over name or null.
     **/
    getOutputPort: function (portNameOrIndex) {
        if (typeof portNameOrIndex === "number") {
            return this.outputPorts.get(portNameOrIndex);
        }

        for (var i = 0; i < this.outputPorts.getSize(); i++) {
            var port = this.outputPorts.get(i);
            if (port.getName() === portNameOrIndex) {
                return port;
            }
        }

        return null;
    },

    /**
     * @method
     * Return the input port with the corresponding name.
     *
     *
     * @param {String/Number} portNameOrIndex The name or numeric index of the port to return.
     * @return {draw2d.InputPort} Returns the port with the hands over name or null.
     **/
    getHybridPort: function (portNameOrIndex) {
        if (typeof portNameOrIndex === "number") {
            return this.hybridPorts.get(portNameOrIndex);
        }

        for (var i = 0; i < this.hybridPorts.getSize(); i++) {
            var port = this.hybridPorts.get(i);
            if (port.getName() === portNameOrIndex) {
                return port;
            }
        }

        return null;
    },

    /**
     * @method
     * Add a port to this node at the given position.<br>
     *
     * @param {draw2d.Port} port The new port to add.
     * @param {draw2d.layout.locator.Locator} locator The layouter for the port.
     **/
    addPort: function (port, locator) {
        if (!(port instanceof draw2d.Port)) {
            throw "Argument is not typeof 'draw2d.Port'. \nFunction: draw2d.shape.node.Node#addPort";
        }

        // add to the internal cache if already build
        if (this.cachedPorts !== null) {
            this.cachedPorts.add(port);
        }
        this.portRelayoutRequired = true;


        if (port instanceof draw2d.InputPort) {
            this.inputPorts.add(port);
        }
        else if (port instanceof draw2d.OutputPort) {
            this.outputPorts.add(port);
        }
        else if (port instanceof draw2d.HybridPort) {
            this.hybridPorts.add(port);
        }

        if ((typeof locator !== "undefined") && (locator instanceof draw2d.layout.locator.Locator)) {
            port.setLocator(locator);
        }

        port.setParent(this);
        port.setCanvas(this.canvas);

        // You can't delete a port with the [DEL] key if a port is a child of a node
        port.setDeleteable(false);

        if (this.canvas !== null) {
            port.getShapeElement();
            this.canvas.registerPort(port);
        }
    },

    /**
     * @method
     * Remove all ports of this node
     *
     * @since 5.0.0
     */
    resetPorts: function () {
        var _this = this;
        this.getPorts().each(function (i, port) {
            _this.removePort(port);
        });

        return this;
    },


    /**
     * @method
     * Removes a port and all related connections from this node.<br>
     *
     * @param {draw2d.Port} port The port to remove.
     **/
    removePort: function (port) {
        this.portRelayoutRequired = true;

        this.cachedPorts = null;
        this.inputPorts.remove(port);
        this.outputPorts.remove(port);
        this.hybridPorts.remove(port);

        if (port.getCanvas() !== null) {
            port.getCanvas().unregisterPort(port);
            // remove the related connections of the port too.
            var connections = port.getConnections();
            for (var i = 0; i < connections.getSize(); ++i) {
                port.getCanvas().remove(connections.get(i));
            }
        }

        port.setCanvas(null);
    },

    /**
     * @method
     * Create a standard Port for this element. Inherited class can override this
     * method to create its own type of ports.
     *
     * @param {String} type the type of the requested port. possible ["input", "output"]
     * @param {draw2d.layout.locator.Locator} [locator] the layouter to use for this port
     * @template
     */
    createPort: function (type, locator) {
        var newPort = null;
        var count = 0;

        switch (type) {
            case "input":
                newPort = new draw2d.InputPort();
                newPort.setBackgroundColor('#f3546a');
                count = this.inputPorts.getSize();
                break;
            case "output":
                newPort = new draw2d.OutputPort();
                newPort.setBackgroundColor('#b9dd69');
                count = this.outputPorts.getSize();
                break;
            case "hybrid":
                newPort = new draw2d.HybridPort();
                count = this.hybridPorts.getSize();
                break;
            case "extend":
                newPort = new draw2d.OutputPort();
                count = this.outputPorts.getSize();
                break;
            default:
                throw "Unknown type [" + type + "] of port requested";
        }

        newPort.setName(type + count);

        this.addPort(newPort, locator);
        // relayout the ports
        this.setDimension(this.width, this.height);

        this.layoutPorts();

        return newPort;
    },

    /**
     * @method
     * Return all connections related to this node.
     *
     * @returns {draw2d.util.ArrayList}
     */
    getConnections: function () {
        var connections = new draw2d.util.ArrayList();
        var ports = this.getPorts();
        for (var i = 0; i < ports.getSize(); i++) {
            var port = ports.get(i);
            // Do NOT add twice the same connection if it is linking ports from the same node
            for (var c = 0, c_size = port.getConnections().getSize(); c < c_size; c++) {
                if (!connections.contains(port.getConnections().get(c))) {
                    connections.add(port.getConnections().get(c));
                }
            }
        }
        return connections;
    },

    /**
     * @inheritdoc
     */
    setCanvas: function (canvas) {
        var oldCanvas = this.canvas;
        this._super(canvas);

        var ports = this.getPorts();
        if (oldCanvas !== null) {
            ports.each(function (i, port) {
                oldCanvas.unregisterPort(port);
            });
        }

        if (canvas !== null) {
            ports.each(function (i, port) {
                port.setCanvas(canvas);
                canvas.registerPort(port);
            });
            // relayout the ports
            this.setDimension(this.width, this.height);
        }
        else {
            ports.each(function (i, port) {
                port.setCanvas(null);
            });
        }
    },

    /**
     * @inheritdoc
     */
    setRotationAngle: function (angle) {
        this.portRelayoutRequired = true;
        this._super(angle);

        this.layoutPorts();
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        this.portRelayoutRequired = true;
        this._super(w, h);
    },

    /**
     * @method
     * Called if the value of any port has been changed
     *
     * @param {draw2d.Port} relatedPort
     * @template
     */
    onPortValueChanged: function (relatedPort) {

    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        this._super(attributes);
        this.layoutPorts();
    },

    /**
     * @method
     *
     * @private
     */
    layoutPorts: function () {

        if (this.portRelayoutRequired === false) {
            return;//silently
        }
        this.portRelayoutRequired = false;

        // layout the ports
        //
        this.outputPorts.each(function (i, port) {
            port.locator.relocate(i, port);
        });

        this.inputPorts.each(function (i, port) {
            port.locator.relocate(i, port);
        });

        this.hybridPorts.each(function (i, port) {
            port.locator.relocate(i, port);
        });
    },

    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        // write all ports to the JSON
        //
        if (this.persistPorts === true) {
            memento.ports = [];
            this.getPorts().each(function (i, port) {
                memento.ports.push({
                    name: port.getName(),
                    port: port.NAME,
                    locator: port.getLocator().NAME
                });
            });
        }

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.ports !== "undefined") {
            // we read the ports from the JSON and now we save it to the JSON too.
            this.persistPorts = true;

            // remove all ports created in the init method
            //
            this.resetPorts();

            // and restore all ports of the JSON document instead.
            //
            $.each(memento.ports, $.proxy(function (i, e) {
                var port = eval("new " + e.port + "()");
                var locator = eval("new " + e.locator + "()");

                this.addPort(port, locator);
                port.setName(e.name);
            }, this));
        }
    }

});

/**
 * @class draw2d.VectorFigure
 * The base class for all vector based figures like {@link draw2d.shape.basic.Rectangle}  or {@link draw2d.shape.basic.Oval}
 * inside a canvas.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.node.Node
 */
draw2d.VectorFigure = draw2d.shape.node.Node.extend({
    NAME: "draw2d.VectorFigure",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.stroke = 1;
        this.radius = 0;
        this.bgColor = new draw2d.util.Color("#ffffff");
        this.color = new draw2d.util.Color("#303030");

        // memento for the stroke if we reset the glow effect of this shape
        //
        this.strokeBeforeGlow = this.stroke;
        this.glowIsActive = false;

        this._super(attr,
            $.extend({
                /** @attr {Number} radius the radius to render the line edges */
                radius: this.setRadius,
                /** @attr {String|draw2d.util.Color} bgColor the background color of the shape */
                bgColor: this.setBackgroundColor,
                /** @attr {String|draw2d.util.Color} color the main color of the shape */
                color: this.setColor,
                /** @attr {Number} stroke the stroke width */
                stroke: this.setStroke
            }, setter),
            $.extend({
                radius: this.getRadius,
                bgColor: this.getBackgroundColor,
                color: this.getColor,
                stroke: this.getStroke
            }, getter)
        );
    },

    /**
     * @method
     * Sets the corner radius or the edges.
     *
     * @param {Number} radius
     * @since 4.2.1
     */
    setRadius: function (radius) {
        this.radius = radius;
        this.repaint();
        this.fireEvent("change:radius");

        return this;
    },

    /**
     * @method
     * Get the corner radius of the edges.
     *
     * @return {Number}
     * @since 4.2.1
     */
    getRadius: function () {
        return this.radius;
    },


    /**
     * @method
     * Highlight the element or remove the highlighting
     *
     * @param {Boolean} flag indicates glow/noGlow
     */
    setGlow: function (flag) {

        if (flag === this.glowIsActive) {
            return this;
        }

        this.glowIsActive = flag;
        if (flag === true) {
            this.strokeBeforeGlow = this.getStroke();
            this.setStroke(this.strokeBeforeGlow * 2.5);
        }
        else {
            this.setStroke(this.strokeBeforeGlow);
        }

        return this;
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();

        if (typeof attributes.stroke === "undefined") {
            if (this.color === null || this.stroke === 0) {
                attributes.stroke = "none";
            }
            else {
                attributes.stroke = this.color.hash();
            }
        }

        if (typeof attributes["stroke-width"] === "undefined") {
            attributes["stroke-width"] = this.stroke;
        }

        if (typeof attributes.fill === "undefined") {
            attributes.fill = this.bgColor.hash();
        }

        this._super(attributes);

        return this;
    },

    /**
     * @method
     * Set the new background color of the figure. It is possible to hands over
     * <code>null</code> to set the background transparent.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        "bgColor": "#f0f0f0"
    *      });
     *
     * @param {String|draw2d.util.Color} color The new background color of the figure
     **/
    setBackgroundColor: function (color) {
        this.bgColor = new draw2d.util.Color(color);

        this.repaint();
        this.fireEvent("change:bgColor");

        return this;
    },

    /**
     * @method
     * The current used background color.
     *
     *      // Alternatively you can use the attr method:
     *      var color =figure.attr("bgColor");
     *
     * @return {draw2d.util.Color}
     */
    getBackgroundColor: function () {
        return this.bgColor;
    },

    /**
     * @method
     * Set the stroke to use.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        "stroke": 2
    *      });
     *
     * @param {Number} w The new line width of the figure
     **/
    setStroke: function (w) {
        this.stroke = w;
        this.repaint();
        this.fireEvent("change:stroke");

        return this;
    },

    /**
     * @method
     * The used line width.
     *
     * @type {Number}
     **/
    getStroke: function () {
        return this.stroke;
    },

    /**
     * @method
     * Set the foreground color of the figure.
     * This method fires a <i>document dirty</i> event.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        "color": "#f3f3f3"
    *      });
     *
     * @param {String|draw2d.util.Color} color The new color of the line.
     **/
    setColor: function (color) {
        this.color = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:color");

        return this;
    },

    /**
     * @method
     * Get the current used foreground color
     *
     *
     * @returns {draw2d.util.Color}
     */
    getColor: function () {
        return this.color;
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        return $.extend(this._super(), {
            bgColor: this.bgColor.hash(),
            color: this.color.hash(),
            stroke: this.stroke,
            radius: this.radius
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.radius !== "undefined") {
            this.setRadius(memento.radius);
        }

        if (typeof memento.bgColor !== "undefined") {
            this.setBackgroundColor(memento.bgColor);
        }

        if (typeof memento.color !== "undefined") {
            this.setColor(memento.color);
        }

        if (typeof memento.stroke !== "undefined") {
            this.setStroke(parseFloat(memento.stroke));
        }

        return this;
    }


});

/**
 * @class draw2d.shape.basic.Rectangle
 * A Rectangle Figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var rect1 =  new draw2d.shape.basic.Rectangle({
 *     	x:10,
 *      y:10
 *     });
 *
 *     var rect2 =  new draw2d.shape.basic.Rectangle({
 *       x: 100,
 *       y: 10,
 *       bgColor: "#f0f000",
 *       alpha  : 0.7,
 *       width: 100,
 *       height: 60,
 *       radius: 10
 *     });
 *
 *     canvas.add(rect1);
 *     canvas.add(rect2);
 *
 *     canvas.setCurrentSelection(rect2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Rectangle = draw2d.VectorFigure.extend({
    NAME: "draw2d.shape.basic.Rectangle",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.dasharray = null;


        this._super(
            $.extend({bgColor: "#a0a0a0", color: "#1B1B1B"}, attr),
            $.extend({}, {
                /** @attr {String} dash The dot/dash pattern for the line style. Valid values: ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]*/
                dash: this.setDashArray
            }, setter),
            $.extend({}, {
                dash: this.getDashArray
            }, getter)
        );

        // some performance improvements
        this.lastAppliedRotation = -1;
    },

    /**
     * @inheritdoc
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = $.extend({}, {
            width: this.getWidth(),
            height: this.getHeight(),
            r: this.getRadius()
        }, attributes);

        if (this.dasharray !== null) {
            attributes["stroke-dasharray"] = this.dasharray;
        }

        this._super(attributes);

        return this;
    },

    /**
     * @inheritdoc
     */
    applyTransformation: function () {
        this.shape.transform("R" + this.rotationAngle);

        if (this.getRotationAngle() === 90 || this.getRotationAngle() === 270) {
            var ratio = this.getHeight() / this.getWidth();
            var rs = "...S" + ratio + "," + 1 / ratio + "," + (this.getAbsoluteX() + this.getWidth() / 2) + "," + (this.getAbsoluteY() + this.getHeight() / 2);
            this.shape.transform(rs);
        }

        return this;
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        return this.canvas.paper.rect(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
    },


    /**
     * @method
     * Set the line style for dot/dash styling. Possible values are
     * ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
     *        dash: pattern
     *      });
     *
     * @param {String} pattern the string with the dot/dash pattern. valid values: ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
     */
    setDashArray: function (pattern) {
        this.dasharray = pattern;
        this.repaint();
        this.fireEvent("change:dashArray");

        return this;
    },

    /**
     * @method
     * Get the line style for this object.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr("dash");
     *
     * @since 5.1.0
     */
    getDashArray: function (dashPattern) {
        return this.dasharray;
    },

    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        if (this.dasharray !== null) {
            memento.dasharray = this.dasharray;
        }

        return memento;
    },


    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.dasharray === "string") {
            this.dasharray = memento.dasharray;
        }

        return this;
    }

});
/**
 * @class draw2d.shape.basic.Image
 * Simple Image shape.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.node.Node
 */
draw2d.shape.basic.Image = draw2d.shape.node.Node.extend({
    NAME: "draw2d.shape.basic.Image",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr,
            $.extend({
                /** @attr {String} path the image path (absolute or relative) of the shape */
                path: this.setPath
            }, setter),
            $.extend({
                path: this.getPath
            }, getter));
    },


    /**
     * @method
     * Set the image path attribute of the Image shape and repaint them.
     * The path can be relative or absolute
     *
     * @param path
     * @since 2.8.0
     */
    setPath: function (path) {
        this.path = path;

        if (this.shape !== null) {
            this.shape.attr({src: this.path});
        }
        this.fireEvent("change:path");

        return this;
    },

    /**
     * @method
     * Return the image path attribute of the shape.
     *
     * @returns {String}
     * @since 2.8.0
     */
    getPath: function () {
        return this.path;
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return this;
        }

        attributes = attributes || {};

        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();
        attributes.width = this.getWidth();
        attributes.height = this.getHeight();
        attributes.src = this.path;

        // propagate the width/height as CSS attribute as well because Chrome
        // did some "flickering" in some versions and sometimes the image disappear complete
        $(this.shape.node).css({width: attributes.width, height: attributes.height});

        this._super(attributes);

        return this;
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        return this.canvas.paper.image(this.path, this.getX(), this.getY(), this.getWidth(), this.getHeight());
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        return $.extend(this._super(), {
            path: this.path
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);
        if (typeof memento.path !== "undefined") {
            this.setPath(memento.path);
        }
    }

});


/**
 * @class draw2d.shape.basic.Polygon
 * A Polygon figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var p1 =  new draw2d.shape.basic.Polygon({width:100, height:100});
 *     var p2 =  new draw2d.shape.basic.Polygon({width:100, height:60});
 *
 *     canvas.add(p1,10,10);
 *     canvas.add(p2,100,10);
 *
 *     p2.attr({color:"#f0f000", alpha:0.7});
 *
 *     canvas.setCurrentSelection(p2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Polygon = draw2d.VectorFigure.extend({

    NAME: "draw2d.shape.basic.Polygon",

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.minX = 0;
        this.minY = 0;
        this.maxX = 0;
        this.maxY = 0;
        this.vertices = new draw2d.util.ArrayList();

        this._super(attr);

        // we must cache the initial width/height because the width/height of the shape
        // is recalculated in the addVertex method. After the first call this values are 0/0
        if (this.vertices.getSize() === 0) {
            var w = this.width;
            var h = this.height;
            var pos = this.getPosition();
            this.addVertex(new draw2d.geo.Point(0, 0));
            this.addVertex(new draw2d.geo.Point(w, 0));
            this.addVertex(new draw2d.geo.Point(w, h));

            this.setPosition(pos);
        }

        this.svgPathString = null;

        this.installEditPolicy(new draw2d.policy.figure.VertexSelectionFeedbackPolicy());
    },

    /**
     * @inheritdoc
     */
    setRadius: function (radius) {
        this.svgPathString = null;

        this._super(radius);
        this.fireEvent("change:radius");

        return this;
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        // return some good default...
        return this.canvas.paper.path("M0 10L100 100");
    },

    /**
     * @method
     * calculate the path of the polygon
     *
     */
    calculatePath: function () {
        var radius = this.getRadius();
        var path = [];
        if (radius === 0) {
            var length = this.vertices.getSize();
            var p = this.vertices.get(0);
            path.push("M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
            for (var i = 1; i < length; i++) {
                p = this.vertices.get(i);
                path.push("L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
            }
            path.push("Z");
        }
        else {
            length = this.vertices.getSize();
            var start = this.vertices.first();
            var end = this.vertices.last();
            var begin = this.insetPoint(start, end, radius);
            path.push("M", (begin.x | 0) + 0.5, ",", (begin.y | 0) + 0.5);
            for (var i = 0; i < length; i++) {
                start = this.vertices.get(i);
                end = this.vertices.get((i + 1) % length);
                modStart = this.insetPoint(start, end, radius);
                modEnd = this.insetPoint(end, start, radius);
                path.push("Q", start.x, ",", start.y, " ", (modStart.x | 0) + 0.5, ", ", (modStart.y | 0) + 0.5);
                path.push("L", (modEnd.x | 0) + 0.5, ",", (modEnd.y | 0) + 0.5);
            }
        }
        this.svgPathString = path.join("");
        return this;
    },

    /**
     * @method
     * Returns a new ray with a new length but with the same direction of the start/end.
     *
     * @param start
     * @param end
     * @param distanceFromStart
     * @private
     * @returns
     */
    insetPoint: function (start, end, distanceFromStart) {
        if (start.equals(end)) {
            return start;
        }
        var vx = start.x - end.x;
        var vy = start.y - end.y;
        var length = Math.sqrt(vx * vx + vy * vy);
        var localDistance = Math.min(length / 2, distanceFromStart);
        return {
            x: end.x + vx / length * (length - localDistance),
            y: end.y + vy / length * (length - localDistance)
        };

    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        if (this.svgPathString === null) {
            this.calculatePath();
        }

        attributes = attributes || {};

        if (typeof attributes.path === "undefined") {
            attributes.path = this.svgPathString;
        }

        this._super(attributes);
    },

    /**
     * @method
     * Translate the figure with the given x/y offset. This method modifies all
     * vertices and the bounding box.
     *
     * @param {Number} dx The new x translate offset
     * @param {Number} dy The new y translate offset
     **/
    translate: function (dx, dy) {
        this.vertices.each(function (i, e) {
            e.translate(dx, dy);
        });
        this.svgPathString = null;

        this.repaint();

        this.updateBoundingBox();

        // Update the resize handles if the user change the position of the
        // element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("move");
        this.fireEvent("change:position");

        return this;
    },

    /**
     * @method
     * Change the position of the polygon. This method updates all vertices.
     *
     * @param {Number|draw2d.geo.Point} x
     * @param {Number} y
     */
    setPosition: function (x, y) {
        if (x instanceof draw2d.geo.Point) {
            y = x.y;
            x = x.x;
        }

        var dx = x - this.minX;
        var dy = y - this.minY;
        this.translate(dx, dy);

        this.x = x;
        this.y = y;

        return this;
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        var oldWidth = this.width;
        var oldHeight = this.height;

        this._super(w, h);

        var fracWidth = (1 / oldWidth) * this.width;
        var fracHeight = (1 / oldHeight) * this.height;

        var thisX = this.x;
        var thisY = this.y;
        this.vertices.each(function (i, e) {
            // calculate difference between point and figure origin
            var diffX = (e.getX() - thisX) * fracWidth;
            var diffY = (e.getY() - thisY) * fracHeight;
            e.setPosition(thisX + diffX, thisY + diffY);
        });

        this.svgPathString = null;
        this.repaint();
        this.fireEvent("change:dimension");

        return this;
    },

    /**
     * @method
     * Return all vertices of the polygon.
     *
     * @returns {draw2d.util.ArrayList}
     */
    getVertices: function () {
        return this.vertices;
    },


    /**
     * @method
     * Return the Vertex with the given index.
     *
     * @param {Number} index the index of the vertex to return
     * @since 5.0.2
     */
    getVertex: function (index) {
        return this.vertices.get(index);
    },

    resetVertices: function () {
        this.vertices = new draw2d.util.ArrayList();

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
    },

    /**
     * @method
     * Update the vertex at the given index. The method call didn't have any effect
     * if the vertex didn't exists.
     *
     * @param {Number} index
     * @param {Number} x
     * @param {Number} y
     */
    setVertex: function (index, x, y) {
        var vertex = this.vertices.get(index);

        // invalid point or nothing todo
        //
        if (vertex === null || (vertex.x === x && vertex.y === y)) {
            return this;
        }

        vertex.x = parseFloat(x);
        vertex.y = parseFloat(y);

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertex");

        return this;
    },

    /**
     * @method
     * Append a new vertex to the polygon.
     *
     * @param {Number} x
     * @param {Number} y
     */
    addVertex: function (x, y) {
        var vertex = null;
        if (x instanceof draw2d.geo.Point) {
            vertex = x.clone();
        }
        else {
            vertex = new draw2d.geo.Point(x, y);
        }
        this.vertices.add(vertex);


        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertices");

        return this;
    },

    /**
     * @method
     * Insert a new vertex at the given index. All vertices will be shifted to
     * free the requested index.
     *
     * @param {Number} index
     * @param {Number} x
     * @param {Number} y
     */
    insertVertexAt: function (index, x, y) {
        var vertex = new draw2d.geo.Point(x, y);

        this.vertices.insertElementAt(vertex, index);

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return this;
    },


    /**
     * @method
     * Remove a vertex from the polygon and return the removed point.
     *
     * @param {Number} index
     *
     * @returns {draw2d.geo.Point} the removed vertex
     */
    removeVertexAt: function (index) {
        // a polygon need at least 3 vertices
        //
        if (this.vertices.getSize() <= 3) {
            return null;
        }

        var vertex = this.vertices.removeElementAt(index);

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return vertex;
    },


    /**
     * @inheritdoc
     */
    setRotationAngle: function (angle) {
        this.rotationAngle = 360 % angle;

        // The different to the other figures is, the the vertices must rotated instead of
        // transform the shape with SVG matrix.
        //
        // Reason: the vertices are selectable and in this case the coordinates must transform
        //         and not only the resulting SVG shape.
        //
        var radian = angle / (180 / Math.PI);
        var center = this.getBoundingBox().getCenter();
        var rotate = function (x, y, xm, ym, radian) {
            var cos = Math.cos,
                sin = Math.sin;
            return {
                x: (x - xm) * cos(radian) - (y - ym) * sin(radian) + xm,
                y: (x - xm) * sin(radian) + (y - ym) * cos(radian) + ym
            };
        };

        this.vertices.each(function (i, e) {
            var rot = rotate(e.x, e.y, center.x, center.y, radian);
            e.setPosition(rot.x, rot.y);
        });

        this.updateBoundingBox();


        // Update the resize handles if the user change the position of the element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.repaint();
        this.fireEvent("change:angle");

        return this;
    },

    /**
     * @method
     * Calculate the bounding box of the shape and store them in an internal
     * variable for fast access.
     *
     * @private
     */
    updateBoundingBox: function () {
        if (this.vertices.isEmpty()) {
            this.minX = this.x;
            this.minY = this.y;
            this.maxX = this.x + this.width;
            this.maxY = this.y + this.height;
        }
        else {
            this.minX = this.x = Math.min.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.x;
            }));
            this.minY = this.y = Math.min.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.y;
            }));
            this.maxX = Math.max.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.x;
            }));
            this.maxY = Math.max.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.y;
            }));
            this.width = this.maxX - this.minX;
            this.height = this.maxY - this.minY;
        }
    },


    /**
     * @inheritdoc
     */
    createCommand: function (request) {

        if (request.getPolicy() === draw2d.command.CommandType.MOVE_VERTEX) {
            if (this.isResizeable() === true) {
                return new draw2d.command.CommandMoveVertex(this);
            }
        }

        return this._super(request);
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        memento.vertices = [];

        this.vertices.each(function (i, e) {
            memento.vertices.push({x: e.x, y: e.y});
        });

        return memento;
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        // restore the points from the JSON data and add them to the polyline
        //
        if (typeof memento.vertices !== "undefined") {
            this.vertices = new draw2d.util.ArrayList();
            var _this = this;
            $.each(memento.vertices, function (i, e) {
                _this.addVertex(e.x, e.y);
            });
        }
    }
});


/**
 * @class draw2d.shape.basic.Diamond
 * A Diamond Figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var d1 =  new draw2d.shape.basic.Diamond({x:10,y:10});
 *     var d2 =  new draw2d.shape.basic.Diamond({x:100,y:10, bgColor:"#f0f000", alpha:0.7, width:100, height:60});
 *
 *     canvas.add(d1);
 *     canvas.add(d2);
 *
 *     canvas.setCurrentSelection(d2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Diamond = draw2d.shape.basic.Polygon.extend({
    NAME: "draw2d.shape.basic.Diamond",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: "#00a3f6", color: "#1B1B1B"}, attr), setter, getter);

        var pos = this.getPosition();

        this.resetVertices();

        var box = this.getBoundingBox();
        this.addVertex(box.w / 2, 0);       // Go to the top center..
        this.addVertex(box.w, box.h / 2); // ...draw line to the right middle
        this.addVertex(box.w / 2, box.h);   // ...bottom center...
        this.addVertex(0, box.h / 2); // ...left middle...

        // override the selection handler from the polygon. Because the vertices of
        // the diamond are not selectable and modifiable
        //
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());

        this.setPosition(pos);
    }


});


/**
 * @class draw2d.shape.basic.Triangle
 * A Triangle Figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Triangle = draw2d.shape.basic.Polygon.extend({
    NAME: "draw2d.shape.basic.Triangle",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: "#00a3f6", color: "#1B1B1B"}, attr), setter, getter);

        var pos = this.getPosition();

        this.resetVertices();

        var box = this.getBoundingBox();

        this.addVertex(0, box.h / 2);       // Go to the top center..
        this.addVertex(box.w, 0); // ...draw line to the right middle
        this.addVertex(box.w, box.h);   // ...bottom center...

        // override the selection handler from the polygon. Because the vertices of
        // the Triangle are not selectable and modifiable
        //
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());

        this.setPosition(pos);
    }


});

/**
 * @class draw2d.SetFigure
 *
 * A SetFigure is a composition of different SVG elements.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.SetFigure = draw2d.shape.basic.Rectangle.extend({

    NAME: "draw2d.SetFigure",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        // collection of SVG DOM nodes
        this.svgNodes = null;

        this.originalWidth = null;
        this.originalHeight = null;

        this.scaleX = 1;
        this.scaleY = 1;

        this.strokeScale = true; // scale the stroke width of the children nodes if the parent resize

        this._super($.extend({stroke: 0, bgColor: null}, attr), setter, getter);
    },

    /**
     * @method
     * Set/Reset the canvas for the element.
     *
     * @param {draw2d.Canvas} canvas the canvas to use
     */
    setCanvas: function (canvas) {
        // remove the shape if we reset the canvas and the element
        // was already drawn
        if (canvas === null && this.svgNodes !== null) {
            this.svgNodes.remove();
            this.svgNodes = null;
        }

        this._super(canvas);
    },


    /**
     * @method
     * Set the css class if the node.
     *
     * @param {String} cssClass the new css class name of the node
     * @since 2.9.0
     */
    setCssClass: function (cssClass) {
        this._super(cssClass);

        if (this.svgNodes === null) {
            return this;
        }

        if (this.cssClass === null) {
            this.svgNodes.forEach(function (e) {
                e.node.removeAttribute("class");
            });
        }
        else {
            this.svgNodes.forEach(function (e) {
                e.node.setAttribute("class", cssClass);
            });
        }

        return this;
    },


    /**
     * @method
     * propagate all attributes like color, stroke,... to the shape element and
     * repaint them.
     *
     **/
    repaint: function (attributes) {

        // repaint can be blocked during deserialization and if the shape
        // not part of any canvas.
        //
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        if (this.originalWidth !== null) {
            this.scaleX = this.width / this.originalWidth;
            this.scaleY = this.height / this.originalHeight;
        }

        attributes = attributes || {};

        this.applyAlpha();

        this._super(attributes);
    },

    /**
     * @inheritdoc
     */
    setVisible: function (flag) {
        this._super(flag);

        if (this.svgNodes !== null) {
            if (this.visible === true) {
                this.svgNodes.show();
            }
            else {
                this.svgNodes.hide();
            }
        }
    },

    /**
     * @method
     * Apply the opacity to all child set elements. Override this if you want to avoid opacity changes.
     * @private
     *
     */
    applyAlpha: function () {
        this.svgNodes.attr({opacity: this.alpha});
    },

    /**
     * @private
     */
    applyTransformation: function () {
        var s =
            "S" + this.scaleX + "," + this.scaleY + ",0,0 " +
            "R" + this.rotationAngle + "," + ((this.getWidth() / 2) | 0) + "," + ((this.getHeight() / 2) | 0) +
            "T" + this.getAbsoluteX() + "," + this.getAbsoluteY() +
            "";
        this.svgNodes.transform(s);
        if (this.rotationAngle === 90 || this.rotationAngle === 270) {
            var before = this.svgNodes.getBBox(true);
            var ratio = before.height / before.width;
            var reverseRatio = before.width / before.height;
            var rs = "...S" + ratio + "," + reverseRatio + "," + (this.getAbsoluteX() + this.getWidth() / 2) + "," + (this.getAbsoluteY() + this.getHeight() / 2);
            this.svgNodes.transform(rs);
        }
    },

    /**
     * @method
     * Moves the element so it is the closest to the viewer?��s eyes, on top of other elements. Additional
     * the internal model changed as well.
     *
     * Optional: Inserts current object in front of the given one.
     *
     * @param {draw2d.Figure} [figure] move current object in front of the given one.
     * @since 3.0.0
     */
    toFront: function (figure) {
        ////////////////////////////////////////////////////////////////////
        // NOTE: the code has a complete different order of draw2d.Figure.
        //       we must respect the svgNodes here
        ////////////////////////////////////////////////////////////////////

        // ensure that the z-oder is still correct if the figure is assigned
        // to a StrongComposite
        //
        if (this.composite instanceof draw2d.shape.composite.StrongComposite && (typeof figure !== "undefined")) {
            var indexFigure = figure.getZOrder();
            var indexComposite = this.composite.getZOrder();
            if (indexFigure < indexComposite) {
                figure = this.composite;
            }
        }

        if (typeof figure === "undefined") {
            this.getShapeElement().toFront();

            if (this.canvas !== null) {
                var figures = this.canvas.getFigures();
                var lines = this.canvas.getLines();
                if (figures.remove(this) !== null) {
                    figures.add(this);
                } else if (lines.remove(this) !== null) {
                    lines.add(this);
                }
            }
        }
        else {
            this.getShapeElement().insertAfter(figure.getTopLevelShapeElement());

            if (this.canvas !== null) {
                var figures = this.canvas.getFigures();
                var lines = this.canvas.getLines();
                if (figures.remove(this) !== null) {
                    var index = figures.indexOf(figure);
                    figures.insertElementAt(this, index + 1);
                } else if (lines.remove(this) !== null) {
                    lines.add(this);
                }
            }
        }


        // Bring the SVG shapes in front
        //
        if (this.svgNodes !== null) {
            if (typeof figure !== "undefined") {
                this.svgNodes.insertAfter(figure.getTopLevelShapeElement());
            }
            else {
                this.svgNodes.toFront();
            }
        }

        // bring all children figures in front of the parent
        //
        this.children.each(function (i, child) {
            child.figure.toFront(figure);
        });

        // and last but not least - the ports are always on top
        //
        var _this = this;
        this.getPorts().each(function (i, port) {
            port.getConnections().each(function (i, connection) {
                connection.toFront(figure);
            });
            // a port should always be in front of the shape doesn't matter what the
            // "figure" parameter says.
            //
            port.toFront(_this);
        });


        return this;
    },

    /**
     * @method
     * Moves the element to the background. Additional
     * the internal model changed as well.
     *
     * Optional: Inserts current object in front of the given one.
     *
     * @param {draw2d.Figure} [figure] move current object in front of the given one.
     * @since 4.7.2
     */
    toBack: function (figure) {

        // it is not allowed that a figure is behind the assigned composite
        //
        if (this.composite instanceof draw2d.shape.composite.StrongComposite) {
            this.toFront(this.composite);
            return;
        }

        // sort the JSON Doc
        //
        if (this.canvas !== null) {
            var figures = this.canvas.getFigures();
            var lines = this.canvas.getLines();
            if (figures.remove(this) !== null) {
                figures.insertElementAt(this, 0);
            } else if (lines.remove(this) !== null) {
                lines.insertElementAt(this, 0);
            }
        }

        // bring all children figures in front of the parent
        // run reverse to the collection to care about the z-order of the children)
        this.children.each(function (i, child) {
            child.figure.toBack(figure);
        }, true);

        if (this.svgNodes !== null) {
            if (typeof figure !== "undefined") {
                this.svgNodes.insertBefore(figure.getShapeElement());
            }
            else {
                this.svgNodes.toBack();
            }
        }


        if (typeof figure !== "undefined") {
            this.getShapeElement().insertBefore(figure.getShapeElement());
        }
        else {
            this.getShapeElement().toBack();
        }

        // and last but not least - the ports are always on top
        //
        var _this = this;
        this.getPorts().each(function (i, port) {
            port.getConnections().each(function (i, connection) {
                connection.toFront(_this);
            });
            // a port should always be in front of the shape doesn't matter what the
            // "figure" parameter says.
            //
            port.toFront(_this);
        });

        return this;
    },


    /**
     * @inheritdoc
     */
    getTopLevelShapeElement: function () {
        return this.svgNodes;
    },

    /**
     * @private
     */
    createShapeElement: function () {
        // NOTE: don't change the order of the two calls. This defines the z-oder in the canvas.
        // The "set" must always be on top.
        var shape = this.canvas.paper.rect(this.getX(), this.getY(), this.getWidth(), this.getHeight());
        this.svgNodes = this.createSet();

        // check if the element is a "set" or a simple raphael shape. otherwise we wrap them into a set
        //
        if (typeof this.svgNodes.forEach === "undefined") {
            var set = this.canvas.paper.set();
            set.push(this.svgNodes);
            this.svgNodes = set;
        }

        this.svgNodes.attr({"stroke-scale": this.strokeScale});

        // update the visibility of the children
        this.setVisible(this.visible);

        // propagate the CSS style to all set elements
        this.setCssClass(this.cssClass);

        var bb = this.svgNodes.getBBox();
        this.originalWidth = bb.width;
        this.originalHeight = bb.height;

        return shape;
    },

    /**
     * @method
     * Override this method to add your own SVG elements. See {@link draw2d.shape.basic.Label} as example.
     *
     * @template
     */
    createSet: function () {
        return this.canvas.paper.set(); // return empty set as default;
    }

});

/**
 * @class draw2d.SVGFigure
 * Abstract class which can handle plain SVG content. Inherit class must override the method
 * <code>getSVG()</code>.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.SVGFigure = draw2d.SetFigure.extend({

    NAME: "draw2d.SVGFigure",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr) {
        this._super(attr);
    },

    /**
     * @inheritdoc
     */
    createSet: function () {
        return this.importSVG(this.canvas, this.getSVG());
    },

    /**
     * @private
     */
    importSVG: function (canvas, rawSVG) {

        var set = canvas.paper.set();

        try {
            if (typeof rawSVG === 'undefined') {
                throw 'No data was provided.';
            }

            // Override the dimension from the JSON if the SVG contains any
            //
            var svgDOM = $(rawSVG);

            // set the dimension of the element if the JSON import didn't provide
            // a dimension already
            //
            if (typeof this._dimensionReadFromJSON === "undefined") {
                if (svgDOM.attr("width") && svgDOM.attr("height")) {
                    this.setDimension(parseFloat(svgDOM.attr("width")), parseFloat(svgDOM.attr("height")));
                }
                delete this._dimensionReadFromJSON;
            }

            var findStyle = new RegExp('([a-z0-9\-]+) ?: ?([^ ;]+)[ ;]?', 'gi');

            svgDOM.children().each(function (i, element) {
                //element = $(element);
                var shape = null;
                var style = null;
                var attr = {};
                var node = element.tagName;

                // remove the namespace of the node if existing. This can happen in IE8
                //
                var index = node.indexOf(":");
                if (index != -1)
                    node = node.substr(index + 1);

                // map some element to Raphael specifix attributes or ignore some unknown attributes
                //
                $(element.attributes).each(function () {
                    switch (this.nodeName) {
                        case 'stroke-dasharray':
                            attr[this.nodeName] = '- ';
                            break;
                        case 'style':
                            style = this.nodeValue;
                            break;
                        case 'id':
                        case 'xml:space':
                            // just to ignore
                            break;
                        default:
                            if (this.value) {
                                attr[this.nodeName] = this.value;
                            }
                            else {
                                // @deprecated
                                attr[this.nodeName] = this.nodeValue;
                            }
                            break;
                    }
                });


                if (style !== null) {
                    while (findStyle.exec(style)) {
                        attr[RegExp.$1] = RegExp.$2;
                    }
                }

                // set some good defaults if the element didn't provide a stroke-width but has a "stroke" attribute
                //
                if (typeof attr['stroke-width'] === 'undefined') {
                    attr['stroke-width'] = (typeof attr.stroke === 'undefined' ? 0 : 1.2);
                }

                switch (node) {
                    case 'rect':
                        shape = canvas.paper.rect();
                        break;
                    case 'circle':
                        shape = canvas.paper.circle();
                        break;
                    case 'ellipse':
                        shape = canvas.paper.ellipse();
                        break;
                    case 'path':
                        attr.fill = "none";
                        shape = canvas.paper.path(attr.d);
                        break;
                    case 'line':
                        attr.d = "M " + attr.x1 + " " + attr.y1 + "L" + attr.x2 + " " + attr.y2;
                        attr.fill = "none";
                        shape = canvas.paper.path(attr.d);
                        break;
                    case 'polyline':
                        var path = attr.points;
                        attr.d = "M " + path.replace(" ", " L");
                        shape = canvas.paper.path(attr.d);
                        break;
                    case 'polygon':
                        shape = canvas.paper.polygon(attr.points);
                        break;
                    case 'image':
                        shape = canvas.paper.image();
                        break;
                    case 'tspan':
                    case 'text':
                        if (element.childNodes.length > 0) {
                            var child = element.firstChild;
                            do {
                                switch (child.nodeType) {
                                    case 2://ATTRIBUTE_NODE
                                    case 4://CDATA_SECTION_NODE
                                    case 5://ENTITY_REFERENCE_NODE
                                    case 6://ENTITY_NODE
                                    case 7://PROCESSING_INSTRUCTION_NODE
                                    case 8://COMMENT_NODE
                                    case 9://DOCUMENT_NODE
                                    case 10://DOCUMENT_TYPE_NODE
                                    case 11://DOCUMENT_FRAGMENT_NODE
                                    case 12://NOTATION_NODE
                                        return;
                                    case 3://TEXT_NOD
                                        // redirect to the parent node if we found a simple TEXT without any attributes
                                        child = element;
                                        break;
                                    case 1://ELEMENT_NODE
                                }
                                var subShape = canvas.paper.text(0, 0, $(child).text());
                                var subAttr = {
                                    "x": parseFloat(child.attributes.x.value),
                                    "y": parseFloat(child.attributes.y.value)
                                };
                                subAttr["text-anchor"] = "start";
                                if (typeof child.attributes["text-anchor"] !== "undefined") {
                                    subAttr["text-anchor"] = child.attributes["text-anchor"].value;
                                }
                                else if (typeof attr["text-anchor"] !== "undefined") {
                                    subAttr["text-anchor"] = attr["text-anchor"];
                                }

                                if (typeof child.attributes["font-size"] !== "undefined") {
                                    subAttr["font-size"] = parseInt(child.attributes["font-size"].value);
                                }
                                else if (typeof attr["font-size"] !== "undefined") {
                                    // inherit the font size from the parent node
                                    subAttr["font-size"] = parseInt(attr["font-size"]);
                                }

                                if (typeof child.attributes["font-family"] !== "undefined") {
                                    subAttr["font-family"] = child.attributes["font-family"].value;
                                }
                                else if (typeof attr["font-family"] !== "undefined") {
                                    // inherit the font size from the parent node
                                    subAttr["font-family"] = attr["font-family"];
                                }

                                subAttr["fill"] = "#000000";
                                if (typeof child.attributes["fill"] !== "undefined") {
                                    subAttr["fill"] = child.attributes["fill"].value;
                                }
                                else if (typeof attr["fill"] !== "undefined") {
                                    // inherit the font size from the parent node
                                    subAttr["fill"] = attr["fill"];
                                }

                                subAttr.y = subAttr.y + subShape.getBBox().height / 2;

                                subShape.attr(subAttr);
                                set.push(subShape);
                            } while (child = child.nextSibling);
                        }
                        else {
                            shape = canvas.paper.text(0, 0, $(element).html());
                            if (typeof attr["fill"] === "undefined")
                                attr["fill"] = "#000000";
                            if (typeof attr["text-anchor"] === "undefined")
                                attr["text-anchor"] = "start";
                            if (typeof attr["font-size"] !== "undefined")
                                attr["font-size"] = parseInt(attr["font-size"]);
                            if (typeof attr["font-family"] !== "undefined")
                                attr["font-family"] = parseInt(attr["font-family"]);
                            attr.y = parseFloat(attr.y) + shape.getBBox().height / 2;
                        }
                        break;
                }
                if (shape !== null) {
                    shape.attr(attr);
                    set.push(shape);
                }
            });
        } catch (error) {
            alert('The SVG data you entered was invalid! (' + error + ')');
        }


        return set;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @return
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        // keep a temp flag to indicate the we have read the dimension of the
        // element from the JSON struct. In this case we didn't care about the dimension
        // from the SVG data
        //
        if (typeof memento.width !== "undefined") {
            this._dimensionReadFromJSON = true;
        }
        else if (typeof memento.height !== "undefined") {
            this._dimensionReadFromJSON = true;
        }

        return this;
    }


});

/**
 * @class draw2d.shape.node.Hub
 *
 * A hub is a shape with a special kind of port handling. The hole figure is a hybrid port. You can drag&drop a Port directly on
 * the figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *
 *     canvas.add(new draw2d.shape.node.Start({x:50, y:50}));
 *     canvas.add(new draw2d.shape.node.Hub({x:150, y:50}));
 *
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.shape.node.Hub = draw2d.shape.basic.Rectangle.extend({

    NAME: "draw2d.shape.node.Hub",

    DEFAULT_COLOR: new draw2d.util.Color("#4DF0FE"),
    BACKGROUND_COLOR: new draw2d.util.Color("#29AA77"),

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.label = null;

        this._super(
            $.extend({color: this.DEFAULT_COLOR.darker(), bgColor: this.BACKGROUND_COLOR}, attr),
            $.extend({
                // deprecated
                label: this.setLabel,
                /** @attr {String} text the text to display in the center of the hub */
                text: this.setLabel
            }, setter),
            $.extend({
                label: this.getLabel,
                text: this.getLabel
            }, getter));

        var _port = this.port = this.createPort("hybrid", new draw2d.layout.locator.CenterLocator());

        this.CONNECTION_DIR_STRATEGY = [function (conn, relatedPort) {
            return _port.getParent().getBoundingBox().getDirection(relatedPort.getAbsolutePosition());
        },
            function (conn, relatedPort) {
                return _port.getAbsoluteY() > relatedPort.getAbsoluteY() ? 0 : 2;
            },
            function (conn, relatedPort) {
                return _port.getAbsoluteX() > relatedPort.getAbsoluteX() ? 3 : 1;
            }];

        // redirect the glow effect and the hitTest for the port to the parent node
        //
        this.port.setGlow = $.proxy(this.setGlow, this);
        this.port._orig_hitTest = this.port.hitTest;
        this.port.hitTest = $.proxy(this.hitTest, this);


        // provide a special connection anchor for this port. We use the bounding box of the
        // parent as connection border
        //
        this.port.setConnectionAnchor(new draw2d.layout.anchor.ShortesPathConnectionAnchor(this.port));
        this.port.setVisible(false);
        this.port.setVisible = function () {
        };

        this.setConnectionDirStrategy(0);
    },

    /**
     * @method
     * Called by the framework during drag&drop operations if the user drag a figure over this figure
     *
     * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
     *
     * @return {draw2d.Figure} the figure which should receive the drop event or null if the element didn't want a drop event
     **/
    onDragEnter: function (draggedFigure) {
        // redirect the dragEnter handling to the hybrid port
        //
        return this.getHybridPort(0).onDragEnter(draggedFigure);
    },

    /**
     * @method
     * This value is relevant for the interactive resize of the figure.
     *
     * @return {Number} Returns the min. width of this object.
     */
    getMinWidth: function () {
        if (this.label !== null) {
            return Math.max(this.label.getMinWidth(), this._super());
        }
        return this._super();
    },


    /**
     * @inheritdoc
     *
     * @private
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        // set some good defaults if the parent didn't
        if (typeof attributes.fill === "undefined") {
            if (this.bgColor !== null) {
                attributes.fill = "90-" + this.bgColor.hash() + ":5-" + this.bgColor.lighter(0.3).hash() + ":95";
            }
            else {
                attributes.fill = "none";
            }
        }

        this._super(attributes);
    },

    /**
     * @method
     * Set the label for the Hub
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
      *        text: label
      *      });
     *
     *
     * @param {String} label
     * @since 3.0.4
     */
    setLabel: function (label) {
        // Create any Draw2D figure as decoration for the connection
        //
        if (this.label === null) {
            this.label = new draw2d.shape.basic.Label({text: label, color: "#0d0d0d", fontColor: "#0d0d0d", stroke: 0});
            // add the new decoration to the connection with a position locator.
            //
            this.add(this.label, new draw2d.layout.locator.CenterLocator());
        }
        else {
            this.label.setText(label);
        }

    },

    /**
     * @method
     * Set the strategy for the connection direction calculation.<br>
     * <br>
     *
     * <ul>
     * <li>0 - Use the best/shortest direction (UP/RIGHT/DOWN/LEFT) for the connection routing (default)</li>
     * <li>1 - Use UP/DOWN for the connection direction</li>
     * <li>2 - Use LEFT/RIGHT</li>
     * </ul>
     * @param {Number} strategy the connection routing strategy to use
     * @since 2.4.3
     */
    setConnectionDirStrategy: function (strategy) {
        switch (strategy) {
            case 0:
            case 1:
            case 2:
                this.port.getConnectionDirection = this.CONNECTION_DIR_STRATEGY[strategy];
                break;
        }
    },

    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        memento.dirStrategy = this.CONNECTION_DIR_STRATEGY.indexOf(this.port.getConnectionDirection);
        if (this.label !== null) {
            memento.label = this.label.getText();
        }

        return memento;
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.dirStrategy === "number") {
            this.setConnectionDirStrategy(memento.dirStrategy);
        }

        if (typeof memento.label !== "undefined") {
            this.setLabel(memento.label);
        }
    }

});


/**
 * @class draw2d.shape.node.HorizontalBus
 *
 * A horizontal bus shape with a special kind of port handling. The hole figure is a hybrid port.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.node.HorizontalBus({width:300, height:20, text:"Horizontal Bus"});
 *
 *     canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.node.Hub
 */
draw2d.shape.node.HorizontalBus = draw2d.shape.node.Hub.extend({

    NAME: "draw2d.shape.node.HorizontalBus",

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr);

        this.setConnectionDirStrategy(1);

        this.installEditPolicy(new draw2d.policy.figure.HBusSelectionFeedbackPolicy());
    }

});


/**
 * @class draw2d.shape.node.VerticalBus
 *
 * A horizontal bus shape with a special kind of port handling. The hole figure is a hybrid port.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.node.VerticalBus({width:40, height:300, text:"Vertical Bus"});
 *
 *     canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.node.Hub
 */
draw2d.shape.node.VerticalBus = draw2d.shape.node.Hub.extend({

    NAME: "draw2d.shape.node.VerticalBus",

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr);

        this.setConnectionDirStrategy(2);
        this.installEditPolicy(new draw2d.policy.figure.VBusSelectionFeedbackPolicy());
    },


    /**
     * @method
     * set the label for the Hub
     *
     * @param {String} labelString
     * @since 3.0.4
     */
    setLabel: function (labelString) {
        var mustAdjustTheAngel = this.label === null;

        this._super(labelString);

        if (mustAdjustTheAngel === true && this.label !== null) {
            this.label.setRotationAngle(90);
        }
    },

    /**
     * @inheritdoc
     */
    getMinHeight: function () {
        if (this.shape === null && this.label === null) {
            return 0;
        }

        if (this.label !== null) {
            return this.label.getMinWidth();
        }

        return this._super();
    },

    /**
     * @inheritdoc
     */
    getMinWidth: function () {
        if (this.shape === null && this.label === null) {
            return 0;
        }

        if (this.label !== null) {
            return this.label.getMinHeight();
        }

        return this._super();
    }


});


/**
 * @class draw2d.shape.node.Fulcrum
 *
 * A horizontal bus shape with a special kind of port handling. The hole figure is a hybrid port.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     canvas.add( new draw2d.shape.node.Fulcrum(),50,10);
 *     canvas.add( new draw2d.shape.node.Fulcrum(),80,100);
 *     canvas.add( new draw2d.shape.node.Fulcrum(),150,50);
 *
 * @extends draw2d.shape.node.Hub
 */
draw2d.shape.node.Fulcrum = draw2d.shape.node.Hub.extend({

    NAME: "draw2d.shape.node.Fulcrum",

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({width: 40, height: 40}, attr), setter, getter);


        this.port.setConnectionAnchor(new draw2d.layout.anchor.ConnectionAnchor(this.port));
        this.port.setVisible(true);
        this.port.hitTest = this.port._orig_hitTest;

        this.setConnectionDirStrategy(0);
        this.setColor(null);
        this.setRadius(10);
        this.setBackgroundColor(null);
        this.setStroke(0);
        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        // set some good defaults if the parent didn't
        if (typeof attributes.fill === "undefined") {
            attributes.fill = this.bgColor.hash();
        }

        this._super(attributes);
    }

});


/**
 * @class draw2d.shape.basic.ARc
 * Oval figure.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var arc =  new draw2d.shape.basic.Arc({diameter:150, x:50, y:10, startAngle:0, endAngle:45});
 *
 *     canvas.add(arc);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Arc = draw2d.SetFigure.extend({
    NAME: "draw2d.shape.basic.Arc",

    /**
     *
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.startAngle = 180;
        this.endAngle = 360;

        this._super($.extend({width: 80, height: 50, bgColor: null, color: "#1B1B1B"}, attr), setter, getter);
        this.strokeScale = false; // scale the stroke width of the children nodes if the parent resize
    },


    /**
     * @template
     **/
    createSet: function () {
        this.canvas.paper.setStart();


        var flag = (this.endAngle - this.startAngle) > 180;
        var a1 = (this.startAngle % 360) * Math.PI / 180;
        var a2 = (this.endAngle % 360) * Math.PI / 180;

        var w2 = this.getWidth() / 2;
        var h2 = this.getHeight() / 2;

        this.canvas.paper.path([
            ["M", w2, h2,
                "l", w2 * Math.cos(a1), h2 * Math.sin(a1),
                "A", w2, h2, 0, +flag, 1, w2 + w2 * Math.cos(a2), h2 + h2 * Math.sin(a2),
                "z"]
        ].join("")).attr({"fill": "#fff0f0"});

        return this.canvas.paper.setFinish();

    }

});


/**
 * @class draw2d.shape.basic.Oval
 * Oval figure.
 *
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var oval =  new draw2d.shape.basic.Oval({width:150, height:100, x:50, y:10});
 *
 *     canvas.add(oval);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Oval = draw2d.VectorFigure.extend({
    NAME: "draw2d.shape.basic.Oval",

    /**
     *
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: "#C02B1D", color: "#1B1B1B"}, attr), setter, getter);
    },


    /**
     * @template
     **/
    createShapeElement: function () {
        var halfW = this.getWidth() / 2;
        var halfH = this.getHeight() / 2;

        return this.canvas.paper.ellipse(this.getAbsoluteX() + halfW, this.getAbsoluteY() + halfH, halfW, halfH);
    },


    /**
     * @inheritdoc
     *
     * @template
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};


        // don't override cx/cy if inherited class has set the center already.
        if (typeof attributes.rx === "undefined") {
            attributes.rx = this.width / 2;
            attributes.ry = this.height / 2;
        }

        // don't override cx/cy if inherited class has set the center already.
        if (typeof attributes.cx === "undefined") {
            attributes.cx = this.getAbsoluteX() + attributes.rx;
            attributes.cy = this.getAbsoluteY() + attributes.ry;
        }

        this._super(attributes);
    },

    /*****
     *
     *   intersectEllipseLine
     *
     *   NOTE: Rotation will need to be added to this function
     *
     *****/
    intersectionWithLine: function (a1, a2) {
        var rx = this.getWidth() / 2;
        var ry = this.getHeight() / 2;

        var result = new draw2d.util.ArrayList();

        var origin = new draw2d.geo.Point(a1.x, a1.y);
        var dir = a2.subtract(a1);
        var center = new draw2d.geo.Point(this.getAbsoluteX() + rx, this.getAbsoluteY() + ry);
        var diff = origin.subtract(center);
        var mDir = new draw2d.geo.Point(dir.x / (rx * rx), dir.y / (ry * ry));
        var mDiff = new draw2d.geo.Point(diff.x / (rx * rx), diff.y / (ry * ry));

        var a = dir.dot(mDir);
        var b = dir.dot(mDiff);
        var c = diff.dot(mDiff) - 1.0;
        var d = b * b - a * c;

        if (d < 0) {
            // "Outside"
        } else if (d > 0) {
            var root = Math.sqrt(d);
            var t_a = (-b - root) / a;
            var t_b = (-b + root) / a;

            if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
                if ((t_a < 0 && t_b < 0) || (t_a > 1 && t_b > 1)) {
                    //"Outside";
                }
                else {
                    //"Inside";
                }
            } else {
                if (0 <= t_a && t_a <= 1)
                    result.add(a1.lerp(a2, t_a));
                if (0 <= t_b && t_b <= 1)
                    result.add(a1.lerp(a2, t_b));
            }
        } else {
            var t = -b / a;
            if (0 <= t && t <= 1) {
                result.add(a1.lerp(a2, t));
            } else {
                //"Outside";
            }
        }

        return result;
    }

});


/**
 * @class draw2d.shape.basic.Circle
 * A circle figure with basic background and stroke API. <br>
 * A circle can not be streched. <strong>The aspect ration is always 1:1</strong>.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var shape =  new draw2d.shape.basic.Circle({x:40,y:10, stroke:3, color:"#3d3d3d", bgColor:"#3dff3d"});
 *
 *     canvas.add(shape);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Oval
 */
draw2d.shape.basic.Circle = draw2d.shape.basic.Oval.extend({

    NAME: "draw2d.shape.basic.Circle",

    /**
     * @constructor
     * Create a new circle figure.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr, $.extend({
            /** @attr {Number} diameter the diameter of the circle */
            diameter: this.setDiameter,
            /** @attr {Number} radius the radius of the circle */
            radius: this.setRadius
        }, setter), $.extend({
            diameter: this.getDiameter,
            radius: this.getRadius
        }, getter));

        this.setKeepAspectRatio(true);
    },

    /**
     * @method
     * Set the diameter of the circle. The center of the circle will be retained.
     *
     * @param {Number} d The new diameter of the circle.
     * @since 4.0.0
     **/
    setDiameter: function (d) {
        var center = this.getCenter();
        this.setDimension(d, d);
        this.setCenter(center);
        this.fireEvent("change:diameter");

        return this;
    },

    /**
     * @method
     * Get the diameter of the circle.
     *
     * @since 4.0.0
     **/
    getDiameter: function () {
        return this.getWidth();
    },


    /**
     * @method
     * Set the radius of the circle. The center of the circle will be retained.
     *
     * @param {Number} d The new radius of the circle.
     * @since 4.0.0
     **/
    setRadius: function (r) {
        this.setDiameter(r * 2);
        this.fireEvent("change:radius");

        return this;
    },


    /**
     * @method
     * Get the center of the circle
     *
     */
    getCenter: function () {
        var d2 = this.getDiameter() / 2;
        return this.getPosition().translate(d2, d2);
    },

    /**
     * @method
     * Set the center of the circle.
     *
     * @param {Number|draw2d.geo.Point} x the new x coordinate of the center or a draw2d.geo.Point object with the center
     * @param {Number} y the y coordinate of the new center of the first argument isn't a draw2d.geo.Point object
     */
    setCenter: function (x, y) {
        var pos = new draw2d.geo.Point(x, y);
        var d2 = this.getDiameter() / 2;
        pos.translate(-d2, -d2);
        this.fireEvent("change:center");
        this.setPosition(pos);

        return this;
    },

    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = this._super();
        // delete the radius attribute of the parent. Because the "radius" is the corner radius
        // of the shape and not the "radius" of the circle. Design flaw.  :-/
        delete memento.radius;

        return memento;
    }

});

/**
 * @class draw2d.shape.basic.Label
 * Implements a simple text label.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var shape =  new draw2d.shape.basic.Label({text:"This is a simple label", x:40, y:10});
 *
 *     canvas.add(shape);
 *
 * @author Andreas Herz
 *
 * @extends draw2d.SetFigure
 */
draw2d.shape.basic.Label = draw2d.SetFigure.extend({

    NAME: "draw2d.shape.basic.Label",

    FONT_FALLBACK: {
        'Georgia': 'Georgia, serif',
        'Palatino Linotype': '"Palatino Linotype", "Book Antiqua", Palatino, serif',
        'Times New Roman': '"Times New Roman", Times, serif',
        'Arial': 'Arial, Helvetica, sans-serif',
        'Arial Black': '"Arial Black", Gadget, sans-serif',
        'Comic Sans MS': '"Comic Sans MS", cursive, sans-serif',
        'Impact': 'Impact, Charcoal, sans-serif',
        'Lucida Sans Unicode': '"Lucida Sans Unicode", "Lucida Grande", sans-serif',
        'Tahoma, Geneva': 'Tahoma, Geneva, sans-seri',
        'Trebuchet MS': '"Trebuchet MS", Helvetica, sans-serif',
        'Verdana': 'Verdana, Geneva, sans-serif',
        'Courier New': '"Courier New", Courier, monospace',
        'Lucida Console': '"Lucida Console", Monaco, monospace'
    },


    /**
     * @constructor
     * Creates a new text element.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this.text = "";
        // for performance reasons
        //
        this.cachedWidth = null;
        this.cachedHeight = null;
        this.cachedMinWidth = null;
        this.cachedMinHeight = null;

        // appearance of the shape
        //
        this.fontSize = 12;
        this.fontColor = new draw2d.util.Color("#080808");
        this.fontFamily = null;
        this.padding = {top: 4, right: 4, bottom: 4, left: 4};

        this.outlineStroke = 0;
        this.outlineColor = new draw2d.util.Color(null);

        this.bold = false;

        this._super(
            $.extend({stroke: 1, width: 1, height: 1, resizeable: false}, attr),
            $.extend({
                /** @attr {String} text the text to show */
                text: this.setText,
                /** @attr {Number} outlineStroke the line width of the text to draw. Fill color and outline of the text can be different. */
                outlineStroke: this.setOutlineStroke,
                /** @attr {String|draw2d.util.Color} outlineColor the outline color of the text */
                outlineColor: this.setOutlineColor,
                /** @attr {String} fontFamily the font to use*/
                fontFamily: this.setFontFamily,
                /** @attr {Number} fontSize the font size to use */
                fontSize: this.setFontSize,
                /** @attr {String|draw2d.util.Color} fontColor the font color */
                fontColor: this.setFontColor,
                /** @attr {Number} padding the padding in pixel around the text */
                padding: this.setPadding,
                /** @attr {Boolean} bold indicator if bold text should be used*/
                bold: this.setBold
            }, setter),
            $.extend({
                text: this.getText,
                outlineStroke: this.getOutlineStroke,
                outlineColor: this.getOutlineColor,
                fontFamily: this.getFontFamily,
                fontSize: this.getFontSize,
                fontColor: this.getFontColor,
                padding: this.getPadding,
                bold: this.isBold
            }, getter));


        // behavior of the shape
        //
        this.editor = null;

        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());


        // some performance approvements
        this.lastAppliedRotation = -1;
    },

    /**
     * @method
     * Creates the shape object for a text node.
     *
     * @template
     **/
    createSet: function () {
        return this.canvas.paper.text(0, 0, this.text);
    },

    /**
     * @method
     * Set the canvas element of this figures.
     *
     * @param {draw2d.Canvas} canvas the new parent of the figure or null
     */
    setCanvas: function (canvas) {
        this.clearCache();
        this._super(canvas);
        this.clearCache();
    },

    /**
     * @method
     * Trigger the repaint of the element and transport all style properties to the visual representation.<br>
     * Called by the framework.
     *
     * @template
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        // style the label
        var lattr = this.calculateTextAttr();
        lattr.text = this.text;
        this.svgNodes.attr(lattr);
        // set of the x/y must be done AFTER the font-size and bold has been set.
        // Reason: the getBBox method needs the font attributes for calculation
        this.svgNodes.attr({
            x: this.padding.left + this.stroke,
            y: this.svgNodes.getBBox(true).height / 2 + this.padding.top
        });

        this._super(attributes);
    },


    /**
     *
     * @private
     */
    calculateTextAttr: function () {
        var lattr = {
            "text-anchor": "start",
            "font-size": this.fontSize,
            "font-weight": (this.bold === true) ? "bold" : "normal",
            fill: this.fontColor.hash(),
            stroke: this.outlineColor.hash(),
            "stroke-width": this.outlineStroke
        };
        if (this.fontFamily !== null) {
            lattr["font-family"] = this.fontFamily;
        }
        return lattr;
    },

    /**
     * @private
     */
    applyTransformation: function () {
        this.shape.transform("R" + this.rotationAngle);

        this.svgNodes.transform(
            "R" + this.rotationAngle +
            "T" + this.getAbsoluteX() + "," + this.getAbsoluteY());

        return this;
    },


    /**
     * @method
     * Set the new font size in [pt].
     *
     * @param {Number} size The new font size in <code>pt</code>
     **/
    setFontSize: function (size) {
        this.clearCache();
        this.fontSize = size;

        this.repaint();

        this.fireEvent("change:fontSize");
        this.fireEvent("resize");

        // Update the resize handles if the user change the position of the element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });


        return this;
    },

    /**
     * @method
     * Return the current used font size in px.
     *
     * @returns {Number}
     * @since 4.0.1
     */
    getFontSize: function () {
        return this.fontSize;
    },


    /**
     * @method
     * Set the label to <b>bold</b> or <b>normal</b> font weight.
     *
     * @param {Boolean} bold The bold flag for the label
     * @since 2.4.1
     **/
    setBold: function (bold) {
        this.clearCache();
        this.bold = bold;
        this.repaint();

        this.fireEvent("change:bold");
        this.fireEvent("resize");

        // Update the resize handles if the user change the position of the element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        return this;
    },

    /**
     * @method
     * Return the "bold" attribute of the label
     *
     * @since 5.0.0
     * @returns {Boolean}
     */
    isBold: function () {
        return this.bold;
    },

    /**
     * @method
     * Set the outline color of the font.
     *
     * @param {draw2d.util.Color/String} color The new color of the line.
     * @since 4.2.1
     **/
    setOutlineColor: function (color) {
        this.outlineColor = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:outlineColor");

        return this;
    },

    /**
     * @method
     * The outlien color of the text
     *
     * @returns {draw2d.util.Color}
     * @since 4.2.1
     */
    getOutlineColor: function () {
        return this.outlineColor;
    },

    /**
     * @method
     * Set the stroke of the text to use.
     *
     * @param {Number} w The new line width of the figure
     * @since 4.2.1
     **/
    setOutlineStroke: function (w) {
        this.outlineStroke = w;
        this.repaint();
        this.fireEvent("change:outlineStroke");

        return this;
    },

    /**
     * @method
     * The used outline line width.
     *
     * @type {Number}
     * @since 4.2.1
     **/
    getOutlineStroke: function () {
        return this.outlineStroke;
    },

    /**
     * @method
     * Set the color of the font.
     *
     * @param {draw2d.util.Color/String} color The new color of the line.
     **/
    setFontColor: function (color) {
        this.fontColor = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:fontColor");

        return this;
    },

    /**
     * @method
     * The current used font color
     *
     * @returns {draw2d.util.Color}
     */
    getFontColor: function () {
        return this.fontColor;
    },

    /**
     * @method
     * Set the padding of the element
     *
     *      // Alternatively you can use the attr method:
     *      //
     *      // set the padding for top,left,bottom,right in one call
     *      figure.attr({
     *        padding: 3
     *      });
     *
     *      // update the padding left and top
     *      figure.attr({
     *        padding: {left:3, top:30}
     *      });
     *
     * @param {Number|Object} padding The new padding
     **/
    setPadding: function (padding) {
        this.clearCache();
        if (typeof padding === "number") {
            this.padding = {top: padding, right: padding, bottom: padding, left: padding};
        }
        else {
            $.extend(this.padding, padding);
        }
        this.repaint();
        this.fireEvent("change:padding");

        return this;
    },


    /**
     * @method
     * Get the padding of the element.
     *
     * @since 4.0.1
     **/
    getPadding: function () {
        return this.padding;
    },

    /**
     * @method
     * Set the font family to use. If you use the shown font names the typical fallback
     * font are installed as well.
     *
     * <b>Serif Fonts</b>
     * <ul>
     *  <li><span style="font-family:'Georgia'">Georgia</span></li>
     *  <li><span style="font-family:'Palatino Linotype'">Palatino Linotype</span></li>
     *  <li><span style="font-family:'Times New Roman'">Times New Roman</span></li>
     * </ul>
     *
     * <b>Sans-Serif Fonts</b>
     * <ul>
     *  <li><span style="font-family:'Arial'">Arial</span></li>
     *  <li><span style="font-family:'Arial Black'">Arial Black</span></li>
     *  <li><span style="font-family:'Comic Sans MS'">Comic Sans MS</span></li>
     *  <li><span style="font-family:'Impact, Charcoal'">Impact, Charcoal</span></li>
     *  <li><span style="font-family:'Lucida Sans Unicode'">Lucida Sans Unicode</span></li>
     *  <li><span style="font-family:'Tahoma, Geneva'">Tahoma, Geneva</span></li>
     *  <li><span style="font-family:'Trebuchet MS'">Trebuchet MS</span> </li>
     *  <li><span style="font-family:'Verdana'">Verdana</span>, Geneva, sans-serif   /li>
     * </ul>
     *
     * <b>Monospace Fonts</b>
     * <ul>
     *  <li><span style="font-family:'Courier New'">Courier New</span></li>
     *  <li><span style="font-family:'Lucida Console'">Lucida Console</span></li>
     * </ul>
     *
     * @param {String} font The font to use
     **/
    setFontFamily: function (font) {
        this.clearCache();

        // check for fallback
        //
        if ((typeof font !== "undefined") && font !== null && typeof this.FONT_FALLBACK[font] !== "undefined") {
            font = this.FONT_FALLBACK[font];
        }

        this.fontFamily = font;
        this.repaint();
        this.fireEvent("change:fontFamily");

        return this;
    },


    /**
     * @method
     * Returns the used font family of the label.
     *
     * @returns {String}
     */
    getFontFamily: function () {
        return this.fontFamily;
    },


    /**
     * @method
     * A Label did have "autosize". Do nothing at all.
     *
     **/
    setDimension: function (w, h) {
        this.clearCache();

        this._super(w, h);

        return this;
    },

    /**
     * @method
     * clear the internal cache for width/height precalculation
     * @private
     */
    clearCache: function () {
        this.portRelayoutRequired = true;
        this.cachedMinWidth = null;
        this.cachedMinHeight = null;
        this.cachedWidth = null;
        this.cachedHeight = null;

        return this;
    },

    /**
     * @method
     * This value is relevant for the interactive resize of the figure.
     *
     * @return {Number} Returns the min. width of this object.
     */
    getMinWidth: function () {
        if (this.shape === null) {
            return 0;
        }

        if (this.cachedMinWidth === null) {
            this.cachedMinWidth = this.svgNodes.getBBox(true).width
                + this.padding.left
                + this.padding.right
                + 2 * this.getStroke();
        }

        return this.cachedMinWidth;
    },

    /**
     * @method
     * This value is relevant for the interactive resize of the figure.
     *
     * @return {Number} Returns the min. width of this object.
     */
    getMinHeight: function () {
        if (this.shape === null) {
            return 0;
        }

        if (this.cachedMinHeight === null) {
            this.cachedMinHeight = this.svgNodes.getBBox(true).height
                + this.padding.top
                + this.padding.bottom
                + 2 * this.getStroke();
        }

        return this.cachedMinHeight;
    },

    /**
     * @method
     * Return the calculate width of the set. This calculates the bounding box of all elements.
     *
     * @returns the calculated width of the label
     * @return {Number}
     **/
    getWidth: function () {
        if (this.shape === null) {
            return 0;
        }

        if (this.cachedWidth === null) {
            if (this.resizeable === true) {
                this.cachedWidth = Math.max(this.width, this.getMinWidth());
            }
            else {
                this.cachedWidth = this.getMinWidth();
            }
        }


        return this.cachedWidth;
    },
    /**
     * @method
     * Return the calculated height of the set. This calculates the bounding box of all elements.
     *
     * @returns the calculated height of the label
     * @return {Number}
     */
    getHeight: function () {
        if (this.shape === null) {
            return 0;
        }

        if (this.cachedHeight === null) {
            this.cachedHeight = Math.max(this.height, this.getMinHeight());
        }

        return this.cachedHeight;
    },

    /**
     * @method
     * Set an editor for the label. This can be a dialog or inplace editor for the
     * Text.<br>
     * The editor will be activated if you doubleClick on the label.
     *
     * @param {draw2d.ui.LabelEditor} editor
     */
    installEditor: function (editor) {
        this.editor = editor;

        return this;
    },

    /**
     * @method
     * Called when a user dbl clicks on the element
     *
     */
    onDoubleClick: function () {
        if (this.editor !== null) {
            this.editor.start(this);
        }
    },


    /**
     * @method
     * Returns the current text of the label.
     *
     * @returns the current display text of the label
     * @type String
     **/
    getText: function () {
        return this.text;
    },

    /**
     * @method
     * Set the text for the label. Use \n for multiline text.
     *
     * @param {String} text The new text for the label.
     **/
    setText: function (text) {
        this.clearCache();
        this.text = text;

        this.repaint();
        // Update the resize handles if the user change the position of the element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("resize");
        this.fireEvent("change:text");

        if (this.parent !== null) {
            this.parent.repaint();
        }

        return this;
    },


    hitTest: function (x, y) {
        // apply a simple bounding box test if the label isn'T rotated
        //
        if (this.rotationAngle === 0) {
            return this._super(x, y);
        }

        // rotate the box with the current matrix of the
        // shape
        var matrix = this.shape.matrix;
        var points = this.getBoundingBox().getVertices();
        points.each(function (i, point) {
            var x = matrix.x(point.x, point.y);
            var y = matrix.y(point.x, point.y);
            point.x = x;
            point.y = y;
        });

        var polySides = 4;
        var i = 0;
        var j = polySides - 1;
        var oddNodes = false;

        for (i = 0; i < polySides; i++) {
            var pi = points.get(i);
            var pj = points.get(j);
            if ((pi.y < y && pj.y >= y
                || pj.y < y && pi.y >= y)
                && (pi.x <= x || pj.x <= x)) {
                if (pi.x + (y - pi.y) / (pj.y - pi.y) * (pj.x - pi.x) < x) {
                    oddNodes = !oddNodes;
                }
            }
            j = i;
        }
        return oddNodes;
    },


    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        memento.text = this.text;
        memento.outlineStroke = this.outlineStroke;
        memento.outlineColor = this.outlineColor.hash();
        memento.fontSize = this.fontSize;
        memento.fontColor = this.fontColor.hash();
        memento.fontFamily = this.fontFamily;

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);
        if (typeof memento.text !== "undefined") {
            this.setText(memento.text);
        }
        if (typeof memento.outlineStroke !== "undefined") {
            this.setOutlineStroke(memento.outlineStroke);
        }
        if (typeof memento.outlineColor !== "undefined") {
            this.setOutlineColor(memento.outlineColor);
        }
        if (typeof memento.fontFamily !== "undefined") {
            this.setFontFamily(memento.fontFamily);
        }
        if (typeof memento.fontSize !== "undefined") {
            this.setFontSize(memento.fontSize);
        }
        if (typeof memento.fontColor !== "undefined") {
            this.setFontColor(memento.fontColor);
        }
    }

});


/**
 * @class draw2d.shape.basic.Text
 * Implements a simple text with word wrapping.<br>The height of the element is automatic calculated. The widht of
 * the element is changeable by the user and respect the minWidth constraint.
 * <br>
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var shape =  new draw2d.shape.basic.Text({text:"This is a simple text with some loooooong word in."});
 *
 *     canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 * @since 4.2.3
 * @extends draw2d.shape.basic.Label
 */
draw2d.shape.basic.Text = draw2d.shape.basic.Label.extend({

    NAME: "draw2d.shape.basic.Text",

    /**
     * @constructor
     * Creates a new text element.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.cachedWrappedAttr = null;

        this._super($.extend({width: 100, height: 50, resizeable: true}, attr), setter, getter);

        this.installEditPolicy(new draw2d.policy.figure.WidthSelectionFeedbackPolicy());
    },


    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        // style the label
        this.svgNodes.attr($.extend({}, this.calculateTextAttr(), this.wrappedTextAttr(this.text, this.getWidth() - this.padding.left - this.padding.right)));

        // set of the x/y must be done AFTER the font-size and bold has been set.
        // Reason: the getHeight method needs the font-size for calculation because
        //         it redirects the calculation to the SVG element.
        this.svgNodes.attr({x: this.padding.left, y: this.getHeight() / 2});

        // this is an exception call. Don't call the super method (Label) to avoid
        // the calculation in this method.
        draw2d.SetFigure.prototype.repaint.call(this, attributes);
    },


    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        this.clearCache();
        var attr = this.wrappedTextAttr(this.text, w);

        this._super(Math.min(w, attr.width), attr.height);
        this.fireEvent("change:dimension");

        return this;
    },

    /**
     * @method
     * clear the internal cache for width/height precalculation
     * @private
     */
    clearCache: function () {
        this._super();
        this.cachedWrappedAttr = null;

        return this;
    },


    /**
     * @inheritdoc
     */
    getMinWidth: function () {
        if (this.shape === null) {
            return 0;
        }

        if (this.cachedMinWidth === null) {
            // get the longest word in the text
            //
            var longestWord = this.text.split(" ").reduce(function (arg1, arg2) {
                return arg1.length > arg2.length ? arg1 : arg2;
            });
            var svgText = this.canvas.paper
                .text(0, 0, longestWord)
                .attr($.extend({}, this.calculateTextAttr(), {text: longestWord}));
            this.cachedMinWidth = svgText.getBBox(true).width + this.padding.left + this.padding.right + 2 * this.getStroke();
            svgText.remove();
        }

        return this.cachedMinWidth;
    },


    /**
     * @method
     * calculates the attributes (wrapped text and width, height) with the given parameter
     *
     * @private
     */
    wrappedTextAttr: function (text, width) {
        var words = text.split(" ");
        if (this.canvas === null || words.length === 0) {
            return {text: text, width: width, height: 20};
        }

        if (this.cachedWrappedAttr === null) {
            var abc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            var svgText = this.canvas.paper.text(0, 0, "").attr($.extend({}, this.calculateTextAttr(), {text: abc}));

            // get a good estimation of a letter width...not correct but this is working for the very first draft implementation
            var letterWidth = svgText.getBBox(true).width / abc.length;

            var s = [words[0]], x = s[0].length * letterWidth;
            var w = null;
            for (var i = 1; i < words.length; i++) {
                w = words[i];
                var l = w.length * letterWidth;
                if ((x + l) > width) {
                    s.push("\n");
                    x = l;
                }
                else {
                    s.push(" ");
                    x += l;
                }
                s.push(w);
            }
            var bbox = svgText.getBBox(true);
            svgText.remove();
            this.cachedWrappedAttr = {
                text: s.join(""),
                width: (bbox.width + this.padding.left + this.padding.right),
                height: (bbox.height + this.padding.top + this.padding.bottom)
            };
        }
        return this.cachedWrappedAttr;
    },

    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = this._super();


        return memento;
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        return this;
    }

});


/**
 * @class draw2d.shape.basic.Line
 * The base class for all visible elements inside a canvas.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // Create the line and modify the start/end after inserting them into
 *     // the canvas
 *     var line1 =  new draw2d.shape.basic.Line({startX:30, startY:30, endX:100, endY:80});
 *
 *     canvas.add(line1);
 *
 *     // Create the line with a given start/end coordinate in the constructor
 *     //
 *     var line2 = new draw2d.shape.basic.Line({
 *           startX:20,
 *           startY:80,
 *           endX:200,
 *           endY:150,
 *           stroke:3,
 *           color:"#1d1dff"
 *      });
 *     canvas.add(line2);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.Figure
 */
draw2d.shape.basic.Line = draw2d.Figure.extend({
    NAME: "draw2d.shape.basic.Line",

    DEFAULT_COLOR: new draw2d.util.Color(0, 0, 0),

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas witht he given start and
     * end coordinate.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        // click area for the line hit test
        this.corona = 10;
        this.isGlowing = false;
        this.lineColor = this.DEFAULT_COLOR;
        this.stroke = 1;
        this.outlineStroke = 0;
        this.outlineColor = new draw2d.util.Color(null);
        this.outlineVisible = false;

        this.dasharray = null;

        this.start = new draw2d.geo.Point(30, 30);
        this.end = new draw2d.geo.Point(100, 100);

        this.vertices = new draw2d.util.ArrayList();
        this.vertices.add(this.start);
        this.vertices.add(this.end);

        this._super(attr,
            $.extend({}, {
                /** @attr {Number} startX the x coordinate of the start point */
                startX: this.setStartX,
                /** @attr {Number} startY the y coordinate of the start point */
                startY: this.setStartY,
                /** @attr {Number} endX the x coordinate of the end */
                endX: this.setEndX,
                /** @attr {Number} endY the y coordinate of the end */
                endY: this.setEndY,
                /** @attr {String | draw2d.util.Color} outlineColor the outline color of the line */
                outlineColor: this.setOutlineColor,
                /** @attr {Number} outlineStroke the line width of the outline */
                outlineStroke: this.setOutlineStroke,
                /** @attr {String|draw2d.util.Color} color the color of the line */
                color: this.setColor,
                /** @attr {Number} stroke the line width of the color */
                stroke: this.setStroke,
                /** @attr {String} dasharray the line pattern see {@link draw2d.shape.basic.Line#setDashArray} for more information*/
                dasharray: this.setDashArray,
                /** @attr {Boolean} glow the glow flag for the shape. The representation of the "glow" depends on the shape */
                glow: this.setGlow
            }, setter),

            $.extend({}, {
                outlineColor: this.getOutlineColor,
                outlineStroke: this.getOutlineStroke,
                stroke: this.getStroke,
                dasharray: this.getDashArray
            }, getter));

        // create the selections handles/decorations
        this.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());

        this.setSelectable(true);
        this.setDeleteable(true);
    },

    /**
     * @method
     * Set the outline color of the line.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        outlineColor: color
    *      });
     *
     * @param {draw2d.util.Color/String} color The new color of the line.
     * @since 4.2.1
     **/
    setOutlineColor: function (color) {
        this.outlineColor = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:outlineColor");

        return this;
    },

    /**
     * @method
     * The outline color of the text
     *
     * @returns {draw2d.util.Color}
     * @since 4.2.1
     */
    getOutlineColor: function () {
        return this.outlineColor;
    },

    /**
     * @method
     * Set the outline stroke of the line to use.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        outlineStroke: w
    *      });
     *
     * @param {Number} w The new outline width of the line
     * @since 4.2.1
     **/
    setOutlineStroke: function (w) {
        this.outlineStroke = w;
        this.repaint();
        this.fireEvent("change:outlineStroke");

        return this;
    },

    /**
     * @method
     * The used outline line width.
     *
     * @type {Number}
     * @since 4.2.1
     **/
    getOutlineStroke: function () {
        return this.outlineStroke;
    },

    /**
     * @method
     * Don't call them manually. This will be done by the framework.<br>
     * Will be called if the object are moved via drag and drop.
     * Sub classes can override this method to implement additional stuff. Don't forget to call
     * the super implementation via <code>this._super(dx, dy, dx2, dy2);</code>
     * @private
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        if (this.command === null) {
            return;
        }

        this.command.setTranslation(dx, dy);

        this.vertices.each(function (i, e) {
            e.translate(dx2, dy2);
        });
        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        this.svgPathString = null;
        this._super(dx, dy, dx2, dy2);
    },

    /**
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        // Element ist zwar schon an seine Position, das Command muss aber trotzdem
        // in dem CommandStack gelegt werden damit das Undo funktioniert.
        //
        this.isInDragDrop = false;

        if (this.command === null) {
            return;
        }

        var _this = this;

        // we must undo the interim drag/drop translation of the line. The real translation will be done
        // by the execute of the command. Yes - you are right. This is a HACK or design flaw :-/
        this.getVertices().each(function (i, e) {
            e.translate(-_this.command.dx, -_this.command.dy);
        });

        this.canvas.getCommandStack().execute(this.command);
        this.command = null;
        this.isMoving = false;

        // notify all installed policies
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.onDragEnd(_this.canvas, _this, x, y, shiftKey, ctrlKey);
            }
        });

        // inform all other listener
        this.fireEvent("move");
    },

    /**
     * @method
     * Called when a user clicks on the element.
     *
     *      // Alternatively you can register for this event with
     *      figure.on("click", function(emitterFigure){
    *          alert("clicked");
    *      });
     *
     * @template
     * @since 4.0.0
     */
    onClick: function () {
    },

    /**
     * @method
     * Set the line style for this object.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        dash: dashPattern
    *      });
     *
     * @param dash can be one of this ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
     */
    setDashArray: function (dashPattern) {
        this.dasharray = dashPattern;
        this.repaint();

        this.fireEvent("change:dashArray");

        return this;
    },

    /**
     * @method
     * Get the line style for this object.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr("dash");
     *
     * @since 5.1.0
     */
    getDashArray: function (dashPattern) {
        return this.dasharray;
    },


    /**
     * @method
     * Set the width for the click hit test of this line.
     *
     * @param {Number} width the width of the line hit test.
     **/
    setCoronaWidth: function (width) {
        this.corona = width;

        return this;
    },


    /**
     * @method
     * Called by the framework. Don't call them manually.
     *
     * @private
     **/
    createShapeElement: function () {
        var set = this.canvas.paper.set();

        // the drop shadow or border line
        set.push(this.canvas.paper.path("M" + this.start.x + " " + this.start.y + "L" + this.end.x + " " + this.end.y));
        // the main path
        set.push(this.canvas.paper.path("M" + this.start.x + " " + this.start.y + "L" + this.end.x + " " + this.end.y));
        set.node = set.items[1].node;

        // indicate that the outline is visisble at the momenet
        // the repaint update the status correct and set the attributes the first time
        this.outlineVisible = true;

        return set;
    },

    /**
     * @inheritdoc
     *
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        // don't override existing values
        //
        if (typeof attributes === "undefined") {
            attributes = {
                "stroke": this.lineColor.hash(),
                "stroke-width": this.stroke,
                "path": ["M", this.start.x, this.start.y, "L", this.end.x, this.end.y].join(" ")
            };
        }
        else {
            if (typeof attributes.path === "undefined") {
                attributes.path = ["M", this.start.x, this.start.y, "L", this.end.x, this.end.y].join(" ");
            }
            attributes.stroke = this.lineColor.hash();
            attributes["stroke-width"] = this.stroke;
        }

        if (this.dasharray !== null) {
            attributes["stroke-dasharray"] = this.dasharray;
        }

        this._super(attributes);

        if (this.outlineStroke > 0) {
            this.shape.items[0].attr({
                "stroke-width": (this.outlineStroke + this.stroke),
                "stroke": this.outlineColor.hash()
            });
            if (this.outlineVisible === false)
                this.shape.items[0].show();
            this.outlineVisible = true;
        }
        else if (this.outlineVisible === true) {
            // reset them once
            this.shape.items[0].attr({"stroke-width": 0, "stroke": "none"});
            this.shape.items[0].hide();
        }
    },

    /**
     * @method
     * Highlight the element or remove the highlighting
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        glow: flag
    *      });
     *
     * @param {Boolean} flag indicates glow/noGlow
     * @template
     */
    setGlow: function (flag) {
        if (this.isGlowing === flag) {
            return;
        }

        if (flag === true) {
            // store old values for restore
            this._lineColor = this.lineColor;
            this._stroke = this.stroke;

            this.setColor(new draw2d.util.Color("#3f72bf"));
            this.setStroke((this.stroke * 4) | 0);
        }
        else {
            this.setColor(this._lineColor);
            this.setStroke(this._stroke);
        }

        this.isGlowing = flag;

        return this;
    },


    /**
     * You can't drag&drop the resize handles if the line not resizeable.
     * @type boolean
     **/
    isResizeable: function () {
        return true;
    },


    /**
     * Set the line width. This enforce a repaint of the line.
     * This method fires a <i>document dirty</i> event.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        stroke: w
    *      });
     *
     * @param {Number} w The new line width of the figure.
     **/
    setStroke: function (w) {
        this.stroke = parseFloat(w);

        this.repaint();
        this.fireEvent("change:stroke");

        return this;
    },


    /**
     * @method
     * The used line width.
     *
     * @type {Number}
     **/
    getStroke: function () {
        return this.stroke;
    },


    /**
     * @method
     * Set the color of the line.
     * This method fires a <i>document dirty</i> event.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        color: color
    *      });
     *
     * @param {draw2d.util.Color|String} color The new color of the line.
     **/
    setColor: function (color) {
        this.lineColor = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:color");

        return this;
    },

    /**
     * @method
     * Return the current paint color.
     *
     * @return {draw2d.util.Color} The paint color of the line.
     **/
    getColor: function () {
        return this.lineColor;
    },

    /**
     * @method
     * Translate the line with the given x/y offset.
     *
     * @param {Number} dx The new x translate offset
     * @param {Number} dy The new y translate offset
     * @since 4.1.0
     **/
    translate: function (dx, dy) {
        this.vertices.each(function (i, e) {
            e.translate(dx, dy);
        });
        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.svgPathString = null;
        this.repaint();

        return this;
    },

    /**
     * @method
     * return the bounding box of the line or polygon
     *
     * TODO: precalculate or cache this values
     *
     * @returns {draw2d.geo.Rectangle}
     * @since 4.8.2
     */
    getBoundingBox: function () {
        var minX = Math.min.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
            return n.x;
        }));
        var minY = Math.min.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
            return n.y;
        }));
        var maxX = Math.max.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
            return n.x;
        }));
        var maxY = Math.max.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
            return n.y;
        }));
        var width = maxX - minX;
        var height = maxY - minY;

        return new draw2d.geo.Rectangle(minX, minY, width, height);
    },


    /**
     * @method
     * Set the start point of the line.
     * This method fires a <i>document dirty</i> event.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        startX: x,
    *        startY: y
    *      });
     *
     * @param {Number} x the x coordinate of the start point
     * @param {Number} y the y coordinate of the start point
     **/
    setStartPoint: function (x, y) {
        if (this.start.x === x && this.start.y === y) {
            return this;
        }

        this.start.setPosition(x, y);
        this.repaint();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:start");

        return this;
    },


    setStartX: function (x) {
        this.setStartPoint(x, this.start.y);
    },

    setStartY: function (y) {
        this.setStartPoint(this.start.x, y);
    },

    setEndX: function (x) {
        this.setEndPoint(x, this.end.y);
    },

    setEndY: function (y) {
        this.setEndPoint(this.start.x, y);
    },

    /**
     * Set the end point of the line.
     * This method fires a <i>document dirty</i> event.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        endX: x,
    *        endY: y
    *      });
     *
     * @param {Number} x the x coordinate of the end point
     * @param {Number} y the y coordinate of the end point
     **/
    setEndPoint: function (x, y) {
        if (this.end.x === x && this.end.y === y) {
            return this;
        }

        this.end.setPosition(x, y);
        this.repaint();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("change:end");

        return this;
    },

    /**
     * @method
     * Return the x coordinate of the start.
     * @deprecated
     * @return {Number}
     **/
    getStartX: function () {
        return this.start.x;
    },

    /**
     * @method
     * Return the y coordinate of the start.
     *
     * @deprecated
     * @return {Number}
     **/
    getStartY: function () {
        return this.start.y;
    },

    /**
     * @method
     * Return the start point.
     *
     * @return {draw2d.geo.Point}
     **/
    getStartPoint: function () {
        return this.start.clone();
    },


    /**
     * @method
     * Return the x coordinate of the end point
     *
     * @deprecated
     * @return {Number}
     **/
    getEndX: function () {
        return this.end.x;
    },

    /**
     * @method
     * Return the y coordinate of the end point.
     *
     * @deprecated
     * @return {Number}
     **/
    getEndY: function () {
        return this.end.y;
    },

    /**
     * @method
     * Return the end point.
     *
     * @return {draw2d.geo.Point}
     **/
    getEndPoint: function () {
        return this.end.clone();
    },


    /**
     * @method
     * Return the Vertex with the given index.
     *
     * @param {Number} index the index of the vertex to return
     */
    getVertex: function (index) {
        return this.vertices.get(index);
    },

    /**
     * @method
     * Returns the vertices of the connection
     *
     * @return {draw2d.util.ArrayList} an draw2d.util.ArrayList of type draw2d.Point
     **/
    getVertices: function () {
        return this.vertices;
    },
    /* @deprecated */
    getPoints: function () {
        return this.getVertices();
    },

    /**
     * @method
     * Update the vertices of the object. The given array is copied and assigned.
     *
     * @param {draw2d.util.ArrayList} vertices the new vertices of the polyline.
     *
     * @since 4.0.1
     */
    setVertices: function (vertices) {
        this.vertices = vertices.clone(true);

        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        // update the UI and the segment parts
        this.svgPathString = null;
        this.repaint();

        var _this = this;
        // align the SelectionHandles to the new situation
        // This is a Hack....normally this should be done below and the Line shouldn't know
        // something about this issue....this is complete a "EditPolicy" domain to handle this.
        if (!this.selectionHandles.isEmpty()) {
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }

        // notify the listener about the changes
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("change:vertices");

        return this;
    },

    /**
     * @method
     * Return the segments of the line with {start:s, end: e} JSON array list
     *
     * @returns {draw2d.util.ArrayList}
     */
    getSegments: function () {
        var result = new draw2d.util.ArrayList();
        result.add({start: this.getStartPoint(), end: this.getEndPoint()});

        return result;
    },

    /**
     * @method
     * Returns the length of the line.
     *
     * @return {Number}
     **/
    getLength: function () {
        return Math.sqrt((this.start.x - this.end.x) * (this.start.x - this.end.x) + (this.start.y - this.end.y) * (this.start.y - this.end.y));
    },

    /**
     * @method
     * Returns the angle of the line in degree.
     *
     * <pre>
     *                                 270�?
     *                               |
     *                               |
     *                               |
     *                               |
     * 180�? -------------------------+------------------------> +X
     *                               |                        0�?
     *                               |
     *                               |
     *                               |
     *                               V +Y
     *                              90�?
     * </pre>
     * @return {Number}
     **/
    getAngle: function () {
        var length = this.getLength();
        var angle = -(180 / Math.PI) * Math.asin((this.start.y - this.end.y) / length);

        if (angle < 0) {
            if (this.end.x < this.start.x) {
                angle = Math.abs(angle) + 180;
            }
            else {
                angle = 360 - Math.abs(angle);
            }
        }
        else {
            if (this.end.x < this.start.x) {
                angle = 180 - angle;
            }
        }
        return angle;
    },

    /**
     * @method
     * Returns the Command to perform the specified Request or null if the shape want cancel the
     * operation or it can't operate the command.
     *
     * @param {draw2d.command.CommandType} request describes the Command being requested
     * @return {draw2d.command.Command} null or a Command
     * @private
     **/
    createCommand: function (request) {
        if (request.getPolicy() === draw2d.command.CommandType.MOVE) {
            if (this.isDraggable()) {
                return new draw2d.command.CommandMoveLine(this);
            }
        }
        if (request.getPolicy() === draw2d.command.CommandType.DELETE) {
            if (this.isDeleteable() === false) {
                return null;
            }
            return new draw2d.command.CommandDelete(this);
        }

        return null;
    },

    /**
     * @method
     * Checks if the hands over coordinate close to the line. The 'corona' is considered
     * for this test. This means the point isn't direct on the line. Is it only close to the
     * line!
     *
     * @param {Number} px the x coordinate of the test point
     * @param {Number} py the y coordinate of the test point
     * @return {boolean}
     **/
    hitTest: function (px, py) {
        return draw2d.shape.basic.Line.hit(this.corona + this.stroke, this.start.x, this.start.y, this.end.x, this.end.y, px, py);
    },

    /**
     * @method
     * Return all intersection points between the given Line.
     *
     * @param {draw2d.shape.basic.Line} other
     * @returns {draw2d.util.ArrayList}
     */
    intersection: function (other) {
        var result = new draw2d.util.ArrayList();

        // empty result. the lines are equal...infinit array
        if (other === this) {
            return result;
        }

        var segments1 = this.getSegments();
        var segments2 = other.getSegments();

        segments1.each(function (i, s1) {
            segments2.each(function (j, s2) {
                var p = draw2d.shape.basic.Line.intersection(s1.start, s1.end, s2.start, s2.end);
                if (p !== null) {
                    result.add(p);
                }
            });
        });
        return result;
    },


    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes: function () {
        var memento = this._super();
        delete memento.x;
        delete memento.y;
        delete memento.width;
        delete memento.height;

        memento.stroke = this.stroke;
        memento.color = this.getColor().hash();
        memento.outlineStroke = this.outlineStroke;
        memento.outlineColor = this.outlineColor.hash();
        if (this.dasharray !== null) {
            memento.dasharray = this.dasharray;
        }

        if (this.editPolicy.getSize() > 0) {
            memento.policy = this.editPolicy.getFirstElement().NAME;
        }

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.dasharray === "string") {
            this.dasharray = memento.dasharray;
        }
        if (typeof memento.stroke !== "undefined") {
            this.setStroke(parseFloat(memento.stroke));
        }
        if (typeof memento.color !== "undefined") {
            this.setColor(memento.color);
        }
        if (typeof memento.outlineStroke !== "undefined") {
            this.setOutlineStroke(memento.outlineStroke);
        }
        if (typeof memento.outlineColor !== "undefined") {
            this.setOutlineColor(memento.outlineColor);
        }
        if (typeof memento.policy !== "undefined") {
            try {
                this.installEditPolicy(eval("new " + memento.policy + "()"));
            }
            catch (exc) {
                debug.warn("Unable to install edit policy '" + memento.policy + "' forced by " + this.NAME + ".setPersistendAttributes. Using default.");
            }
        }
    }
});


/**
 * see: http://en.wikipedia.org/wiki/Line-line_intersection
 *
 * @param {draw2d.geo.Point} a1
 * @param {draw2d.geo.Point} a2
 * @param {draw2d.geo.Point} b1
 * @param {draw2d.geo.Point} b2
 *
 * @static
 * @private
 * @returns
 */
draw2d.shape.basic.Line.intersection = function (a1, a2, b1, b2) {
    var result = null;

    var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

    if (u_b != 0) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;

        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
            result = new draw2d.geo.Point((a1.x + ua * (a2.x - a1.x)) | 0, (a1.y + ua * (a2.y - a1.y)) | 0);

            // determine if the lines are crossing or just touching
            //
            result.justTouching = ( 0 == ua || ua == 1 || 0 == ub || ub == 1 );
        }
    }

    return result;
};

/**
 * Static util function to determine is a point(px,py) on the line(x1,y1,x2,y2)
 * A simple hit test.
 *
 * @return {boolean}
 * @static
 * @private
 * @param {Number} coronaWidth the accepted corona for the hit test
 * @param {Number} X1 x coordinate of the start point of the line
 * @param {Number} Y1 y coordinate of the start point of the line
 * @param {Number} X2 x coordinate of the end point of the line
 * @param {Number} Y2 y coordinate of the end point of the line
 * @param {Number} px x coordinate of the point to test
 * @param {Number} py y coordinate of the point to test
 **/
draw2d.shape.basic.Line.hit = function (coronaWidth, X1, Y1, X2, Y2, px, py) {
    // Adjust vectors relative to X1,Y1
    // X2,Y2 becomes relative vector from X1,Y1 to end of segment
    X2 -= X1;
    Y2 -= Y1;
    // px,py becomes relative vector from X1,Y1 to test point
    px -= X1;
    py -= Y1;
    var dotprod = px * X2 + py * Y2;
    var projlenSq;
    if (dotprod <= 0.0) {
        // px,py is on the side of X1,Y1 away from X2,Y2
        // distance to segment is length of px,py vector
        // "length of its (clipped) projection" is now 0.0
        projlenSq = 0.0;
    } else {
        // switch to backwards vectors relative to X2,Y2
        // X2,Y2 are already the negative of X1,Y1=>X2,Y2
        // to get px,py to be the negative of px,py=>X2,Y2
        // the dot product of two negated vectors is the same
        // as the dot product of the two normal vectors
        px = X2 - px;
        py = Y2 - py;
        dotprod = px * X2 + py * Y2;
        if (dotprod <= 0.0) {
            // px,py is on the side of X2,Y2 away from X1,Y1
            // distance to segment is length of (backwards) px,py vector
            // "length of its (clipped) projection" is now 0.0
            projlenSq = 0.0;
        } else {
            // px,py is between X1,Y1 and X2,Y2
            // dotprod is the length of the px,py vector
            // projected on the X2,Y2=>X1,Y1 vector times the
            // length of the X2,Y2=>X1,Y1 vector
            projlenSq = dotprod * dotprod / (X2 * X2 + Y2 * Y2);
        }
    }
    // Distance to line is now the length of the relative point
    // vector minus the length of its projection onto the line
    // (which is zero if the projection falls outside the range
    //  of the line segment).
    var lenSq = px * px + py * py - projlenSq;
    if (lenSq < 0) {
        lenSq = 0;
    }
    return Math.sqrt(lenSq) < coronaWidth;
};


/**
 * @class draw2d.shape.basic.PolyLine
 *
 * A PolyLine is a line with more than 2 points.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Line
 */
draw2d.shape.basic.PolyLine = draw2d.shape.basic.Line.extend({

    NAME: "draw2d.shape.basic.PolyLine",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        // internal status handling for performance reasons
        //
        this.svgPathString = null;
        this.oldPoint = null;

        this.router = null;
        this.routingRequired = true;
        this.lineSegments = new draw2d.util.ArrayList();

        this.radius = 2;

        this._super(
            $.extend(
                {router: draw2d.shape.basic.PolyLine.DEFAULT_ROUTER}, attr),
            $.extend({}, {
                /** @attr {draw2d.layout.connection.ConnectionRouter} the router to use to layout the polyline */
                router: this.setRouter,
                /** @attr {Number} radius the radius to render the line edges */
                radius: this.setRadius
            }, setter),
            $.extend({}, {
                router: this.getRouter,
                radius: this.getRadius
            }, getter)
        );
    },

    /**
     * @method
     * Sets the corner radius of the edges.
     *
     * @param {Number} radius the corner radius
     * @since 4.2.1
     */
    setRadius: function (radius) {
        this.radius = radius;
        this.svgPathString = null;
        this.repaint();
        this.fireEvent("change:radius");

        return this;
    },

    /**
     * @method
     * Get the corner radius of the edges.
     *
     * @return {Number}
     * @since 4.2.1
     */
    getRadius: function () {
        return this.radius;
    },


    /**
     * @method
     * Set the start point of the line.
     *
     * @param {Number} x the x coordinate of the start point
     * @param {Number} y the y coordinate of the start point
     **/
    setStartPoint: function (x, y) {
        if (this.start.x === x && this.start.y === y) {
            return this;
        }
        this.start.setPosition(x, y);
        this.calculatePath();
        this.repaint();
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:start");

        return this;
    },

    /**
     * @method
     * Set the end point of the line.
     *
     * @param {Number} x the x coordinate of the end point
     * @param {Number} y the y coordinate of the end point
     */
    setEndPoint: function (x, y) {
        if (this.end.x === x && this.end.y === y) {
            return this;
        }

        this.end.setPosition(x, y);
        this.calculatePath();
        this.repaint();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:end");

        return this;
    },

    /**
     * @method
     * Inserts the draw2d.geo.Point object into the vertex list of the polyline just after the object with the given index.
     *
     * @param {Number} index the insert index
     * @param {Number|draw2d.geo.Point} x the x coordinate or the draw2d.geo.Point object
     * @param {Number} [y] the y coordinate or undefined of the second argument is a point
     *
     * @since 4.0.0
     */
    addVertex: function (x, y) {
        this.vertices.add(new draw2d.geo.Point(x, y));

        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        this.svgPathString = null;
        this.repaint();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return this;
    },

    /**
     * @method
     * Update the vertex at the give position with the new coordinate
     *
     * @param {Number} index the index of the vertex to update
     * @param {Number|draw2d.geo.Point} x the x coordinate or the draw2d.geo.Point object
     * @param {Number} [y] the y coordinate or undefined of the second argument is a point
     *
     * @since 4.0.0
     */
    setVertex: function (index, x, y) {
        if (x instanceof draw2d.geo.Point) {
            y = x.y;
            x = x.x;
        }

        var vertex = this.vertices.get(index);

        // invalid point or nothing todo
        //
        if (vertex === null || (vertex.x === x && vertex.y === y)) {
            return;
        }

        vertex.x = parseFloat(x);
        vertex.y = parseFloat(y);

        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        this.svgPathString = null;
        this.routingRequired = true;
        this.repaint();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertices");

        return this;
    },


    /**
     * @method
     * Inserts the draw2d.geo.Point object into the vertex list of the polyline just after the object with the given index.
     *
     * @param {Number} index the insert index
     * @param {Number|draw2d.geo.Point} x the x coordinate or the draw2d.geo.Point object
     * @param {Number} [y] the y coordinate or undefined of the second argument is a point
     *
     * @since 4.0.0
     */
    insertVertexAt: function (index, x, y) {
        var vertex = new draw2d.geo.Point(x, y);

        this.vertices.insertElementAt(vertex, index);

        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        this.svgPathString = null;
        this.repaint();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return this;
    },


    /**
     * @method
     * Remove a vertex from the polyline and return the removed point. The current installed connection router
     * can send an veto for this operation.
     *
     * @param index
     * @returns {draw2d.geo.Point} the removed point or null of the current router decline this operation
     * @since 4.0.0
     */
    removeVertexAt: function (index) {
        var removedPoint = this.vertices.removeElementAt(index);

        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();

        this.svgPathString = null;
        this.repaint();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return removedPoint;
    },


    /**
     * @method
     * Set the router for this connection.
     *
     * @param {draw2d.layout.connection.ConnectionRouter} [router] the new router for this connection or null if the connection should use the default routing
     **/
    setRouter: function (router) {
        if (this.router !== null) {
            this.router.onUninstall(this);
        }

        if (typeof router === "undefined" || router === null) {
            this.router = new draw2d.layout.connection.DirectRouter();
        }
        else {
            this.router = router;
        }

        this.router.onInstall(this);

        this.routingRequired = true;

        // repaint the connection with the new router
        this.repaint();

        this.fireEvent("change:router");

        return this;
    },

    /**
     * @method
     * Return the current active router of this connection.
     *
     * @type draw2d.layout.connection.ConnectionRouter
     **/
    getRouter: function () {
        return this.router;
    },

    /**
     * @method
     * Calculate the path of the polyline
     *
     * @private
     */
    calculatePath: function () {

        if (this.shape === null) {
            return;
        }

        this.svgPathString = null;

        var oldVertices = this.vertices;

        // cleanup the routing cache
        //
        this.oldPoint = null;
        this.lineSegments = new draw2d.util.ArrayList();
        this.vertices = new draw2d.util.ArrayList();

        // Use the internal router
        //
        this.router.route(this, oldVertices);
        this.routingRequired = false;
        this.fireEvent("routed");
        this.fireEvent("change:route");

        // update the selection handles if the count of the vertices has changed.
        //
        /*
         if(oldVertices.getSize()!==this.vertices.getSize() && !this.selectionHandles.isEmpty()){
         this.editPolicy.each($.proxy(function(i, e) {
         if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
         e.onUnselect(this.canvas, this);
         e.onSelect(this.canvas, this);
         }
         }, this));
         }
         */
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        if (this.svgPathString === null || this.routingRequired === true) {
            this.calculatePath();
        }


        this._super($.extend({
            path: this.svgPathString,
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
        }, attributes));

        return this;
    },


    /**
     * @method
     * Called if the DragDrop object leaving the current hover figure.
     *
     * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
     * @template
     **/
    onDragLeave: function (draggedFigure) {
    },


    /**
     * @method
     * Return all line segments of the polyline.
     *
     * @returns {draw2d.util.ArrayList}
     */
    getSegments: function () {
        return this.lineSegments;
    },

    /**
     * @method
     * used for the router to add the calculated points
     *
     * @private
     *
     **/
    addPoint: function (/*:draw2d.geo.Point*/ p, y) {
        if (typeof y !== "undefined") {
            p = new draw2d.geo.Point(p, y);
        }
        this.vertices.add(p);

        if (this.oldPoint !== null) {
            // store the painted line segment for the "mouse selection test"
            // (required for user interaction)
            this.lineSegments.add({start: this.oldPoint, end: p});
        }
        this.svgPathString = null;
        this.oldPoint = p;
    },

    /**
     * @inheritdoc
     */
    onOtherFigureIsMoving: function (/*:draw2d.Figure*/ figure) {
        this.repaintBlocked = true;
        this._super(figure);
        this.calculatePath();

        this.repaintBlocked = false;
        this.repaint();
    },

    /**
     * @method
     * get the best segment of the line which is below the given coordinate or null if
     * all segment are not below the coordinate. <br>
     * The 'corona' property of the polyline is considered for this test. This means
     * the point isn't direct on the line. Is it only close to the line!
     *
     * @param {Number} px the x coordinate of the test point
     * @param {Number} py the y coordinate of the test point
     * @return {Object}
     * @since 4.4.0
     **/
    hitSegment: function (px, py) {
        for (var i = 0; i < this.lineSegments.getSize(); i++) {
            var segment = this.lineSegments.get(i);
            if (draw2d.shape.basic.Line.hit(this.corona, segment.start.x, segment.start.y, segment.end.x, segment.end.y, px, py)) {
                return {index: i, start: segment.start, end: segment.end};
            }
        }
        return null;
    },

    /**
     * @method
     * Checks if the hands over coordinate close to the line. The 'corona' property of the polyline
     * is considered for this test. This means the point isn't direct on the line. Is it only close to the
     * line!
     *
     * @param {Number} px the x coordinate of the test point
     * @param {Number} py the y coordinate of the test point
     * @return {boolean}
     **/
    hitTest: function (px, py) {
        return this.hitSegment(px, py) !== null;
    },

    /**
     * @inheritdoc
     */
    createCommand: function (request) {

        if (request.getPolicy() === draw2d.command.CommandType.DELETE) {
            if (this.isDeleteable() === true) {
                return new draw2d.command.CommandDelete(this);
            }
        }
        else if (request.getPolicy() === draw2d.command.CommandType.MOVE_VERTEX) {
            if (this.isResizeable() === true) {
                return new draw2d.command.CommandMoveVertex(this);
            }
        }
        else if (request.getPolicy() === draw2d.command.CommandType.MOVE_VERTICES) {
            if (this.isResizeable() === true) {
                return new draw2d.command.CommandMoveVertices(this);
            }
        }

        return this._super(request);
    },

    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = $.extend(this._super(), {
            router: this.router.NAME,
            radius: this.radius
        });

        memento = this.router.getPersistentAttributes(this, memento);

        return memento;
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.router !== "undefined") {
            try {
                this.setRouter(eval("new " + memento.router + "()"));
            }
            catch (exc) {
                debug.warn("Unable to install router '" + memento.router + "' forced by " + this.NAME + ".setPersistendAttributes. Using default");
            }
        }

        if (typeof memento.radius !== "undefined") {
            this.setRadius(memento.radius);
        }

        this.router.setPersistentAttributes(this, memento);

        this.start = this.vertices.first().clone();
        this.end = this.vertices.last().clone();
    }
});

/**
 * The default ConnectionRouter for the running applicaiton. Set this to your wanted implementation
 * {@link draw2d.layout.connection.ConnectionRouter}
 */
draw2d.shape.basic.PolyLine.DEFAULT_ROUTER = new draw2d.layout.connection.ManhattanConnectionRouter();


/**
 * @class draw2d.shape.basic.Image
 * Simple Image shape.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.node.Node
 */
draw2d.shape.basic.Image = draw2d.shape.node.Node.extend({
    NAME: "draw2d.shape.basic.Image",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr,
            $.extend({
                /** @attr {String} path the image path (absolute or relative) of the shape */
                path: this.setPath
            }, setter),
            $.extend({
                path: this.getPath
            }, getter));
    },


    /**
     * @method
     * Set the image path attribute of the Image shape and repaint them.
     * The path can be relative or absolute
     *
     * @param path
     * @since 2.8.0
     */
    setPath: function (path) {
        this.path = path;

        if (this.shape !== null) {
            this.shape.attr({src: this.path});
        }
        this.fireEvent("change:path");

        return this;
    },

    /**
     * @method
     * Return the image path attribute of the shape.
     *
     * @returns {String}
     * @since 2.8.0
     */
    getPath: function () {
        return this.path;
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return this;
        }

        attributes = attributes || {};

        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();
        attributes.width = this.getWidth();
        attributes.height = this.getHeight();
        attributes.src = this.path;

        // propagate the width/height as CSS attribute as well because Chrome
        // did some "flickering" in some versions and sometimes the image disappear complete
        $(this.shape.node).css({width: attributes.width, height: attributes.height});

        this._super(attributes);

        return this;
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        return this.canvas.paper.image(this.path, this.getX(), this.getY(), this.getWidth(), this.getHeight());
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        return $.extend(this._super(), {
            path: this.path
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);
        if (typeof memento.path !== "undefined") {
            this.setPath(memento.path);
        }
    }

});


/**
 * @class draw2d.shape.basic.Polygon
 * A Polygon figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var p1 =  new draw2d.shape.basic.Polygon({width:100, height:100});
 *     var p2 =  new draw2d.shape.basic.Polygon({width:100, height:60});
 *
 *     canvas.add(p1,10,10);
 *     canvas.add(p2,100,10);
 *
 *     p2.attr({color:"#f0f000", alpha:0.7});
 *
 *     canvas.setCurrentSelection(p2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Polygon = draw2d.VectorFigure.extend({

    NAME: "draw2d.shape.basic.Polygon",

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.minX = 0;
        this.minY = 0;
        this.maxX = 0;
        this.maxY = 0;
        this.vertices = new draw2d.util.ArrayList();

        this._super(attr);

        // we must cache the initial width/height because the width/height of the shape
        // is recalculated in the addVertex method. After the first call this values are 0/0
        if (this.vertices.getSize() === 0) {
            var w = this.width;
            var h = this.height;
            var pos = this.getPosition();
            this.addVertex(new draw2d.geo.Point(0, 0));
            this.addVertex(new draw2d.geo.Point(w, 0));
            this.addVertex(new draw2d.geo.Point(w, h));

            this.setPosition(pos);
        }

        this.svgPathString = null;

        this.installEditPolicy(new draw2d.policy.figure.VertexSelectionFeedbackPolicy());
    },

    /**
     * @inheritdoc
     */
    setRadius: function (radius) {
        this.svgPathString = null;

        this._super(radius);
        this.fireEvent("change:radius");

        return this;
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        // return some good default...
        return this.canvas.paper.path("M0 10L100 100");
    },

    /**
     * @method
     * calculate the path of the polygon
     *
     */
    calculatePath: function () {
        var radius = this.getRadius();
        var path = [];
        if (radius === 0) {
            var length = this.vertices.getSize();
            var p = this.vertices.get(0);
            path.push("M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
            for (var i = 1; i < length; i++) {
                p = this.vertices.get(i);
                path.push("L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
            }
            path.push("Z");
        }
        else {
            length = this.vertices.getSize();
            var start = this.vertices.first();
            var end = this.vertices.last();
            var begin = this.insetPoint(start, end, radius);
            path.push("M", (begin.x | 0) + 0.5, ",", (begin.y | 0) + 0.5);
            for (var i = 0; i < length; i++) {
                start = this.vertices.get(i);
                end = this.vertices.get((i + 1) % length);
                modStart = this.insetPoint(start, end, radius);
                modEnd = this.insetPoint(end, start, radius);
                path.push("Q", start.x, ",", start.y, " ", (modStart.x | 0) + 0.5, ", ", (modStart.y | 0) + 0.5);
                path.push("L", (modEnd.x | 0) + 0.5, ",", (modEnd.y | 0) + 0.5);
            }
        }
        this.svgPathString = path.join("");
        return this;
    },

    /**
     * @method
     * Returns a new ray with a new length but with the same direction of the start/end.
     *
     * @param start
     * @param end
     * @param distanceFromStart
     * @private
     * @returns
     */
    insetPoint: function (start, end, distanceFromStart) {
        if (start.equals(end)) {
            return start;
        }
        var vx = start.x - end.x;
        var vy = start.y - end.y;
        var length = Math.sqrt(vx * vx + vy * vy);
        var localDistance = Math.min(length / 2, distanceFromStart);
        return {
            x: end.x + vx / length * (length - localDistance),
            y: end.y + vy / length * (length - localDistance)
        };

    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        if (this.svgPathString === null) {
            this.calculatePath();
        }

        attributes = attributes || {};

        if (typeof attributes.path === "undefined") {
            attributes.path = this.svgPathString;
        }

        this._super(attributes);
    },

    /**
     * @method
     * Translate the figure with the given x/y offset. This method modifies all
     * vertices and the bounding box.
     *
     * @param {Number} dx The new x translate offset
     * @param {Number} dy The new y translate offset
     **/
    translate: function (dx, dy) {
        this.vertices.each(function (i, e) {
            e.translate(dx, dy);
        });
        this.svgPathString = null;

        this.repaint();

        this.updateBoundingBox();

        // Update the resize handles if the user change the position of the
        // element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("move");
        this.fireEvent("change:position");

        return this;
    },

    /**
     * @method
     * Change the position of the polygon. This method updates all vertices.
     *
     * @param {Number|draw2d.geo.Point} x
     * @param {Number} y
     */
    setPosition: function (x, y) {
        if (x instanceof draw2d.geo.Point) {
            y = x.y;
            x = x.x;
        }

        var dx = x - this.minX;
        var dy = y - this.minY;
        this.translate(dx, dy);

        this.x = x;
        this.y = y;

        return this;
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        var oldWidth = this.width;
        var oldHeight = this.height;

        this._super(w, h);

        var fracWidth = (1 / oldWidth) * this.width;
        var fracHeight = (1 / oldHeight) * this.height;

        var thisX = this.x;
        var thisY = this.y;
        this.vertices.each(function (i, e) {
            // calculate difference between point and figure origin
            var diffX = (e.getX() - thisX) * fracWidth;
            var diffY = (e.getY() - thisY) * fracHeight;
            e.setPosition(thisX + diffX, thisY + diffY);
        });

        this.svgPathString = null;
        this.repaint();
        this.fireEvent("change:dimension");

        return this;
    },

    /**
     * @method
     * Return all vertices of the polygon.
     *
     * @returns {draw2d.util.ArrayList}
     */
    getVertices: function () {
        return this.vertices;
    },


    /**
     * @method
     * Return the Vertex with the given index.
     *
     * @param {Number} index the index of the vertex to return
     * @since 5.0.2
     */
    getVertex: function (index) {
        return this.vertices.get(index);
    },

    resetVertices: function () {
        this.vertices = new draw2d.util.ArrayList();

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
    },

    /**
     * @method
     * Update the vertex at the given index. The method call didn't have any effect
     * if the vertex didn't exists.
     *
     * @param {Number} index
     * @param {Number} x
     * @param {Number} y
     */
    setVertex: function (index, x, y) {
        var vertex = this.vertices.get(index);

        // invalid point or nothing todo
        //
        if (vertex === null || (vertex.x === x && vertex.y === y)) {
            return this;
        }

        vertex.x = parseFloat(x);
        vertex.y = parseFloat(y);

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertex");

        return this;
    },

    /**
     * @method
     * Append a new vertex to the polygon.
     *
     * @param {Number} x
     * @param {Number} y
     */
    addVertex: function (x, y) {
        var vertex = null;
        if (x instanceof draw2d.geo.Point) {
            vertex = x.clone();
        }
        else {
            vertex = new draw2d.geo.Point(x, y);
        }
        this.vertices.add(vertex);


        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertices");

        return this;
    },

    /**
     * @method
     * Insert a new vertex at the given index. All vertices will be shifted to
     * free the requested index.
     *
     * @param {Number} index
     * @param {Number} x
     * @param {Number} y
     */
    insertVertexAt: function (index, x, y) {
        var vertex = new draw2d.geo.Point(x, y);

        this.vertices.insertElementAt(vertex, index);

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return this;
    },


    /**
     * @method
     * Remove a vertex from the polygon and return the removed point.
     *
     * @param {Number} index
     *
     * @returns {draw2d.geo.Point} the removed vertex
     */
    removeVertexAt: function (index) {
        // a polygon need at least 3 vertices
        //
        if (this.vertices.getSize() <= 3) {
            return null;
        }

        var vertex = this.vertices.removeElementAt(index);

        this.svgPathString = null;
        this.repaint();

        this.updateBoundingBox();

        if (!this.selectionHandles.isEmpty()) {
            var _this = this;
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices");

        return vertex;
    },


    /**
     * @inheritdoc
     */
    setRotationAngle: function (angle) {
        this.rotationAngle = 360 % angle;

        // The different to the other figures is, the the vertices must rotated instead of
        // transform the shape with SVG matrix.
        //
        // Reason: the vertices are selectable and in this case the coordinates must transform
        //         and not only the resulting SVG shape.
        //
        var radian = angle / (180 / Math.PI);
        var center = this.getBoundingBox().getCenter();
        var rotate = function (x, y, xm, ym, radian) {
            var cos = Math.cos,
                sin = Math.sin;
            return {
                x: (x - xm) * cos(radian) - (y - ym) * sin(radian) + xm,
                y: (x - xm) * sin(radian) + (y - ym) * cos(radian) + ym
            };
        };

        this.vertices.each(function (i, e) {
            var rot = rotate(e.x, e.y, center.x, center.y, radian);
            e.setPosition(rot.x, rot.y);
        });

        this.updateBoundingBox();


        // Update the resize handles if the user change the position of the element via an API call.
        //
        var _this = this;
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.repaint();
        this.fireEvent("change:angle");

        return this;
    },

    /**
     * @method
     * Calculate the bounding box of the shape and store them in an internal
     * variable for fast access.
     *
     * @private
     */
    updateBoundingBox: function () {
        if (this.vertices.isEmpty()) {
            this.minX = this.x;
            this.minY = this.y;
            this.maxX = this.x + this.width;
            this.maxY = this.y + this.height;
        }
        else {
            this.minX = this.x = Math.min.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.x;
            }));
            this.minY = this.y = Math.min.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.y;
            }));
            this.maxX = Math.max.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.x;
            }));
            this.maxY = Math.max.apply(Math, $.map(this.vertices.asArray(), function (n, i) {
                return n.y;
            }));
            this.width = this.maxX - this.minX;
            this.height = this.maxY - this.minY;
        }
    },


    /**
     * @inheritdoc
     */
    createCommand: function (request) {

        if (request.getPolicy() === draw2d.command.CommandType.MOVE_VERTEX) {
            if (this.isResizeable() === true) {
                return new draw2d.command.CommandMoveVertex(this);
            }
        }

        return this._super(request);
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        memento.vertices = [];

        this.vertices.each(function (i, e) {
            memento.vertices.push({x: e.x, y: e.y});
        });

        return memento;
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        // restore the points from the JSON data and add them to the polyline
        //
        if (typeof memento.vertices !== "undefined") {
            this.vertices = new draw2d.util.ArrayList();
            var _this = this;
            $.each(memento.vertices, function (i, e) {
                _this.addVertex(e.x, e.y);
            });
        }
    }
});


/**
 * @class draw2d.shape.basic.Diamond
 * A Diamond Figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var d1 =  new draw2d.shape.basic.Diamond({x:10,y:10});
 *     var d2 =  new draw2d.shape.basic.Diamond({x:100,y:10, bgColor:"#f0f000", alpha:0.7, width:100, height:60});
 *
 *     canvas.add(d1);
 *     canvas.add(d2);
 *
 *     canvas.setCurrentSelection(d2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Diamond = draw2d.shape.basic.Polygon.extend({
    NAME: "draw2d.shape.basic.Diamond",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: "#00a3f6", color: "#1B1B1B"}, attr), setter, getter);

        var pos = this.getPosition();

        this.resetVertices();

        var box = this.getBoundingBox();
        this.addVertex(box.w / 2, 0);       // Go to the top center..
        this.addVertex(box.w, box.h / 2); // ...draw line to the right middle
        this.addVertex(box.w / 2, box.h);   // ...bottom center...
        this.addVertex(0, box.h / 2); // ...left middle...

        // override the selection handler from the polygon. Because the vertices of
        // the diamond are not selectable and modifiable
        //
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());

        this.setPosition(pos);
    }


});


/**
 * @class draw2d.shape.basic.Triangle
 * A Triangle Figure.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
draw2d.shape.basic.Triangle = draw2d.shape.basic.Polygon.extend({
    NAME: "draw2d.shape.basic.Triangle",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: "#00a3f6", color: "#1B1B1B"}, attr), setter, getter);

        var pos = this.getPosition();

        this.resetVertices();

        var box = this.getBoundingBox();

        this.addVertex(0, box.h / 2);       // Go to the top center..
        this.addVertex(box.w, 0); // ...draw line to the right middle
        this.addVertex(box.w, box.h);   // ...bottom center...

        // override the selection handler from the polygon. Because the vertices of
        // the Triangle are not selectable and modifiable
        //
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());

        this.setPosition(pos);
    }


});

/**
 * @class draw2d.shape.composite.Composite
 * Base interface for the compiste shapes
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 * @since 4.7.2
 */
draw2d.shape.composite.Composite = draw2d.shape.basic.Rectangle.extend({
    NAME: "draw2d.shape.composite.Composite",

    /**
     * @constructor
     * Creates a new composite element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr, setter, getter);
    },

    /**
     * @method
     * Called when a user dbl clicks on the element
     *
     * @template
     */
    onDoubleClick: function () {
        // do nothing per default. no rotation of the shape.
    },

    /**
     * @method
     * Delegate method to calculate if a figure is selectable. A composite has the right to override the
     * initial selectable flag of the figure.
     *
     * @param {draw2d.Figure} figure the figure to test
     * @param {Boolean} selectable the initial selectable flag of the figure
     * @returns
     *
     */
    isMemberSelectable: function (figure, selectable) {
        return selectable;
    },

    /**
     * @method
     * Delegate method to calculate if a figure is draggable. A composite has the right to override the
     * initial draggable flag of the figure.
     *
     * @param {draw2d.Figure} figure the figure to test
     * @param {Boolean} draggable the initial draggable flag of the figure
     * @returns
     *
     */
    isMemberDraggable: function (figure, draggable) {
        return draggable;
    },

    delegateSelectionHandling: function (figure) {
        return figure;
    },

    /**
     * @method
     * Set the canvas element of this figures. This can be used to determine whenever an element
     * is added or removed to the canvas.
     *
     * @param {draw2d.Canvas} canvas the new parent of the figure or null
     */
    setCanvas: function (canvas) {
        this._super(canvas);

        // an composite shape goes always in the background
        //
        if (canvas !== null) {
            this.toBack();
        }
    }

});

/**
 * @class draw2d.shape.composite.StrongComposite
 * A StrongComposite is a composite figure with strong assignment of the children and the composite.
 * The child knows everything about the assigned composite and receives events about assignment to a
 * composite.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.Composite
 * @since 4.8.0
 */
draw2d.shape.composite.StrongComposite = draw2d.shape.composite.Composite.extend({
    NAME: "draw2d.shape.composite.StrongComposite",

    /**
     * @constructor
     * Creates a new strong composite element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this.assignedFigures = new draw2d.util.ArrayList();

        this._super(attr, setter, getter);

    },


    /**
     * @method
     * Assign a figure to the composite.
     *
     * @param {draw2d.Figure} figure
     * @template
     */
    assignFigure: function (figure) {
        return this;
    },

    /**
     * @method
     * Remove the given figure from the group assignment
     *
     * @param {draw2d.Figure} figure the figure to remove
     * @template
     */
    unassignFigure: function (figure) {
        return this;
    },

    /**
     * @method
     * Return all assigned figures of the composite
     *
     * @returns {draw2d.util.ArrayList}
     */
    getAssignedFigures: function () {
        return this.assignedFigures;
    },


    /**
     * @method
     * Called if the user drop this element onto the dropTarget. This event is ONLY fired if the
     * shape return "this" in the onDragEnter method.
     *
     *
     * @param {draw2d.Figure} dropTarget The drop target.
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     * @since  4.7.4
     **/
    onDrop: function (dropTarget, x, y, shiftKey, ctrlKey) {
    },

    /**
     * @method
     * Called if the user dropped an figure onto this element. This event is ONLY fired if the
     * shape return "this" in the onDragEnter method.
     *
     *
     * @param {draw2d.Figure} droppedFigure The dropped figure.
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     * @since 4.7.4
     **/
    onCatch: function (droppedFigure, x, y, shiftKey, ctrlKey) {
    },

    /**
     * @method
     * Moves the element so it is the closest to the viewer?��s eyes, on top of other elements. Additional
     * the internal model changed as well.
     *
     * Optional: Inserts current object in front of the given one.
     *
     * @param {draw2d.Figure} [figure] move current object in front of the given one.
     */
    toFront: function (figure) {
        this._super(figure);
        // ensure that all assigned figures are in front of the composite
        //
        var figures = this.getAssignedFigures().clone();
        figures.sort(function (a, b) {
            // return 1  if a before b
            // return -1 if b before a
            return a.getZOrder() > b.getZOrder() ? -1 : 1;
        });
        var _this = this;
        figures.each(function (i, f) {
            f.toFront(_this);
        });

        return this;
    },

    toBack: function (figure) {
        this._super(figure);
        // ensure that all assigned figures are in front of the composite
        //
        var figures = this.getAssignedFigures().clone();
        figures.sort(function (a, b) {
            // return 1  if a before b
            // return -1 if b before a
            return a.getZOrder() > b.getZOrder() ? -1 : 1;
        });

        var _this = this;
        figures.each(function (i, f) {
            f.toBack(_this);
        });

        return this;
    }
});


/**
 * @class draw2d.shape.composite.Group
 *
 * A group is a figure that acts as a transparent container for other figures. A group
 * is a StrongComposite node that controls a set of child figures. The bounding rectangle of
 * a group is the union of the bounds of its children. Child nodes cannot be selected or
 * manipulated individually.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.StrongComposite
 * @since 4.8.0
 */
draw2d.shape.composite.Group = draw2d.shape.composite.StrongComposite.extend({
    NAME: "draw2d.shape.composite.Group",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: null, color: null, resizeable: false}, attr), setter, getter);


        this.stickFigures = false;
    },

    /**
     * @method
     * Checks whenever a figure is selectable. In case of a group a single figure
     * isn't selectable. Just a complete group can be selected.
     *
     * @param {draw2d.Figure} figure the figure to check
     */
    delegateSelectionHandling: function (figure) {
        return this;
    },


    /**
     * @method
     * Delegate method to calculate if a figure is selectable. A composite has the right to override the
     * initial selectable flag of the figure.
     *
     * @param {draw2d.Figure} figure the figure to test
     * @param {Boolean} selectable the initial selectable flag of the figure
     * @returns
     *
     */
    isMemberSelectable: function (figure, selectable) {
        return false;
    },

    /**
     * @method
     * Delegate method to calculate if a figure is draggable. A composite has the right to override the
     * initial draggable flag of the figure.
     * <br>
     * Returns false because only the complete group is draggable
     *
     * @param {draw2d.Figure} figure the figure to test
     * @param {Boolean} draggable the initial draggable flag of the figure
     * @returns
     *
     */
    isMemberDraggable: function (figure, draggable) {
        return false;
    },

    /**
     * @method
     * Set the position of the object.
     *
     * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure
     * @param {Number} [y] The new y coordinate of the figure
     **/
    setPosition: function (x, y) {
        var oldX = this.x;
        var oldY = this.y;


        this._super(x, y);

        var dx = this.x - oldX;
        var dy = this.y - oldY;

        if (dx === 0 && dy === 0) {
            return this;
        }

        if (this.stickFigures === false) {
            this.assignedFigures.each(function (i, figure) {
                figure.translate(dx, dy);
            });
        }

        return this;
    },

    /**
     * @method
     * Assign a figure to the given group.
     * The bounding box of the group is recalculated and the union of the current bounding box with the
     * figure bounding box.
     *
     * @param {draw2d.Figure} figure
     */
    assignFigure: function (figure) {
        if (!this.assignedFigures.contains(figure)) {
            this.stickFigures = true;
            if (this.assignedFigures.isEmpty() === true) {
                this.setBoundingBox(figure.getBoundingBox());
            }
            else {
                this.setBoundingBox(this.getBoundingBox().merge(figure.getBoundingBox()));
            }
            this.assignedFigures.add(figure);
            figure.setComposite(this);
            this.stickFigures = false;
        }
        return this;
    },

    /**
     * @method
     * Remove the given figure from the group assignment
     *
     * @param {draw2d.Figure} figure the figure to remove
     *
     */
    unassignFigure: function (figure) {
        if (this.assignedFigures.contains(figure)) {
            this.stickFigures = true;
            figure.setComposite(null);
            this.assignedFigures.remove(figure);
            if (!this.assignedFigures.isEmpty()) {
                var box = this.assignedFigures.first().getBoundingBox();
                this.assignedFigures.each(function (i, figure) {
                    box.merge(figure.getBoundingBox());
                });
                this.setBoundingBox(box);
            }
            this.stickFigures = false;
        }

        return this;
    }
});


/**
 * @class draw2d.shape.composite.Jailhouse
 *
 * A Jailhouse is a figure that acts as a container for other figures. A Jailhouse
 * is a StrongComposite node that controls a set of child figures. Child nodes can't
 * moved outside of the composite.<br>
 * Objects in a jailhouse have the same Z-order, which can be relatively controlled with
 * respect to other figures.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.StrongComposite
 * @since 4.8.0
 */
draw2d.shape.composite.Jailhouse = draw2d.shape.composite.StrongComposite.extend({
    NAME: "draw2d.shape.composite.Jailhouse",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.policy = new draw2d.policy.figure.RegionEditPolicy(0, 0, 10, 10);
        this._super($.extend({bgColor: "#f0f0f0", color: "#333333"}, attr), setter, getter);

        this.stickFigures = false;
    },

    /**
     * @method
     * Set the new width and height of the figure and update the constraint policy for the assigned
     * figures..
     *
     * @param {Number} w The new width of the figure
     * @param {Number} h The new height of the figure
     **/
    setDimension: function (w, h) {
        this._super(w, h);
        this.policy.setBoundingBox(this.getAbsoluteBounds());
    },

    /**
     * @method
     * Return the figure which handles the selection handling. In case of a jailhouse, all
     * assigned figures are selectable and this method return always the "figure" parameter.
     *
     * @param {draw2d.Figure} figure the figure which requests the selection
     * @returns
     */
    delegateSelectionHandling: function (figure) {
        return figure;
    },


    /**
     * @method
     * Set the position of the object.
     *
     * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure
     * @param {Number} [y] The new y coordinate of the figure
     **/
    setPosition: function (x, y) {
        var oldX = this.x;
        var oldY = this.y;


        this._super(x, y);

        var dx = this.x - oldX;
        var dy = this.y - oldY;

        if (dx === 0 && dy === 0) {
            return this;
        }
        this.policy.setBoundingBox(this.getAbsoluteBounds());

        if (this.stickFigures === false) {
            this.assignedFigures.each(function (i, figure) {
                figure.translate(dx, dy);
            });
        }

        return this;
    },

    /**
     * @method
     * Assign a figure to the given group.
     * The bounding box of the group is recalculated and the union of the current bounding box with the
     * figure bounding box.
     *
     * @param {draw2d.Figure} figure
     */
    assignFigure: function (figure) {
        if (!this.assignedFigures.contains(figure) && figure !== this) {
            this.stickFigures = true;
            this.setBoundingBox(this.getBoundingBox().merge(figure.getBoundingBox()));
            this.assignedFigures.add(figure);
            figure.setComposite(this);
            figure.installEditPolicy(this.policy);
            figure.toFront(this);
            this.stickFigures = false;
        }
        return this;
    },

    /**
     * @method
     * Remove the given figure from the group assignment
     *
     * @param {draw2d.Figure} figure the figure to remove
     *
     */
    unassignFigure: function (figure) {
        if (this.assignedFigures.contains(figure)) {
            this.stickFigures = true;
            figure.setComposite(null);
            figure.uninstallEditPolicy(this.policy);
            this.assignedFigures.remove(figure);
            if (!this.assignedFigures.isEmpty()) {
                var box = this.assignedFigures.first().getBoundingBox();
                this.assignedFigures.each(function (i, figure) {
                    box.merge(figure.getBoundingBox());
                });
                this.setBoundingBox(box);
            }
            this.stickFigures = false;
        }

        return this;
    },

    onCatch: function (droppedFigure, x, y, shiftKey, ctrlKey) {
        this.getCanvas().getCommandStack().execute(new draw2d.command.CommandAssignFigure(droppedFigure, this));
    },


    /**
     * @method
     * Return the minWidth of the jailhouse. The minWidth is calculated by care the assigned figures.
     *
     *
     * @private
     * @returns
     */
    getMinWidth: function () {
        var width = 0;
        this.assignedFigures.each(function (i, figure) {
            width = Math.max(width, figure.getBoundingBox().getRight());
        });
        return width - this.getAbsoluteX();
    },

    /**
     * @method
     *
     * @private
     * @returns
     */
    getMinHeight: function () {
        var height = 0;
        this.assignedFigures.each(function (i, figure) {
            height = Math.max(height, figure.getBoundingBox().getBottom());
        });
        return height - this.getAbsoluteY();
    }
});


/**
 * @class draw2d.shape.composite.WeakComposite
 * A WeakComposite is a composite figure with loose coupling of the children and the composite.
 * The child didn't know anything about the assigned composite nor did they receive any events
 * about assignment to a composite.
 *
 * Assignment without obligation.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.Composite
 * @since 4.8.0
 */
draw2d.shape.composite.WeakComposite = draw2d.shape.composite.Composite.extend({
    NAME: "draw2d.shape.composite.WeakComposite",

    /**
     * @constructor
     * Creates a new weak composite element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr, setter, getter);
    }
});


/**
 * @class draw2d.shape.composite.Raft
 * Raft figures are shapes, which aggregate multiple figures. It works like a real raft. Aboard figures are
 * moved if the raft figures moves.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var rect1 =  new draw2d.shape.composite.Raft({width:200, height:100});
 *     var rect2 =  new draw2d.shape.basic.Rectangle({width:50, height:50});
 *
 *     canvas.add(rect1,10,10);
 *     canvas.add(rect2,20,20);
 *
 *     rect2.attr({bgColor:"#f0f000", width:50, height:50, radius:10});
 *
 *     canvas.setCurrentSelection(rect1);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.WeakComposite
 * @since 4.7.0
 */
draw2d.shape.composite.Raft = draw2d.shape.composite.WeakComposite.extend({
    NAME: "draw2d.shape.composite.Raft",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this.aboardFigures = new draw2d.util.ArrayList();

        this._super($.extend({bgColor: "#f0f0f0", color: "#1B1B1B"}, attr), setter, getter);
    },


    /**
     * @method
     * Will be called if the drag and drop action begins. You can return [false] if you
     * want avoid that the figure can be move.
     *
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean} true if the figure accepts dragging
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {
        this._super(x, y, shiftKey, ctrlKey);

        this.aboardFigures = new draw2d.util.ArrayList();
        // force the recalculation of the aboard figures if the shape is in a drag&drop operation
        this.getAboardFigures(this.isInDragDrop);
    },

    /**
     * @method
     * Set the position of the object.
     *
     * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure
     * @param {Number} [y] The new y coordinate of the figure
     **/
    setPosition: function (x, y) {
        var oldX = this.x;
        var oldY = this.y;

        // we need the figures before the composite has moved. Otherwise some figures are fall out of the raft
        //
        var aboardedFigures = this.getAboardFigures(this.isInDragDrop === false);

        this._super(x, y);

        var dx = this.x - oldX;
        var dy = this.y - oldY;

        if (dx === 0 && dy === 0) {
            return this;
        }

        aboardedFigures.each(function (i, figure) {
            figure.translate(dx, dy);
        });

        return this;
    },

    /**
     * @method
     * Return all figures which are aboard of this shape. These shapes are moved as well if the raft
     * is moving.
     *
     * @returns {draw2d.util.ArrayList}
     */
    getAboardFigures: function (recalculate) {
        if (recalculate === true && this.canvas !== null) {
            var raftBoundingBox = this.getBoundingBox();
            var zIndex = this.getZOrder();
            this.aboardFigures = new draw2d.util.ArrayList();

            var _this = this;
            this.getCanvas().getFigures().each(function (i, figure) {
                if (figure !== _this && figure.isSelectable() === true && figure.getBoundingBox().isInside(raftBoundingBox)) {
                    // Don't add the figure if it is already catched by another composite with a higher z-index
                    //
                    if (_this.getNextComposite(figure) !== _this) {
                        return;
                    }
                    // only add the shape if it is in front of the raft
                    if (figure.getZOrder() > zIndex) {
                        _this.aboardFigures.add(figure);
                    }
                }
            });
        }
        return this.aboardFigures;
    },

    /**
     * @method
     * return the next potential composite parent figure
     *
     * @param figureToTest
     * @returns
     */
    getNextComposite: function (figureToTest) {
        var nextComposite = null;
        this.getCanvas().getFigures().each(function (i, figure) {
            if (figureToTest === figure) {
                return;
            }
            if (figure instanceof draw2d.shape.composite.Composite) {
                if (nextComposite !== null && nextComposite.getZOrder() > figure.getZOrder()) {
                    return;
                }

                if (figure.getBoundingBox().contains(figureToTest.getBoundingBox())) {
                    nextComposite = figure;
                }
            }
        });

        return nextComposite;
    }
});


/**
 * @class draw2d.Connection
 * See the example:
 *
 *     @example preview small frame
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.Connection();
 *
 *     // Set the endpoint decorations for the connection
 *     //
 *     c.setSourceDecorator(new draw2d.decoration.connection.BarDecorator());
 *     c.setTargetDecorator(new draw2d.decoration.connection.DiamondDecorator());
 *     // Connect the endpoints with the start and end port
 *     //
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 * Connections figures are used to display a line between two points. The Connection interface extends
 * {@link draw2d.shape.basic.PolyLine PolyLine}.<br>
 * The source and target endpoints of a connection are each defined using a {@link draw2d.layout.anchor.ConnectionAnchor ConnectionAnchor}.
 * These endpoints, along with any other points on the connection, are set by the connection's  {@link draw2d.layout.connection.ConnectionRouter ConnectionRouter}.
 * <br>
 * Usually every connection in a drawing has the same router instance. Connections with
 * common endpoints can share anchor instances as well.
 *
 * <h2>Connection Usage</h2>
 *
 * Connections are created and added just like any other figure. Unlike normal figures, you must not set the
 * bounds of a connection. Instead, you must provide the source and target port and let the connection router
 * calculate the connection's points. The connection then determines its own bounding box.<br>
 * <br>
 * A connection has a simple router by default - one that can connect the source and target anchors. But additional routers
 * are available and can be set on the connection. Some routers can handle constraints for the connection. Note that when
 * setting a routing constraint on a connection, you must first set the router which will use that constraint.<br>
 * <br>
 *
 * <b>TODO:<br></b>
 * <i>
 * A convenient way to share the router with all connections and to place connections above the drawing is to use a
 * ConnectionLayer. The layer has a connection router property which it shares with every child that's a connection.
 * You can update this property and easily change every connection's router at once.
 * </i>
 * <br>
 * <br>
 * <h2>Routing and Anchors</h2>
 * A connection always has a router and it must set at least two ports on the connection: the source and target
 * endpoints. By default, or when set to null, the connection's routing will be performed by an internal default router.
 * The ends are placed with the help of {@link draw2d.layout.anchor.ConnectionAnchor anchors}. An
 * {@link draw2d.layout.anchor.ConnectionAnchor anchors} is a fixed or calculated location, usually associated with some
 * figure. For example, the {@link draw2d.layout.anchor.ChopboxConnectionAnchor ChopboxAnchor} finds the point at which a
 * line going to the reference point intersects a box, such as the bounds of a figure. The reference point is either
 * the anchor at the opposite end, or a bendpoint or some other point nearest to the anchor.
 * <br>
 * {@img jsdoc_chopbox.gif ChopboxAnchor}
 * <br>
 * The router calculates the endpoints and any other points in the middle of the connection. It then sets the points on the
 * connection by calling {@link draw2d.shape.basic.PolyLine#addPoint Polyline.addPoint}. The connection's existing point list
 * can be reused to reduce garbage, but the points must be set on the connection anyway so that it knows about any changes made.
 * <br>
 * <h2>Adding Decorations and Children to Connections</h2>
 * Like most figures, Connection supports the addition of children. The children might be a label that
 * decorate the connection. The placement of each type of decoration can vary, so a {@link draw2d.layout.locator.ConnectionLocator ConnectionLocator}
 * is used to delegate to each child's constraint object, a Locator. <br>
 * <br>
 * {@link draw2d.decoration.connection.Decorator Decorator} can be used to create and render a rotatable shape at
 * the end or start of a connection like arrows or boxes. Examples are {@link draw2d.decoration.connection.ArrowDecorator ArrowDecorator}, {@link draw2d.decoration.connection.BarDecorator BarDecorator} or {@link draw2d.decoration.connection.CircleDecorator CircleDecorator}
 * <br>
 * <h2>Connection Layout</h2>
 * Connections extend the process of validation and layout to include routing. Since layout is the process of positioning children, routing must
 * come first. This allows a child's locator to operate on the connection's newly-routed points.<br>
 * Check out [Class System Guide](#!/guide/class_system) for additional reading.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.PolyLine
 */
draw2d.Connection = draw2d.shape.basic.PolyLine.extend({
    NAME: "draw2d.Connection",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this.sourcePort = null;
        this.targetPort = null;

        this.oldPoint = null;

        this.sourceDecorator = null;
        /*:draw2d.ConnectionDecorator*/
        this.targetDecorator = null;
        /*:draw2d.ConnectionDecorator*/

        // decoration of the polyline
        //
        this.sourceDecoratorNode = null;
        this.targetDecoratorNode = null;

        this.isMoving = false;

        var _this = this;
        this.moveListener = function (figure) {
            if (figure === _this.sourcePort) {
                _this.setStartPoint(_this.sourcePort.getAbsoluteX(), _this.sourcePort.getAbsoluteY());
            }
            else {
                _this.setEndPoint(_this.targetPort.getAbsoluteX(), _this.targetPort.getAbsoluteY());
            }
        };

        this._super(
            $.extend({color: "#1b1b1b", stroke: 1}, attr),
            $.extend({
                router: this.setRouter,
                sourceDecorator: this.setSourceDecorator,
                targetDecorator: this.setTargetDecorator,
                source: this.setSource,
                target: this.setTarget
            }, setter),
            $.extend({
                router: this.getRouter,
                sourceDecorator: this.getSourceDecorator,
                targetDecorator: this.getTargetDecorator,
                source: this.getSource,
                target: this.getTarget
            }, getter)
        );
    },


    /**
     * @private
     **/
    disconnect: function () {
        if (this.sourcePort !== null) {
            this.sourcePort.off(this.moveListener);
            this.sourcePort.connections.remove(this);
            this.fireSourcePortRouteEvent();
        }

        if (this.targetPort !== null) {
            this.targetPort.off(this.moveListener);
            this.targetPort.connections.remove(this);
            this.fireTargetPortRouteEvent();
        }
    },


    /**
     * @private
     **/
    reconnect: function () {
        if (this.sourcePort !== null) {
            this.sourcePort.on("move", this.moveListener);
            this.sourcePort.connections.add(this);
            this.fireSourcePortRouteEvent();
        }

        if (this.targetPort !== null) {
            this.targetPort.on("move", this.moveListener);
            this.targetPort.connections.add(this);
            this.fireTargetPortRouteEvent();
        }
        this.routingRequired = true;
        this.repaint();
    },


    /**
     * You can't drag&drop the resize handles of a connector.
     * @type boolean
     **/
    isResizeable: function () {
        return this.isDraggable();
    },


    /**
     * @method
     * Add a child figure to the Connection. The hands over figure doesn't support drag&drop
     * operations. It's only a decorator for the connection.<br>
     * Mainly for labels or other fancy decorations :-)
     *
     * @param {draw2d.Figure} figure the figure to add as decoration to the connection.
     * @param {draw2d.layout.locator.ConnectionLocator} locator the locator for the child.
     **/
    add: function (child, locator) {
        // just to ensure the right interface for the locator.
        // The base class needs only 'draw2d.layout.locator.Locator'.
        if (!(locator instanceof draw2d.layout.locator.ConnectionLocator)) {
            throw "Locator must implement the class draw2d.layout.locator.ConnectionLocator";
        }

        this._super(child, locator);
    },


    /**
     * @method
     * Set the ConnectionDecorator for this object.
     *
     * @param {draw2d.decoration.connection.Decorator} the new source decorator for the connection
     **/
    setSourceDecorator: function (decorator) {
        this.sourceDecorator = decorator;
        this.routingRequired = true;
        if (this.sourceDecoratorNode !== null) {
            this.sourceDecoratorNode.remove();
            this.sourceDecoratorNode = null;
        }
        this.repaint();
    },

    /**
     * @method
     * Get the current source ConnectionDecorator for this object.
     *
     * @returns draw2d.decoration.connection.Decorator
     **/
    getSourceDecorator: function () {
        return this.sourceDecorator;
    },

    /**
     * @method
     * Set the ConnectionDecorator for this object.
     *
     * @param {draw2d.decoration.connection.Decorator} the new target decorator for the connection
     **/
    setTargetDecorator: function (decorator) {
        this.targetDecorator = decorator;
        this.routingRequired = true;
        if (this.targetDecoratorNode !== null) {
            this.targetDecoratorNode.remove();
            this.targetDecoratorNode = null;
        }
        this.repaint();
    },

    /**
     * @method
     * Get the current target ConnectionDecorator for this object.
     *
     * @returns draw2d.decoration.connection.Decorator
     **/
    getTargetDecorator: function () {
        return this.targetDecorator;
    },


    /**
     * @method
     * Calculate the path of the polyline.
     *
     * @private
     */
    calculatePath: function () {

        if (this.sourcePort === null || this.targetPort === null) {
            return this;
        }

        this._super();

        return this;
    },

    /**
     * @private
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        if (this.sourcePort === null || this.targetPort === null) {
            return;
        }


        this._super(attributes);

        // paint the decorator if any exists
        //
        if (this.targetDecorator !== null && this.targetDecoratorNode === null) {
            this.targetDecoratorNode = this.targetDecorator.paint(this.getCanvas().paper);
        }

        if (this.sourceDecorator !== null && this.sourceDecoratorNode === null) {
            this.sourceDecoratorNode = this.sourceDecorator.paint(this.getCanvas().paper);
        }

        var _this = this;

        // translate/transform the decorations to the end/start of the connection
        // and rotate them as well
        //
        if (this.sourceDecoratorNode !== null) {
            var start = this.getVertices().first();
            this.sourceDecoratorNode.transform("r" + this.getStartAngle() + "," + start.x + "," + start.y + " t" + start.x + "," + start.y);
            // propagate the color and the opacity to the decoration as well
            this.sourceDecoratorNode.attr({"stroke": "#" + this.lineColor.hex(), opacity: this.alpha});
            this.sourceDecoratorNode.forEach(function (shape) {
                shape.node.setAttribute("class", _this.cssClass !== null ? _this.cssClass : "");
            });
        }

        if (this.targetDecoratorNode !== null) {
            var end = this.getVertices().last();
            this.targetDecoratorNode.transform("r" + this.getEndAngle() + "," + end.x + "," + end.y + " t" + end.x + "," + end.y);
            this.targetDecoratorNode.attr({"stroke": "#" + this.lineColor.hex(), opacity: this.alpha});
            this.targetDecoratorNode.forEach(function (shape) {
                shape.node.setAttribute("class", _this.cssClass !== null ? _this.cssClass : "");
            });
        }

    },

    /**
     * @method
     * The x-offset related to the canvas.
     * Didn't provided by a connection. Return always '0'. This is required
     * for children position calculation. (e.g. Label decoration)
     *
     * @return {Number} the x-offset to the parent figure
     **/
    getAbsoluteX: function () {
        return 0;
    },


    /**
     * @method
     * The y-offset related to the canvas.
     * Didn't provided by a connection. Return always '0'. This is required
     * for children position calculation. (e.g. Label decoration)
     *
     * @return {Number} The y-offset to the parent figure.
     **/
    getAbsoluteY: function () {
        return 0;
    },


    postProcess: function (postProcessCache) {
        this.router.postProcess(this, this.getCanvas(), postProcessCache);
    },


    /**
     * @method
     * Don't call them manually. This will be done by the framework.<br>
     * Will be called if the object are moved via drag and drop.
     * Sub classes can override this method to implement additional stuff. Don't forget to call
     * the super implementation via <code>this._super(dx, dy, dx2, dy2);</code>
     * @private
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        if (this.command === null) {
            return;
        }

        this.command.setTranslation(dx, dy);

        // don't drag start/end around. This Points are bounded to the related
        // ports.
        var count = this.getVertices().getSize() - 1;
        for (var i = 1; i < count; i++) {
            this.getVertex(i).translate(dx2, dy2);

        }

        var _this = this;

        // notify all installed policies
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.onDrag(_this.canvas, _this);
            }
        });

        this.svgPathString = null;
        this.repaint();

        // Update the resize handles if the user change the position of the
        // element via an API call.
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });

        this.fireEvent("move");
    },


    /**
     * @method
     * Called if the DragDrop object leaving the current hover figure.
     *
     * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
     * @template
     **/
    onDragLeave: function (draggedFigure) {
    	this.setGlow(false);
    },


    /**
     * @method
     * Return the recalculated position of the start point with the usage of
     * the installed connection anchor locator.
     *
     * @return draw2d.geo.Point
     **/
    getStartPoint: function (refPoint) {
        if (this.isMoving === false) {
            if (refPoint) {
                return this.sourcePort.getConnectionAnchorLocation(refPoint, this);
            }
            return this.sourcePort.getConnectionAnchorLocation(this.targetPort.getConnectionAnchorReferencePoint(this), this);
        }

        return this._super();
    },


    /**
     * @method
     * Return the recalculated position of the start point with the usage of
     * the installed connection anchor locator.
     *
     * @return draw2d.geo.Point
     **/
    getEndPoint: function (refPoint) {
        if (this.isMoving === false) {
            if (refPoint) {
                return this.targetPort.getConnectionAnchorLocation(refPoint, this);
            }
            return this.targetPort.getConnectionAnchorLocation(this.sourcePort.getConnectionAnchorReferencePoint(this), this);
        }

        return this._super();
    },

    /**
     * @method
     * Set the new source port of this connection. This enforce a repaint of the connection.
     *
     * @param {draw2d.Port} port The new source port of this connection.
     *
     **/
    setSource: function (port) {
        if (this.sourcePort !== null) {
            this.sourcePort.off(this.moveListener);
            this.sourcePort.connections.remove(this);
            this.sourcePort.fireEvent("disconnect", this);
            this.canvas.fireEvent("disconnect", {"port": this.sourcePort, "connection": this});
            this.sourcePort.onDisconnect(this);
        }

        this.sourcePort = port;
        if (this.sourcePort === null) {
            return;
        }

        this.routingRequired = true;
        this.fireSourcePortRouteEvent();
        if(this.sourcePort != undefined) {
            this.sourcePort.connections.add(this);
            this.sourcePort.on("move", this.moveListener);
        }

        if (this.canvas !== null) {
            this.canvas.fireEvent("connect", {"port": this.sourcePort, "connection": this});
            this.sourcePort.fireEvent("connect", this);
            this.sourcePort.onConnect(this);
        }
        this.setStartPoint(port.getAbsoluteX(), port.getAbsoluteY());
    },

    /**
     * @method
     * Returns the source port of this connection.
     *
     * @type draw2d.Port
     **/
    getSource: function () {
        return this.sourcePort;
    },

    /**
     * @method
     * Set the target port of this connection. This enforce a repaint of the connection.
     *
     * @param {draw2d.Port} port The new target port of this connection
     **/
    setTarget: function (port) {
        if (this.targetPort !== null) {
            this.targetPort.off(this.moveListener);
            this.targetPort.connections.remove(this);
            this.targetPort.fireEvent("disconnect", this);
            this.canvas.fireEvent("disconnect", {"port": this.targetPort, "connection": this});
            this.targetPort.onDisconnect(this);
        }

        this.targetPort = port;
        if (this.targetPort === null) {
            return;
        }

        this.routingRequired = true;
        this.fireTargetPortRouteEvent();
        this.targetPort.connections.add(this);
        this.targetPort.on("move", this.moveListener);
        if (this.canvas !== null) {
            this.canvas.fireEvent("connect", {"port": this.targetPort, "connection": this});
            this.targetPort.fireEvent("connect", this);
            this.targetPort.onConnect(this);
        }
        this.setEndPoint(port.getAbsoluteX(), port.getAbsoluteY());
    },

    /**
     * @method
     * Returns the target port of this connection.
     *
     * @type draw2d.Port
     **/
    getTarget: function () {
        return this.targetPort;
    },

    /**
     * @method
     * Method returns true if the connection has at least one common draw2d.Port with the given connection.
     *
     * @param {draw2d.Connection} other
     * @returns {Boolean}
     */
    sharingPorts: function (other) {
        return this.sourcePort == other.sourcePort ||
            this.sourcePort == other.targetPort ||
            this.targetPort == other.sourcePort ||
            this.targetPort == other.targetPort;
    },


    /**
     * @method
     * Set the canvas element of this figures.
     *
     * @param {draw2d.Canvas} canvas the new parent of the figure or null
     */
    setCanvas: function (canvas) {
        var notiCanvas = this.canvas == null ? canvas : this.canvas;

        this._super(canvas);


        if (this.sourceDecoratorNode !== null) {
            this.sourceDecoratorNode.remove();
            this.sourceDecoratorNode = null;
        }

        if (this.targetDecoratorNode !== null) {
            this.targetDecoratorNode.remove();
            this.targetDecoratorNode = null;
        }

        if (this.canvas === null) {
            this.router.onUninstall(this);

            if (this.sourcePort !== null) {
                this.sourcePort.off(this.moveListener);
                notiCanvas.fireEvent("disconnect", {"port": this.sourcePort, "connection": this});
                this.sourcePort.onDisconnect(this);
            }
            if (this.targetPort !== null) {
                this.targetPort.off(this.moveListener);
                notiCanvas.fireEvent("disconnect", {"port": this.targetPort, "connection": this});
                this.targetPort.onDisconnect(this);
            }
        }
        else {
            this.router.onInstall(this);

            if (this.sourcePort !== null) {
                this.sourcePort.on("move", this.moveListener);
                this.canvas.fireEvent("connect", {"port": this.sourcePort, "connection": this});
                this.sourcePort.onConnect(this);
            }
            if (this.targetPort !== null) {
                this.targetPort.on("move", this.moveListener);
                this.canvas.fireEvent("connect", {"port": this.targetPort, "connection": this});
                this.targetPort.onConnect(this);
            }
        }

    },


    /**
     * Returns the angle of the connection at the output port (source)
     *
     **/
    getStartAngle: function () {
        // return a good default value if the connection is not routed at the
        //  moment
        if (this.lineSegments.getSize() === 0) {
            return 0;
        }

        var p1 = this.lineSegments.get(0).start;
        var p2 = this.lineSegments.get(0).end;
        if (this.router instanceof draw2d.layout.connection.SplineConnectionRouter) {
            p2 = this.lineSegments.get(5).end;
        }
        var length = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
        var angle = -(180 / Math.PI) * Math.asin((p1.y - p2.y) / length);

        if (angle < 0) {
            if (p2.x < p1.x) {
                angle = Math.abs(angle) + 180;
            }
            else {
                angle = 360 - Math.abs(angle);
            }
        }
        else {
            if (p2.x < p1.x) {
                angle = 180 - angle;
            }
        }
        return angle;
    },

    getEndAngle: function () {
        // return a good default value if the connection is not routed at the
        //  moment
        if (this.lineSegments.getSize() === 0) {
            return 90;
        }

        var p1 = this.lineSegments.get(this.lineSegments.getSize() - 1).end;
        var p2 = this.lineSegments.get(this.lineSegments.getSize() - 1).start;
        if (this.router instanceof draw2d.layout.connection.SplineConnectionRouter) {
            p2 = this.lineSegments.get(this.lineSegments.getSize() - 5).end;
        }
        var length = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
        var angle = -(180 / Math.PI) * Math.asin((p1.y - p2.y) / length);

        if (angle < 0) {
            if (p2.x < p1.x) {
                angle = Math.abs(angle) + 180;
            }
            else {
                angle = 360 - Math.abs(angle);
            }
        }
        else {
            if (p2.x < p1.x) {
                angle = 180 - angle;
            }
        }
        return angle;
    },


    /**
     * @private
     **/
    fireSourcePortRouteEvent: function () {
        if(this.sourcePort == undefined) {
            return;
        }
        this.sourcePort.getConnections().each(function (i, conn) {
            conn.routingRequired = true;
            conn.repaint();
        });
    },

    /**
     * @private
     **/
    fireTargetPortRouteEvent: function () {
        // enforce a repaint of all connections which are related to this port
        // this is required for a "FanConnectionRouter" or "ShortesPathConnectionRouter"
        //
        this.targetPort.getConnections().each(function (i, conn) {
            conn.routingRequired = true;
            conn.repaint();
        });
    },


    /**
     * @method
     * Returns the Command to perform the specified Request or null.
     *
     * @param {draw2d.command.CommandType} request describes the Command being requested
     * @return {draw2d.command.Command} null or a Command
     **/
    createCommand: function (request) {
        if (request.getPolicy() === draw2d.command.CommandType.MOVE_BASEPOINT) {
            // DragDrop of a connection doesn't create a undo command at this point. This will be done in
            // the onDrop method
            return new draw2d.command.CommandReconnect(this);
        }

        return this._super(request);
    },


    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        var parentNode = this.getSource().getParent();
        while (parentNode.getParent() !== null) {
            parentNode = parentNode.getParent();
        }
        memento.source = {
            node: parentNode.getId(),
            port: this.getSource().getName()
        };

        var parentNode = this.getTarget().getParent();
        while (parentNode.getParent() !== null) {
            parentNode = parentNode.getParent();
        }
        memento.target = {
            node: parentNode.getId(),
            port: this.getTarget().getName()
        };

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        // nothing to to for the connection creation. This will be done in the draw2d.io.Reader
        // implementation
        //
    }
});

/**
 * @method
 * Factory method to provide a default connection for all drag&drop connections. You
 * can override this method and customize this for your personal purpose.
 *
 * Either you return a conection of "undefined". If "undefined" returned the "callback" must
 * be called by this method.
 *
 * @param {draw2d.Port} sourcePort port of the source of the connection
 * @param {draw2d.Port} targetPort port of the target of the connection
 * @template
 * @returns {draw2d.Connection}
 */
draw2d.Connection.createConnection = function (sourcePort, targetPort, callback, dropTarget) {

    return new draw2d.Connection();
};


/**
 * The default ConnectionRouter for the running applicaiton. Set this to your wanted implementation
 * {@link draw2d.layout.connection.ConnectionRouter}
 */
draw2d.Connection.DEFAULT_ROUTER = new draw2d.layout.connection.ManhattanConnectionRouter();

/**
 * @class draw2d.VectorFigure
 * The base class for all vector based figures like {@link draw2d.shape.basic.Rectangle}  or {@link draw2d.shape.basic.Oval}
 * inside a canvas.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.node.Node
 */
draw2d.VectorFigure = draw2d.shape.node.Node.extend({
    NAME: "draw2d.VectorFigure",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.stroke = 1;
        this.radius = 0;
        this.bgColor = new draw2d.util.Color("#ffffff");
        this.color = new draw2d.util.Color("#303030");

        // memento for the stroke if we reset the glow effect of this shape
        //
        this.strokeBeforeGlow = this.stroke;
        this.glowIsActive = false;

        this._super(attr,
            $.extend({
                /** @attr {Number} radius the radius to render the line edges */
                radius: this.setRadius,
                /** @attr {String|draw2d.util.Color} bgColor the background color of the shape */
                bgColor: this.setBackgroundColor,
                /** @attr {String|draw2d.util.Color} color the main color of the shape */
                color: this.setColor,
                /** @attr {Number} stroke the stroke width */
                stroke: this.setStroke
            }, setter),
            $.extend({
                radius: this.getRadius,
                bgColor: this.getBackgroundColor,
                color: this.getColor,
                stroke: this.getStroke
            }, getter)
        );
    },

    /**
     * @method
     * Sets the corner radius or the edges.
     *
     * @param {Number} radius
     * @since 4.2.1
     */
    setRadius: function (radius) {
        this.radius = radius;
        this.repaint();
        this.fireEvent("change:radius");

        return this;
    },

    /**
     * @method
     * Get the corner radius of the edges.
     *
     * @return {Number}
     * @since 4.2.1
     */
    getRadius: function () {
        return this.radius;
    },


    /**
     * @method
     * Highlight the element or remove the highlighting
     *
     * @param {Boolean} flag indicates glow/noGlow
     */
    setGlow: function (flag) {

        if (flag === this.glowIsActive) {
            return this;
        }

        this.glowIsActive = flag;
        if (flag === true) {
            this.strokeBeforeGlow = this.getStroke();
            this.setStroke(this.strokeBeforeGlow * 2.5);
        }
        else {
            this.setStroke(this.strokeBeforeGlow);
        }

        return this;
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();

        if (typeof attributes.stroke === "undefined") {
            if (this.color === null || this.stroke === 0) {
                attributes.stroke = "none";
            }
            else {
                attributes.stroke = this.color.hash();
            }
        }

        if (typeof attributes["stroke-width"] === "undefined") {
            attributes["stroke-width"] = this.stroke;
        }

        if (typeof attributes.fill === "undefined") {
            attributes.fill = this.bgColor.hash();
        }

        this._super(attributes);

        return this;
    },


    /**
     * @method
     * Set the new background color of the figure. It is possible to hands over
     * <code>null</code> to set the background transparent.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        "bgColor": "#f0f0f0"
    *      });
     *
     * @param {String|draw2d.util.Color} color The new background color of the figure
     **/
    setBackgroundColor: function (color) {
        this.bgColor = new draw2d.util.Color(color);

        this.repaint();
        this.fireEvent("change:bgColor");

        return this;
    },

    /**
     * @method
     * The current used background color.
     *
     *      // Alternatively you can use the attr method:
     *      var color =figure.attr("bgColor");
     *
     * @return {draw2d.util.Color}
     */
    getBackgroundColor: function () {
        return this.bgColor;
    },

    /**
     * @method
     * Set the stroke to use.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        "stroke": 2
    *      });
     *
     * @param {Number} w The new line width of the figure
     **/
    setStroke: function (w) {
        this.stroke = w;
        this.repaint();
        this.fireEvent("change:stroke");

        return this;
    },

    /**
     * @method
     * The used line width.
     *
     * @type {Number}
     **/
    getStroke: function () {
        return this.stroke;
    },

    /**
     * @method
     * Set the foreground color of the figure.
     * This method fires a <i>document dirty</i> event.
     *
     *      // Alternatively you can use the attr method:
     *      figure.attr({
    *        "color": "#f3f3f3"
    *      });
     *
     * @param {String|draw2d.util.Color} color The new color of the line.
     **/
    setColor: function (color) {
        this.color = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:color");

        return this;
    },

    /**
     * @method
     * Get the current used foreground color
     *
     *
     * @returns {draw2d.util.Color}
     */
    getColor: function () {
        return this.color;
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        return $.extend(this._super(), {
            bgColor: this.bgColor.hash(),
            color: this.color.hash(),
            stroke: this.stroke,
            radius: this.radius
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.radius !== "undefined") {
            this.setRadius(memento.radius);
        }

        if (typeof memento.bgColor !== "undefined") {
            this.setBackgroundColor(memento.bgColor);
        }

        if (typeof memento.color !== "undefined") {
            this.setColor(memento.color);
        }

        if (typeof memento.stroke !== "undefined") {
            this.setStroke(parseFloat(memento.stroke));
        }

        return this;
    }


});


/**
 * @class draw2d.ResizeHandle
 * The Resizehandles for Figures.

 * <pre>
 * Possible Type:
 *
 *     1             2               3
 *     O-----------O-------------O
 *     |                         |
 *     |                         |
 *   8 O           + 9           O 4
 *     |                         |
 *     |                         |
 *     O-----------O-------------O
 *   7             6               5
 * </pre>
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.ResizeHandle = draw2d.shape.basic.Rectangle.extend({
    NAME: "draw2d.ResizeHandle",

    /**
     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {draw2d.Canvas} canvas the related canvas element
     * @param {Number} type the type of the ResizeHandle.
     */
    init: function (figure, type) {

        this._super({bgColor: "#5bcaff", stroke: 1, radius: 0});

        // required in the SelectionEditPolicy to indicate the type of figure
        // which the user clicks
        this.isResizeHandle = true;

        this.owner = figure;
        this.type = type;
        this.command = null;
        this.commandMove = null;
        this.commandResize = null;

        this.setSelectable(false);

        this.setDimension(); // get best if no params are given
    },


    /**
     * @method
     * The edge of the rectangle for the snapTo mechanism.
     *
     * @return
     */
    getSnapToDirection: function () {
        switch (this.type) {
            case 1:
                return draw2d.SnapToHelper.NORTH_WEST;
            case 2:
                return draw2d.SnapToHelper.NORTH;
            case 3:
                return draw2d.SnapToHelper.NORTH_EAST;
            case 4:
                return draw2d.SnapToHelper.EAST;
            case 5:
                return draw2d.SnapToHelper.SOUTH_EAST;
            case 6:
                return draw2d.SnapToHelper.SOUTH;
            case 7:
                return draw2d.SnapToHelper.SOUTH_WEST;
            case 8:
                return draw2d.SnapToHelper.WEST;
            case 9:
                return draw2d.SnapToHelper.NSEW;
            default :
                return draw2d.SnapToHelper.EAST;
        }
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        var shape = this._super();

        shape.node.setAttribute("type", this.type);
        this.updateCursor(shape);

        return shape;
    },

    /**
     * @method
     * calculate and set the cursor of the reize handle
     * @private
     */
    updateCursor: function (shape) {
        if (shape === null) {
            return this;
        }

        if (this.isDraggable() === false) {
            shape.attr({"cursor": "default"});
            return this;
        }

        switch (this.type) {
            case 1:
                shape.attr({"cursor": "nw-resize"});
                break;
            case 2:
                shape.attr({"cursor": "n-resize"});
                break;
            case 3:
                shape.attr({"cursor": "ne-resize"});
                break;
            case 4:
                shape.attr({"cursor": "e-resize"});
                break;
            case 5:
                shape.attr({"cursor": "se-resize"});
                break;
            case 6:
                shape.attr({"cursor": "s-resize"});
                break;
            case 7:
                shape.attr({"cursor": "sw-resize"});
                break;
            case 8:
                shape.attr({"cursor": "w-resize"});
                break;
            default:
                shape.attr({"cursor": "move"});
                break;
        }
        return this;
    },

    /**
     * @method
     * Adjust the draggable flag of the resize handle and update the cursor of the shape in relation
     * to the type of resize handle. north, south,west,..
     *
     * @param flag
     * @returns
     */
    setDraggable: function (flag) {
        this._super(flag);
        this.updateCursor(this.shape);

        return this;
    },

    /**
     * @method
     * Will be called if the drag and drop action beginns. You can return [false] if you
     * want avoid that the figure can be move.
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean} true whenever the drag drop operation is allowed.
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {
        // This happens if the selected figure has set the "nonResizeable" flag
        // In this case the ResizeHandle can't be dragged. => no resize
        //
        if (!this.isDraggable()) {
            return false;
        }

        this.ox = this.getAbsoluteX();
        this.oy = this.getAbsoluteY();

        this.commandMove = this.owner.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
        this.commandResize = this.owner.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.RESIZE));

        return true;
    },


    /**
     * @method
     * Called by the framework if the figure is moved by user interaction.
     *
     * @param {Number} dx the move x offset
     * @param {Number} dy the move y offset
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     *
     * @return {boolean}
     */
    onDrag: function (dx, dy, dx2, dy2) {
        if (this.isDraggable() === false) {
            return;
        }

        var oldX = this.getAbsoluteX();
        var oldY = this.getAbsoluteY();

        // call the super.drag method with all snapTo### handler and adjustments
        this._super(dx, dy, dx2, dy2);

        var diffX = this.getAbsoluteX() - oldX;
        var diffY = this.getAbsoluteY() - oldY;

        var obj = this.owner;
        var objPosX = obj.getAbsoluteX();
        var objPosY = obj.getAbsoluteY();
        var objWidth = obj.getWidth();
        var objHeight = obj.getHeight();

        var newX = null;
        var newY = null;
        var corrPos = null;
        switch (this.type) {
            case 1:
                obj.setDimension(objWidth - diffX, objHeight - diffY);
                newX = objPosX + (objWidth - obj.getWidth());
                newY = objPosY + (objHeight - obj.getHeight());
                obj.setPosition(newX, newY);
                break;
            case 2:
                obj.setDimension(objWidth, objHeight - diffY);
                newX = objPosX;
                newY = objPosY + (objHeight - obj.getHeight());
                obj.setPosition(newX, newY);
                break;
            case 3:
                obj.setDimension(objWidth + diffX, objHeight - diffY);
                newX = objPosX;
                newY = objPosY + (objHeight - obj.getHeight());
                obj.setPosition(newX, newY);
                break;
            case 4:
                obj.setDimension(objWidth + diffX, objHeight);
                break;
            case 5:
                obj.setDimension(objWidth + diffX, objHeight + diffY);
                break;
            case 6:
                obj.setDimension(objWidth, objHeight + diffY);
                break;
            case 7:
                obj.setDimension(objWidth - diffX, objHeight + diffY);
                newX = objPosX + (objWidth - obj.getWidth());
                newY = objPosY;
                obj.setPosition(newX, newY);
                break;
            case 8:
                obj.setDimension(objWidth - diffX, objHeight);
                newX = objPosX + (objWidth - obj.getWidth());
                newY = objPosY;
                obj.setPosition(newX, newY);
                break;
        }

        if (newX !== null) {
            // may the setPosition has changed regarding any constraint or edit policies. In this case
            // we must adjust the dimension with the related correction
            //
            corrPos = obj.getPosition();
            if (corrPos.x !== newX || corrPos.y !== newY) {
                obj.setDimension(obj.getWidth() - (corrPos.x - newX), obj.getHeight() - (corrPos.y - newY));
            }
        }
    },

    /**
     * @method
     * Will be called after a drag and drop action.<br>
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        if (!this.isDraggable()) {
            return;
        }

        // An non draggable resizeHandle doesn't create a move/resize command.
        // This happens if the selected figure has set the "nonResizeable" flag.
        //
        if (this.commandMove !== null) {
            this.commandMove.setPosition(this.owner.getX(), this.owner.getY());
            this.canvas.getCommandStack().execute(this.commandMove);
            this.commandMove = null;
        }

        if (this.commandResize !== null) {
            this.commandResize.setDimension(this.owner.getWidth(), this.owner.getHeight());
            this.canvas.getCommandStack().execute(this.commandResize);
            this.commandResize = null;
        }

        this.canvas.hideSnapToHelperLines();
    },

    /**
     * Set the position of the object.<br>
     * The ResizeHandle overrides the Figure.setPosition method. The base
     * class updates the resize handles during the update of the Dimension/Position. This
     * is not neccessary for the ResizeHandles. Performance issue.
     *
     * @param {Number} x The new x coordinate of the figure
     * @param {Number} y The new y coordinate of the figure
     **/
    setPosition: function (x, y) {
        // don't call base implementation. Base implementation will show
        // ResizeHandles...but I'm the ResizeHandle
        if (x instanceof draw2d.geo.Point) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }

        if (this.repaintBlocked === true || this.shape === null) {
            return this;
        }

        // performace improment by setting the coordinates direct.
        this.shape.attr({x: this.x, y: this.y});
//        this.repaint();
    },


    /**
     * @method
     * Set the new dimension of the the ResizeHandle. IF you didn't pass any width/height the best default for the
     * platform will be used.
     *
     * @param {Number} [width] new width of the resize handle
     * @param {Number} [height] new width of the resize handle
     */
    setDimension: function (width, height) {
        if (typeof height !== "undefined") {
            this._super(width, height);
        }
        else {
            if (draw2d.isTouchDevice) {
                this._super(15, 15);
            }
            else {
                this._super(8, 8);
            }
        }

        var offset = this.getWidth();
        var offset2 = offset / 2;

        switch (this.type) {
            case 1:
                this.setSnapToGridAnchor(new draw2d.geo.Point(offset, offset));
                break;
            case 2:
                this.setSnapToGridAnchor(new draw2d.geo.Point(offset2, offset));
                break;
            case 3:
                this.setSnapToGridAnchor(new draw2d.geo.Point(0, offset));
                break;
            case 4:
                this.setSnapToGridAnchor(new draw2d.geo.Point(0, offset2));
                break;
            case 5:
                this.setSnapToGridAnchor(new draw2d.geo.Point(0, 0));
                break;
            case 6:
                this.setSnapToGridAnchor(new draw2d.geo.Point(offset2, 0));
                break;
            case 7:
                this.setSnapToGridAnchor(new draw2d.geo.Point(offset, 0));
                break;
            case 8:
                this.setSnapToGridAnchor(new draw2d.geo.Point(offset, offset2));
                break;
            case 9:
                this.setSnapToGridAnchor(new draw2d.geo.Point(offset2, offset2));
                break;
        }

    },

    /**
     * @method
     * Show the ResizeHandle and add it to the canvas.<br>
     * Additional bring it in to the front of other figures.
     *
     * @param {draw2d.Canvas} canvas the canvas to use
     * @param {Number} x the x-positin
     * @param {Number} y the y-position
     **/
    show: function (canvas) {
        // don't call the parent function. The parent functions delete this object
        // and a resize handle can't be deleted.
        this.setCanvas(canvas);

        this.canvas.resizeHandles.add(this);
        this.shape.insertAfter(this.owner.getShapeElement());
        this.repaint();

        return this;
    },

    /**
     * @method
     * Hide the resize handle and remove it from the canvas.
     *
     **/
    hide: function () {
        // don't call the parent function. The parent functions delete this object
        // and a resize handle shouldn't be deleted.
        if (this.shape === null) {
            return;
        }

        this.canvas.resizeHandles.remove(this);
        this.setCanvas(null);

        return this;
    },

    /**
     * @method
     * Set the new background color of the figure. It is possible to hands over
     * <code>null</code> to set the background transparent.
     *
     * @param {draw2d.util.Color} color The new background color of the figure
     **/
    setBackgroundColor: function (color) {
        color = new draw2d.util.Color(color);

        this.bgGradient = "90-" + color.hash() + "-" + color.darker(0.2).hash();
        this._super(color);

        return this;
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        if (this.bgColor.hash() === "none") {
            attributes.fill = "none";
        }
        else if (this.getAlpha() < 0.9) {
            attributes.fill = this.bgColor.hash();
        }
        else {
            attributes.fill = this.bgGradient;
        }


        this._super(attributes);
    },


    /**
     * @method
     * return true if the element can be used in combination with the
     * SnapToHelper feature.
     *
     * @return [boolean]
     **/
    supportsSnapToHelper: function () {
        return true;
    },


    /**
     * @method
     * Override this method and redirect them to the cavas. A ResizeHandle didn't support
     * Keyboard interaction at the moment.
     *
     * @param {Number} keyCode the id of the pressed key
     * @param {boolean} ctrl true if the user has pressed the CTRL/STRG key as well.
     **/
    onKeyDown: function (keyCode, ctrl) {
        // don't call the parent function. The parent functions delete this object
        // and a resize handle can't be deleted.
        this.canvas.onKeyDown(keyCode, ctrl);
    },


    fireEvent: function () {
        // A resizeHandle doesn't fire this event.
        // Normally this set the document dirty. This is not necessary for a ResizeHandle.
    }
});

/**
 * @class draw2d.shape.basic.LineResizeHandle
 * Base class for selection handle for connections and normal lines.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Circle
 */
draw2d.shape.basic.LineResizeHandle = draw2d.shape.basic.Circle.extend({
    NAME: "draw2d.shape.basic.LineResizeHandle",

    init: function (figure) {
        this._super();
        this.owner = figure;
        // required in the SelectionEditPolicy to indicate the type of figure
        // which the user clicks
        this.isResizeHandle = true;

        if (draw2d.isTouchDevice) {
            this.setDimension(20, 20);
        }
        else {
            this.setDimension(10, 10);
        }

        this.setBackgroundColor("#5bcaff");
        this.setStroke(1);
        this.setSelectable(false);

        this.currentTarget = null;
    },

    /**
     * @inheritdoc
     */
    createShapeElement: function () {
        var shape = this._super();

        shape.attr({"cursor": "move"});
        return shape;
    },

    /**
     * @inheritdoc
     **/
    setBackgroundColor: function (color) {
        color = new draw2d.util.Color(color);

        this.bgGradient = "r(.4,.3)" + color.hash() + "-" + color.darker(0.1).hash() + ":60-" + color.darker(0.2).hash();
        this._super(color);
        this.setColor(color.darker(0.3));

        return this;
    },


    /**
     * @method
     * Return the port below the ResizeHandle.
     *
     * @template
     * @return {draw2d.Port}
     */
    getRelatedPort: function () {
        return null;
    },


    /**
     * @method
     * Return the port of the other side of the related connection.
     *
     * @template
     * @return {draw2d.Port}
     */
    getOppositePort: function () {
        return null;
    },


    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};


        if (this.bgColor.hash() === "none") {
            attributes.fill = this.bgColor.hash();
        }
        else if (this.getAlpha() < 0.9) {
            attributes.fill = this.bgColor.hash();
        }
        else {
            attributes.fill = this.bgGradient;
        }


        this._super(attributes);
    },

    /**
     * Called if the drag and drop action beginns. You can return [false] if you
     * want avoid the that the figure can be move.
     *
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @type {boolean}
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {
        this.command = this.getCanvas().getCurrentSelection().createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE_BASEPOINT));
        this.setAlpha(0.2);
        this.shape.attr({"cursor": "crosshair"});

        return true;
    },


    /**
     * @method
     * Called from the framework during a drag&drop operation
     *
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @return {boolean}
     * @private
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        this.setPosition(this.x + dx2, this.y + dy2);

        var port = this.getOppositePort();

        var target = port !== null ? port.getCanvas().getBestFigure(this.getX(), this.getY(), [this, this.owner]) : null;

        // the hovering element has been changed
        if (target !== this.currentTarget) {

            if (this.currentTarget !== null) {
                this.currentTarget.onDragLeave(port);
                this.currentTarget.setGlow(false);
            }

            if (target !== null) {
                this.currentTarget = target.onDragEnter(port);
                if (this.currentTarget !== null) {
                    this.currentTarget.setGlow(true);
                }
            }
        }

        return true;
    },

    /**
     * @method Called after a drag and drop action.<br>
     *         Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean}
     */
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        if (!this.isDraggable()) {
            return false;
        }

        this.shape.attr({"cursor": "move"});

        var port = this.getOppositePort();
        if (port !== null) {
            if (this.currentTarget !== null) {

                this.onDrop(this.currentTarget, x, y, shiftKey, ctrlKey);
                this.currentTarget.onDragLeave(port);
                this.currentTarget.setGlow(false);
                this.currentTarget.onCatch(this, x, y, shiftKey, ctrlKey);
                this.currentTarget = null;
            }
        }

        this.owner.isMoving = false;
        // A Connection is stuck to the corresponding ports. So we must reset the position
        // to the origin port if we doesn't drop the ResizeHandle on a other port.
        //
        if (this.getCanvas().getCurrentSelection() instanceof draw2d.Connection) {
            if (this.command !== null) {
                this.command.cancel();
            }
        }
        //
        else {
            // An non draggable resizeHandle doesn't create a move/resize command.
            // This happens if the selected figure has set "isResizeable=false".
            //
            if (this.command !== null) {
                this.getCanvas().getCommandStack().execute(this.command);
            }
        }
        this.command = null;
        this.getCanvas().hideSnapToHelperLines();

        this.setAlpha(1);

        return true;
    },


    /**
     * @inheritdoc
     **/
    relocate: function () {

    },


    /**
     * @method
     * The LineResizeHandle didn't support the SnapToHelper feature if the
     * corresponding object is an Connection. A Connection is always bounded to
     * Port. In this case it makes no sense to use a Grid or Geometry for snapping.
     *
     * @return {boolean} return false if the corresponding object didn't support snapTo
     **/
    supportsSnapToHelper: function () {
        if (this.getCanvas().getCurrentSelection() instanceof draw2d.Connection) {
            return false;
        }

        return true;
    },

    /**
     * @method
     * Show the ResizeHandle and add it to the canvas.<br>
     * Additional bring it in to the front of other figures.
     *
     * @param {draw2d.Canvas} canvas the canvas to use
     * @param {Number} x the x-position
     * @param {Number} y the y-position
     **/
    show: function (canvas, x, y) {
        // don't call the parent function. The parent functions make this object selectable/deleteable
        // and a resize handle can't be deleted.
        this.setCanvas(canvas);
        //     this.setPosition(x,y);
        this.shape.toFront();
        this.canvas.resizeHandles.add(this);
    },

    /**
     * @method
     * Hide the resize handle and remove it from the canvas.
     *
     **/
    hide: function () {
        // don't call the parent function. The parent functions delete this object
        // and a resize handle shouldn't be deleted.
        if (this.shape === null) {
            return;
        }

        this.canvas.resizeHandles.remove(this);
        this.setCanvas(null);
    },

    /**
     * @method
     * Override this method and redirect them to the canvas. A ResizeHandle didn't support
     * Keyboard interaction at the moment.
     *
     * @param {Number} keyCode the id of the pressed key
     * @param {boolean} ctrl true if the user has pressed the CTRL/STRG key as well.
     **/
    onKeyDown: function (keyCode, ctrl) {
        // don't call the parent function. The parent functions delete this object
        // and a resize handle can't be deleted.
        this.canvas.onKeyDown(keyCode, ctrl);
    }
});

/**
 * @class draw2d.shape.basic.LineStartResizeHandle
 * Selection handle for connections and normal lines.
 *
 * TODO: Split the LineEndResizeHandle to ConnectionEndResizeHandle and LineEndResizeHandle!!!!
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.LineResizeHandle
 */
draw2d.shape.basic.LineStartResizeHandle = draw2d.shape.basic.LineResizeHandle.extend({
    NAME: "draw2d.shape.basic.LineStartResizeHandle",

    init: function (figure) {
        this._super(figure);
    },

    /**
     * @method
     * Return the Port below the ResizeHandle
     *
     * @return {draw2d.Port}
     */
    getRelatedPort: function () {
        if (this.owner instanceof draw2d.Connection)
            return this.owner.getSource();

        return null;
    },

    /**
     * @method
     * Return the Port on the opposite side of the ResizeHandle
     *
     * @returns
     */
    getOppositePort: function () {
        if (this.owner instanceof draw2d.Connection)
            return this.owner.getTarget();

        return null;
    },

    /**
     * @method
     * Called from the framework during a drag&drop operation
     *
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @return {boolean}
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        this._super(dx, dy, dx2, dy2);

        var objPos = this.owner.getStartPoint();
        objPos.translate(dx2, dy2);

        this.owner.setStartPoint(objPos.x, objPos.y);

        this.owner.isMoving = true;

        return true;
    },

    /**
     * @method
     * Resize handle has been drop on a InputPort/OutputPort.
     *
     * @param {draw2d.Port} dropTarget
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     **/
    onDrop: function (dropTarget, x, y, shiftKey, ctrlKey) {
        this.owner.isMoving = false;

        // The ResizeHandle of a Connection has been droped on a Port
        // This will enforce a ReconnectCommand
        if (this.owner instanceof draw2d.Connection && this.command !== null) {
            this.command.setNewPorts(dropTarget, this.owner.getTarget());
            this.getCanvas().getCommandStack().execute(this.command);
        }
        this.command = null;
    },

    /**
     * @method
     * Controls the location of the resize handle
     *
     * @template
     **/
    relocate: function () {

        var resizeWidthHalf = this.getWidth() / 2;
        var resizeHeightHalf = this.getHeight() / 2;

        var anchor = this.owner.getStartPoint();

        this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);
    }


});

/**
 * @class draw2d.shape.basic.LineEndResizeHandle
 *
 * Selection handle for connections and normal lines.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.LineResizeHandle
 */
draw2d.shape.basic.LineEndResizeHandle = draw2d.shape.basic.LineResizeHandle.extend({
    NAME: "draw2d.shape.basic.LineEndResizeHandle",

    init: function (figure) {
        this._super(figure);
    },


    /**
     * @method
     * Return the Port assigned to this ResizeHandle if the line is an instance of draw2d.Connection
     *
     * @return {draw2d.Port}
     */
    getRelatedPort: function () {
        if (this.owner instanceof draw2d.Connection) {
            return this.owner.getTarget();
        }

        return null;
    },

    /**
     * @method
     * Return the peer Port assigned to this ResizeHandle if the line is an instance of draw2d.Connection
     *
     * @returns {draw2d.Port}
     */
    getOppositePort: function () {
        if (this.owner instanceof draw2d.Connection) {
            return this.owner.getSource();
        }

        return null;
    },


    /**
     * @method
     * Called from the framework during a drag&drop operation
     *
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @return {boolean}
     * @private
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        this._super(dx, dy, dx2, dy2);

        var objPos = this.owner.end.clone();//getEndPoint();
        // objPos.translate(dx2,dy2);

        this.owner.setEndPoint(objPos.x + dx2, objPos.y + dy2);

        this.owner.isMoving = true;

        return true;
    },

    /**
     * @method
     * Resizehandle has been drop on a InputPort/OutputPort.
     *
     * @param {draw2d.Figure} dropTarget
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onDrop: function (dropTarget, x, y, shiftKey, ctrlKey) {
        this.owner.isMoving = false;

        if (this.owner instanceof draw2d.Connection && this.command !== null) {
            this.command.setNewPorts(this.owner.getSource(), dropTarget);
            this.getCanvas().getCommandStack().execute(this.command);
        }
        this.command = null;
    },

    /**
     * @method
     * Controls the location of the resize handle
     *
     * @private
     **/
    relocate: function () {

        var resizeWidthHalf = this.getWidth() / 2;
        var resizeHeightHalf = this.getHeight() / 2;

        var anchor = this.owner.getEndPoint();

        this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);

        return this
    }
});

/**
 * @class draw2d.shape.basic.VertexResizeHandle
 *
 * Selection handle for polyline vertices.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.ResizeHandle
 */
draw2d.shape.basic.VertexResizeHandle = draw2d.ResizeHandle.extend({
    NAME: "draw2d.shape.basic.VertexResizeHandle",

    SNAP_THRESHOLD: 3,
    LINE_COLOR: "#1387E6",
    FADEOUT_DURATION: 300,

    init: function (figure, index) {
        this._super(figure);
        this.index = index;
        this.isDead = false;

        this.vline = null;
        this.hline = null;
    },


    /**
     * @method
     * Called when a user double clicks on the element
     *
     * @template
     */
    onDoubleClick: function () {
        var cmd = new draw2d.command.CommandRemoveVertex(this.owner, this.index);
        this.getCanvas().getCommandStack().execute(cmd);

        this.isDead = true;
    },


    /**
     * @method
     * Called if a drag&drop operation starts.<br>
     *
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {
        if (this.isDead === true) {
            return;
        }

        this._super();
        this.command = this.getCanvas().getCurrentSelection().createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE_VERTEX));
        if (this.command != null) {
            this.command.setIndex(this.index);
            this.setAlpha(0.2);
            this.shape.attr({"cursor": "crosshair"});
        }

        // Vertex is a reference and not a copy of the point
        this.vertex = this.owner.getVertex(this.index).clone();
    },

    /**
     * @method
     * Called from the framework during a drag&drop operation
     *
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @return {boolean}
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        if (this.isDead === true || this.command == null) {
            return false;
        }

        this.setPosition(this.x + dx2, this.y + dy2);

        // update the polyline for immediately  drag&drop feedback
        //
        this.vertex.translate(dx2, dy2);
        this.owner.setVertex(this.index, this.vertex.x, this.vertex.y);

        // update the command for the undo/redo stuff
        //
        this.command.updatePosition(this.vertex.x, this.vertex.y);

        // show snapTo lines
        //
        var points = this.owner.getVertices();
        var size = points.getSize();
        var left = points.get((this.index - 1 + size) % size); // % is just to ensure the [0, size] interval
        var right = points.get((this.index + 1) % size);       // % is just to ensure the [0, size] interval

        // horizontal guided line
        //
        if (Math.abs(left.x - this.vertex.x) < this.SNAP_THRESHOLD) {
            this.showVerticalLine(left.x);
        }
        else if (Math.abs(right.x - this.vertex.x) < this.SNAP_THRESHOLD) {
            this.showVerticalLine(right.x);
        }
        else {
            this.hideVerticalLine();
        }

        // horizontal guided line
        //
        if (Math.abs(left.y - this.vertex.y) < this.SNAP_THRESHOLD) {
            this.showHorizontalLine(left.y);
        }
        else if (Math.abs(right.y - this.vertex.y) < this.SNAP_THRESHOLD) {
            this.showHorizontalLine(right.y);
        }
        else {
            this.hideHorizontalLine();
        }


        return true;
    },

    /**
     * @method Called after a drag and drop action.<br>
     *         Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean}
     */
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        if (this.isDead === true || this.command === null) {
            return false;
        }

        this.shape.attr({"cursor": "move"});
        this.hideVerticalLine();
        this.hideHorizontalLine();

        // snapTo
        var points = this.owner.getVertices();
        var size = points.getSize();
        var left = points.get((this.index - 1 + size) % size); // % is just to ensure the [0, size] interval
        var right = points.get((this.index + 1) % size);       // % is just to ensure the [0, size] interval

        // Vertical snapTo
        //
        if (Math.abs(left.x - this.vertex.x) < this.SNAP_THRESHOLD) {
            this.command.updatePosition(left.x, this.vertex.y);
        }
        else if (Math.abs(right.x - this.vertex.x) < this.SNAP_THRESHOLD) {
            this.command.updatePosition(right.x, this.vertex.y);
        }

        // horizontal snapTo
        //
        if (Math.abs(left.y - this.vertex.y) < this.SNAP_THRESHOLD) {
            this.command.updatePosition(this.vertex.x, left.y);
        }
        else if (Math.abs(right.y - this.vertex.y) < this.SNAP_THRESHOLD) {
            this.command.updatePosition(this.vertex.x, right.y);
        }

        var stack = this.getCanvas().getCommandStack();

        stack.startTransaction();
        try {
            stack.execute(this.command);
            this.command = null;
            this.getCanvas().hideSnapToHelperLines();

            var angle = this.getEnclosingAngle();
            if (angle > 178) {
                var cmd = new draw2d.command.CommandRemoveVertex(this.owner, this.index);
                stack.execute(cmd);
            }
        }
        finally {
            stack.commitTransaction();
        }

        this.setAlpha(1);

        return true;
    },


    /**
     * @method
     * Controls the location of the resize handle
     *
     * @template
     **/
    relocate: function () {

        var resizeWidthHalf = this.getWidth() / 2;
        var resizeHeightHalf = this.getHeight() / 2;

        var anchor = this.owner.getVertex(this.index);

        this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);
    },

    /**
     * @method
     * Calculates the angle between the siblings
     *
     * @returns {Number}
     */
    getEnclosingAngle: function () {
        // calculate the angle between the siblings
        var points = this.owner.getVertices();
        var trans = this.vertex.getScaled(-1);
        var size = points.getSize();
        var left = points.get((this.index - 1 + size) % size).getTranslated(trans); // % is just to ensure the [0, size] interval
        var right = points.get((this.index + 1) % size).getTranslated(trans);       // % is just to ensure the [0, size] interval

        var dot = left.dot(right);

        var acos = Math.acos(dot / (left.length() * right.length()));
        return acos * 180 / Math.PI;
    },

    showVerticalLine: function (x) {
        if (this.vline != null) {
            return; //silently
        }
        this.vline = this.canvas.paper
            .path("M " + x + " 0 l 0 " + this.canvas.getHeight())
            .attr({"stroke": this.LINE_COLOR, "stroke-width": 1});
    },

    hideVerticalLine: function () {
        if (this.vline == null) {
            return;
        }
        var tmp = this.vline;
        tmp.animate({
            opacity: 0.1
        }, this.FADEOUT_DURATION, function () {
            tmp.remove();
        });

        this.vline = null;
    },


    showHorizontalLine: function (y) {
        if (this.hline != null) {
            return;
        }

        this.hline = this.canvas.paper
            .path("M 0 " + y + " l " + this.canvas.getWidth() + " 0")
            .attr({"stroke": this.LINE_COLOR, "stroke-width": 1});
    },

    hideHorizontalLine: function () {
        if (this.hline == null) {
            return; //silently
        }
        var tmp = this.hline;
        tmp.animate({
            opacity: 0.1
        }, this.FADEOUT_DURATION, function () {
            tmp.remove();
        });
        this.hline = null;
    }

});

/**
 * @class draw2d.shape.basic.GhostVertexResizeHandle
 * ResizeHandle for a vertex edit policy. Click of this kind of resize handles
 * adds a new vertex to the polyline or polygon.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.LineResizeHandle
 */
draw2d.shape.basic.GhostVertexResizeHandle = draw2d.shape.basic.LineResizeHandle.extend({
    NAME: "draw2d.shape.basic.GhostVertexResizeHandle",

    init: function (figure, precursorIndex) {
        this.maxOpacity = 0.35;

        this._super(figure);
        this.precursorIndex = precursorIndex;

        this.setAlpha(this.maxOpacity);
    },

    createShapeElement: function () {
        var shape = this._super();

        shape.attr({"cursor": "pointer"});

        return shape;
    },

    /**
     * @method
     * Set the alpha blending of this figure.
     *
     * @param {Number} percent Value between [0..1].
     * @template
     **/
    setAlpha: function (percent) {
        percent = Math.min(this.maxOpacity, Math.max(0, parseFloat(percent)));
        this._super(percent);

        return this;
    },

    /**
     * @method
     * Called when a user clicks on the element
     *
     * @template
     */
    onClick: function () {
        var cmd = new draw2d.command.CommandAddVertex(this.owner, this.precursorIndex + 1, this.getAbsoluteX() + this.getWidth() / 2, this.getAbsoluteY() + this.getHeight() / 2);
        this.getCanvas().getCommandStack().execute(cmd);
    },


    /**
     * @method
     * Called from the framework during a drag&drop operation
     *
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @return {boolean}
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        return true;
    },

    /**
     * @method Called after a drag and drop action.<br>
     *         Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean}
     */
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        return true;
    },


    /**
     * @method
     * Controls the location of the resize handle
     *
     * @template
     **/
    relocate: function () {
        var p1 = this.owner.getVertices().get(this.precursorIndex);
        var p2 = this.owner.getVertices().get(this.precursorIndex + 1);

        var x = ((p2.x - p1.x) / 2 + p1.x - this.getWidth() / 2) | 0;
        var y = ((p2.y - p1.y) / 2 + p1.y - this.getHeight() / 2) | 0;


        this.setPosition(x, y);
    }


});

/**
 * @class draw2d.Port
 * A port is an object that is used to establish a connection between a node and a {@link draw2d.Connection}. The port can
 * be placed anywhere within a node ( see {@link draw2d.layout.locator.PortLocator} for details)
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Circle
 */
draw2d.Port = draw2d.shape.basic.Circle.extend({
    NAME: "draw2d.Port",

    DEFAULT_BORDER_COLOR: new draw2d.util.Color("#1B1B1B"),

    /**
     * @constructor
     * Creates a new Node element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr) {
        this.locator = null;
        this.lighterBgColor = null;

        this._super(attr);

        if (draw2d.isTouchDevice) {
            this.setDiameter(25);
        }
        else {
            this.setDiameter(10);
        }


        // status var for user interaction
        //
        this.ox = this.x;
        this.oy = this.y;
        this.coronaWidth = 5; // the corona width for the hitTest method. Useful during drag&drop of ports. Better SnapTo behavior.
        this.corona = null; // Circle

        // currentTarget can be differ from the currentTargetPort. In this case
        // we must store booth of them for notifications hoverEnter/hoverLeft
        this.currentTargetPort = null; // port
        this.currentTarget = null; // Figure

        // current attached connections
        this.connections = new draw2d.util.ArrayList();

        // visible representation
        //
        this.setBackgroundColor("#4f6870");
        this.setStroke(1);
        this.setColor(this.DEFAULT_BORDER_COLOR);
        this.setSelectable(false);

        // avoid "undefined" values. This breaks the code on iOS.
        if (typeof name === "undefined") {
            this.name = null;
        }
        else {
            this.name = name;
        }

        this.moveListener = function (figure) {
            this.repaint();
            // Falls sich der parent bewegt hat, dann muss der Port dies seinen
            // Connections mitteilen
            this.fireEvent("move");
        }.bind(this);

        this.connectionAnchor = new draw2d.layout.anchor.ConnectionAnchor(this);

        // for dynamic diagrams. A Port can have a value which is set by a connector
        //
        this.value = null;
        this.maxFanOut = Number.MAX_VALUE;

        this.setCanSnapToHelper(false);

        this.installEditPolicy(new draw2d.policy.port.IntrusivePortsFeedbackPolicy());
        //    this.installEditPolicy(new draw2d.policy.port.ElasticStrapFeedbackPolicy());
    },

    /**
     * @method
     * set the maximal possible count of connections for this port.<br>
     * This method din't delete any connection if you reduce the number and a bunch of
     * connection are bounded already.
     *
     * @param {Number} count the maximal number of connection related to this port
     */
    setMaxFanOut: function (count) {
        this.maxFanOut = Math.max(1, count);
        this.fireEvent("change:maxFanOut");

        return this;
    },

    /**
     * @method
     * return the maximal possible connections (in+out) for this port.
     *
     * @returns
     */
    getMaxFanOut: function () {
        return this.maxFanOut;
    },

    /**
     * @method
     * Set the Anchor for this object. An anchor is responsible for the endpoint calculation
     * of an connection. just visible representation.
     *
     * @param {draw2d.layout.anchor.ConnectionAnchor} [anchor] the new source anchor for the connection
     **/
    setConnectionAnchor: function (anchor) {
        // set some good defaults.
        if (typeof anchor === "undefined" || anchor === null) {
            anchor = new draw2d.layout.anchor.ConnectionAnchor();
        }

        this.connectionAnchor = anchor;
        this.connectionAnchor.setOwner(this);

        // the anchor has changed. In this case all connections needs an change event to recalculate
        // the anchor and the routing itself
        this.fireEvent("move");

        return this;
    },

    getConnectionAnchorLocation: function (referencePoint, inquiringConnection) {
        return this.connectionAnchor.getLocation(referencePoint, inquiringConnection);
    },

    getConnectionAnchorReferencePoint: function (inquiringConnection) {
        return this.connectionAnchor.getReferencePoint(inquiringConnection);
    },


    /**
     * @method
     * Returns the **direction** for the connection in relation to the given port and it's parent.
     *
     * <p>
     * Possible values:
     * <ul>
     *   <li>up -&gt; 0</li>
     *   <li>right -&gt; 1</li>
     *   <li>down -&gt; 2</li>
     *   <li>left -&gt; 3</li>
     * </ul>
     * <p>
     *
     * @param {draw2d.Connection} conn the related Connection
     * @param {draw2d.Port} relatedPort the counterpart port
     * @return {Number} the direction.
     */
    getConnectionDirection: function (conn, relatedPort) {
        return this.getParent().getBoundingBox().getDirection(this.getAbsolutePosition());
    },

    /**
     * @method
     * Set the locator/layouter of the port. A locator is responsive for the x/y arrangement of the
     * port in relation to the parent node.
     *
     * @param {draw2d.layout.locator.Locator} locator
     */
    setLocator: function (locator) {
        this.locator = locator;

        return this;
    },

    /**
     * @method
     * Get the locator/layouter of the port. A locator is responsive for the x/y arrangement of the
     * port in relation to the parent node.
     *
     * @since 4.2.0
     */
    getLocator: function () {
        return this.locator;
    },


    /**
     * @method
     * Set the new background color of the figure. It is possible to hands over
     * <code>null</code> to set the background transparent.
     *
     * @param {draw2d.util.Color} color The new background color of the figure
     **/
    setBackgroundColor: function (color) {
        this._super(color);
        this.lighterBgColor = this.bgColor.lighter(0.3).hash();
        return this;
    },

    /**
     * @method
     * Set a value for the port. This is useful for interactive/dynamic diagrams like circuits, simulator,...
     *
     * @param {Object} value the new value for the port
     */
    setValue: function (value) {
        this.value = value;
        if (this.getParent() !== null) {
            this.getParent().onPortValueChanged(this);
        }

        return this;
    },

    /**
     * @method
     * Return the user defined value of the port.
     *
     * @returns {Object}
     */
    getValue: function () {
        return this.value;
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};


        // a port did have the 0/0 coordinate in the center and not in the top/left corner
        //
        attributes.cx = this.getAbsoluteX();
        attributes.cy = this.getAbsoluteY();
        attributes.rx = this.width / 2;
        attributes.ry = attributes.rx;
        attributes.cursor = "move";

        if (this.getAlpha() < 0.9) {
            attributes.fill = this.bgColor.hash();
        }
        else {
            attributes.fill = ["90", this.bgColor.hash(), this.lighterBgColor].join("-");
        }

        this._super(attributes);
    },


    /**
     * @inheritdoc
     *
     **/
    onMouseEnter: function () {
        this.setStroke(2);
    },


    /**
     * @inheritdoc
     *
     **/
    onMouseLeave: function () {
        this.setStroke(1);
    },


    /**
     * @method
     * Returns a {@link draw2d.util.ArrayList} of {@link draw2d.Connection}s of all related connections to this port.
     *
     * @type {draw2d.util.ArrayList}
     **/
    getConnections: function () {
        return this.connections;
    },


    /**
     * @inheritdoc
     */
    setParent: function (parent) {
        this._super(parent);

        if (this.parent !== null) {
            this.parent.off(this.moveListener);
        }

        if (this.parent !== null) {
            this.parent.on("move", this.moveListener);
        }
    },


    /**
     * @method
     * Returns the corona width of the Port. The corona width will be used during the
     * drag&drop of a port.
     *
     * @return {Number}
     **/
    getCoronaWidth: function () {
        return this.coronaWidth;
    },


    /**
     * @method
     * Set the corona width of the Port. The corona width will be used during the
     * drag&drop of a port. You can drop a port in the corona of this port to create
     * a connection. It is not neccessary to drop exactly on the port.
     *
     * @param {Number} width The new corona width of the port
     **/
    setCoronaWidth: function (width) {
        this.coronaWidth = width;
    },

    /**
     * @inheritdoc
     *
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean}
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {
        // just allow the DragOperation if the port didn't have reached the max fanOut
        // limit.
        if (this.getConnections().getSize() >= this.maxFanOut) {
            return false;
        }

        var _this = this;

        // this can happen if the user release the mouse button outside the window during a drag&drop
        // operation
        if (this.isInDragDrop === true) {
            this.onDragEnd(x, y, shiftKey, ctrlKey);
        }

        this.getShapeElement().insertAfter(this.parent.getShapeElement());
        // don't call the super method. This creates a command and this is not necessary for a port
        this.ox = this.x;
        this.oy = this.y;

        // notify all installed policies
        //
        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.onDragStart(_this.canvas, _this, x, y, shiftKey, ctrlKey);
            }
        });

        return true;
    },

    /**
     * @inheritdoc
     *
     * @param {Number} dx the x difference between the start of the drag drop operation and now
     * @param {Number} dy the y difference between the start of the drag drop operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     **/
    onDrag: function (dx, dy, dx2, dy2) {
        this.isInDragDrop = true;

        this._super(dx, dy);

        var _this = this;

        var target = this.getCanvas().getBestFigure(this.getAbsoluteX(), this.getAbsoluteY(), this);

        // the hovering element has been changed
        if (target !== this.currentTarget) {
            if (this.currentTarget !== null) {
                this.currentTarget.onDragLeave(this);
                this.editPolicy.each(function (i, e) {
                    if (e instanceof draw2d.policy.port.PortFeedbackPolicy) {
                        e.onHoverLeave(_this.canvas, _this, _this.currentTarget);
                    }
                });
            }

            // possible hoverEnter event
            //
            if (target !== null) {
                this.currentTarget = target.onDragEnter(this);
                if (this.currentTarget !== null) {
                    this.currentTargetPort = target;
                    this.editPolicy.each(function (i, e) {
                        if (e instanceof draw2d.policy.port.PortFeedbackPolicy) {
                            e.onHoverEnter(_this.canvas, _this, _this.currentTarget);
                        }
                    });
                }
            }
            else {
                this.currentTarget = null;
            }

        }
    },


    /**
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     **/
    onDragEnd: function (x, y, shiftKey, ctrlKey) {
        // Don't call the parent implementation. This will create an CommandMove object
        // and store them o the CommandStack for the undo operation. This makes no sense for a
        // port.
        // draw2d.shape.basic.Rectangle.prototype.onDragEnd.call(this); DON'T call the super implementation!!!

        this.setAlpha(1.0);

        // 1.) Restore the old Position of the node
        //
        this.setPosition(this.ox, this.oy);

        this.isInDragDrop = false;

        var _this = this;

        // notify all installed policies
        //
        if (this.currentTarget) {
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.port.PortFeedbackPolicy) {
                    e.onHoverLeave(_this.canvas, _this, _this.currentTarget);
                }
            });
        }

        this.editPolicy.each(function (i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.onDragEnd(_this.canvas, _this, x, y, shiftKey, ctrlKey);
            }
        });

        // Reset the drag&drop flyover information
        //
        this.currentTarget = null;
    },

    /**
     * @method
     *
     * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
     *
     * @return {draw2d.Figure} the figure which should receive the drop event or null if the element didn't want a drop event
     * @private
     **/
    onDragEnter: function (draggedFigure) {
        var delegate = null;
        var _this = this;
        this.getCanvas().getInterceptorPolicies().each(function (i, policy) {
            delegate = policy.delegateDrop(draggedFigure, _this);
            if (delegate !== null) {
                return false; // break the loop
            }
        });

        if (delegate === null) {
            return null;
        }

        // Create a CONNECT Command to determine if we can show a Corona.
        //
        var request = new draw2d.command.CommandType(draw2d.command.CommandType.CONNECT);
        request.canvas = this.getCanvas();
        request.source = delegate;
        request.target = draggedFigure;
        var command = draggedFigure.createCommand(request);

        if (command === null) {
            return null;
        }

        return delegate;
    },

    /**
     * @method
     *
     * @param {draw2d.Figure} figure The figure which is currently dragging
     * @private
     **/
    onDragLeave: function (figure) {
        // Ports accepts only Ports as DropTarget
        //
        if (!(figure instanceof draw2d.Port)) {

        }
    },

    /**
     * @method
     * Called if the user drop this element onto the dropTarget
     *
     * @param {draw2d.Figure} dropTarget The drop target.
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onDrop: function (dropTarget, x, y, shiftKey, ctrlKey) {

        // Ports accepts only Ports as DropTarget
        //
        if (!(dropTarget instanceof draw2d.Port)) {
            return;
        }

        var request = new draw2d.command.CommandType(draw2d.command.CommandType.CONNECT);
        request.canvas = this.parent.getCanvas();
        request.source = dropTarget;
        request.target = this;
        var command = this.createCommand(request);

        if (command !== null) {
            this.parent.getCanvas().getCommandStack().execute(command);
        }
        this.setGlow(false);
    },


    /**
     * @method
     * Callback method if a new connection has created with this port
     *
     *      // Alternatively you register for this event with:
     *      port.on("connect", function(emitterPort, connection){
     *          alert("port connected");
     *      });
     *
     * @param {draw2d.Connection} connection The connection which has been created
     * @since 2.5.1
     * @template
     **/
    onConnect: function (connection) {
    },

    /**
     * @method
     * Callback method if a new connection has created with this port
     *
     *      // Alternatively you register for this event with:
     *      port.on("connect", function(emitterPort, connection){
     *          alert("port disconnected");
     *      });
     *
     * @param {draw2d.Connection} connection The connection which has been deleted
     * @since 2.5.1
     * @template
     **/
    onDisconnect: function (connection) {
    },


    /**
     * @method
     * Return the name of this port.
     *
     * @return {String}
     **/
    getName: function () {
        return this.name;
    },

    /**
     * @method
     * Set the name of this port. The name of the port can be referenced by the lookup of
     * ports in the node.
     *
     *
     * @param {String} name The new name of this port.
     **/
    setName: function (name) {
        this.name = name;
    },

    /**
     * @method
     * Hit test for ports. This method respect the corona diameter of the port for the hit test.
     * The corona width can be set with {@link draw2d.Port#setCoronaWidth}
     * @param {Number} iX
     * @param {Number} iY
     * @returns {Boolean}
     */
    hitTest: function (iX, iY) {
        var x = this.getAbsoluteX() - this.coronaWidth - this.getWidth() / 2;
        var y = this.getAbsoluteY() - this.coronaWidth - this.getHeight() / 2;
        var iX2 = x + this.getWidth() + (this.coronaWidth * 2);
        var iY2 = y + this.getHeight() + (this.coronaWidth * 2);

        return (iX >= x && iX <= iX2 && iY >= y && iY <= iY2);
    },

    /**
     * @method
     * Highlight this port
     *
     * @param {boolean} flag indicator if the figure should glow.
     */
    setGlow: function (flag) {
        if (flag === true && this.corona === null) {
            this.corona = new draw2d.Corona();
            this.corona.setDimension(this.getWidth() + (this.getCoronaWidth() * 2), this.getWidth() + (this.getCoronaWidth() * 2));
            this.corona.setPosition(this.getAbsoluteX() - this.getCoronaWidth() - this.getWidth() / 2, this.getAbsoluteY() - this.getCoronaWidth() - this.getHeight() / 2);

            this.corona.setCanvas(this.getCanvas());

            // important inital
            this.corona.getShapeElement();
            this.corona.repaint();

            // DON'T add them to the document. The corona is just a visual feedback and not part
            // of the canvas document.
            // this.parent.getCanvas().add(this.corona,this.getAbsoluteX()-this.getCoronaWidth()-this.getWidth()/2, this.getAbsoluteY()-this.getCoronaWidth()-this.getHeight()/2);
        }
        else if (flag === false && this.corona !== null) {
//    	  this.parent.getCanvas().remove(this.corona);
            this.corona.setCanvas(null);
            this.corona = null;
        }

        return this;
    },

    /**
     * @inheritdoc
     */
    createCommand: function (request) {
        // the port has its own implementation of the CommandMove
        //
        if (request.getPolicy() === draw2d.command.CommandType.MOVE) {
            if (!this.isDraggable()) {
                return null;
            }
            return new draw2d.command.CommandMovePort(this);
        }

        // Connect request between two ports
        //
        if (request.getPolicy() === draw2d.command.CommandType.CONNECT) {
            return new draw2d.command.CommandConnect(request.canvas, request.source, request.target, request.source);
        }

        return null;
    },

    /**
     * @method
     * Called from the figure itself when any position changes happens. All listener
     * will be informed.
     * <br>
     * DON'T fire this event if the Port is during a Drag&Drop operation. This can happen
     * if we try to connect two ports
     *
     * @private
     **/
    fireEvent: function (event, args) {
        if (this.isInDragDrop === true) {
            return;
        }

        this._super(event, args);
    },

    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @return
     */
    getPersistentAttributes: function () {
        var memento = this._super();

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);


        return this;
    }
});

/**
 * @class draw2d.Corona
 * Glow effect for ports. Just for internal use.
 *
 * @extend draw2d.shape.basic.Circle
 */
draw2d.Corona = draw2d.shape.basic.Circle.extend({

    /**
     * @constructor
     * Creates a new Node element which are not assigned to any canvas.
     *
     */
    init: function () {
        this._super();
        this.setAlpha(0.3);
        this.setBackgroundColor(new draw2d.util.Color(178, 225, 255));
        this.setColor(new draw2d.util.Color(102, 182, 252));
    },

    /**
     * @method
     * the the opacity of the element.
     *
     * @param {Number} percent
     */
    setAlpha: function (percent) {
        this._super(Math.min(0.3, percent));
        this.setDeleteable(false);
        this.setDraggable(false);
        this.setResizeable(false);
        this.setSelectable(false);

        return this;
    }
});

/**
 * @class draw2d.InputPort
 * A InputPort is the start anchor for a {@link draw2d.Connection}.
 *
 * @author Andreas Herz
 * @extend draw2d.Port
 */
draw2d.InputPort = draw2d.Port.extend({

    NAME: "draw2d.InputPort",

    /**
     * @constructor
     * Create a new InputPort element
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr) {
        this._super(attr);

        // responsive for the arrangement of the port
        // calculates the x/y coordinates in relation to the parent node
        this.locator = new draw2d.layout.locator.InputPortLocator();
    },


    /**
     * @inheritdoc
     */
    onDragLeave: function (figure) {
        if (figure instanceof draw2d.OutputPort) {
            this._super(figure);
        }

        else if (figure instanceof draw2d.HybridPort) {
            this._super(figure);
        }
    },


    /**
     * @inheritdoc
     */
    createCommand: function (request) {
        // Connect request between two ports
        //
        if (request.getPolicy() === draw2d.command.CommandType.CONNECT) {
            return new draw2d.command.CommandConnect(request.canvas, request.source, request.target, request.source);
        }

        // ...else call the base class
        return this._super(request);
    }
});

/**
 * @class draw2d.OutputPort
 * A OutputPort is the start anchor for a {@link draw2d.Connection}.
 *
 * @author Andreas Herz
 * @extends draw2d.Port
 */
draw2d.OutputPort = draw2d.Port.extend({

    NAME: "draw2d.OutputPort",

    /**
     * @constructor
     * Create a new OutputPort element
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr) {
        this._super(attr);

        // responsive for the arrangement of the port
        // calculates the x/y coordinates in relation to the parent node
        this.locator = new draw2d.layout.locator.OutputPortLocator();
    },


    /**
     * @inheritdoc
     *
     */
    onDragLeave: function (figure) {
        // Ports accepts only InputPorts as DropTarget
        //
        if (figure instanceof draw2d.InputPort) {
            this._super(figure);
        }
        else if (figure instanceof draw2d.HybridPort) {
            this._super(figure);
        }
    },

    /**
     * @inheritdoc
     */
    createCommand: function (request) {
        // Connect request between two ports
        //
        if (request.getPolicy() === draw2d.command.CommandType.CONNECT) {
            return new draw2d.command.CommandConnect(request.canvas, request.target, request.source, request.source);
        }

        // ...else call the base class
        return this._super(request);
    }
});

/**
 * @class draw2d.HybridPort
 * A HybridPort can work as Input and as Output port in the same way for a {@link draw2d.Connection}.
 *
 * @author Andreas Herz
 * @extends draw2d.Port
 */
draw2d.HybridPort = draw2d.Port.extend({

    NAME: "draw2d.HybridPort",

    /**
     * @constructor
     * Create a new HybridPort element
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr) {
        this._super(attr);

        // responsive for the arrangement of the port
        // calculates the x/y coordinates in relation to the parent node
        this.locator = new draw2d.layout.locator.InputPortLocator();
    },


    /**
     * @inheritdoc
     *
     * @param {draw2d.Figure} figure The figure which is currently dragging
     * @return {draw2d.Figure} the figure which should receive the drop event or null if the element didnt want a drop event
     */
    onDragEnter: function (figure) {
        // Accept any kind of port
        if (figure instanceof draw2d.Port) {
            return this._super(figure);
        }

        return null;
    },

    /**
     * @inheritdoc
     *
     */
    onDragLeave: function (figure) {
        // Ports accepts only Ports as DropTarget
        //
        if (!(figure instanceof draw2d.Port)) {
            return;
        }

        // accept any kind of port
        if (figure instanceof draw2d.Port) {
            this._super(figure);
        }

    },

    /**
     * @inheritdoc
     */
    createCommand: function (request) {
        // Connect request between two ports
        //
        if (request.getPolicy() === draw2d.command.CommandType.CONNECT) {

            if (request.source.getParent().getId() === request.target.getParent().getId()) {
                return null;
            }

            if (request.source instanceof draw2d.InputPort) {
                // This is the difference to the InputPort implementation of createCommand.
                return new draw2d.command.CommandConnect(request.canvas, request.target, request.source, request.source);
            }
            else if (request.source instanceof draw2d.OutputPort) {
                // This is the different to the OutputPort implementation of createCommand
                return new draw2d.command.CommandConnect(request.canvas, request.source, request.target, request.source);
            }
            else if (request.source instanceof draw2d.HybridPort) {
                // This is the different to the OutputPort implementation of createCommand
                return new draw2d.command.CommandConnect(request.canvas, request.target, request.source, request.source);
            }

            return null;
        }

        // ...else call the base class
        return this._super(request);
    }
});

/**
 * @class draw2d.layout.anchor.ConnectionAnchor
 *  An object to which a {@link draw2d.Connection} will be anchored.
 *
 * @inheritable
 * @author Andreas Herz
 */
draw2d.layout.anchor.ConnectionAnchor = Class.extend({
    NAME: "draw2d.layout.anchor.ConnectionAnchor",

    /**
     * @constructor
     *
     * @param {draw2d.Figure} [owner] the figure to use for the anchor calculation
     */
    init: function (owner) {
        this.owner = owner;
    },

    /**
     * @method
     * Returns the location where the Connection should be anchored in absolute coordinates.
     * The anchor may use the given reference Point to calculate this location.
     *
     * @param {draw2d.geo.Point} reference the opposite reference point
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     *
     * @return {Number} reference The reference Point in absolute coordinates
     */
    getLocation: function (reference, inquiringConnection) {
        // return the center of the owner/port.
        return this.getReferencePoint(inquiringConnection);
    },

    /**
     * @method
     * Returns the Figure that contains this ConnectionAnchor.
     *
     * @return {draw2d.Figure} The Figure that contains this ConnectionAnchor
     */
    getOwner: function () {
        return this.owner;
    },

    /**
     * @method
     * Set the owner of the Anchor.
     *
     * @param {draw2d.Figure} owner the new owner of the anchor locator
     */
    setOwner: function (owner) {
        if (typeof owner === "undefined") {
            throw "Missing parameter for 'owner' in ConnectionAnchor.setOwner";
        }
        this.owner = owner;
    },

    /**
     * @method
     * Returns the bounds of this Anchor's owner.  Subclasses can override this method
     * to adjust the box. Maybe you return the box of the port parent (the parent figure)
     *
     * @return {draw2d.geo.Rectangle} The bounds of this Anchor's owner
     */
    getBox: function () {
        return this.getOwner().getAbsoluteBounds();
    },

    /**
     * @method
     * Returns the reference point for this anchor in absolute coordinates. This might be used
     * by another anchor to determine its own location.
     *
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     * @return {draw2d.geo.Point} The reference Point
     */
    getReferencePoint: function (inquiringConnection) {
        return this.getOwner().getAbsolutePosition();
    }
});

/**
 * @class draw2d.layout.anchor.ChopboxConnectionAnchor
 *
 * The ChopboxAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box. A Connection using the
 * ChopBoxAnchor will be oriented such that they point to their port owner's
 * center.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */
draw2d.layout.anchor.ChopboxConnectionAnchor = draw2d.layout.anchor.ConnectionAnchor.extend({

    NAME: "draw2d.layout.anchor.ChopboxConnectionAnchor",

    /**
     * @constructor
     *
     * @param {draw2d.Figure} owner the figure to use for the anchor calculation

     */
    init: function (owner) {
        this._super(owner);
    },

    /**
     * @method
     *
     * Returns the location where the Connection should be anchored in
     * absolute coordinates. The anchor may use the given reference
     * Point to calculate this location.
     *
     * @param {draw2d.geo.Point} reference The reference Point in absolute coordinates
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     * @return The anchor's location
     */
    getLocation: function (reference, inquiringConnection) {

        var r = new draw2d.geo.Rectangle(0, 0);
        r.setBounds(this.getBox());
        r.translate(-1, -1);
        r.resize(1, 1);

        var center = r.getCenter();

        if (r.isEmpty() || (reference.x === center.x && reference.y === center.y)) {
            return center; // This avoids divide-by-zero
        }

        var dx = reference.x - center.x;
        var dy = reference.y - center.y;

        // r.width, r.height, dx, and dy are guaranteed to be non-zero.
        var scale = 0.5 / Math.max(Math.abs(dx) / r.w, Math.abs(dy) / r.h);

        dx *= scale;
        dy *= scale;
        center.translate(dx, dy);

        return center;
    },

    /**
     * Returns the bounds of this Anchor's owner. Subclasses can
     * override this method to adjust the box. Maybe you return the box
     * of the port parent (the parent figure)
     *
     * @return The bounds of this Anchor's owner
     */
    getBox: function () {
        return this.getOwner().getParent().getBoundingBox();
    },

    /**
     * @method
     *
     * Returns the reference point for this anchor in absolute coordinates. This might be used
     * by another anchor to determine its own location.
     *
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     * @return The bounds of this Anchor's owner
     */
    getReferencePoint: function (inquiringConnection) {
        return this.getBox().getCenter();
    },

});

/**
 * @class draw2d.layout.anchor.FanConnectionAnchor
 *
 * The FanConnectionAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box.
 * Additional the anchor resolves conflicts by spread the anchor if more than one
 * connection has the same reference point. <br>
 * In a case of a DirectRouter parallel connections are the result.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @since 4.6.0
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */
draw2d.layout.anchor.FanConnectionAnchor = draw2d.layout.anchor.ConnectionAnchor.extend({

    NAME: "draw2d.layout.anchor.FanConnectionAnchor",

    /**
     * @constructor
     *
     * @param {draw2d.Figure} owner the figure to use for the anchor calculation
     * @param {Number} [separation] the separation or fan distance between the concurrent/conflicting anchors
     */
    init: function (owner, separation) {
        this._super(owner);

        if (separation) {
            this.separation = parseInt(separation);
        }
        else {
            this.separation = 10;
        }
    },

    /**
     * @method
     *
     * Returns the location where the Connection should be anchored in
     * absolute coordinates. The anchor may use the given reference
     * Point to calculate this location.
     *
     * @param {draw2d.geo.Point} reference The reference Point in absolute coordinates
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     * @return The anchor's location
     */
    getLocation: function (reference, inquiringConnection) {

        var r = new draw2d.geo.Rectangle(0, 0);
        r.setBounds(this.getBox());
        r.translate(-1, -1);
        r.resize(1, 1);

        var center = r.getCenter();

        if (r.isEmpty() || (reference.x === center.x && reference.y === center.y)) {
            return center; // This avoids divide-by-zero
        }

        // translate the center if required
        //
        var s = inquiringConnection.getSource();
        var t = inquiringConnection.getTarget();
        var lines = this.getOwner().getConnections().clone();
        lines.grep(function (other) {
            return (other.getTarget() === t && other.getSource() === s) || (other.getTarget() === s && other.getSource() === t);
        });
        var index = lines.indexOf(inquiringConnection) + 1;
        var position = center.getPosition(reference);
        var ray;
        if (position == draw2d.geo.PositionConstants.SOUTH || position == draw2d.geo.PositionConstants.EAST) {
            ray = new draw2d.geo.Point(reference.x - center.x, reference.y - center.y);
        }
        else {
            ray = new draw2d.geo.Point(center.x - reference.x, center.y - reference.y);
        }
        var length = Math.sqrt(ray.x * ray.x + ray.y * ray.y);
        if (index <= 2) {
            length *= 1.5;
        }
        var xSeparation = this.separation * ray.x / length;
        var ySeparation = this.separation * ray.y / length;
        if (index % 2 === 0) {
            center = new draw2d.geo.Point(center.x + (index / 2) * (-1 * ySeparation), center.y + (index / 2) * xSeparation);
        }
        else {
            center = new draw2d.geo.Point(center.x + (index / 2) * ySeparation, center.y + (index / 2) * (-1 * xSeparation));
        }

        var intersections = this.getBox().intersectionWithLine(center, reference);
        // perfect - one intersection mean that the shifted center point is inside the bounding box and has only one intersection with it.
        //
        switch (intersections.getSize()) {
            case 0:
                // calculate the edge of the boundign box which is nearest to the reference point
                //
                var v = this.getBox().getVertices();
                var first = v.first();
                first.distance = reference.getDistance(first);
                return v.asArray().reduce(function (previous, current) {
                    current.distance = reference.getDistance(current);
                    return current.distance < previous.distance ? current : previous;
                });
            case 1:
                return intersections.get(0);
                break;
            case 2:
                // get the nearest of these points
                var p0 = intersections.get(0);
                var p1 = intersections.get(1);
                var p0diff = reference.getDistance(p0);
                var p1diff = reference.getDistance(p1);
                if (p0diff < p1diff) {
                    return p0;
                }
                return p1;
        }

        // we have 0 or 2 intersections with the bounding box. This means the shifted
        // calculate the intersection if the new "center" with the bounding box of the
        // shape (if any exists)

    },

    /**
     * Returns the bounds of this Anchor's owner. Subclasses can
     * override this method to adjust the box. Maybe you return the box
     * of the port parent (the parent figure)
     *
     * @return The bounds of this Anchor's owner
     */
    getBox: function () {
        return this.getOwner().getParent().getBoundingBox();
    },

    /**
     * @method
     *
     * Returns the reference point for this anchor in absolute coordinates. This might be used
     * by another anchor to determine its own location.
     *
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     * @return The bounds of this Anchor's owner
     */
    getReferencePoint: function (inquiringConnection) {
        return this.getBox().getCenter();
    }
});

/**
 * @class draw2d.layout.anchor.ShortesPathConnectionAnchor
 *
 * The ChopboxAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box. A Connection using the
 * ChopBoxAnchor will be oriented such that they point to their port owner's
 * center.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */
draw2d.layout.anchor.ShortesPathConnectionAnchor = draw2d.layout.anchor.ConnectionAnchor.extend({

    NAME: "draw2d.layout.anchor.ShortesPathConnectionAnchor",

    /**
     * @constructor
     *
     * @param {draw2d.Figure} [owner] the figure to use for the anchor calculation
     */
    init: function (owner) {
        this._super(owner);
    },

    /**
     * @method
     *
     * Returns the location where the Connection should be anchored in
     * absolute coordinates. The anchor may use the given reference
     * Point to calculate this location.
     *
     * @param {draw2d.geo.Point} ref The reference Point in absolute coordinates
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     *
     * @return {draw2d.geo.Point} The anchor's location
     */
    getLocation: function (ref, inquiringConnection) {
        var r = this.getOwner().getParent().getBoundingBox();
        var center = r.getCenter();

        // check if we can calculate with a circle/line intersection
        //
        if (this.getOwner().getParent() instanceof draw2d.shape.basic.Oval) {
            var result = this.getOwner().getParent().intersectionWithLine(ref, center);
            if (result.getSize() == 1) {
                return result.get(0);
            }
        }

        /*    0 | 1 | 2
         *    __|___|__
         *    7 | 8 | 3
         *    __|___|__
         *    6 | 5 | 4
         */
        var octant = r.determineOctant(new draw2d.geo.Rectangle(ref.x, ref.y, 2, 2));

        switch (octant) {
            case 0:
                return r.getTopLeft();
            case 1:
                return new draw2d.geo.Point(ref.x, r.getTop());
            case 2:
                return r.getTopRight();
            case 3:
                return new draw2d.geo.Point(r.getRight(), ref.y);
            case 4:
                return r.getBottomRight();
            case 5:
                return new draw2d.geo.Point(ref.x, r.getBottom());
            case 6:
                return r.getBottomLeft();
            case 7:
                return new draw2d.geo.Point(r.getLeft(), ref.y);
        }

        return r.getTopLeft();
    },

    /**
     * Returns the bounds of this Anchor's owner. Subclasses can
     * override this method to adjust the box. Maybe you return the box
     * of the port parent (the parent figure)
     *
     * @return The bounds of this Anchor's owner
     */
    getBox: function () {
        return this.getOwner().getParent().getBoundingBox();
    },

    /**
     * @method
     *
     * Returns the bounds of this Anchor's owner. Subclasses can
     * override this method to adjust the box. Maybe you return the box
     * of the port parent (the parent figure)
     *
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     *
     * @return The bounds of this Anchor's owner
     */
    getReferencePoint: function (inquiringConnection) {
        return this.getBox().getCenter();
    }
});

/**
 * @class draw2d.layout.anchor.CenterEdgeConnectionAnchor
 *
 * The ChopboxAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box. A Connection using the
 * ChopBoxAnchor will be oriented such that they point to their port owner's
 * center.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */
draw2d.layout.anchor.CenterEdgeConnectionAnchor = draw2d.layout.anchor.ConnectionAnchor.extend({

    NAME: "draw2d.layout.anchor.CenterEdgeConnectionAnchor",

    /**
     * @constructor
     *
     * @param {draw2d.Figure} [owner] the figure to use for the anchor calculation
     */
    init: function (owner) {
        this._super(owner);
    },

    /**
     * @method
     *
     * Returns the location where the Connection should be anchored in
     * absolute coordinates. The anchor may use the given reference
     * Point to calculate this location.
     *
     * @param {draw2d.geo.Point} ref The reference Point in absolute coordinates
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     *
     * @return {draw2d.geo.Point} The anchor's location
     */
    getLocation: function (ref, inquiringConnection) {
        var r = this.getOwner().getParent().getBoundingBox();

        var dir = r.getDirection(ref);
        var center = r.getCenter();

        switch (dir) {
            case 0:
                center.y = r.y;
                break;
            case 1:
                center.x = r.x + r.w;
                break;
            case 2:
                center.y = r.y + r.h;
                break;
            case 3:
                center.x = r.x;
        }

        return center;
    },

    /**
     * Returns the bounds of this Anchor's owner. Subclasses can
     * override this method to adjust the box. Maybe you return the box
     * of the port parent (the parent figure)
     *
     * @return The bounds of this Anchor's owner
     */
    getBox: function () {
        return this.getOwner().getParent().getBoundingBox();
    },

    /**
     * @method
     *
     * Returns the bounds of this Anchor's owner. Subclasses can
     * override this method to adjust the box. Maybe you return the box
     * of the port parent (the parent figure)
     *
     * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
     * @return The bounds of this Anchor's owner
     */
    getReferencePoint: function (inquiringConnection) {
        return this.getBox().getCenter();
    }
});

/**
 * @class draw2d.shape.arrow.CalligrapherArrowLeft
 * Hand drawn arrow to the left.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.arrow.CalligrapherArrowLeft({x:10, y:10, color:"#3d3d3d"});
 *
 *     canvas.add(figure);
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.arrow.CalligrapherArrowLeft = draw2d.SVGFigure.extend({

    NAME: "draw2d.shape.arrow.CalligrapherArrowLeft",

    /**
     * @constructor
     * Creates a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr);
    },


    getSVG: function () {
        return '<svg width="230" height="60" xmlns="http://www.w3.org/2000/svg" version="1.1">' +
            '  <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3024" d="m 218.87943,27.464763 c -1.21088,-0.0563 -2.42064,-0.14616 -3.63262,-0.16893 c -5.82495,-0.10948 -18.61676,-0.0226 -22.97385,0.0122 c -7.12848,0.057 -14.25673,0.14021 -21.38495,0.22333 c -9.03765,0.10539 -18.07511,0.22813 -27.11266,0.3422 c -10.2269,0.11878 -20.4538,0.23756 -30.6807,0.35634 c -35.488759,0.4089 -70.975849,0.82793 -106.4669238,0.95195 c 0,0 7.9718628,-5.70244 7.9718628,-5.70244 l 0,0 c 6.374241,0.28694 12.745594,0.64561 19.122722,0.86083 c 28.09499,0.94816 56.21338,0.92473 84.315959,0.32205 c 10.51273,-0.32805 21.0288,-0.56402 31.53819,-0.98412 c 27.47361,-1.09824 54.91405,-2.91665 82.28177,-5.53697 c 0,0 -12.9788,9.32351 -12.9788,9.32351 z" inkscape:connector-curvature="0" />' +
            '  <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3026" d="m 100.75066,1.6309831 c -7.165239,3.9571 -14.284929,7.47866 -22.036659,10.2707299 c -5.00195,1.80163 -10.10374,3.31886 -15.2402,4.79424 c -8.25878,2.37815 -16.55626,4.65805 -24.9012,6.79479 c -2.89107,0.71593 -5.74687,1.56407 -8.66266,2.20424 c -3.211679,0.70512 -6.49468,1.17333 -9.752959,1.6747 c -5.447101,0.92112 -10.9044008,1.81762 -16.3983488,2.50082 c -1.608931,0.0814 -0.850754,0.10697 -2.275834,-0.0365 C 20.004071,21.041553 19.256899,21.517873 32.515691,19.216243 c 6.21537,-1.05913 12.34875,-2.37668 18.3945,-4.03234 c 8.12719,-2.02803 16.23765,-4.1157 24.26421,-6.4321199 c 5.23574,-1.55053 10.41682,-3.15473 15.46857,-5.12875 c 1.38953,-0.54295 2.7579,-1.12682 4.12253,-1.71603 c 0.98421,-0.42496 3.86537,-1.81801999 2.92296,-1.32600999 C 93.642191,2.6934931 89.529511,4.7073031 85.450031,6.7704531 l 15.300629,-5.1394 z" inkscape:connector-curvature="0" sodipodi:nodetypes="csccsccccccsssccc" />' +
            '  <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3028" d="m 80.764281,58.068863 c -2.45498,-3.50762 -6.58178,-6.10525 -10.40324,-8.66732 c -4.30614,-2.72676 -7.93958,-6.28283 -12.6021,-8.28702 c -7.39912,-4.50257 -11.70055,-7.85592 -20.85866,-9.23429 c -4.9257,-0.85706 -17.294247,-1.32043 -22.226462,-2.15427 c -3.445882,-0.42869 -6.2035918,0.70541 -9.6845138,0.57715 c -1.496337,-0.0586 -2.99355,-0.0965 -4.491229,-0.12472 l 13.9525278,-6.24562 l 3.25,-1.17153 c 1.441459,0.0813 -1.116338,0.15309 0.325505,0.23016 c 3.574557,0.17902 7.211864,0.0695 10.712655,0.73822 c 4.723107,1.08097 9.443947,2.1624 14.234177,3.05317 c 2.76739,0.64203 3.92627,0.87082 6.64127,1.66289 c 4.42146,1.28993 8.60075,3.01513 12.86503,4.58129 c 1.90199,0.73446 5.05193,1.93181 6.89302,2.7216 c 4.92005,2.11061 9.5916,4.57045 13.9716,7.31023 c 4.16708,2.62011 8.48023,5.20033 11.72012,8.56863 z" inkscape:connector-curvature="0" sodipodi:nodetypes="ccccccccccccscsccc" />' +
            '</svg>';
    },

    /**
     * @method
     * propagate all attributes like color, stroke,... to the shape element
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }


        if (this.svgNodes !== null) {
            this.svgNodes.attr({fill: this.color.hash()});
        }

        this._super(attributes);
    }

});

/**
 * @class draw2d.shape.arrow.CalligrapherArrowDownLeft
 * Hand drawn arrow which points down left
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.arrow.CalligrapherArrowDownLeft({x:10,y:10, color:"#3d3d3d"});
 *
 *     canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.arrow.CalligrapherArrowDownLeft = draw2d.SVGFigure.extend({

    NAME: "draw2d.shape.arrow.CalligrapherArrowDownLeft",

    /**
     * @constructor
     * Create a new instance
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr);
    },


    getSVG: function () {
        return '<svg width="180" height="300" xmlns="http://www.w3.org/2000/svg" version="1.1">' +
            '     <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3084" d="m 159.63578,17.846597 c 0.43137,9.44641 -0.0636,18.88035 -0.8284,28.30165 c -1.73211,18.38336 -4.05381,36.71698 -6.08253,55.075313 c -1.61738,13.7075 -3.03402,27.43467 -3.97611,41.19113 c -1.09101,11.16584 -1.31019,22.36559 -1.28541,33.56466 c -0.1328,4.82188 0.3218,9.6468 0.14332,14.46812 c -0.0888,2.39977 -0.28315,3.73625 -0.55012,6.12095 c -0.85848,4.73147 -2.27416,9.40019 -4.7769,13.68272 c -1.47003,2.51544 -3.78493,5.6647 -5.47739,8.05048 c -5.02888,6.66256 -11.08555,12.65652 -18.10552,17.75963 c -4.23302,3.07716 -7.74942,5.12065 -12.22081,7.86298 c -13.253319,6.72606 -25.889792,15.11686 -40.84124,18.60576 c -3.016829,0.7039 -4.431417,0.8157 -7.450859,1.2076 c -6.983246,0.5774 -14.009174,0.3375 -21.010676,0.2509 c -3.278795,-0.033 -6.55749,0.01 -9.835897,0.045 c 0,0 20.838833,-13.2364 20.838833,-13.2364 l 0,0 c 3.147056,0.093 6.294483,0.1852 9.443646,0.2007 c 6.966697,0.011 13.971433,0.1301 20.897176,-0.6344 c 3.732439,-0.5577 7.321215,-1.2431 10.881203,-2.4145 c 1.517208,-0.4992 5.830867,-2.43339 4.487902,-1.6386 c -6.098183,3.6088 -25.104875,12.8748 -9.52514,5.223 c 4.40875,-2.5927 8.262057,-4.7459 12.425175,-7.65986 c 6.839117,-4.78709 12.633657,-10.50427 17.500607,-16.86761 c 2.53518,-3.56692 5.24684,-7.12748 7.07617,-11.03446 c 1.42357,-3.0404 2.21532,-6.28727 2.91146,-9.50152 c 0.91919,-6.88822 1.03991,-13.81392 1.25118,-20.74151 c 0.47683,-11.27871 0.96259,-22.55877 1.61689,-33.83062 c 1.21127,-14.03392 3.64191,-27.94339 5.46543,-41.92167 c 2.26899,-18.186603 4.6835,-36.384373 5.4487,-54.679643 c 0.0788,-2.46092 0.23808,-4.92087 0.23618,-7.38276 c -0.005,-6.45916 -0.62194,-13.00218 -2.13821,-19.32664 c 0,0 23.48134,-10.73998 23.48134,-10.73998 z" inkscape:connector-curvature="0" />' +
            '     <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3086" d="m 41.271518,252.40239 c 2.465518,-0.7264 4.879503,-1.7726 7.145328,-2.9859 c 0.955597,-0.5117 3.736822,-2.1986 2.791991,-1.6673 c -5.218817,2.9348 -10.409826,5.9187 -15.61474,8.878 c 5.366557,-3.4898 10.227818,-7.6685 14.119927,-12.75576 c 3.507157,-5.09382 4.097613,-11.17122 4.301158,-17.17644 c 0.02635,-3.95844 -0.31227,-7.90612 -0.635377,-11.84752 c 0,0 19.920693,-10.3059 19.920693,-10.3059 l 0,0 c 0.171761,4.05015 0.409899,8.09777 0.50079,12.15101 c -0.185739,6.23619 -0.347804,12.66862 -3.492579,18.24747 c -0.503375,0.75197 -0.961922,1.53596 -1.510126,2.25591 c -3.478528,4.56826 -8.226837,8.04586 -12.757403,11.47443 c -7.345206,4.3297 -14.671333,8.692 -22.035619,12.9891 c -3.551305,2.0723 -7.368692,3.8726 -11.394645,4.7773 c 0,0 18.660602,-14.0344 18.660602,-14.0344 z" inkscape:connector-curvature="0" />' +
            '     <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3088" d="m 37.815923,255.49919 c 3.41111,0.1581 6.814569,0.2213 10.182693,0.8184 c 6.92998,2.6928 13.533527,6.2357 20.043462,9.8162 c 3.912139,2.1362 7.91195,4.4644 10.690321,8.0298 c 1.039962,1.2802 1.510411,2.7604 1.893523,4.3313 c 0,0 -20.370847,10.9259 -20.370847,10.9259 l 0,0 c -0.225419,-1.2711 -0.55067,-2.4558 -1.329618,-3.5184 c -2.332229,-3.3633 -5.869056,-5.6279 -9.247191,-7.8233 c -6.335066,-3.7106 -12.98611,-7.1834 -20.232784,-8.6836 c -3.497247,-0.3814 -7.011372,-0.4307 -10.521829,-0.1703 c 0,0 18.89227,-13.726 18.89227,-13.726 z" inkscape:connector-curvature="0" />' +
            '</svg>';
    },

    /**
     * @method
     * propagate all attributes like color, stroke,... to the shape element
     **/
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }


        if (this.svgNodes !== null) {
            this.svgNodes.attr({fill: this.color.hash()});
        }

        this._super(attributes);
    }

});

/**
 * @class draw2d.shape.node.Start
 *
 * A generic Node which has an OutputPort. Mainly used for demo and examples.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.node.Start({color: "#3d3d3d"});
 *
 *     canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.shape.node.Start = draw2d.shape.basic.Rectangle.extend({

    NAME: "draw2d.shape.node.Start",

    DEFAULT_COLOR: new draw2d.util.Color("#4D90FE"),

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({
            bgColor: this.DEFAULT_COLOR,
            color: this.DEFAULT_COLOR.darker(),
            width: 50,
            height: 50
        }, attr), setter, getter);

        this.createPort("output");
    }

});

/**
 * @class draw2d.shape.node.End
 * A simple Node which has a InputPort. Mainly used for demo and examples.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.node.End({color: "#3d3d3d"});
 *
 *     canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.shape.node.End = draw2d.shape.basic.Rectangle.extend({

    NAME: "draw2d.shape.node.End",

    DEFAULT_COLOR: new draw2d.util.Color("#4D90FE"),

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({
            bgColor: this.DEFAULT_COLOR,
            color: this.DEFAULT_COLOR.darker(),
            width: 50,
            height: 50
        }, attr), setter, getter);

        this.createPort("input");

    }

});

/**
 * @class draw2d.shape.node.Between
 * A simple Node which has a  InputPort and OutputPort. Mainly used for demo and examples.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.node.Between({color: "#3d3d3d"});
 *
 *     canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.shape.node.Between = draw2d.shape.basic.Rectangle.extend({

    NAME: "draw2d.shape.node.Between",

    DEFAULT_COLOR: new draw2d.util.Color("#4D90FE"),

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({
            bgColor: this.DEFAULT_COLOR,
            color: this.DEFAULT_COLOR.darker(),
            width: 50,
            height: 50
        }, attr), setter, getter);

        this.createPort("output");
        this.createPort("input");
    }
});

/**
 * @class draw2d.shape.note.PostIt
 *
 * Simple Post-it like figure with text. Can be used for annotations or documentation.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var shape =  new draw2d.shape.note.PostIt({
 *        text:"This is a simple sticky note",
 *        color:"#000000",
 *        padding:20
 *     });
 *
 *     canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Label
 */
draw2d.shape.note.PostIt = draw2d.shape.basic.Label.extend({

    NAME: "draw2d.shape.note.PostIt",

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super(attr);

        this.setStroke(1);
        this.setBackgroundColor("#5b5b5b");
        this.setColor("#FFFFFF");
        this.setFontColor("#ffffff");
        this.setFontSize(14);
        this.setPadding(5);
        this.setRadius(5);
    }
});

/**
 * @class draw2d.shape.widget.Widget
 * Base class for all diagrams.
 *
 * @extends draw2d.SetFigure
 */
draw2d.shape.widget.Widget = draw2d.SetFigure.extend({

    init: function (attr, setter, getter) {
        this._super(attr);
    }
});

/**
 * @class draw2d.shape.widget.Slider
 * See the example:
 *
 *     @example preview small frame
 *
 *     var slider = new draw2d.shape.widget.Slider({width:120, height:20});
 *     canvas.add( slider,100,60);
 *
 * @extends draw2d.shape.widget.Widget
 */
draw2d.shape.widget.Slider = draw2d.shape.widget.Widget.extend({

    NAME: "draw2d.shape.widget.Slider",

    DEFAULT_COLOR_THUMB: new draw2d.util.Color("#bddf69"),
    DEFAULT_COLOR_BG: new draw2d.util.Color("#d3d3d3"),


    init: function (attr, setter, getter) {
        this.currentValue = 0; // [0..100]
        this.slideBoundingBox = new draw2d.geo.Rectangle(0, 0, 10, 20);

        this._super($.extend({width: 150, height: 15}, attr));

        this.setBackgroundColor(this.DEFAULT_COLOR_BG);
        this.setColor(this.DEFAULT_COLOR_THUMB);
        this.setStroke(1);
        this.setRadius(4);
        this.setResizeable(true);

        this.setMinHeight(10);
        this.setMinWidth(80);
    },

    /**
     * @method
     * Create the additional elements for the figure
     *
     */
    createSet: function () {
        var result = this.canvas.paper.set();
        var thumb = this.canvas.paper.rect(5, 5, 10, 20);
        thumb.node.style.cursor = "col-resize";
        result.push(thumb);

        return result;
    },

    setDimension: function (w, h) {
        this._super(w, h);
        this.slideBoundingBox.setBoundary(0, 0, this.getWidth() - 10, this.getHeight());
        this.slideBoundingBox.setHeight(this.getHeight() + 1);

        // TODO: and repaint again.....two repaints for one "setDimension"....BAD
        //
        this.repaint();
    },

    /**
     * @method
     * Called if the value of the slider has been changed.
     *
     * @param {Number} value The new value of the slider in percentage [0..100]
     * @template
     */
    onValueChange: function (value) {
    },

    /**
     * @method
     * Will be called if the drag and drop action begins. You can return [false] if you
     * want avoid that the figure can be move.
     *
     * @param {Number} x the x-coordinate of the mouse up event
     * @param {Number} y the y-coordinate of the mouse up event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @return {boolean} true if the figure accepts dragging
     **/
    onDragStart: function (x, y, shiftKey, ctrlKey) {

        // check if the use has been clicked on the thumb
        //
        if (this.slideBoundingBox.hitTest(x, y)) {
            this.origX = this.slideBoundingBox.getX();
            this.origY = this.slideBoundingBox.getY();
            return false;
        }

        return this._super(x, y, shiftKey, ctrlKey);
    },

    /**
     * @method
     * Called by the framework if the figure returns false for the drag operation. In this
     * case we send a "panning" event - mouseDown + mouseMove. This is very usefull for
     * UI-Widget like slider, spinner,...
     *
     * @param {Number} dx the x difference between the mouse down operation and now
     * @param {Number} dy the y difference between the mouse down operation and now
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     */
    onPanning: function (dx, dy, dx2, dy2) {
        this.slideBoundingBox.setPosition(this.origX + dx, this.origY + dy);
        // calculate the internal value of the slider
        this.setValue(100 / (this.slideBoundingBox.bw - this.slideBoundingBox.getWidth()) * this.slideBoundingBox.getX());
    },

    /**
     * @method
     * Set the current value of the slider. Valid values are [0..100]
     *
     * @param {Number} value values between [0..100]
     */
    setValue: function (value) {
        this.currentValue = Math.min(Math.max(0, (value | 0)), 100);
        this.repaint();
        this.onValueChange(this.currentValue);
        this.fireEvent("change:value");
    },


    /**
     *
     * @param attributes
     */
    repaint: function (attributes) {

        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        // adjust the slider to the current value and the new dimension of the widget
        //
        var thumbX = ((this.slideBoundingBox.bw - this.slideBoundingBox.getWidth()) / 100 * this.currentValue) | 0;
        this.slideBoundingBox.setX(thumbX);


        // update slider
        //
        if (this.svgNodes !== null) {
            var attr = this.slideBoundingBox.toJSON();
            attr.y = attr.y - 5;
            attr.height = attr.height + 10;
            attr.fill = this.getColor().hash();
            attr.stroke = this.getColor().darker(0.2).hash();
            attr.r = 4;
            this.svgNodes.attr(attr);
        }


        attributes.fill = "90-" + this.bgColor.hash() + ":5-" + this.bgColor.lighter(0.3).hash() + ":95";
        attributes.stroke = this.bgColor.darker(0.1).hash();

        this._super(attributes);
    },


    applyTransformation: function () {
        this.svgNodes.transform("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());
    }

});

/**
 * @class draw2d.shape.diagram.Diagram
 *
 * Base class for all diagrams.
 *
 * @extends draw2d.SetFigure
 */
draw2d.shape.diagram.Diagram = draw2d.SetFigure.extend({

    /**
     * @constructor
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.data = [];
        this.cache = {};

        this._super(
            $.extend({data: [], bgColor: "#8dabf2", stroke: 1, color: "#f0f0f0", radius: 2, resizeable: true}, attr),
            $.extend({}, {
                /** @attr {Array} data the data to display in the diagram */
                data: this.setData
            }, setter),
            $.extend({}, {
                data: this.getData
            }, getter)
        );
    },

    /**
     * @method
     * Set the data for the chart/diagram element
     *
     * @param {Array} data
     *
     */
    setData: function (data) {
        this.data = data;
        this.cache = {};


        if (this.svgNodes !== null) {
            this.svgNodes.remove();
            this.svgNodes = this.createSet();
        }

        this.repaint();
        this.fireEvent("change:data");

    },

    /**
     * @method
     * Return the data of the diagram
     *
     * @since 5.0.0
     */
    getData: function () {
        return this.data;
    },


    /**
     * @method
     * Set the dimension of the diagram and reset the cached calculation
     *
     * @since 5.0.0
     */
    setDimension: function (w, h) {
        this.cache = {};
        this._super(w, h);

        return this;
    },


    /**
     * @method
     * Return the calculate width of the set. This calculates the bounding box of all elements.
     *
     * @return {Number} the calculated width of the label
     **/
    getWidth: function () {
        return this.width;
    },

    /**
     * @method
     * Return the calculated height of the set. This calculates the bounding box of all elements.
     *
     * @return {Number} the calculated height of the label
     */
    getHeight: function () {
        return this.height;
    },

    /**
     *
     * @param attributes
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape == null) {
            return;
        }

        attributes = attributes || {};

        if (typeof attributes.fill === "undefined") {
            attributes.fill = "none";
        }

        this._super(attributes);

        return this;
    },

    applyTransformation: function () {
        if (this.isResizeable() === true) {
            this.svgNodes.transform("S" + this.scaleX + "," + this.scaleY + "," + this.getAbsoluteX() + "," + this.getAbsoluteY() + "t" + this.getAbsoluteX() + "," + this.getAbsoluteY());
        }
        else {
            this.svgNodes.transform("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());
        }

        return this;
    }


});

/**
 * @class draw2d.shape.diagram.Pie
 *
 * Small data pie chart.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var pie = new draw2d.shape.diagram.Pie({
 *        diameter:80,
 *        data:[30,60,122,4],
 *        x:100,
 *        y:60
 *     });
 *
 *     canvas.add( pie);
 *
 * @extends draw2d.shape.diagram.Diagram
 */
draw2d.shape.diagram.Pie = draw2d.shape.diagram.Diagram.extend({

    COLORS: ['#00A8F0', '#b9dd69', '#f3546a', '#4DA74D', '#9440ED'],
    TWO_PI: Math.PI * 2,

    /**
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {


        this._super(
            $.extend({stroke: 0}, attr),
            $.extend({
                /** @attr {Number} diameter the diameter of the pie chart */
                diameter: this.setDiameter,
                /** @attr {Number} radius the radius of the pie chart */
                radius: this.setRadius
            }, setter),
            $.extend({
                diameter: this.getDiameter,
                radius: this.getRadius
            }, getter));
    },

    /**
     * @method
     * Set the diameter of the circle. The center of the circle will be retained.
     *
     * @param {Number} d The new diameter of the circle.
     * @since 4.0.0
     **/
    setDiameter: function (d) {
        var center = this.getCenter();
        this.setDimension(d, d);
        this.setCenter(center);
        this.fireEvent("change:diameter");

        return this;
    },

    /**
     * @method
     * Get the diameter of the circle.
     *
     * @since 4.0.0
     **/
    getDiameter: function () {
        return this.getWidth();
    },


    /**
     * @method
     * Set the radius of the circle. The center of the circle will be retained.
     *
     * @param {Number} r The new radius of the circle.
     * @since 4.0.0
     **/
    setRadius: function (r) {
        this.setDiameter(r * 2);
        this.fireEvent("change:radius");

        return this;
    },


    /**
     * @method
     * Get the center of the circle
     *
     */
    getCenter: function () {
        var d2 = this.getDiameter() / 2;
        return this.getPosition().translate(d2, d2);
    },

    /**
     * @method
     * Set the center of the circle.
     *
     * @param {Number|draw2d.geo.Point} x the new x coordinate of the center or a draw2d.geo.Point object with the center
     * @param {Number} y the y coordinate of the new center of the first argument isn't a draw2d.geo.Point object
     */
    setCenter: function (x, y) {
        var pos = new draw2d.geo.Point(x, y);
        var d2 = this.getDiameter() / 2;
        pos.translate(-d2, -d2);
        this.setPosition(pos);
        this.fireEvent("change:center");

        return this;
    },

    /**
     * @inheritdoc
     */
    setData: function (data) {

        // Normalize the Data.
        // The SUM must be == 1.
        this.sum = 0;
        var _this = this;
        $.each(data, function (i, val) {
            _this.sum += val;
        });
        var _sum = 1 / this.sum;
        $.each(data, function (i, val) {
            data[i] = _sum * val;
        });

        //  pass the normalize data to the base implementation
        //
        this._super(data);
        this.fireEvent("change:data");

        return this;
    },

    /**
     * @inheritdoc
     */
    createSet: function () {
        var radius = this.getWidth() / 2;
        var length = this.data.length;

        var pie = this.canvas.paper.set();

        var offsetAngle = 0;

        for (var i = 0; i < length; i++) {
            // angle is percent of TWO_PI
            var angle = this.TWO_PI * this.data[i];
            var color = this.COLORS[i % length];
            var seg = this.drawSegment(radius, angle, offsetAngle, 0.1);
            seg.attr({stroke: this.color.hash(), fill: color});
            pie.push(seg);
            offsetAngle += angle;
        }
        return pie;
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        // keep the aspect ration
        //
        if (w > h) {
            this._super(w, w);
        }
        else {
            this._super(h, h);
        }

        // we must recreate the diagram if we change the size.
        // low performance. Better: transfor/scale the set. Can be done in the next release
        //
        if (this.svgNodes !== null) {
            this.svgNodes.remove();
            this.svgNodes = this.createSet();
        }

        this.repaint();

        return this;
    },

    polarPath: function (radius, theta, rotation) {
        var x, y;
        x = radius * Math.cos(theta + rotation) + radius;
        y = radius * Math.sin(theta + rotation) + radius;
        return "L " + x + " " + y + " ";
    },

    drawSegment: function (radius, value, rotation, resolution) {
        var path = "M " + radius + " " + radius;

        for (var i = 0; i < value; i += resolution) {
            path += this.polarPath(radius, i, rotation);
        }
        path += this.polarPath(radius, value, rotation);

        path += "L " + radius + " " + radius;
        return this.getCanvas().paper.path(path);
    },

    /**
     * @inheritdoc
     */
    applyTransformation: function () {
        this.svgNodes.transform("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());

        return this;
    }

});

/**
 * @class draw2d.shape.diagram.Sparkline
 *
 * Small data line diagram.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var testData = [];
 *     for(var i=0;i<100;i++) {
 *       testData.push(Math.floor(Math.random() * 100));
 *     }
 *
 *     var sparkline = new draw2d.shape.diagram.Sparkline({
 *     	data: testData,
 *      width:150,
 *      height:50,
 *      x:100,
 *      y:60
 *     });
 *
 *     canvas.add( sparkline);
 *
 * @extends draw2d.shape.diagram.Diagram
 */
draw2d.shape.diagram.Sparkline = draw2d.shape.diagram.Diagram.extend({

    /**
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.min = 0;
        this.max = 10;
        this.padding = 4;

        this._super($.extend({width: 180, height: 50}, attr), setter, getter);
    },

    /**
     * @inheritdoc
     */
    setData: function (data) {
        if (data.length > 0) {
            // get the min/max from an array and not only from two elements..
            this.min = Math.min.apply(Math, data);
            this.max = Math.max.apply(Math, data);
        }
        else {
            this.min = 0;
            this.max = 1;
        }

        if (this.max == this.min) {
            this.max = this.min + 1;
        }

        this._super(data);
        this.fireEvent("change:data");

        return this;
    },

    /**
     * @inheritdoc
     */
    createSet: function () {
        return this.canvas.paper.path("M0 0 l0 0");
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        attributes.fill = "90-#000:5-#4d4d4d:95";

        var padding = this.padding;
        var width = this.getWidth() - 2 * padding;
        var height = this.getHeight() - 2 * padding;
        var length = this.data.length;
        var min = this.min;
        var max = this.max;
        var toCoords = function (value, idx) {
            var step = 1;
            // avoid divisionByZero
            if (length > 1) {
                step = (width / (length - 1));
            }

            return {
                y: -((value - min) / (max - min) * height) + height + padding,
                x: padding + idx * step
            };
        };

        if (this.svgNodes !== null && (typeof this.cache.pathString === "undefined")) {
            var prev_pt = null;
            $.each(this.data, $.proxy(function (idx, item) {
                var pt = toCoords(item, idx);
                if (prev_pt === null) {
                    this.cache.pathString = ["M", pt.x, pt.y].join(" ");
                }
                else {
                    this.cache.pathString = [this.cache.pathString, "L", pt.x, pt.y].join(" ");
                }
                prev_pt = pt;
            }, this));

            this.svgNodes.attr({path: this.cache.pathString, stroke: "#f0f0f0"});

        }
        this._super(attributes);

        return this;
    }
});

/**
 * @class draw2d.shape.analog.OpAmp
 * Hand drawn arrow which points down left
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.analog.OpAmp({x:10, y:10});
 *
 *     canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.analog.OpAmp = draw2d.SVGFigure.extend({

    NAME: "draw2d.shape.analog.OpAmp",

    // custom locator for the special design of the OpAmp Input area
    MyInputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, port) {
            var parent = port.getParent();
            var calcY = (8 + 18.5 * index) * parent.scaleY;
            this.applyConsiderRotation(port, 1, calcY);
        }
    }),

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({stroke: 0, bgColor: "#f0f0ff"}, attr), setter, getter);

        this.inputLocator = new this.MyInputPortLocator();

        this.createPort("input", this.inputLocator);
        this.createPort("input", this.inputLocator);

        this.createPort("output");

    },


    /**
     * @inheritdoc
     */
    getSVG: function () {
        return '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="50"  height="50">' +
            '<path d="m8.2627,0l0,35.36035l31.23926,-17.76025l-31.23926,-17.60011l0,0l0,0.00001zm2.27832,27.36719l4.08105,0m-2.10449,-2.20703l0,4.27979m2.26367,-21.35938l-4.15918,0"  stroke="#1B1B1B" fill="none"/>' +
            '<line x1="0.53516"  y1="8"  x2="8.21191"  y2="8"  stroke="#010101"/>' +
            '<line x1="39.14941" y1="18" x2="45.81055" y2="18" stroke="#010101" />' +
            '<line x1="0.53516"  y1="27" x2="8.21191"  y2="27" stroke="#010101" />' +
            '</svg>';
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        // redirect the backgroundColor to an internal SVG node.
        // In this case only a small part of the shape are filled with the background color
        // and not the complete rectangle/bounding box
        //
        attributes["fill"] = "none";
        if (this.bgColor != null) {
            this.svgNodes[0].attr({fill: this.bgColor.hash()});
        }

        this._super(attributes);

        return this;
    }

});

/**
 * @class draw2d.shape.analog.ResistorBridge
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.analog.ResistorBridge({x:10, y:10});
 *
 *     canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.analog.ResistorBridge = draw2d.SVGFigure.extend({

    NAME: "draw2d.shape.analog.ResistorBridge",

    // custom locator for the special design of the ResistorBridge Input area
    MyInputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            var h = figure.getParent().getHeight();
            this.applyConsiderRotation(figure, w / 2 + 1, h * index);
        }
    }),

    // custom locator for the special design of the ResistorBridge Input area
    MyOutputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            var h = figure.getParent().getHeight();

            this.applyConsiderRotation(figure, w * (index - 2), h / 2);
        }
    }),


    /**
     * @constructor
     * Create a new instance
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this._super($.extend({width: 50, height: 50}, attr), setter, getter);

        this.inputLocator = new this.MyInputPortLocator();
        this.outputLocator = new this.MyOutputPortLocator();

        this.createPort("hybrid", this.inputLocator);
        this.createPort("hybrid", this.inputLocator);

        this.createPort("hybrid", this.outputLocator);
        this.createPort("hybrid", this.outputLocator);
    },


    /**
     * @inheritdoc
     */
    getSVG: function () {
        return '<svg  xmlns="http://www.w3.org/2000/svg" version="1.1">' +
            '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12322" d="m47.62207,22.71094l0,0c0.73145,0.73242 0.71777,1.93359 -0.03027,2.68164c-0.74805,0.74951 -1.94922,0.76123 -2.68073,0.0293c-0.73138,-0.73242 -0.71967,-1.93211 0.03033,-2.68115c0.74707,-0.74803 1.94727,-0.76219 2.68066,-0.02979l0,0z"/>' +
            '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12324" d="m25.84082,0.93115l0,0c0.73145,0.73096 0.71875,1.93359 -0.02832,2.68066c-0.75,0.74951 -1.94922,0.76123 -2.68164,0.0293c-0.73242,-0.73241 -0.71973,-1.93164 0.0293,-2.68065c0.74805,-0.74756 1.94922,-0.76172 2.68066,-0.0293l0,0l0,-0.00002z"/>' +
            '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12326" d="m25.75098,44.58203l0,0c0.73145,0.73193 0.71875,1.93311 -0.02832,2.68115c-0.75,0.74902 -1.94922,0.76074 -2.68262,0.0293c-0.73145,-0.73193 -0.71973,-1.93262 0.03033,-2.68164c0.74707,-0.74756 1.94922,-0.76123 2.68066,-0.02879l0,0l-0.00006,-0.00002z"/>' +
            '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12328" d="m3.9707,22.80127l0,0c0.73242,0.73193 0.71777,1.93359 -0.0293,2.68115c-0.74902,0.74951 -1.94922,0.76172 -2.68164,0.0293c-0.73145,-0.73242 -0.71973,-1.93164 0.03027,-2.68115c0.74707,-0.74707 1.94922,-0.76074 2.68066,-0.0293l0,0z"/>' +
            '<polyline fill="none" stroke="#010101" id="polyline12334" points="24.908203125,45.49267578125 31.71875,38.68310546875 31.2119140625,36.98876953125 34.892578125,37.95703125 33.953125,34.22265625 37.6650390625,35.18359375 36.6767578125,31.52490234375 40.3759765625,32.47314453125 39.873046875,30.52783203125 45.884765625,24.51708984375 " stroke-miterlimit="14.3"/>' +
            '<polyline fill="#010101" id="polyline12338" points="36.3408203125,23.98876953125 38.146484375,29.55810546875 33.630859375,29.55810546875 35.435546875,23.98779296875 "/>' +
            '<line fill="none" stroke="#010101" id="line12340" y2="28.90967" x2="35.8877" y1="41.13428" x1="35.88867" stroke-miterlimit="14.3"/>' +
            '<polyline fill="none" stroke="#010101" id="polyline12346" points="3.2109375,23.79248046875 10.01953125,16.98388671875 9.513671875,15.2890625 13.193359375,16.25732421875 12.251953125,12.5234375 15.9658203125,13.48486328125 14.9775390625,9.82568359375 18.6767578125,10.7734375 18.173828125,8.82958984375 24.185546875,2.81787109375 " stroke-miterlimit="14.3"/>' +
            '<polyline fill="#010101" id="polyline12350" points="13.126953125,23.80419921875 11.3212890625,18.236328125 15.8369140625,18.236328125 14.0322265625,23.806640625 "/>' +
            '<line fill="none" stroke="#010101" id="line12352" y2="18.8833" x2="13.58008" y1="6.65967" x1="13.5791" stroke-miterlimit="14.3"/>' +
            '<polyline fill="none" stroke="#010101" id="polyline12358" points="46.65625,24.33642578125 39.84765625,17.52783203125 38.154296875,18.033203125 39.1220703125,14.353515625 35.3876953125,15.29345703125 36.34765625,11.58056640625 32.689453125,12.56884765625 33.6376953125,8.86865234375 31.6923828125,9.373046875 24.322265625,2.00341796875 " stroke-miterlimit="14.3"/>' +
            '<polyline fill="#010101" id="polyline12362" points="36.578125,1.87109375 38.3828125,7.439453125 33.8681640625,7.439453125 35.6728515625,1.869140625 "/>' +
            '<line fill="none" stroke="#010101" id="line12364" y2="6.7915" x2="36.125" y1="19.01758" x1="36.125" stroke-miterlimit="14.3"/>' +
            '<polyline fill="none" stroke="#010101" id="polyline12370" points="24.494140625,46.49951171875 17.685546875,39.69091796875 15.9921875,40.1953125 16.958984375,36.515625 13.2265625,37.45556640625 14.185546875,33.7421875 10.52734375,34.73193359375 11.474609375,31.03125 9.529296875,31.53515625 2.1611328125,24.166015625 " stroke-miterlimit="14.3"/>' +
            '<polyline fill="#010101" id="polyline12374" points="12.150390625,44.80029296875 10.34765625,39.23193359375 14.861328125,39.23095703125 13.0556640625,44.80224609375 "/>' +
            '<line fill="none" stroke="#010101" id="line12376" y2="39.87891" x2="12.60352" y1="27.6543" x1="12.60352" stroke-miterlimit="14.3"/>' +
            '</svg>';
    }
});

/**
 * @class draw2d.shape.analog.ResistorVertical
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.analog.ResistorVertical({x:10, y:10});
 *
 *     canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.analog.ResistorVertical = draw2d.SetFigure.extend({

    NAME: "draw2d.shape.analog.ResistorVertical",

    // custom locator for the special design of the Input area
    MyInputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            var h = figure.getParent().getHeight();
            this.applyConsiderRotation(figure, w / 2, h);
        }
    }),

    // custom locator for the special design of the Output area
    MyOutputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            this.applyConsiderRotation(figure, w / 2, 0);
        }
    }),

    /**
     * @constructor
     * Create a new instance
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {

        this._super($.extend({width: 30, height: 50, bgColor: null}, attr), setter, getter);

        this.inputLocator = new this.MyInputPortLocator();
        this.outputLocator = new this.MyOutputPortLocator();

        this.createPort("hybrid", this.inputLocator);
        this.createPort("hybrid", this.outputLocator);
    },


    /**
     * @inheritdoc
     */
    createSet: function () {
        var set = this._super();

        set.push(this.canvas.paper.path("M15,0 L15,5 L0,7.5 L30,10 L0,15 L30,20 L0,25 L30,30 L15,32.5 L15,40"));

        return set;
    }
});

/**
 * @class draw2d.shape.analog.VoltageSupplyHorizontal
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.analog.VoltageSupplyHorizontal({x:10, y:10});
 *
 *     canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.analog.VoltageSupplyHorizontal = draw2d.SVGFigure.extend({

    NAME: "draw2d.shape.analog.VoltageSupplyHorizontal",

    // custom locator for the special design of the Input area
    MyInputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var h = figure.getParent().getHeight();
            this.applyConsiderRotation(figure, 0, h / 2);
        }
    }),

    // custom locator for the special design of the Output area
    MyOutputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            var h = figure.getParent().getHeight();
            this.applyConsiderRotation(figure, w, h / 2);
        }
    }),

    /**
     * @constructor
     * Create a new instance
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({width: 50, height: 30}, attr), setter, getter);

        this.createPort("hybrid", new this.MyInputPortLocator());  // GND
        this.createPort("hybrid", new this.MyOutputPortLocator()); // VCC
    },


    /**
     * @inheritdoc
     */
    getSVG: function () {
        return '<svg width="49" height="28" xmlns="http://www.w3.org/2000/svg" version="1.1">' +
            '<path d="m24.99933,18.95592l0,-9.54576m-5.78374,-9.40907l0,28.35939m-5.78718,-9.40457l0,-9.54576m-5.78374,-9.40907l0,28.35939" id="path10566" stroke-miterlimit="14.3" stroke="#010101" fill="none"/>' +
            '<path d="m26.79878,14.13039l6.90583,0m-33.22691,0l6.90583,0" id="path10568" stroke-miterlimit="14.3" stroke-linecap="square" stroke="#010101" fill="none"/>' +
            '</svg>';
    }
});

/**
 * @class draw2d.shape.analog.VoltageSupplyVertical
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.analog.VoltageSupplyVertical({x:10, y:10});
 *
 *     canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
draw2d.shape.analog.VoltageSupplyVertical = draw2d.SVGFigure.extend({

    NAME: "draw2d.shape.analog.VoltageSupplyVertical",

    // custom locator for the special design of the Input area
    MyInputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            var h = figure.getParent().getHeight();
            this.applyConsiderRotation(figure, w / 2, h);
        }
    }),

    // custom locator for the special design of the Output area
    MyOutputPortLocator: draw2d.layout.locator.PortLocator.extend({
        init: function () {
            this._super();
        },
        relocate: function (index, figure) {
            var w = figure.getParent().getWidth();
            this.applyConsiderRotation(figure, w / 2, 0);
        }
    }),

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({width: 30, height: 50}, attr), setter, getter);

        this.inputLocator = new this.MyInputPortLocator();
        this.outputLocator = new this.MyOutputPortLocator();

        this.createPort("hybrid", this.inputLocator); // GND
        this.createPort("hybrid", this.outputLocator);// VCC
    },


    /**
     * @inheritdoc
     */
    getSVG: function () {
        return '<svg  xmlns="http://www.w3.org/2000/svg" version="1.1">' +
            '<path d="m19.62398,12.37594l-9.87926,0m-9.74355,8.22145l29.36289,0m-9.74007,8.22469l-9.87927,0m-9.74355,8.22145l29.36289,0" id="path10560" stroke-miterlimit="14.3" stroke="#010101" fill="none"/>' +
            '<path d="m14.63157,9.81646l0,-9.81646m0,47.2328l0,-9.81646" id="path10562" stroke-miterlimit="14.3" stroke-linecap="square" stroke="#010101" fill="none"/>' +
            '</svg>';
    }
});

/**
 * @class draw2d.shape.layout.Layout
 *
 * A base class for positioning child figures and determining the ideal size for
 * a figure with children.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.shape.layout.Layout = draw2d.shape.basic.Rectangle.extend({

    NAME: "draw2d.shape.layout.Layout",

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this._super($.extend({bgColor: null, radius: 0, stroke: 0}, attr), setter, getter);

        var _this = this;
        this.resizeListener = function (figure) {
            // propagate the event to the parent or other listener if existing
            //
            if (_this.getParent() instanceof draw2d.shape.layout.Layout) {
                _this.fireEvent("resize");
            }
            // or we are the parent and must consume it self
            else {
                _this.setDimension(1, 1);
            }
        };

        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
    },

    /**
     * @inheritdoc
     */
    add: function (child, locator, index) {
        var r = this._super(child, locator, index);
        child.on("resize", this.resizeListener);
        child.on("change:visibility", this.resizeListener);
        this.setDimension(1, 1);

        return r;
    },

    /**
     * @inheritdoc
     */
    remove: function (child) {
        var r = this._super(child);
        child.off(this.resizeListener);
        this.setDimension(1, 1);

        return r;
    },


    /**
     * @inheritdoc
     */
    setRotationAngle: function (angle) {
        // ignore them for the layout elements
        // Layout's can't rotate
    }

});

/**
 * @class draw2d.shape.layout.HorizontalLayout
 * The HorizontalLayout class arranges the layout elements in a horizontal sequence,
 * left to right, with optional gaps between the elements.
 *
 * During the execution of the setDimension() method, the minimum width of the container is calculated
 * by accumulating the minimum sizes of the elements, including stroke, gaps and padding.
 *
 *
 * See the example below with and without gap and border settings
 *
 *
 *     @example preview small frame
 *
 *     // first container without any gap and a border of the parent
 *     // container
 *     var label1 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *     var label2 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *     var label3 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *     var container1 = new draw2d.shape.layout.HorizontalLayout();
 *
 *     container1.add(label1);
 *     container1.add(label2);
 *     container1.add(label3);
 *     container1.setGap(10);
 *     container1.setStroke(2);
 *     canvas.add(container1,50,10);
 *
 *     // second container without any gab or border
 *     //
 *     var label11 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *     var label12 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *     var label13 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *     var container2 = new draw2d.shape.layout.HorizontalLayout();
 *
 *     container2.add(label11);
 *     container2.add(label12);
 *     container2.add(label13);
 *
 *     canvas.add(container2,50,90);
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 * @since 2.5.1
 */
draw2d.shape.layout.HorizontalLayout = draw2d.shape.layout.Layout.extend({

    NAME: "draw2d.shape.layout.HorizontalLayout",

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        this.gap = 0;
        var _this = this;
        this.locator = {
            translate: function (figure, diff) {
                figure.setPosition(figure.x + diff.x, figure.y + diff.y);
            },
            relocate: function (index, target) {
                var stroke = _this.getStroke();
                var xPos = stroke; // respect the border of the parent
                var gap = 0;
                for (var i = 0; i < index; i++) {
                    var child = _this.children.get(i).figure;
                    if (child.isVisible()) {
                        xPos += child.getWidth() + gap;
                        gap = _this.gap;
                    }
                }

                target.setPosition(xPos, stroke);
            }
        };

        this._super(
            $.extend({width: 1, height: 1, gap: 0}, attr),
            $.extend({
                /** @attr {Number} gap the gap between the children shapes */
                gap: this.setGap
            }, setter),
            $.extend({
                gap: this.getGap
            }, getter));

    },

    /**
     * @inheritdoc
     */
    add: function (child, locator, index) {
        return this._super(child, this.locator, index);
    },

    /**
     * @method
     * Set the gap width between child components within this layout.
     * This will only affect the space between components, not the space around all the components in the layout.
     *
     * @param {Number} gap The space, in pixels, between items.
     * @since 2.5.1
     */
    setGap: function (gap) {
        this.gap = gap;
        // this forces a relayout of the element
        this.setDimension(1, 1);

        return this;
    },

    /**
     * @method
     * Return the gap between the children shapes
     *
     * @since 5.0.0
     *
     */
    getGap: function () {
        return this.gap;
    },

    /**
     * @inheritdoc
     */
    getMinWidth: function () {
        var width = this.stroke * 2;
        var gap = 0;
        this.children.each(function (i, e) {
            if (e.figure.isVisible()) {
                width += (e.figure.isResizeable() ? e.figure.getMinWidth() : e.figure.getWidth() + gap);
                gap = this.gap;
            }
        }.bind(this));
        return width;
    },

    /**
     * @inheritdoc
     */
    getMinHeight: function () {
        var height = (this.stroke * 2);
        this.children.each(function (i, e) {
            height = Math.max(height, e.figure.isResizeable() ? e.figure.getMinHeight() : e.figure.getHeight());
        });
        return height + this.stroke * 2;
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        this._super(w, h);

        var diff = this.width - this.getMinWidth();
        if (diff > 0) {
            diff = (diff / this.children.getSize()) | 0;
            this.children.each(function (i, e) {
                if (e.figure.isResizeable() === true) {
                    e.figure.setDimension(e.figure.getMinWidth() + diff, e.figure.getHeight());
                }
            });
        }
        else {
            this.children.each(function (i, e) {
                // The layout respect the "resizeable" flag because a layout is a kind of layouter and
                // any kind of autolayouter must respect this flag
                if (e.figure.isResizeable() === true) {
                    // reset the shape to the minimum width/height. see setMinWidth/setMinHeight
                    e.figure.setDimension(1, 1);
                }
            });
        }
    }
});

/**
 * @class draw2d.shape.layout.VerticalLayout
 * The VerticalLayout class arranges the layout elements in a vertical sequence,
 * left to right, with optional gaps between the elements.
 *
 * During the execution of the setDimension() method, the minimum height of the container is calculated
 * by accumulating the minimum sizes of the elements, including stroke, gaps and padding.
 *
 * See the example below with and without gap and border settings
 *
 *
 *     @example preview small frame
 *
 *     // first container without any gap and a border of the parent
 *     // container
 *     var label1 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *     var label2 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *     var label3 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *     var container1 = new draw2d.shape.layout.VerticalLayout();
 *
 *     container1.add(label1);
 *     container1.add(label2);
 *     container1.add(label3);
 *     container1.setGap(10);
 *     container1.setStroke(2);
 *     canvas.add(container1,50,10);
 *
 *     // second container without any gab or border
 *     //
 *     var label11 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *     var label12 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *     var label13 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *     var container2 = new draw2d.shape.layout.VerticalLayout();
 *
 *     container2.add(label11);
 *     container2.add(label12);
 *     container2.add(label13);
 *
 *     canvas.add(container2,150,10);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 */
draw2d.shape.layout.VerticalLayout = draw2d.shape.layout.Layout.extend({

    NAME: "draw2d.shape.layout.VerticalLayout",

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        // some layout parameter
        //
        this.gap = 0;

        // "this" shortcut to avoid $.proxy
        var _this = this;

        this.locator = {
            translate: function (figure, diff) {
                figure.setPosition(figure.x + diff.x, figure.y + diff.y);
            },
            relocate: function (index, target) {
                var stroke = _this.getStroke();
                var yPos = stroke; // respect the border of the shape

                for (var i = 0; i < index; i++) {
                    var child = _this.children.get(i).figure;
                    if (child.isVisible())
                        yPos = yPos + child.getHeight() + _this.gap;
                }

                target.setPosition(stroke, yPos);
            }
        };

        this._super(
            $.extend({width: 10, height: 10}, attr),
            $.extend({
                /** @attr {Number} gap the gap between the children shapes */
                gap: this.setGap
            }, setter),
            $.extend({
                gap: this.getGap
            }, getter));

    },

    /**
     * @inheritdoc
     */
    add: function (child, locator, index) {
        // ignore the parameter "locator" and use the locator for the vertical layout instead

        return this._super(child, this.locator, index);
    },


    /**
     * @method
     * Set the gap width between child components within this layout.
     * This will only affect the space between components, not the space around all the components in the layout.
     *
     * @param {Number} gap The space, in pixels, between items.
     */
    setGap: function (gap) {
        this.gap = gap;
        // this forces a relayout of the element
        this.setDimension(1, 1);
    },

    /**
     * @inheritdoc
     */
    getMinWidth: function () {
        var width = 10;
        this.children.each(function (i, e) {
            if (e.figure.isVisible())
                width = Math.max(width, e.figure.isResizeable() ? e.figure.getMinWidth() : e.figure.getWidth());
        });
        return width + (this.stroke * 2);
    },

    /**
     * @inheritdoc
     */
    getMinHeight: function () {
        var gap = 0;
        var height = 2 * this.stroke;
        this.children.each(function (i, e) {
            if (e.figure.isVisible()) {
                height += ((e.figure.isResizeable() ? e.figure.getMinHeight() : e.figure.getHeight()) + gap);
                // first element is iterated. Now we must add the gap to all next elements
                gap = this.gap;
            }
        }.bind(this));

        return height;
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        this._super(w, h);

        var width = this.width - (2 * this.stroke);
        this.children.each(function (i, e) {
            if (e.figure.isResizeable() && e.figure.isVisible()) {
                e.figure.setDimension(width, e.figure.getHeight());
            }
        });
    }


});

/**
 * @class draw2d.shape.pert.Activity
 *
 * NOT FOR PRODUCTIVE
 *
 * Checkout [Wikipedia PERT][1] for more information.
 *
 * Double click on the Task name or the top middle number to change the value.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     canvas.add( new draw2d.shape.pert.Start(),10,10);
 *     canvas.add( new draw2d.shape.pert.Activity(),80,130);
 *     canvas.add( new draw2d.shape.pert.Activity(),180,50);
 *
 * [1] http://en.wikipedia.org/wiki/Program_Evaluation_and_Review_Technique
 *
 * @extends draw2d.shape.layout.VerticalLayout
 */
draw2d.shape.pert.Activity = draw2d.shape.layout.VerticalLayout.extend({

    NAME: "draw2d.shape.pert.Activity",

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        // shortcut for some callback methods to avoid $.proxy wrapper
        var _this = this;

        // persistence values for the activity
        // will be stored/read in the JSON
        this.mementoValues = {
            duration: null
        };

        // just some color attributes for the rendering/gradient
        this.bgColor = new draw2d.util.Color("#f3f3f3");
        this.lighterBgColor = this.bgColor.lighter(0.2).hash();
        this.darkerBgColor = this.bgColor.darker(0.2).hash();


        this._super($.extend({
            bgColor: this.bgColor,
            stroke: 2,
            radius: 2,
            color: this.darkerBgColor
        }, attr), setter, getter);

        // Compose the top row of the shape
        //
        var top = new draw2d.shape.layout.HorizontalLayout({stroke: 0});


        this.earlyStartLabel = this.createLabel("Early Start").setStroke(0);

        this.durationLabel = new draw2d.shape.basic.Label({
            text: "Duration",
            stroke: 1,
            color: this.darkerBgColor,
            radius: 0,
            bgColor: null,
            padding: 5
        });
        // duration label has a inplaceEditor for the value
        this.durationLabel.installEditor(new draw2d.ui.LabelEditor({
            onCommit: function (value) {
                _this.setDuration(parseFloat(value));
            }
        }));

        this.earlyEndLabel = this.createLabel({text: "Early End", stroke: 0});

        top.add(this.earlyStartLabel);
        top.add(this.durationLabel);
        top.add(this.earlyEndLabel);


        // the middle part of the shape
        // This part contains the ports for the connection
        //
        this.activityLabel = new draw2d.shape.basic.Label({
            text: "Activity Name",
            radius: 0,
            padding: 10,
            color: this.darkerBgColor,
            bgColor: null
        });
        // direct editor for the label
        this.activityLabel.installEditor(new draw2d.ui.LabelInplaceEditor());

        this.inputPort = this.activityLabel.createPort("input");
        this.inputPort.getActivity = function () {
            return _this;
        };
        this.inputPort.onConnect = function () {
            _this.setDuration(_this.mementoValues.duration);
        };
        this.inputPort.onDisconnect = function () {
            _this.setDuration(_this.mementoValues.duration);
        };
        this.inputPort.setValue = function (anyValue) {
            _this.setDuration(_this.mementoValues.duration);
        };

        this.outputPort = this.activityLabel.createPort("output");
        this.outputPort.getActivity = function () {
            return _this;
        };
        this.outputPort.onConnect = function () {
            _this.setDuration(_this.mementoValues.duration);
        };
        this.outputPort.onDisconnect = function () {
            _this.setDuration(_this.mementoValues.duration);
        };


        // the bottom of the activity shape
        //
        var bottom = new draw2d.shape.layout.HorizontalLayout({stroke: 0});


        this.lateStartLabel = this.createLabel("Late Start").setStroke(0);
        this.stackLabel = this.createLabel("Stack");
        this.lateEndLabel = this.createLabel("Late End").setStroke(0);

        bottom.add(this.lateStartLabel);
        bottom.add(this.stackLabel);
        bottom.add(this.lateEndLabel);

        // finally compose the shape with top/middle/bottom in VerticalLayout
        //
        this.add(top);
        this.add(this.activityLabel);
        this.add(bottom);


        // set some good default value for the activity
        //
        this.setDuration(1);
    },

    /**
     * @method
     * Set the duration for the activity. This triggers a complete recalculation of the complete
     * diagram. No further calls are required
     *
     * @param {Number} duration the new Duration for the activity
     */
    setDuration: function (duration) {

        if (this.mementoValues.duration !== duration) {
            // store the new value
            this.mementoValues.duration = duration;

            // update the labels for duration
            this.durationLabel.setText(this.mementoValues.duration);
        }

        // calculate the earlyStart and latestEnd and set the labels
        //
        var start = this.getEarlyStart();

        this.earlyStartLabel.setText(start);
        this.earlyEndLabel.setText(start + this.mementoValues.duration);

        // notify all children that a parent value has been changed
        // Just knock on the inputPort...
        //
        var connections = this.outputPort.getConnections();
        connections.each(function (i, conn) {
            var targetPort = conn.getTarget();
            targetPort.setValue();
        });

        // propagate the lateFinish up to all parent nodes if we are a leaf
        //
        if (connections.getSize() === 0) {
            var lateFinish = parseFloat(this.earlyEndLabel.getText());
            this.setLateFinish(lateFinish);
        }
    },

    getEarlyEnd: function () {
        return this.getEarlyStart() + this.mementoValues.duration;
    },

    getEarlyStart: function () {
        var latestEarlyEnd = 0;

        // retrieve the greatest "earlyStart" from all parent activities
        this.inputPort.getConnections().each(function (i, conn) {
            var parentActivity = conn.getSource().getActivity();
            latestEarlyEnd = Math.max(latestEarlyEnd, parentActivity.getEarlyEnd());
        });

        return latestEarlyEnd;
    },

    setLateFinish: function (value) {
        var lateStart = value - this.mementoValues.duration;

        this.lateEndLabel.setText(value);
        this.lateStartLabel.setText(lateStart);
        this.stackLabel.setText(lateStart - parseFloat(this.earlyStartLabel.getText()));

        var connections = this.inputPort.getConnections();
        connections.each(function (i, conn) {
            var sourcePort = conn.getSource();
            sourcePort.getActivity().setLateFinish(lateStart);
        });
    },

    /**
     * @method
     * help method to create some labels
     *
     * @param {String} txt the label to display
     * @returns {draw2d.shape.basic.Label}
     */
    createLabel: function (txt) {
        var label = new draw2d.shape.basic.Label({text: txt});
        label.setStroke(1);
        label.setColor(this.darkerBgColor);
        label.setRadius(0);
        label.setBackgroundColor(null);
        label.setPadding(5);
        label.setColor(this.bgColor.darker(0.2));
        label.onDoubleClick = function (angle) {/* ignore them for the layout elements*/
        };

        return label;
    },

    /**
     * @inheritdoc
     */
    setBackgroundColor: function (color) {
        this._super(color);

        // calculate the new lighter and darker colors for the gradient
        //
        this.lighterBgColor = this.bgColor.lighter(0.2).hash();
        this.darkerBgColor = this.bgColor.darker(0.2).hash();
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {

        // repaint can be blocked during deserialization and if the shape
        // not part of any canvas.
        //
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }


        attributes = attributes || {};

        if (this.getAlpha() < 0.9) {
            attributes.fill = this.bgColor.hash();
        }
        else {
            attributes.fill = ["90", this.bgColor.hash(), this.lighterBgColor].join("-");
        }


        this._super(attributes);
    }
});

/**
 * @class draw2d.shape.pert.Start
 *
 * NOT FOR PRODUCTIVE
 *
 * Checkout [Wikipedia PERT][1] for more information.
 *
 * Double click on the Task name or the top middle number to change the value.
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     canvas.add( new draw2d.shape.pert.Start(),10,10);
 *     canvas.add( new draw2d.shape.pert.Activity(),80,130);
 *     canvas.add( new draw2d.shape.pert.Activity(),180,50);
 *
 * [1] http://en.wikipedia.org/wiki/Program_Evaluation_and_Review_Technique
 *
 * @extends draw2d.shape.layout.VerticalLayout
 */
draw2d.shape.pert.Start = draw2d.shape.layout.VerticalLayout.extend({

    NAME: "draw2d.shape.pert.Start",

    /**
     * @constructor
     * Create a new instance
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function (attr, setter, getter) {
        // shortcut for some callback methods to avoid $.proxy wrapper
        var _this = this;

        // persistence values for the activity
        // will be stored/read in the JSON
        this.mementoValues = {
            duration: null
        };

        // just some color attributes for the rendering/gradient
        this.bgColor = new draw2d.util.Color("#f3f3f3");
        this.lighterBgColor = this.bgColor.lighter(0.2).hash();
        this.darkerBgColor = this.bgColor.darker(0.2).hash();


        this._super($.extend({
            bgColor: this.bgColor,
            stroke: 2,
            radius: 2,
            color: this.darkerBgColor
        }, attr), setter, getter);

        // Compose the top row of the shape
        //
        var top = new draw2d.shape.layout.HorizontalLayout({stroke: 0});


        this.durationLabel = new draw2d.shape.basic.Label({
            text: "Duration",
            stroke: 1,
            color: this.darkerBgColor,
            radius: 0,
            bgColor: null,
            padding: 5
        });
        // duration label has a inplaceEditor for the value
        this.durationLabel.installEditor(new draw2d.ui.LabelEditor({
            text: "Enter new duration",
            onCommit: function (value) {
                _this.setDuration(parseFloat(value));
            }
        }));

        this.earlyEndLabel = this.createLabel({text: "Early End", stroke: 0});

        top.add(this.durationLabel);
        top.add(this.earlyEndLabel);


        // the middle part of the shape
        // This part contains the ports for the connection
        //
        this.activityLabel = new draw2d.shape.basic.Label({
            text: "Start",
            radius: 0,
            padding: 10,
            color: this.darkerBgColor,
            bgColor: null
        });
        // direct editor for the label
        this.activityLabel.installEditor(new draw2d.ui.LabelInplaceEditor());

        this.outputPort = this.activityLabel.createPort("output");
        this.outputPort.getActivity = function () {
            return _this;
        };
        this.outputPort.onConnect = function () {
            _this.setDuration(_this.mementoValues.duration);
        };
        this.outputPort.onDisconnect = function () {
            _this.setDuration(_this.mementoValues.duration);
        };


        // the bottom of the activity shape
        //
        var bottom = this.createLabel(" ");
        bottom.setPadding(10);
        bottom.setStroke(0);
        this.lateEndLabel = bottom;

        // finally compose the shape with top/middle/bottom in VerticalLayout
        //
        this.add(top);
        this.add(this.activityLabel);
        this.add(bottom);

        // set some good default value for the activity
        //
        this.setDuration(1);
    },

    /**
     * @method
     * Set the duration for the activity. This triggers a complete recalculation of the complete
     * diagram. No further calls are required
     *
     * @param {Number} duration the new Duration for the activity
     */
    setDuration: function (duration) {

        if (this.mementoValues.duration !== duration) {
            // store the new value
            this.mementoValues.duration = duration;

            // update the labels for duration
            this.durationLabel.setText(this.mementoValues.duration);
        }

        this.earlyEndLabel.setText(this.mementoValues.duration);

        // notify all children that a parent value has been changed
        // Just knock on the inputPort...
        //
        var connections = this.outputPort.getConnections();
        connections.each(function (i, conn) {
            var targetPort = conn.getTarget();
            targetPort.setValue();
        });

        // propagate the lateFinish up to all parent nodes if we are a leaf
        //
        if (connections.getSize() === 0) {
            var lateFinish = parseFloat(this.earlyEndLabel.getText());
            this.setLateFinish(lateFinish);
        }
    },

    getEarlyEnd: function () {
        return this.mementoValues.duration;
    },


    setLateFinish: function (value) {
        var lateStart = value - this.mementoValues.duration;

        this.lateEndLabel.setText(value);

    },

    /**
     * @method
     * help method to create some labels
     *
     * @param {String} txt the label to display
     * @returns {draw2d.shape.basic.Label}
     */
    createLabel: function (txt) {
        var label = new draw2d.shape.basic.Label({text: txt});
        label.setStroke(1);
        label.setColor(this.darkerBgColor);
        label.setRadius(0);
        label.setBackgroundColor(null);
        label.setPadding(5);
        label.setColor(this.bgColor.darker(0.2));
        label.onDoubleClick = function (angle) {/* ignore them for the layout elements*/
        };

        return label;
    },

    /**
     * @inheritdoc
     */
    setBackgroundColor: function (color) {
        this._super(color);

        // calculate the new lighter and darker colors for the gradient
        //
        this.lighterBgColor = this.bgColor.lighter(0.2).hash();
        this.darkerBgColor = this.bgColor.darker(0.2).hash();
    },

    /**
     * @inheritdoc
     */
    repaint: function (attributes) {

        // repaint can be blocked during deserialization and if the shape
        // not part of any canvas.
        //
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }


        attributes = attributes || {};

        if (this.getAlpha() < 0.9) {
            attributes.fill = this.bgColor.hash();
        }
        else {
            attributes.fill = ["90", this.bgColor.hash(), this.lighterBgColor].join("-");
        }

        this._super(attributes);
    }
});

/**
 * @class draw2d.shape.state.Start
 *
 * The start node for a state diagram
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     var figure =  new draw2d.shape.state.Start({color:"#3d3d3d"});
 *
 *     canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
draw2d.shape.state.Start = draw2d.shape.basic.Circle.extend({

    NAME: "draw2d.shape.state.Start",

    DEFAULT_COLOR: new draw2d.util.Color("#3369E8"),

    init: function (attr, setter, getter) {
        this._super(attr);

        this.port = this.createPort("output", new draw2d.layout.locator.BottomLocator());
        this.port.setConnectionAnchor(new draw2d.layout.anchor.ShortesPathConnectionAnchor(this.port));

        this.setDimension(50, 50);
        this.setBackgroundColor(this.DEFAULT_COLOR);
        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());

        this.setStroke(0);
        //this.setColor(this.DEFAULT_COLOR.darker());

        var label = new draw2d.shape.basic.Label({text: "START"});
        label.setStroke(0);
        label.setFontColor("#ffffff");
        label.setFontFamily('"Open Sans",sans-serif');
        this.add(label, new draw2d.layout.locator.CenterLocator());
    }
});

/**
 * @class draw2d.shape.state.End
 *
 * The end node for a state diagram
 *
 * See the example:
 *
 *     @example preview small frame
 *     var end   = new draw2d.shape.state.End();

 *     // ...add it to the canvas
 *     canvas.add( end, 230,80);
 *
 * @extends draw2d.shape.basic.Circle
 */
draw2d.shape.state.End = draw2d.shape.basic.Circle.extend({

    NAME: "draw2d.shape.state.End",

    DEFAULT_COLOR: new draw2d.util.Color("#4D90FE"),

    init: function (attr, setter, getter) {
        this.innerCircle = new draw2d.shape.basic.Circle(20);

        this._super(attr);

        this.port = this.createPort("input", new draw2d.layout.locator.TopLocator());
        this.port.setConnectionAnchor(new draw2d.layout.anchor.ShortesPathConnectionAnchor(this.port));

        this.setDimension(50, 50);
        this.setBackgroundColor(this.DEFAULT_COLOR);
        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());

        this.innerCircle.setStroke(2);
        this.innerCircle.setBackgroundColor(null);
        this.add(this.innerCircle, new draw2d.layout.locator.CenterLocator());

        this.setStroke(0);
        //this.setColor(this.DEFAULT_COLOR.darker());
    },

    /**
     * @inheritdoc
     */
    setDimension: function (w, h) {
        this._super(w, h);
        this.innerCircle.setDimension(this.getWidth() - 10, this.getHeight() - 10);
    }
});

/**
 * @class draw2d.shape.state.State
 *
 * a state shape for a state diagram
 *
 *     @example preview small frame
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.state.Start();
 *     var state   = new draw2d.shape.state.State();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( state, 230,180);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.shape.state.Connection({
 *     		source : start.getOutputPort(0),
 *          target : state.getInputPort(0)
 *     });
 *
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 * @extends draw2d.shape.layout.VerticalLayout
 */
draw2d.shape.state.State = draw2d.shape.layout.VerticalLayout.extend({

    NAME: "draw2d.shape.state.State",

    init: function (attr, setter, getter) {
        this._super(attr);

        this.port = this.createPort("hybrid", new draw2d.layout.locator.BottomLocator());
        this.port.setConnectionAnchor(new draw2d.layout.anchor.ChopboxConnectionAnchor(this.port));


        this.setBackgroundColor("#f3f3f3");

        // UI representation
        this.setStroke(1);
        this.setColor("#e0e0e0");
        this.setRadius(5);

        // Compose the top row of the shape
        //
        var top = this.createLabel("State").setStroke(0);
        this.label = top;

        // the middle part of the shape
        // This part contains the ports for the connection
        //
        var center = new draw2d.shape.basic.Rectangle();
        center.getHeight = function () {
            return 1;
        };
        center.setMinWidth(90);
        center.setColor("#e0e0e0");

        // the bottom of the activity shape
        //
        var bottom = new draw2d.shape.basic.Rectangle();
        bottom.setMinHeight(30);
        bottom.setStroke(0);
        bottom.setBackgroundColor(null);

        // finally compose the shape with top/middle/bottom in VerticalLayout
        //
        this.add(top);
        this.add(center);
        this.add(bottom);
    },

    /**
     * @method
     * Set the text to show if the state shape
     *
     * @param {String} text
     */
    setLabel: function (text) {
        this.label.setText(text);
        this.fireEvent("change:label");

        return this;
    },


    /**
     * @method
     * Return the label of the shape
     *
     */
    getLabel: function () {
        return this.label.getText();
    },


    /**
     * @method
     * helper method to create some labels
     *
     * @param {String} txt the label to display
     * @returns {draw2d.shape.basic.Label}
     * @private
     */
    createLabel: function (txt) {
        var label = new draw2d.shape.basic.Label(txt);
        label.setStroke(1);
        label.setColor(this.darkerBgColor);
        label.setRadius(0);
        label.setBackgroundColor(null);
        label.setPadding(5);
        label.setColor(this.bgColor.darker(0.2));
        label.onDoubleClick = function (angle) {/* ignore them for the layout elements*/
        };

        return label;
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        return $.extend(this._super(), {
            label: this.getLabel()
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.label !== "undefined") {
            this.setLabel(memento.label);
        }

    }
});

/**
 * @class draw2d.shape.state.Connection
 *
 * Connection designed for a state diagram with arrow decoration at the
 * target of the connection and a label
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.state.Start();
 *     var end   = new draw2d.shape.state.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,180);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.shape.state.Connection({
 *     	 source : start.getOutputPort(0),
 *       target : end.getInputPort(0)
 *     });
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 *
 * @extends draw2d.Connection
 */
draw2d.shape.state.Connection = draw2d.Connection.extend({

    NAME: "draw2d.shape.state.Connection",

    DEFAULT_COLOR: new draw2d.util.Color("#4D90FE"),

    init: function (attr, setter, getter) {
        this._super($.extend({router: null, stroke: 2}, attr), setter, getter);

        this.setTargetDecorator(new draw2d.decoration.connection.ArrowDecorator(17, 8));


        this.label = new draw2d.shape.basic.Label({text: "label"});
        this.label.setStroke(1);
        this.label.setPadding(2);
        this.label.setBackgroundColor("#f0f0f0");
        this.add(this.label, new draw2d.layout.locator.ParallelMidpointLocator());

    },
    /**
     * @method
     * Set the text to show if the state shape
     *
     * @param {String} text
     */
    setLabel: function (text) {
        this.label.setText(text);

        // hide the label if no text available
        this.label.setVisible(!(text === null || text === ""));
        this.fireEvent("change:label");

        return this;
    },


    /**
     * @method
     * Return the label of the shape
     *
     */
    getLabel: function () {
        return this.label.getText();
    },


    /**
     * @inheritdoc
     */
    getPersistentAttributes: function () {
        return $.extend(this._super(), {
            label: this.getLabel()
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function (memento) {
        this._super(memento);

        if (typeof memento.label !== "undefined") {
            this.setLabel(memento.label);
        }
    }

});

/**
 * @class draw2d.ui.LabelEditor
 * Base class for all draw2d.shape.basic.Label editors. The default implementation is to open
 * a simple javascript prompt dialog.<br>
 * Use LabelInplaceEditor or your own implementation if you need more comfort.
 *
 *     @example preview small frame
 *
 *     var label =  new draw2d.shape.basic.Label({text:"Double Click on me"});
 *
 *     label.installEditor(new draw2d.ui.LabelEditor({
 *        // called after the value has been set to the LabelFigure
 *        onCommit: $.proxy(function(value){
 *            alert("new value set to:"+value);
 *        },this),
 *        // called if the user abort the operation
 *        onCancel: function(){
 *        }
 *     }));
 *
 *     canvas.add(label,50,10);
 *
 *
 * @author Andreas Herz
 */
draw2d.ui.LabelEditor = Class.extend({

    /**
     * @constructor
     * Create an label editor with a dedicated callback listener
     *
     */
    init: function (listener) {

        // register some default listener and override this with the handover one
        this.configuration = $.extend({
            onCommit: function () {
            }, onCancel: function () {
            }, text: "Value"
        }, listener);
    },

    /**
     * @method
     * Trigger the edit of the label text.
     *
     * @param {draw2d.shape.basic.Label} label the label to edit
     */
    start: function (label) {
        var newText = prompt(this.configuration.text, label.getText());
        if (newText) {
            label.setText(newText);
            this.configuration.onCommit(label.getText());
        }
        else {
            this.configuration.onCancel();
        }
    }

});

/**
 * @class draw2d.ui.LabelInplaceEditor
 *
 * Inplace editor for draw2d.shape.base.Label
 *
 *     @example preview small frame
 *
 *     var label =  new draw2d.shape.basic.Label({text:"Double Click on me"});
 *
 *     label.installEditor(new draw2d.ui.LabelInplaceEditor({
 *        // called after the value has been set to the LabelFigure
 *        onCommit: $.proxy(function(value){
 *            alert("new value set to:"+value);
 *        },this),
 *        // called if the user abort the operation
 *        onCancel: function(){
 *        }
 *     }));
 *
 *     canvas.add(label,50,10);
 *
 * @author Andreas Herz
 * @extends draw2d.ui.LabelEditor
 */
draw2d.ui.LabelInplaceEditor = draw2d.ui.LabelEditor.extend({

    /**
     * @constructor
     * @private
     */
    init: function (listener) {
        this._super();

        // register some default listener and override this with the handover one
        this.listener = $.extend({
            onCommit: function () {
            }, onCancel: function () {
            }
        }, listener);
    },

    /**
     * @method
     * Trigger the edit of the label text.
     *
     * @param {draw2d.shape.basic.Label} label the label to edit
     */
    start: function (label) {
        this.label = label;

        this.commitCallback = $.proxy(this.commit, this);

        // commit the editor if the user clicks anywhere in the document
        //
        $("body").bind("click", this.commitCallback);

        // append the input field to the document and register
        // the ENTER and ESC key to commit /cancel the operation
        //
        this.html = $('<input id="inplaceeditor">');
        this.html.val(label.getText());
        this.html.hide();

        $("body").append(this.html);

        this.html.autoResize({animate: false});

        this.html.bind("keyup", $.proxy(function (e) {
            switch (e.which) {
                case 13:
                    this.commit();
                    break;
                case 27:
                    this.cancel();
                    break;
            }
        }, this));

        this.html.bind("blur", this.commitCallback);

        // avoid commit of the operation if we click inside the editor
        //
        this.html.bind("click", function (e) {
            e.stopPropagation();
            e.preventDefault();
        });

        // Position the INPUT and init the autoresize of the element
        //
        var canvas = this.label.getCanvas();
        var bb = this.label.getBoundingBox();

        bb.setPosition(canvas.fromCanvasToDocumentCoordinate(bb.x, bb.y));

        // remove the scroll from the body if we add the canvas directly into the body
        var scrollDiv = canvas.getScrollArea();
        if (scrollDiv.is($("body"))) {
            bb.translate(canvas.getScrollLeft(), canvas.getScrollTop());
        }

        bb.translate(-1, -1);
        bb.resize(2, 2);

        this.html.css({
            position: "absolute",
            "top": bb.y,
            "left": bb.x,
            "min-width": bb.w * (1 / canvas.getZoom()),
            "height": Math.max(25, bb.h * (1 / canvas.getZoom()))
        });
        this.html.fadeIn($.proxy(function () {
            this.html.focus();
        }, this));
    },

    /**
     * @method
     * Transfer the data from the editor into the label.<br>
     * Remove the editor.<br>
     * @private
     */
    commit: function () {
        this.html.unbind("blur", this.commitCallback);
        $("body").unbind("click", this.commitCallback);
        var label = this.html.val();
        this.label.setText(label);
        this.html.fadeOut($.proxy(function () {
            this.html.remove();
            this.html = null;
            this.listener.onCommit(this.label.getText());
        }, this));
    },

    /**
     * @method
     * Transfer the data from the editor into the label.<br>
     * Remove the editor.<br>
     * @private
     */
    cancel: function () {
        this.html.unbind("blur", this.commitCallback);
        $("body").unbind("click", this.commitCallback);
        this.html.fadeOut($.proxy(function () {
            this.html.remove();
            this.html = null;
            this.listener.onCancel();
        }, this));

    }
});

/**
 * @class draw2d.decoration.connection.Decorator
 *
 *
 * @inheritable
 * @author Andreas Herz
 */
draw2d.decoration.connection.Decorator = Class.extend({

    NAME: "draw2d.decoration.connection.Decorator",

    /**
     * @constructor
     */
    init: function (width, height) {

        if (typeof width === "undefined" || width < 1) {
            this.width = 20;
        }
        else {
            this.width = width;
        }

        if (typeof height === "undefined" || height < 1) {
            this.height = 15;
        }
        else {
            this.height = height;
        }

        this.color = new draw2d.util.Color(0, 0, 0);
        this.backgroundColor = new draw2d.util.Color(250, 250, 250);
    },

    /**
     * @method
     * Paint the decoration for a connector. The Connector starts always in
     * [0,0] and ends in [x,0].
     * It is not necessary to consider any rotation of the connection. This will be done by the
     * framework.
     *
     * <pre>
     *                | -Y
     *                |
     *                |
     *  --------------+-----------------------------&gt; +X
     *                |
     *                |
     *                |
     *                V +Y
     *
     *
     * </pre>
     *
     * See in ArrowConnectionDecorator for example implementation.
     * @param {Raphael} paper
     */
    paint: function (paper) {
        // do nothing per default
    },

    /**
     * @method
     * Set the stroke color for the decoration
     *
     * @param {draw2d.util.Color|String} c
     */
    setColor: function (c) {
        this.color = new draw2d.util.Color(c);

        return this;
    },

    /**
     * @method
     * Set the background color for the decoration
     *
     * @param {draw2d.util.Color|String} c
     */
    setBackgroundColor: function (c) {
        this.backgroundColor = new draw2d.util.Color(c);

        return this;
    },

    /**
     * @method
     * Change the dimension of the decoration shape
     *
     * @param {Number} width  The new width of the decoration
     * @param {Number} height The new height of the decoration
     **/
    setDimension: function (width, height) {
        this.width = width;
        this.height = height;

        return this;
    }

});

/**
 * @class draw2d.decoration.connection.ArrowDecorator
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.Connection();
 *
 *     // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *     c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *     // Set the endpoint decorations for the connection
 *     //
 *     c.setSourceDecorator(new draw2d.decoration.connection.ArrowDecorator());
 *     c.setTargetDecorator(new draw2d.decoration.connection.ArrowDecorator());
 *     // Connect the endpoints with the start and end port
 *     //
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extend draw2d.decoration.connection.Decorator
 */
draw2d.decoration.connection.ArrowDecorator = draw2d.decoration.connection.Decorator.extend({

    NAME: "draw2d.decoration.connection.ArrowDecorator",

    /**
     * @constructor
     *
     * @param {Number} [width] the width of the arrow
     * @param {Number} [height] the height of the arrow
     */
    init: function (width, height) {
        this._super(width, height);
    },

    /**
     * Draw a filled arrow decoration.
     * It's not your work to rotate the arrow. The draw2d do this job for you.
     *
     * <pre>
     *                        ---+ [length , width/2]
     *                 -------   |
     * [3,0]   --------          |
     *     +---                  |==========================
     *         --------          |
     *                 -------   |
     *                        ---+ [lenght ,-width/2]
     *
     *</pre>
     * @param {Raphael} paper the raphael paper object for the paint operation
     **/
    paint: function (paper) {
        var st = paper.set();

        st.push(paper.path(["M0 0",
            "L", this.width, " ", -this.height / 2,
            "L", this.width, " ", this.height / 2,
            "L0 0"].join("")));

        st.attr({fill: this.backgroundColor.hash(), stroke: this.color.hash()});

        return st;
    }
});

/**
 * @class draw2d.decoration.connection.DiamondDecorator
 * See the example:
 *
 *     @example preview small frame
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.Connection();
 *
 *     // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *     c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *     // Set the endpoint decorations for the connection
 *     //
 *     c.setSourceDecorator(new draw2d.decoration.connection.DiamondDecorator());
 *     c.setTargetDecorator(new draw2d.decoration.connection.DiamondDecorator());
 *     // Connect the endpoints with the start and end port
 *     //
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extend draw2d.decoration.connection.Decorator
 */
draw2d.decoration.connection.DiamondDecorator = draw2d.decoration.connection.Decorator.extend({

    NAME: "draw2d.decoration.connection.DiamondDecorator",

    /**
     * @constructor
     *
     * @param {Number} [width] the width of the arrow
     * @param {Number} [height] the height of the arrow
     */
    init: function (width, height) {
        this._super(width, height);
    },

    /**
     * Draw a filled diamond decoration.
     *
     * It's not your work to rotate the arrow. The draw2d do this job for you.
     *
     * @param {Raphael} paper the raphael paper object for the paint operation
     **/
    paint: function (paper) {
        var st = paper.set();

        st.push(
            paper.path(["M", this.width / 2, " ", -this.height / 2,  // Go to the top center..
                "L", this.width, " ", 0,               // ...draw line to the right middle
                "L", this.width / 2, " ", this.height / 2,   // ...bottom center...
                "L", 0, " ", 0,               // ...left middle...
                "L", this.width / 2, " ", -this.height / 2,  // and close the path
                "Z"].join(""))
        );

        st.attr({fill: this.backgroundColor.hash(), stroke: this.color.hash()});
        return st;
    }

});

/**
 * @class draw2d.decoration.connection.CircleDecorator
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.Connection();
 *
 *     // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *     c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *     // Set the endpoint decorations for the connection
 *     //
 *     c.setSourceDecorator(new draw2d.decoration.connection.CircleDecorator());
 *     c.setTargetDecorator(new draw2d.decoration.connection.CircleDecorator());
 *     // Connect the endpoints with the start and end port
 *     //
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 * @extend draw2d.decoration.connection.Decorator
 */
draw2d.decoration.connection.CircleDecorator = draw2d.decoration.connection.Decorator.extend({

    NAME: "draw2d.decoration.connection.CircleDecorator",

    /**
     * @constructor
     *
     * @param {Number} [width] the width of the arrow
     * @param {Number} [height] the height of the arrow
     */
    init: function (width, height) {
        this._super(width, height);
    },

    /**
     * Draw a filled circle decoration.
     *
     * @param {Raphael} paper the raphael paper object for the paint operation
     **/
    paint: function (paper) {
        var st = paper.set();

        st.push(paper.circle(0, 0, this.width / 2));
        st.attr({fill: this.backgroundColor.hash(), stroke: this.color.hash()});

        return st;
    }
});

/**
 * @class draw2d.decoration.connection.BarDecorator
 *
 * See the example:
 *
 *     @example preview small frame
 *
 *     // create and add two nodes which contains Ports (In and OUT)
 *     //
 *     var start = new draw2d.shape.node.Start();
 *     var end   = new draw2d.shape.node.End();

 *     // ...add it to the canvas
 *     canvas.add( start, 50,50);
 *     canvas.add( end, 230,80);
 *
 *     // Create a Connection and connect the Start and End node
 *     //
 *     var c = new draw2d.Connection();
 *
 *     // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *     c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *     // Set the endpoint decorations for the connection
 *     //
 *     c.setSourceDecorator(new draw2d.decoration.connection.BarDecorator());
 *     c.setTargetDecorator(new draw2d.decoration.connection.BarDecorator());
 *     // Connect the endpoints with the start and end port
 *     //
 *     c.setSource(start.getOutputPort(0));
 *     c.setTarget(end.getInputPort(0));
 *
 *     // and finally add the connection to the canvas
 *     canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 * @extend draw2d.decoration.connection.Decorator
 */
draw2d.decoration.connection.BarDecorator = draw2d.decoration.connection.Decorator.extend({

    NAME: "draw2d.decoration.connection.BarDecorator",

    /**
     * @constructor
     *
     * @param {Number} [width] the width of the bar
     * @param {Number} [height] the height of the bar
     */
    init: function (width, height) {
        this._super(width, height);
    },

    /**
     * @method
     * Draw a bar decoration.
     *
     *
     * @param {Raphael} paper the raphael paper object for the paint operation
     **/
    paint: function (paper) {
        var st = paper.set();
        var path = ["M", this.width / 2, " ", -this.height / 2];  // Go to the top center..
        path.push("L", this.width / 2, " ", this.height / 2);   // ...bottom center...

        st.push(
            paper.path(path.join(""))
        );
        st.attr({fill: this.backgroundColor.hash(), stroke: this.color.hash()});
        return st;
    }

});

/**
 * @class draw2d.io.Reader
 * Template class for general import of a document into the canvas.
 *
 * @author andreas Herz
 */
draw2d.io.Reader = Class.extend({

    /**
     * @constructor
     * @private
     */
    init: function () {

    },

    /**
     * @method
     *
     * Restore the canvas from a given String.
     *
     * @param {draw2d.Canvas} canvas the canvas to restore
     * @param {Object} document the document to read
     *
     * @return {draw2d.util.ArrayList} the added elements
     * @template
     */
    unmarshal: function (canvas, document) {
        // do nothing. Inherit classes must implement this method
    }

});

/**
 * @class draw2d.io.Writer
 * Serialize the canvas to an external format. This is only a template/interface class.
 * Inherit classes must implement the export format.
 *
 * @author Andreas Herz
 */
draw2d.io.Writer = Class.extend({

    /**
     * @constructor
     * @private
     */
    init: function () {

    },

    /**
     * @method
     * Export the content to the implemented data format. Inherit class implements
     * content specific writer.
     * <br>
     * <br>
     *
     * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
     * The parameter <b>resultCallback</b> is required and new. The method calls
     * the callback instead of return the result.
     *
     * @template
     * @since 2.10.1
     * @param {draw2d.Canvas} canvas
     * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 content of a corresponding file
     * @returns {Object}
     *
     */
    marshal: function (canvas, resultCallback) {
        // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
        // if any application not care about this changes.
        if (typeof resultCallback !== "function") {
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }


        resultCallback("", "");
    },

    /**
     * @method
     * utility method to format a given XML string.
     *
     * @param xml
     * @returns {String}
     */
    formatXml: function (xml) {
        var formatted = '';
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        jQuery.each(xml.split('\r\n'), function (index, node) {
            var indent = 0;
            if (node.match(/.+<\/\w[^>]*>$/)) {
                indent = 0;
            } else if (node.match(/^<\/\w/)) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });

        return formatted;
    }
});

/**
 * @class draw2d.io.svg.Writer
 *
 * Serialize the canvas document into a SVG document.
 *
 *      // Create a SVG writer and convert the canvas into a SVG document.
 *      //
 *      var writer = new draw2d.io.svg.Writer();
 *      writer.marshal(canvas, function(svg){
 *          // insert the svg string into a DIV for preview or post
 *          // it via ajax to the server....
 *          $("#svg").text(svg);
 *      });
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.io.Writer
 */
draw2d.io.svg.Writer = draw2d.io.Writer.extend({

    init: function () {
        this._super();
    },

    /**
     * @method
     * Export the content of the canvas into SVG. The SVG document can be loaded with Inkscape or any other SVG Editor.
     * <br>
     * <br>
     *
     * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
     * The parameter <b>resultCallback</b> is required and new. The method calls
     * the callback instead of return the result.
     *
     *
     * @param {draw2d.Canvas} canvas the canvas to marshal
     * @param {Function} callback the method to call on success. The first argument is the SVG document
     * @param {String} callback.svg  the SVG document
     * @param {String} callback.base64  the SVG document encoded in base64
     */
    marshal: function (canvas, callback) {
        // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
        // if any application not care about this changes.
        if (typeof callback !== "function") {
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }

        var s = canvas.getCurrentSelection();
        canvas.setCurrentSelection(null);
        var svg = canvas.getHtmlContainer().html()
            .replace(/>\s+/g, ">")
            .replace(/\s+</g, "<");
        svg = this.formatXml(svg);
        svg = svg.replace(/<desc>.*<\/desc>/g, "<desc>Create with draw2d JS graph library and RaphaelJS</desc>");

        canvas.setCurrentSelection(s);

        var base64Content = draw2d.util.Base64.encode(svg);
        callback(svg, base64Content);
    }
});
/**
 * @class draw2d.io.png.Writer
 * Convert the canvas document into a PNG Image.
 *
 *     // example how to create a PNG image and set an
 *     // image src attribute.
 *     //
 *     var writer = new draw2d.io.png.Writer();
 *     writer.marshal(canvas, function(png){
 *         $("#preview").attr("src",png);
 *     });
 *
 * @author Andreas Herz
 * @extends draw2d.io.Writer
 */
draw2d.io.png.Writer = draw2d.io.Writer.extend({

    init: function () {
        this._super();
    },

    /**
     * @method
     * Export the content to a PNG image. The result can be set as <b>src="...."</b> because
     * the result is encoded as data source url <b>data:image/png;base64....</b>
     * <br>
     * <br>
     *
     * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
     * The parameter <b>resultCallback</b> is required and new. The method calls
     * the callback instead of return the result.
     *
     * @param {draw2d.Canvas} canvas
     * @param {Function} resultCallback the method to call on success. The first argument is the dataUrl, the second is the base64 formated png image
     * @param {String} resultCallback.img  The image as data source url <b>data:image/png;base64....</b>
     * @param {String} resultCallback.base64  the image encoded in base64
     * @param {draw2d.geo.Rectangle} cropBoundingBox optional cropping/clipping bounding box
     */
    marshal: function (canvas, resultCallback, cropBoundingBox) {
        // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
        // if any application not care about this changes.
        if (typeof resultCallback !== "function") {
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }

        canvas.hideDecoration();

        var svg = canvas.getHtmlContainer().html().replace(/>\s+/g, ">").replace(/\s+</g, "<");

        // add missing namespace for images in SVG
        //
        svg = svg.replace("<svg ", "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" ");

        // required for IE9 support.
        // The following table contains ready-to-use conditions to detec IE Browser versions
        //
        // IE versions     Condition to check for
        // ------------------------------------------------------------
        // 10 or older     document.all
        // 9 or older      document.all && !window.atob
        // 8 or older      document.all && !document.addEventListener
        // 7 or older      document.all && !document.querySelector
        // 6 or older      document.all && !window.XMLHttpRequest
        // 5.x             document.all && !document.compatMode
        if (document.all) {
            svg = svg.replace(/xmlns=\"http:\/\/www\.w3\.org\/2000\/svg\"/, '');
        }

        canvasDomNode = $('<canvas id="canvas_png_export_for_draw2d" style="display:none"></canvas>');
        $('body').append(canvasDomNode);
        fullSizeCanvas = $("#canvas_png_export_for_draw2d")[0];
        fullSizeCanvas.width = canvas.initialWidth;
        fullSizeCanvas.height = canvas.initialHeight;

        canvg("canvas_png_export_for_draw2d", svg, {
            ignoreMouse: true,
            ignoreAnimation: true,
            renderCallback: function () {
                try {
                    canvas.showDecoration();

                    if (typeof cropBoundingBox !== "undefined") {
                        var sourceX = cropBoundingBox.x;
                        var sourceY = cropBoundingBox.y;
                        var sourceWidth = cropBoundingBox.w;
                        var sourceHeight = cropBoundingBox.h;

                        croppedCanvas = document.createElement('canvas');
                        croppedCanvas.width = sourceWidth;
                        croppedCanvas.height = sourceHeight;

                        croppedCanvas.getContext("2d").drawImage(fullSizeCanvas, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);

                        var dataUrl = croppedCanvas.toDataURL("image/png");
                        var base64Image = dataUrl.replace("data:image/png;base64,", "");
                        resultCallback(dataUrl, base64Image);
                    }
                    else {
                        var img = fullSizeCanvas.toDataURL("image/png");
                        resultCallback(img, img.replace("data:image/png;base64,", ""));
                    }
                }
                finally {
                    canvasDomNode.remove();
                }
            }
        });
    }
});

/**
 * @class draw2d.io.xml.Writer
 *
 * @author David
 * @extends draw2d.io.Writer
 */
draw2d.io.xml.Writer = draw2d.io.Writer.extend({

    init: function () {
        this._super();
    },

    /**
     * @method
     * Export the content to the implemented data format. Inherit class implements
     * content specific writer.
     * <br>
     * <br>
     *
     * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
     * The parameter <b>resultCallback</b> is required and new. The method calls
     * the callback instead of return the result.
     *
     * @param {draw2d.Canvas} canvas
     * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 representation of the file content
     * @param {Object} resultCallback.json  the canvas document as JSON object
     * @param {String} resultCallback.base64  the canvas document as base encoded JSON
     */
    marshal: function (canvas, resultCallback) {
        // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
        // if any application not care about this changes.
        if (typeof resultCallback !== "function") {
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }

        var header = '<?xml version="1.0" encoding="UTF-8"?>';

        var DEF_START = '<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" '+
                        'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" '+
                        'xmlns:xsd="http://www.w3.org/2001/XMLSchema" '+
                        'xmlns:activiti="http://activiti.org/bpmn" '+
                        'xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" '+
                        'xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" '+
                        'xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" '+
                        'xmlns:xs="http://www.w3.org/2001/XMLSchema" '+
                        'typeLanguage="http://www.w3.org/2001/XMLSchema" '+
                        'expressionLanguage="http://www.w3.org/1999/XPath" '+
                        'targetNamespace="http://www.activiti.org/test" '+
                        'id="Definitions_1" '+
                        'exporter="org.eclipse.bpmn2.modeler.core" '+
                        'exporterVersion="1.2.4.Final-v20160330-1625-B110">';
        var DEF_END = '</definitions>';

        var PROCESS_START = '<process id="BPMN_'+canvas.userData.id+'" name="'+canvas.userData.name+'" isExecutable="true">';
        var PROCESS_END = '</process>';

        var DIAGRAM_START = '<bpmndi:BPMNDiagram id="BPMNDiagram_'+canvas.userData.id+'">' +
            '<bpmndi:BPMNPlane bpmnElement="'+canvas.userData.id+'" id="BPMNPlane_'+canvas.userData.id+'">';
        var DIAGRAM_END = '</bpmndi:BPMNPlane>'+
            '</bpmndi:BPMNDiagram>';



        var process = new Array();
        var diagram = new Array();

        canvas.getFigures().each(function (i, figure) {
            process.push(figure.toProcessElement());
            diagram.push(figure.toDiagramElement());
        });

        canvas.getLines().each(function (i, element) {
            process.push(element.toProcessElement());
            diagram.push(element.toDiagramElement());
        });

        var writer = new draw2d.io.Writer();
        var content = header + DEF_START + PROCESS_START +
                        XML.toXML(process) + PROCESS_END +
                        DIAGRAM_START + XML.toXML(diagram) + DIAGRAM_END + DEF_END;
        var document = writer.formatXml(content);

        resultCallback(canvas, document);
    }
});


/**
 * @class draw2d.io.json.Writer
 * Serialize the canvas document into a JSON object which can be read from the corresponding
 * {@link draw2d.io.json.Reader}.
 *
 *      // Create a JSON writer and convert it into a JSON-String representation.
 *      //
 *      var writer = new draw2d.io.json.Writer();
 *      writer.marshal(canvas, function(json){
 *         // convert the json object into string representation
 *         var jsonTxt = JSON.stringify(json,null,2);
 *
 *         // insert the json string into a DIV for preview or post
 *         // it via ajax to the server....
 *         $("#json").text(jsonTxt);
 *
 *      });
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.io.Writer
 */
draw2d.io.json.Writer = draw2d.io.Writer.extend({

    init: function () {
        this._super();
    },

    /**
     * @method
     * Export the content to the implemented data format. Inherit class implements
     * content specific writer.
     * <br>
     * <br>
     *
     * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
     * The parameter <b>resultCallback</b> is required and new. The method calls
     * the callback instead of return the result.
     *
     * @param {draw2d.Canvas} canvas
     * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 representation of the file content
     * @param {Object} resultCallback.json  the canvas document as JSON object
     * @param {String} resultCallback.base64  the canvas document as base encoded JSON
     */
    marshal: function (canvas, resultCallback) {
        // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
        // if any application not care about this changes.
        if (typeof resultCallback !== "function") {
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }

        var obj = {};
        var result = [];

        canvas.getFigures().each(function (i, figure) {
            result.push(figure.getPersistentAttributes());
        });

        canvas.getLines().each(function (i, element) {
            result.push(element.getPersistentAttributes());
        });

        obj['canvas'] = result;
        obj['userData'] = canvas['userData'];

        var base64Content = draw2d.util.Base64.encode(JSON.stringify(obj, null, 2));

        resultCallback(obj, base64Content);
    }
});

/**
 * @class draw2d.io.json.Reader
 * Read a JSON data and import them into the canvas. The JSON must be generated with the
 * {@link draw2d.io.json.Writer}.
 *
 *      // Load a standard draw2d JSON object into the canvas
 *      //
 *      var jsonDocument =
 *          [
 *           {
 *              "type": "draw2d.shape.basic.Oval",
 *              "id": "5b4c74b0-96d1-1aa3-7eca-bbeaed5fffd7",
 *              "x": 237,
 *              "y": 236,
 *              "width": 93,
 *              "height": 38
 *            },
 *            {
 *              "type": "draw2d.shape.basic.Rectangle",
 *              "id": "354fa3b9-a834-0221-2009-abc2d6bd852a",
 *              "x": 225,
 *              "y": 97,
 *              "width": 201,
 *              "height": 82,
 *              "radius": 2
 *            }
 *          ];
 *      // unmarshal the JSON document into the canvas
 *      // (load)
 *      var reader = new draw2d.io.json.Reader();
 *      reader.unmarshal(canvas, jsonDocument);
 *
 *
 * @extends draw2d.io.Reader
 */
draw2d.io.json.Reader = draw2d.io.Reader.extend({

    NAME: "draw2d.io.json.Reader",

    init: function () {
        this._super();
    },

    /**
     * @method
     *
     * Restore the canvas from a given JSON object.
     *
     * @param {draw2d.Canvas} canvas the canvas to restore
     * @param {Object} document the json object to load.
     */
    unmarshal: function (canvas, json) {
        var result = new draw2d.util.ArrayList();

        if (typeof json === "string") {
            json = JSON.parse(json);
        }

        var node = null;
        $.each(json, $.proxy(function (i, element) {
            try {
                var o = eval("new " + element.type + "()");
                var source = null;
                var target = null;
                for (i in element) {
                    var val = element[i];
                    if (i === "source") {
                        node = canvas.getFigure(val.node);
                        if (node === null) {
                            throw "Source figure with id '" + val.node + "' not found";
                        }
                        source = node.getPort(val.port);
                        if (source === null) {
                            throw "Unable to find source port '" + val.port + "' at figure '" + val.node + "' to unmarschal '" + element.type + "'";
                        }
                    }
                    else if (i === "target") {
                        node = canvas.getFigure(val.node);
                        if (node === null) {
                            throw "Target figure with id '" + val.node + "' not found";
                        }
                        target = node.getPort(val.port);
                        if (target === null) {
                            throw "Unable to find target port '" + val.port + "' at figure '" + val.node + "' to unmarschal '" + element.type + "'";
                        }
                    }
                }
                if (source !== null && target !== null) {
                    o.setSource(source);
                    o.setTarget(target);
                }
                o.setPersistentAttributes(element);
                canvas.add(o);
                result.add(o);
            }
            catch (exc) {
                debug.error(element, "Unable to instantiate figure type '" + element.type + "' with id '" + element.id + "' during unmarshal by " + this.NAME + ". Skipping figure..");
                debug.error(exc);
                debug.warn(element);
            }
        }, this));

        // restore group assignment
        //
        $.each(json, $.proxy(function (i, element) {
            if (typeof element.composite !== "undefined") {
                var figure = canvas.getFigure(element.id);
                if (figure === null) {
                    figure = canvas.getLine(element.id);
                }
                var group = canvas.getFigure(element.composite);
                group.assignFigure(figure);
            }
        }, this));

        // recalculate all crossings and repaint the connections with
        // possible crossing decoration
        canvas.calculateConnectionIntersection();
        canvas.getLines().each(function (i, line) {
            line.svgPathString = null;
            line.repaint();
        });
        canvas.linesToRepaintAfterDragDrop = canvas.getLines().clone();

        canvas.showDecoration();

        return result;
    }
});

/**
 * @class draw2d.storage.FileStorage
 *
 * <b>BETA: changes can happen without notice</b>
 * <br>
 * <br>
 * FileStorage is an file storage abstraction library for Draw2D. It allows you to easily
 * read and write files to any supported file storage backends with a simple an consistent
 * API. FileStorage also supports storing metadata if the storage backend supports it.
 *
 * There are a number of different ways to store your files when you're building an application
 * with Draw2D. There's the local file system of the server, Databases and of course there are
 * cloud-based CDN solutions such as Google Drive, Amazon S3 and many more.
 *
 * From application point of view, it's not optimal to deeply bind your implementation to any single
 * storage backend, as there might be a need to be able to change that later. For example, you might
 * first use a local filesystem when you start developing but the change to a more advanced solution
 * when the application matures. This is when FileStorage becomes handy. Using the simple API of
 * FileStorage you are able to change the storage backend without needing to change the code using it.
 *
 *
 */
draw2d.storage.FileStorage = Class.extend({
    NAME: "draw2d.storage.FileStorage",

    /**
     * @constructor
     *
     */
    init: function () {
    },

    /**
     * @method
     *
     * @param {String} filenameFilter the file picker set a file name filter with the given pattern. Only files which contains the given string will be loaded
     * @param {Function} successCallback callback method if the user select a file and the content is loaded
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    pickFileAndLoad: function (filenameFilter, successCallback, errorCallback) {
    },


    /**
     * @method
     * Request a filename for a new file. The application can use this platform depending
     * filename selector before the saveFile function is called.
     *
     * @since 4.2.0
     */
    promptForFilename: function (successCallback, abortCallback) {
        var fileName = prompt(draw2d.Configuration.i18n.dialog.filenamePrompt);
        if (!fileName) {
            if (abortCallback) {
                abortCallback();
            }
        }
        else {
            successCallback(fileName);
        }
    },

    /**
     * @method
     * Save a file to the google drive bakcend. Either <b>file</b> is a string or a fileHandle.<br>
     * If it is a fileHnadle a <b>updateFile</b> is called.
     *
     * @param {String} fileName the filename of the file
     * @param {String} content the content of the file base64 decoded
     * @param {boolean} contentIsBase64 indicates if the provided content base64 encoded
     * @param {Function} successCallback callback method if the save operation finished
     * @param {Function} errorCallback method to call if any error happens
     * @since 4.0.0
     */
    saveFile: function (fileName, content, contentIsBase64, base64Thumbnail, successCallback, errorCallback) {
    },

    /**
     * @method
     * Save a already loaded file.
     *
     *
     * @param {Object} fileHandle the file handle of the pickFileAndLoad method
     * @param {String} content the file content as base64 coded content
     * @param {boolean} contentIsBase64 indicates if the provided content base64 encoded
     * @param {Function} successCallback the callback method if the file has been saved successfully.
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    updateFile: function (fileHandle, content, contentIsBase64, successCallback, errorCallback) {
    },

    /**
     * @method
     * Save a new file in the storage provider.
     *
     *
     * @param {String} fileName the file name if the new file
     * @param {String} content the content of the file as base64 encoded
     * @param {boolean} contentIsBase64 indicates if the provided content base64 encoded
     * @param {Function} successCallback the callback method after a successful save operation
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    insertFile: function (fileName, content, contentIsBase64, successCallback, errorCallback) {
    }
});
/**
 * <b>BETA: changes can happen without notice</b>
 * <br>
 * <br>
 * Applications that use this interface must abide by all existing Terms of Service of the Google Drive API.<br>
 * Most importantly, you must correctly identify yourself in your requests. Please read the documentation below before
 * you send any "getting started" questions or any bug reports<br>
 *
 * https://developers.google.com/picker/docs/
 *
 *
 * Example usage of the google drive and auth libs. Please note that I didn't use a parallel loading
 * mechanism for the google dependencies. I did this just to simplify the example code.<br>
 *
 *        var app=null;
 *
 *        // call this after the DOM onLoad
 *        //
 *        function initApp(){
 *              // configure the google drive FilePicker API
 *              //
 *              draw2d.storage.GoogleDrive.developerKey = <YOUR_GOOGLE_DEVELOPER_KEY>;
 *              draw2d.storage.GoogleDrive.clientId     = <YOUR_GOOGLE_CIENT_ID>;
 *
 *              // load all dependencies for the google drive api.
 *              // TODO: switch to parallel loading of scripts .. this is just a hack
 *              //
 *              gapi.load('auth', {'callback': function(){
 *                     gapi.load('picker', {'callback': function(){
 *                         gapi.client.load('drive', 'v2', function(){
 *
 *                             // all google libs loaded well. you can now init the application.
 *                             //
 *                             app  = new example.Application();
 *                         });
 *                     }});
 *                  }
 *              });
 *        }
 *
 * @author Andreas Herz
 * @extends draw2d.storage.FileStorage
 */
/**
 * @class draw2d.storage.LocalFileStorage
 *
 * <b>BETA: changes can happen without notice</b>
 * <br>
 * <br>
 * Storage provider for the HTML5 FileAPI.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.storage.FileStorage
 */
draw2d.storage.LocalFileStorage = draw2d.storage.FileStorage.extend({
    NAME: "draw2d.storage.LocalFileStorage",

    /**
     * @constructor
     *
     */
    init: function () {
        this._super();

        this.initDone = false;
        // Check for the various File API support.
        if (window.File && window.FileReader && window.FileList && window.Blob) {
            // Great success! All the File APIs are supported.
        } else {
            alert('The File APIs are not fully supported in this browser.');
            return;
        }

        this.initDone = true;

    },

    /**
     * @method
     *
     * Open the file picker and load the selected file.<br>
     *
     * Example usage:
     *
     *      this.openButton.on("click",$.proxy(function(){
     *         this.filePicker.pickFileAndLoad($.proxy(function(file, fileData){
     *            // save the fileHandle for further save operations
     *            this.file = file;
     *
     *            // cleanup the canvas
     *            this.canvas.clear();
     *
     *            // load the JSON into the canvas
     *            var reader = new draw2d.io.json.Reader();
     *            reader.unmarshal(canvas, JSON.parse(fileData));
     *        },this));
     *     },this));
     *
     * @param {String} filenameFilter the file picker set a file name filter with the given pattern. Only files which contains the given string will be loaded
     * @param {Function} successCallback callback method if the user select a file and the content is loaded
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    pickFileAndLoad: function (filenameFilter, successCallback, errorCallback) {
        // #modal-background
        var modalBackgroundCSS = {
            "display": "block",
            "position": "fixed",
            "top": 0,
            "left": 0,
            "width": "100%",
            "height": "100%",
            "background-color": "white",
            "opacity": .50,
            "-webkit-opacity": .5,
            "-moz-opacity": .5,
            "filter": "alpha(opacity=50)",
            "z-index": 1000
        };

        var modelContentCSS = {
            "background-color": "white",
            "border-radius": "10px",
            "-webkit-border-radius": "10px",
            "-moz-border-radius": "10px",
            "box-shadow": "0 0 20px 0 #222",
            "-webkit-box-shadow": "0 0 20px 0 #222",
            "-moz-box-shadow": " 0 20px 0 #222",
            "display": "block",
            "height": "240px",
            "left": "50%",
            "margin": "-120px 0 0 -160px",
            "padding": "10px",
            "position": "absolute",
            "top": "50%",
            "width": "320px",
            "z-index": "1000"
        };


        $("body").append($('<div id="modal-background"></div>' +
            '<div id="modal-content">' +
            '    <input type="file" id="storage_files" name="files"  />' +
            '</div>'));

        // open a dialog as modal div above the document body
        //
        $("#modal-background").css(modalBackgroundCSS);
        $("#modal-content").css(modelContentCSS);

        $("#modal-background, #modal-close").click(function () {
            $("#modal-background, #modal-content").remove();
        });

        $('#storage_files').on('change', function (event) {
            $("#modal-background, #modal-content").remove();
            var f = event.target.files[0]; // FileList object
            f.title = f.name;
            var reader = new FileReader();

            // Closure to capture the file information.
            reader.onload = function (e) {
                // Render thumbnail.
                successCallback(f, e.target.result);
            };
            // Read in the image file as a data URL.
            reader.readAsText(f);
        });
    },


    /**
     * @method
     * Save a file to the google drive back end. Either <b>file</b> is a string or a fileHandle.<br>
     * If it is a fileHnadle a <b>updateFile</b> is called.
     *
     * @param {String} fileName the filename of the file
     * @param {String} content the content of the file base64 decoded
     * @param {String} contentIsBase64 indicates if the content already base64 encoded
     * @param {Function} successCallback callback method if the save operation finished
     * @since 4.0.0
     */
    saveFile: function (fileName, content, contentIsBase64, successCallback) {
        var blob = new Blob([content]);
        saveAs(blob, fileName);
        successCallback({title: fileName});
    },

    /**
     * @method
     * Save a already loaded file.
     *
     *
     * @param {Object} fileHandle the file handle of the pickFileAndLoad method
     * @param {String} content the file content
     * @param {String} contentIsBase64 indicates if the content already base64 encoded
     * @param {Function} successCallback the callback method if the file has been saved successfully.
     *
     * @since 4.0.0
     */
    updateFile: function (fileHandle, content, contentIsBase64, successCallback) {
        this.saveFile(fileHandle.title, content, contentIsBase64, successCallback);
    },

    /**
     * @method
     * Save a new file in the storage provider.
     *
     *
     * @param {String} fileName the file name if the new file
     * @param {String} content the content of the file
     * @param {String} [contentIsBase64] idicates if the content already base64 encoded
     * @param {Function} successCallback the callback method after a successful save operation
     *
     * @since 4.0.0
     */
    insertFile: function (fileName, content, contentIsBase64, successCallback) {
        this.saveFile(fileName, content, contentIsBase64, successCallback);
    }
});

/***/ }),
/* 40 */
/***/ (function(module, exports) {

/* 
 * Simple JavaScript Inheritance 
 * By John Resig http://ejohn.org/ 
 * MIT Licensed. 
 * 
 ****************************************************** 
 * Example Usage 
 ****************************************************** 
 var Person = Class.extend({ 
  init: function(isDancing){ 
    this.dancing = isDancing; 
  }, 
  dance: function(){ 
    return this.dancing; 
  } 
}); 

var Ninja = Person.extend({ 
  init: function(){ 
    this._super( false ); 
  }, 
  dance: function(){ 
    // Call the inherited version of dance() 
    return this._super(); 
  }, 
  swingSword: function(){ 
    return true; 
  } 
}); 

var p = new Person(true); 
p.dance(); // => true 

var n = new Ninja(); 
n.dance(); // => false 
n.swingSword(); // => true 

// Should all be true 
p instanceof Person && p instanceof Class && 
n instanceof Ninja && n instanceof Person && n instanceof Class 

 ****************************************************** 
 */ 
  
// Inspired by base2 and Prototype 
(function(){ 
  var fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/; 

  // The base Class implementation (does nothing) 
  this.Class = function(){}; 
  

  // Create a new Class that inherits from this class 
  Class.extend = function(prop) { 
    var _super = this.prototype; 
    
    // Instantiate a base class (but only create the instance, 
    // don't run the init constructor) 
    initializing = true; 
    var prototype = new this(); 
    initializing = false; 
    
     
    // Copy the properties over onto the new prototype 
    for (var name in prop) { 
      // Check if we're overwriting an existing function 
      prototype[name] = typeof prop[name] == "function" && 
        typeof _super[name] == "function" && fnTest.test(prop[name]) ? 
        (function(name, fn){ 
          return function() { 
            var tmp = this._super; 
            
            // Add a new ._super() method that is the same method 
            // but on the super-class 
            this._super = _super[name]; 
            
            // The method only need to be bound temporarily, so we 
            // remove it when we're done executing 
            var ret = fn.apply(this, arguments);        
            this._super = tmp; 
            
            return ret; 
          }; 
        })(name, prop[name]) : 
        prop[name]; 
    } 
    
    // The dummy class constructor 
    function Class() { 
      // All construction is actually done in the init method 
      if ( !initializing && this.init ) 
        this.init.apply(this, arguments); 
    } 
    
    // Populate our constructed prototype object 
    Class.prototype = prototype; 
    
    // Enforce the constructor to be what we expect 
    Class.prototype.constructor = Class; 

    // And make this class extendable 
    Class.extend = arguments.callee; 
    
    // EXTENSION BY Draw2D.org to inject methods into an existing class to provide plugins or 
    // bugfixes for further releases 
    // 
    Class.inject = function (prop) { 
        var proto = this.prototype; 
        var parent = {}; 
        for (var name in prop) { 
            if (typeof (prop[name]) == "function" && typeof (proto[name]) == "function" && fnTest.test(prop[name])) { 
                parent[name] = proto[name]; 
                proto[name] = (function (name, fn) { 
                    return function () { 
                        var tmp = this.parent; 
                        this.parent = parent[name]; 
                        var ret = fn.apply(this, arguments); 
                        this.parent = tmp; 
                        return ret; 
                    }; 
                })(name, prop[name]); 
            } else { 
                proto[name] = prop[name]; 
            } 
        } 
    }; 
     
    return Class; 
  }; 
})();
 
 

/***/ }),
/* 41 */
/***/ (function(module, exports) {

/*
 * ==============================================================================
 * IMPORTANT NOTE: 
 * This file is patched by a.herz.
 * The original code didn't work together with raphaelJS and stroke.dasharray.
 * Please search for " PATCHED BY FREEGROUP" to find all patches.
 * ==============================================================================
 * 
 *
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed 
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
    // canvg(target, s)
    // empty parameters: replace all 'svg' elements on page with 'canvas' elements
    // target: canvas element or the id of a canvas element
    // s: svg string, url to svg file, or xml document
    // opts: optional hash of options
    //       ignoreMouse: true => ignore mouse events
    //       ignoreAnimation: true => ignore animations
    //       ignoreDimensions: true => does not try to resize canvas
    //       ignoreClear: true => does not clear canvas
    //       offsetX: int => draws at a x offset
    //       offsetY: int => draws at a y offset
    //       scaleWidth: int => scales horizontally to width
    //       scaleHeight: int => scales vertically to height
    //       renderCallback: function => will call the function after the first render is completed
    //       forceRedraw: function => will call the function on every frame, if it returns true, will redraw
    this.canvg = function (target, s, opts) {
        // no parameters
        if (target == null && s == null && opts == null) {
            var svgTags = document.querySelectorAll('svg');
            for (var i=0; i<svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML);
            }
            return;
        }
    
        if (typeof target == 'string') {
            target = document.getElementById(target);
        }
        
        // store class on canvas
        if (target.svg != null) target.svg.stop();
        var svg = build(opts || {});
        // on i.e. 8 for flash canvas, we can't assign the property so check for it
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;
        
        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined') {
            // load from xml doc
            svg.loadXmlDoc(ctx, s);
        }
        else if (s.substr(0,1) == '<') {
            // load from xml string
            svg.loadXml(ctx, s);
        }
        else {
            // load from url
            svg.load(ctx, s);
        }
    };

    function build(opts) {
        var svg = { opts: opts };
        
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        
        svg.log = function(msg) {};
        if (svg.opts['log'] == true && typeof(console) != 'undefined') {
            svg.log = function(msg) { console.log(msg); };
        }
        // globals
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId; };
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new (function () {
                this.viewPorts = [];
                this.Clear = function() { this.viewPorts = []; };
                this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); };
                this.RemoveCurrent = function() { this.viewPorts.pop(); };
                this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; };
                this.width = function() { return this.Current().width; };
                this.height = function() { return this.Current().height; };
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') return d;
                    if (d == 'x') return this.width();
                    if (d == 'y') return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);            
                }
            });
        };
        svg.init();
        
        // images loaded
        svg.ImagesLoaded = function() { 
            for (var i=0; i<svg.Images.length; i++) {
                if (!svg.Images[i].loaded) return false;
            }
            return true;
        };

        // trim
        svg.trim = function(s) { 
            return s.replace(/^\s+|\s+$/g, ''); 
        };
        
        // compress spaces
        svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); };
        
        // ajax
        svg.ajax = function(url) {
            var AJAX;
            if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
            else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
            if(AJAX){
               AJAX.open('GET',url,false);
               AJAX.send(null);
               return AJAX.responseText;
            }
            return null;
        };
        
        // parse xml
        svg.parseXml = function(xml) {
            if (window.DOMParser)
            {
                var parser = new DOMParser();
                return parser.parseFromString(xml, 'text/xml');
            }
            else 
            {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml); 
                return xmlDoc;
            }       
        };
        
        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;
        };
            svg.Property.prototype.getValue = function() {
                return this.value;
            };
        
            svg.Property.prototype.hasValue = function() {
                return (this.value != null && this.value !== '');
            };
                            
            // return the numerical value of the property
            svg.Property.prototype.numValue = function() {
                if (!this.hasValue()) return 0;
                
                var n = parseFloat(this.value);
                if ((this.value + '').match(/%$/)) {
                    n = n / 100.0;
                }
                return n;
            };
            
            svg.Property.prototype.valueOrDefault = function(def) {
                if (this.hasValue()) return this.value;
                return def;
            };
            
            svg.Property.prototype.numValueOrDefault = function(def) {
                if (this.hasValue()) return this.numValue();
                return def;
            };
            
            // color extensions
                // augment the current color value with the opacity
                svg.Property.prototype.addOpacity = function(opacity) {
                    var newValue = this.value;
                    if (opacity != null && opacity != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
                        var color = new RGBColor(this.value);
                        if (color.ok) {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';
                        }
                    }
                    return new svg.Property(this.name, newValue);
                };
            
            // definition extensions
                // get the definition from the definitions table
                svg.Property.prototype.getDefinition = function() {
                    var name = this.value.match(/#([^\)'"]+)/);
                    if (name) { name = name[1]; }
                    if (!name) { name = this.value; }
                    return svg.Definitions[name];
                };
                
                svg.Property.prototype.isUrlDefinition = function() {
                    return this.value.indexOf('url(') == 0
                };
                
                svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
                    var def = this.getDefinition();
                    
                    // gradient
                    if (def != null && def.createGradient) {
                        return def.createGradient(svg.ctx, e, opacityProp);
                    }
                    
                    // pattern
                    if (def != null && def.createPattern) {
                        if (def.getHrefAttribute().hasValue()) {
                            var pt = def.attribute('patternTransform');
                            def = def.getHrefAttribute().getDefinition();
                            if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
                        }
                        return def.createPattern(svg.ctx, e);
                    }
                    
                    return null;
                };
            
            // length extensions
                svg.Property.prototype.getDPI = function(viewPort) {
                    return 96.0; // TODO: compute?
                };
                
                svg.Property.prototype.getEM = function(viewPort) {
                    var em = 12;
                    
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);
                    
                    return em;
                };
                
                svg.Property.prototype.getUnits = function() {
                    var s = this.value+'';
                    return s.replace(/[0-9\.\-]/g,'');
                };
            
                // get the length as pixels
                svg.Property.prototype.toPixels = function(viewPort, processPercent) {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
                    if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
                    if (s.match(/px$/)) return this.numValue();
                    if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
                    if (s.match(/pc$/)) return this.numValue() * 15;
                    if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
                    if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
                    if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
                    if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
                    var n = this.numValue();
                    if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
                    return n;
                };

            // time extensions
                // get the time as milliseconds
                svg.Property.prototype.toMilliseconds = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/s$/)) return this.numValue() * 1000;
                    if (s.match(/ms$/)) return this.numValue();
                    return this.numValue();
                };
            
            // angle extensions
                // get the angle as radians
                svg.Property.prototype.toRadians = function() {
                    if (!this.hasValue()) return 0;
                    var s = this.value+'';
                    if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/)) return this.numValue();
                    return this.numValue() * (Math.PI / 180.0);
                };
        
            // text extensions
                // get the text baseline
                var textBaselineMapping = {
                    'baseline': 'alphabetic',
                    'before-edge': 'top',
                    'text-before-edge': 'top',
                    'middle': 'middle',
                    'central': 'middle',
                    'after-edge': 'bottom',
                    'text-after-edge': 'bottom',
                    'ideographic': 'ideographic',
                    'alphabetic': 'alphabetic',
                    'hanging': 'hanging',
                    'mathematical': 'alphabetic'
                };
                svg.Property.prototype.toTextBaseline = function () {
                    if (!this.hasValue()) return null;
                    return textBaselineMapping[this.value];
                };
                
        // fonts
        svg.Font = new (function() {
            this.Styles = 'normal|italic|oblique|inherit';
            this.Variants = 'normal|small-caps|inherit';
            this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
            
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return { 
                    fontFamily: fontFamily || f.fontFamily, 
                    fontSize: fontSize || f.fontSize, 
                    fontStyle: fontStyle || f.fontStyle, 
                    fontWeight: fontWeight || f.fontWeight, 
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') } 
                } 
            };
            
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false };
                var ff = '';
                for (var i=0; i<d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;  }
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
                    else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
                    else { if (d[i] != 'inherit') ff += d[i]; }
                } if (ff != '') f.fontFamily = ff;
                return f;
            }
        });
        
        // points and paths
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i=0; i<a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        };
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
        };
            svg.Point.prototype.angleTo = function(p) {
                return Math.atan2(p.y - this.y, p.x - this.x);
            };
            
            svg.Point.prototype.applyTransform = function(v) {
                var xp = this.x * v[0] + this.y * v[2] + v[4];
                var yp = this.x * v[1] + this.y * v[3] + v[5];
                this.x = xp;
                this.y = yp;
            };

        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        };
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i=0; i<a.length; i+=2) {
                path.push(new svg.Point(a[i], a[i+1]));
            }
            return path;
        };
        
        // bounding box
        svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            
            this.x = function() { return this.x1; };
            this.y = function() { return this.y1; };
            this.width = function() { return this.x2 - this.x1; };
            this.height = function() { return this.y2 - this.y1; };
            
            this.addPoint = function(x, y) {    
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) this.x1 = x;
                    if (x > this.x2) this.x2 = x;
                }
            
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) this.y1 = y;
                    if (y > this.y2) this.y2 = y;
                }
            };
            this.addX = function(x) { this.addPoint(x, null); };
            this.addY = function(y) { this.addPoint(null, y); };
            
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            };
            
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
            };
            
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                
                for (i=0; i<=1; i++) {
                    var f = function(t) { 
                        return Math.pow(1-t, 3) * p0[i]
                        + 3 * Math.pow(1-t, 2) * t * p1[i]
                        + 3 * (1-t) * Math.pow(t, 2) * p2[i]
                        + Math.pow(t, 3) * p3[i];
                    };
                    
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    
                    if (a == 0) {
                        if (b == 0) continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) this.addX(f(t));
                            if (i == 1) this.addY(f(t));
                        }
                        continue;
                    }
                    
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) this.addX(f(t1));
                        if (i == 1) this.addY(f(t1));
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) this.addX(f(t2));
                        if (i == 1) this.addY(f(t2));
                    }
                }
            };
            
            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            };
            
            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        };
        
        // transforms
        svg.Transform = function(v) {   
            var that = this;
            this.Type = {};
        
            // translate
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);            
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                };
                this.unapply = function(ctx) {
                    ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                };
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            };
            
            // rotate
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                };
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1.0 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                };
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }           
            };
            
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                };
                this.unapply = function(ctx) {
                    ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                };
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }               
            };
            
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                };
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }                   
            };
            
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            };
            this.Type.SkewBase.prototype = new this.Type.matrix;
            
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
            };
            this.Type.skewX.prototype = new this.Type.SkewBase;
            
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
            };
            this.Type.skewY.prototype = new this.Type.SkewBase;
        
            this.transforms = [];
            
            this.apply = function(ctx) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            };
            
            this.unapply = function(ctx) {
                for (var i=this.transforms.length-1; i>=0; i--) {
                    this.transforms[i].unapply(ctx);
                }
            };
            
            this.applyToPoint = function(p) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            };
            
            var data = svg.trim(svg.compressSpaces(v)).replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
            for (var i=0; i<data.length; i++) {
                var type = svg.trim(data[i].split('(')[0]);
                var s = data[i].split('(')[1].replace(')','');
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform);
            }
        };
        
        // aspect ratio
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';                  
    
            // calculate scale
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
            if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }    
            
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {               
                ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
            } 
            else {                  
                // align
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0); 
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0); 
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0); 
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight); 
            }
            
            // scale
            if (align == 'none') ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin); 
            else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);     
            
            // translate
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);          
        };
        
        // elements
        svg.Element = {};
        
        svg.EmptyProperty = new svg.Property('EMPTY', '');
        
        svg.Element.ElementBase = function(node) {  
            this.attributes = {};
            this.styles = {};
            this.children = [];
            
            // get or create attribute
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) return a;
                            
                if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
                return a || svg.EmptyProperty;
            };
            
            this.getHrefAttribute = function() {
                for (var a in this.attributes) { 
                    if (a.match(/:href$/)) { 
                        return this.attributes[a]; 
                    } 
                }
                return svg.EmptyProperty;
            };
            
            // get or create style, crawls up node tree
            this.style = function(name, createIfNotExists) {
                var s = this.styles[name];
                if (s != null) return s;
                
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a; // move up to me to cache
                    return a;
                }
                
                var p = this.parent;
                if (p != null) {
                    var ps = p.style(name);
                    if (ps != null && ps.hasValue()) {
                        return ps;
                    }
                }
                    
                if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
                return s || svg.EmptyProperty;
            };
            
            // base render
            this.render = function(ctx) {
                // don't render display=none
                if (this.style('display').value == 'none') return;
                
                // don't render visibility=hidden
                if (this.style('visibility').value == 'hidden') return;
            
                ctx.save();
                if (this.attribute('mask').hasValue()) { // mask
                    var mask = this.attribute('mask').getDefinition();
                    if (mask != null) mask.apply(ctx, this);
                }
                else if (this.style('filter').hasValue()) { // filter
                    var filter = this.style('filter').getDefinition();
                    if (filter != null) filter.apply(ctx, this);
                }
                else {  
                    this.setContext(ctx);
                    this.renderChildren(ctx);   
                    this.clearContext(ctx);                         
                }
                ctx.restore();
            };
            
            // base set context
            this.setContext = function(ctx) {
                // OVERRIDE ME!
            };
            
            // base clear context
            this.clearContext = function(ctx) {
                // OVERRIDE ME!
            };
            
            // base render children
            this.renderChildren = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            };
            
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) child = svg.CreateElement(childNode);
                child.parent = this;
                this.children.push(child);          
            };
                
            if (node != null && node.nodeType == 1) { //ELEMENT_NODE
                // add children
                for (var i=0; i<node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
                    if (this.captureTextNodes && childNode.nodeType == 3) {
                        var text = childNode.nodeValue || childNode.text || '';
                        if (svg.trim(svg.compressSpaces(text)) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
                        }
                    }
                }
                
                // add attributes
                for (var i=0; i<node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
                }
                                        
                // add tag styles
                var styles = svg.Styles[node.nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name];
                    }
                }                   
                
                // add class styles
                if (this.attribute('class').hasValue()) {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j=0; j<classes.length; j++) {
                        styles = svg.Styles['.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                        styles = svg.Styles[node.nodeName+'.'+classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                    }
                }
                
                // add id styles
                if (this.attribute('id').hasValue()) {
                    var styles = svg.Styles['#' + this.attribute('id').value];
                    if (styles != null) {
                        for (var name in styles) {
                            this.styles[name] = styles[name];
                        }
                    }
                }
                
                // add inline styles
                if (this.attribute('style').hasValue()) {     	
         // Freegroup Patch
         // canvg.js can't handle data:image/gif;base64,123NJABBGFR... data URL's       	
         //           var styles = this.attribute('style').value.split(';');
                    var styles = this.attribute('style').value.split(new RegExp(";(?![^\\(]*\\))"));
         // END PATCH            
                    for (var i=0; i<styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            // FreeGroup Patch
                            // a CSS style can contain more than one ":". e.g. "background-image:data:image/gif;base64,R0lGODlhFAAUAPAAAP///+Dg8CH5);"
                            if (style.length > 2) {
                            	style[1] = style.slice(1).join(':');
                            	style.length = 2;
                            }
                            // end patch
                            
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            // console.log(name+":"+value);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }   

                // add id
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }
            }
        };
        
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.setContext = function(ctx) {
                // fill
                if (this.style('fill').isUrlDefinition()) {
                    var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                    if (fs != null) ctx.fillStyle = fs;
                }
                else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                    if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                if (this.style('fill-opacity').hasValue()) {
                    var fillStyle = new svg.Property('fill', ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style('fill-opacity').value);
                    ctx.fillStyle = fillStyle.value;
                }
                                    
                // stroke
                if (this.style('stroke').isUrlDefinition()) {
                    var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                    if (fs != null) ctx.strokeStyle = fs;
                }
                else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-opacity').hasValue()) {
                    var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity').value);
                    ctx.strokeStyle = strokeStyle.value;
                }
                if (this.style('stroke-width').hasValue()) {
                    var newLineWidth = this.style('stroke-width').toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
                }
                if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
                if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
                    var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                    if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
                    else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
                    else if (typeof(ctx.mozDash ) != 'undefined') { ctx.mozDash  = gaps; }
                    
                    var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                    if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
                    else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
                    else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
                }

                // font
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont( 
                        this.style('font-style').value, 
                        this.style('font-variant').value, 
                        this.style('font-weight').value, 
                        this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', 
                        this.style('font-family').value).toString();
                }
                
                // transform
                if (this.attribute('transform').hasValue()) { 
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx);
                }
                
                // clip
                if (this.style('clip-path').hasValue()) {
                    var clip = this.style('clip-path').getDefinition();
                    if (clip != null) clip.apply(ctx);
                }
                
                // opacity
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }       
        };
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                if (ctx != null) ctx.beginPath();
                return new svg.BoundingBox();
            };
            
            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '') {
                    if (this.attribute('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.attribute('fill-rule').value); }
                    else { ctx.fill(); }
                }
                if (ctx.strokeStyle != '') ctx.stroke();
                
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').isUrlDefinition()) {
                        var marker = this.style('marker-start').getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').isUrlDefinition()) {
                        var marker = this.style('marker-mid').getDefinition();
                        for (var i=1;i<markers.length-1;i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').isUrlDefinition()) {
                        var marker = this.style('marker-end').getDefinition();
                        marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
                    }
                }                   
            };
            
            this.getBoundingBox = function() {
                return this.path();
            };
            
            this.getMarkers = function() {
                return null;
            }
        };
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // svg element
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            };
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                // initial values and defaults
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4; 
                if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
                    ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
                }
            
                this.baseSetContext(ctx);
                
                // create new view port
                if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
                if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
                ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
                
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                
                if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
                if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
                if (typeof(this.root) == 'undefined') {
                    width = this.attribute('width').toPixels('x');
                    height = this.attribute('height').toPixels('y');
                    
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').toPixels('x');
                        y = -this.attribute('refY').toPixels('y');
                    }
                    
                    if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, height);
                        ctx.lineTo(x, height);
                        ctx.closePath();
                        ctx.clip();
                    }
                }
                svg.ViewPort.SetCurrent(width, height); 
                        
                // viewbox
                if (this.attribute('viewBox').hasValue()) {             
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value, 
                                    svg.ViewPort.width(), 
                                    width,
                                    svg.ViewPort.height(),
                                    height,
                                    minX,
                                    minY,
                                    this.attribute('refX').value,
                                    this.attribute('refY').value);
                    
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }               
            }
        };
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

        // rect element
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                rx = Math.min(rx, width / 2.0);
                ry = Math.min(ry, height / 2.0);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        };
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        
        // circle element
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                var r = this.attribute('r').toPixels();
            
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true); 
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
            }
        };
        svg.Element.circle.prototype = new svg.Element.PathElementBase; 

        // ellipse element
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        };
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;            
        
        // line element
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.getPoints = function() {
                return [
                    new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
                    new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
            };
                                
            this.path = function(ctx) {
                var points = this.getPoints();
                
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }
                
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            };
            
            this.getMarkers = function() {
                var points = this.getPoints();  
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]];
            }
        };
        svg.Element.line.prototype = new svg.Element.PathElementBase;       
                
        // polyline element
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i=1; i<this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                return bb;
            };
            
            this.getMarkers = function() {
                var markers = [];
                for (var i=0; i<this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
                }
                markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
                return markers;
            }           
        };
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;               
                
        // polygon element
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        };
        svg.Element.polygon.prototype = new svg.Element.polyline;

        // path element
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
                    
            var d = this.attribute('d').value;
            // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
            d = d.replace(/,/gm,' '); // get rid of all commas
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points
            d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when no comma
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
            d = svg.compressSpaces(d); // compress multiple spaces
            d = svg.trim(d);
            this.PathParser = new (function(d) {
                this.tokens = d.split(' ');
                
                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                };
                                
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                };
                
                this.isCommandOrEnd = function() {
                    if (this.isEnd()) return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                };
                
                this.isRelativeCommand = function() {
                    switch(this.command)
                    {
                        case 'm':
                        case 'l':
                        case 'h':
                        case 'v':
                        case 'c':
                        case 's':
                        case 'q':
                        case 't':
                        case 'a':
                        case 'z':
                            return true;
                            break;
                    }
                    return false;
                };
                            
                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i];
                };
                
                this.getScalar = function() {
                    return parseFloat(this.getToken());
                };
                
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                };
                
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                };
                
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                };
                
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;   
                };
                
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' && 
                        this.previousCommand.toLowerCase() != 's' &&
                        this.previousCommand.toLowerCase() != 'q' && 
                        this.previousCommand.toLowerCase() != 't' ){
                        return this.current;
                    }
                    
                    // reflect point
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);                    
                    return p;
                };
                
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y;
                    }
                    return p;
                };
                
                this.addMarker = function(p, from, priorTo) {
                    // if the last angle isn't filled in because we didn't have this point yet ...
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
                        this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                };
                
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                };
                
                this.getMarkerPoints = function() { return this.points; };
                this.getMarkerAngles = function() {
                    for (var i=0; i<this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j=i+1; j<this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);

            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();

                var bb = new svg.BoundingBox();
                if (ctx != null) ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                    case 'M':
                    case 'm':
                        var p = pp.getAsCurrentPoint();
                        pp.addMarker(p);
                        bb.addPoint(p.x, p.y);
                        if (ctx != null) ctx.moveTo(p.x, p.y);
                        pp.start = pp.current;
                        while (!pp.isCommandOrEnd()) {
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, pp.start);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'L':
                    case 'l':
                        while (!pp.isCommandOrEnd()) {
                            var c = pp.current;
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p, c);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.lineTo(p.x, p.y);
                        }
                        break;
                    case 'H':
                    case 'h':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'V':
                    case 'v':
                        while (!pp.isCommandOrEnd()) {
                            var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                            pp.addMarker(newP, pp.current);
                            pp.current = newP;
                            bb.addPoint(pp.current.x, pp.current.y);
                            if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                        }
                        break;
                    case 'C':
                    case 'c':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'S':
                    case 's':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var p1 = pp.getReflectedControlPoint();
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, p1);
                            bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'Q':
                    case 'q':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getAsControlPoint();
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'T':
                    case 't':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var cntrl = pp.getReflectedControlPoint();
                            pp.control = cntrl;
                            var cp = pp.getAsCurrentPoint();
                            pp.addMarker(cp, cntrl, cntrl);
                            bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                        }
                        break;
                    case 'A':
                    case 'a':
                        while (!pp.isCommandOrEnd()) {
                            var curr = pp.current;
                            var rx = pp.getScalar();
                            var ry = pp.getScalar();
                            var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                            var largeArcFlag = pp.getScalar();
                            var sweepFlag = pp.getScalar();
                            var cp = pp.getAsCurrentPoint();

                            // Conversion from endpoint to center parameterization
                            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                            // x1', y1'
                            var currp = new svg.Point(
                                Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                                -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                            );
                            // adjust radii
                            var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
                            if (l > 1) {
                                rx *= Math.sqrt(l);
                                ry *= Math.sqrt(l);
                            }
                            // cx', cy'
                            var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                                (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
                            );
                            if (isNaN(s)) s = 0;
                            var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                            // cx, cy
                            var centp = new svg.Point(
                                (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                            );
                            // vector magnitude
                            var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); };
                            // ratio between two vectors
                            var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) };
                            // angle between two vectors
                            var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); };
                            // initial angle
                            var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
                            // angle delta
                            var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
                            var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
                            var ad = a(u, v);
                            if (r(u,v) <= -1) ad = Math.PI;
                            if (r(u,v) >= 1) ad = 0;

                            // for markers
                            var dir = 1 - sweepFlag ? 1.0 : -1.0;
                            var ah = a1 + dir * (ad / 2.0);
                            var halfWay = new svg.Point(
                                centp.x + rx * Math.cos(ah),
                                centp.y + ry * Math.sin(ah)
                            );
                            pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                            pp.addMarkerAngle(cp, ah - dir * Math.PI);

                            bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                            if (ctx != null) {
                                var r = rx > ry ? rx : ry;
                                var sx = rx > ry ? 1 : rx / ry;
                                var sy = rx > ry ? ry / rx : 1;

                                ctx.translate(centp.x, centp.y);
                                ctx.rotate(xAxisRotation);
                                ctx.scale(sx, sy);
                                ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                ctx.scale(1/sx, 1/sy);
                                ctx.rotate(-xAxisRotation);
                                ctx.translate(-centp.x, -centp.y);
                            }
                        }
                        break;
                    case 'Z':
                    case 'z':
                        if (ctx != null) ctx.closePath();
                        pp.current = pp.start;
                    }
                }

                return bb;
            };

            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                
                var markers = [];
                for (var i=0; i<points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        };
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        
        // pattern element
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.createPattern = function(ctx, element) {
                var width = this.attribute('width').toPixels('x', true);
                var height = this.attribute('height').toPixels('y', true);
            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                tempSvg.children = this.children;
                
                var c = document.createElement('canvas');
                c.width = width;
                c.height = height;
                var cctx = c.getContext('2d');
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                }
                // render 3x3 grid so when we transform there's no white space on edges
                for (var x=-1; x<=1; x++) {
                    for (var y=-1; y<=1; y++) {
                        cctx.save();
                        cctx.translate(x * c.width, y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore();
                    }
                }
                var pattern = ctx.createPattern(c, 'repeat');
                return pattern;
            }
        };
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        
        // marker element
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                            
                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y);
            }
        };
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        
        // definitions element
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.render = function(ctx) {
                // NOOP
            }
        };
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        
        // base for gradients
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            
            this.stops = [];            
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'stop') this.stops.push(child);
            }   
            
            this.getGradient = function() {
                // OVERRIDE ME!
            };

            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition();
                }
                
                var addParentOpacity = function (color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property('color', color);
                        return p.addOpacity(parentOpacityProp.value).value;
                    }
                    return color;
                };
            
                var g = this.getGradient(ctx, element);
                if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i=0; i<stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                }
                
                if (this.attribute('gradientTransform').hasValue()) {
                    // render as transformed pattern on temporary canvas
                    var rootView = svg.ViewPort.viewPorts[0];
                    
                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    
                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [ rect ];
                    
                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [ group ];
                    
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);        
                    return tempCtx.createPattern(c, 'no-repeat');
                }
                
                return g;               
            }
        };
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        
        // linear gradient element
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = this.gradientUnits == 'objectBoundingBox' ? element.getBoundingBox() : null;
                
                if (!this.attribute('x1').hasValue()
                 && !this.attribute('y1').hasValue()
                 && !this.attribute('x2').hasValue()
                 && !this.attribute('y2').hasValue()) {
                    this.attribute('x1', true).value = 0;
                    this.attribute('y1', true).value = 0;
                    this.attribute('x2', true).value = 1;
                    this.attribute('y2', true).value = 0;
                 }
                
                var x1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x1').numValue() 
                    : this.attribute('x1').toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y1').numValue()
                    : this.attribute('y1').toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('x2').numValue()
                    : this.attribute('x2').toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('y2').numValue()
                    : this.attribute('y2').toPixels('y'));

                if (x1 == x2 && y1 == y2) return null;
                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        };
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        
        // radial gradient element
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                
                if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
                if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
                if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';
                
                var cx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('cx').numValue() 
                    : this.attribute('cx').toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('cy').numValue() 
                    : this.attribute('cy').toPixels('y'));
                
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.x() + bb.width() * this.attribute('fx').numValue() 
                    : this.attribute('fx').toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits == 'objectBoundingBox' 
                    ? bb.y() + bb.height() * this.attribute('fy').numValue() 
                    : this.attribute('fy').toPixels('y'));
                }
                
                var r = (this.gradientUnits == 'objectBoundingBox' 
                    ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
                    : this.attribute('r').toPixels());
                
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        };
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        
        // gradient stop element
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.offset = this.attribute('offset').numValue();
            if (this.offset < 0) this.offset = 0;
            if (this.offset > 1) this.offset = 1;
            
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity').value);
            this.color = stopColor.value;
        };
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        
        // animation base element
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            svg.Animations.push(this);
            
            this.duration = 0.0;
            this.begin = this.attribute('begin').toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
            
            this.getProperty = function() {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;
                
                if (attributeType == 'CSS') {
                    return this.parent.style(attributeName, true);
                }
                return this.parent.attribute(attributeName, true);          
            };
            
            this.initialValue = null;
            this.initialUnits = '';
            this.removed = false;           

            this.calcValue = function() {
                // OVERRIDE ME!
                return '';
            };
                    
            this.update = function(delta) { 
                // set initial value
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits();
                }
            
                // if we're past the end time
                if (this.duration > this.maxDuration) {
                    // loop for indefinitely repeating animations
                    if (this.attribute('repeatCount').value == 'indefinite'
                     || this.attribute('repeatDur').value == 'indefinite') {
                        this.duration = 0.0
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.initialValue;
                        return true;
                    }
                    else {
                        return false; // no updates made
                    }
                }           
                this.duration = this.duration + delta;
            
                // if we're past the begin time
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue(); // tween
                    
                    if (this.attribute('type').hasValue()) {
                        // for transform, etc.
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')';
                    }
                    
                    this.getProperty().value = newValue;
                    updated = true;
                }
                
                return updated;
            };
            
            this.from = this.attribute('from');
            this.to = this.attribute('to');
            this.values = this.attribute('values');
            if (this.values.hasValue()) this.values.value = this.values.value.split(';');
            
            // fraction of duration we've covered
            this.progress = function() {
                var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb);
                }
                else {
                    ret.from = this.from;
                    ret.to = this.to;
                }
                return ret;
            }           
        };
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        
        // animate element
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress; 
                return newValue + this.initialUnits;
            };
        };
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
            
        // animate color element
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);
                
                if (from.ok && to.ok) {
                    // tween color linearly
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
                }
                return this.attribute('from').value;
            };
        };
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        
        // animate transform element
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            
            this.calcValue = function() {
                var p = this.progress();
                
                // tween value linearly
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = '';
                for (var i=0; i<from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                }
                return newValue;
            };
        };
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        
        // font element
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();          
            
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];           
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                }
                else if (child.type == 'missing-glyph') this.missingGlyph = child;
                else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    }
                    else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }   
        };
        svg.Element.font.prototype = new svg.Element.ElementBase;
        
        // font-face element
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);    
            
            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();                
        };
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        
        // missing-glyph element
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = 0;
        };
        svg.Element.missingglyph.prototype = new svg.Element.path;
        
        // glyph element
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);    
            
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        };
        svg.Element.glyph.prototype = new svg.Element.path;
        
        // text element
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                
                var textBaseline = this.style('dominant-baseline').toTextBaseline();
                if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
                if (textBaseline != null) ctx.textBaseline = textBaseline;
            };
            
            this.getBoundingBox = function () {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
            };
            
            this.renderChildren = function(ctx) {
                this.x = this.attribute('x').toPixels('x');
                this.y = this.attribute('y').toPixels('y');
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i=0; i<this.children.length; i++) {
                    this.renderChild(ctx, this, i);
                }
            };
            
            this.getAnchorDelta = function (ctx, parent, startI) {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                if (textAnchor != 'start') {
                    var width = 0;
                    for (var i=startI; i<parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute('x').hasValue()) break; // new group
                        width += child.measureTextRecursive(ctx);
                    }
                    return -1 * (textAnchor == 'end' ? width : width / 2.0);
                }
                return 0;
            };
            
            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute('x').hasValue()) {
                    child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
                }
                else {
                    if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
                    if (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');
                    child.x = this.x;
                }
                this.x = child.x + child.measureText(ctx);
                
                if (child.attribute('y').hasValue()) {
                    child.y = child.attribute('y').toPixels('y');
                }
                else {
                    if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
                    if (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');
                    child.y = this.y;
                }
                this.y = child.y;
                
                child.render(ctx);
                
                for (var i=0; i<child.children.length; i++) {
                    this.renderChild(ctx, child, i);
                }
            }
        };
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        
        // text base
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal'; 
                    if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
                    if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                    }
                }
                else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) glyph = font.missingGlyph;
                return glyph;
            };
            
            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1/scale, -1/scale);
                        ctx.translate(-this.x, -this.y);    
                        
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }
            
                if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
            };
            
            this.getText = function() {
                // OVERRIDE ME
            };
            
            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i=0; i<this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx);
                }
                return width;
            };
            
            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }
            
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) return textToMeasure.length * 10;
                
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        };
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        
        // tspan 
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.text = node.nodeValue || node.text || '';
            this.getText = function() {
                return this.text;
            }
        };
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        
        // tref
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null) return element.children[0].getText();
            }
        };
        svg.Element.tref.prototype = new svg.Element.TextElementBase;       
        
        // a element
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            
            this.hasText = true;
            for (var i=0; i<node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3) this.hasText = false;
            }
            
            // this might contain text
            this.text = this.hasText ? node.childNodes[0].nodeValue : '';
            this.getText = function() {
                return this.text;
            };

            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    // render as text element
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));                 
                }
                else {
                    // render as temporary group
                    var g = new svg.Element.g();
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx);
                }
            };
            
            this.onclick = function() {
                window.open(this.getHrefAttribute().value);
            };
            
            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = 'pointer';
            }
        };
        svg.Element.a.prototype = new svg.Element.TextElementBase;      
        
        // image element
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            var href = this.getHrefAttribute().value;
            var isSvg = href.match(/\.svg$/);
            
            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement('img');
                if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
                var self = this;
                this.img.onload = function() { self.loaded = true; };
                this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; };
                this.img.src = href;
            }
            else {
                this.img = svg.ajax(href);
                this.loaded = true;
            }
            
            this.renderChildren = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');            
                if (width == 0 || height == 0) return;
            
                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height);
                }
                else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx,
                                    this.attribute('preserveAspectRatio').value,
                                    width,
                                    this.img.width,
                                    height,
                                    this.img.height,
                                    0,
                                    0); 
                    ctx.drawImage(this.img, 0, 0);      
                }
                ctx.restore();
            };
            
            this.getBoundingBox = function() {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        };
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        
        // group element
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        };
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;

        // symbol element
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.render = function(ctx) {
                // NO RENDER
            };
        };
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;     
            
        // style element
        svg.Element.style = function(node) { 
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            // text, or spaces then CDATA
            var css = '';
            for (var i=0; i<node.childNodes.length; i++) {
              css += node.childNodes[i].nodeValue;
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
            css = svg.compressSpaces(css); // replace whitespace
            var cssDefs = css.split('}');
            for (var i=0; i<cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j=0; j<cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = {};
                            for (var k=0; k<cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g,'');
                                var srcs = props['src'].value.split(',');
                                for (var s=0; s<srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f=0; f<fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        svg.Element.style.prototype = new svg.Element.ElementBase;
        
        // use element 
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
                if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
            };
            
            var element = this.getHrefAttribute().getDefinition();
            
            this.path = function(ctx) {
                if (element != null) element.path(ctx);
            };
            
            this.getBoundingBox = function() {
                if (element != null) return element.getBoundingBox();
            };
            
            this.renderChildren = function(ctx) {
                if (element != null) {
                    var tempSvg = element;
                    if (element.type == 'symbol') {
                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                        tempSvg = new svg.Element.svg();
                        tempSvg.type = 'svg';
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
                        tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
                        tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
                        tempSvg.children = element.children;
                    }
                    if (tempSvg.type == 'svg') {
                        // if symbol or svg, inherit width/height from me
                        if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                        if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                    }
                    var oldParent = tempSvg.parent;
                    tempSvg.parent = null;
                    tempSvg.render(ctx);
                    tempSvg.parent = oldParent;
                }
            }
        };
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        
        // mask element
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                
                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox();
                    for (var i=0; i<this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var height = Math.floor(bb.height());
                }
                
                // temporarily remove mask to avoid recursion
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                
                    var cMask = document.createElement('canvas');
                    cMask.width = x + width;
                    cMask.height = y + height;
                    var maskCtx = cMask.getContext('2d');
                    this.renderChildren(maskCtx);
                
                    var c = document.createElement('canvas');
                    c.width = x + width;
                    c.height = y + height;
                    var tempCtx = c.getContext('2d');
                    element.render(tempCtx);
                    tempCtx.globalCompositeOperation = 'destination-in';
                    tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                    tempCtx.fillRect(0, 0, x + width, y + height);
                    
                    ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                    ctx.fillRect(0, 0, x + width, y + height);
                    
                // reassign mask
                element.attribute('mask').value = mask; 
            };
            
            this.render = function(ctx) {
                // NO RENDER
            }
        };
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        
        // clip element
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof(child.path) != 'undefined') {
                        var transform = null;
                        if (child.attribute('transform').hasValue()) { 
                            transform = new svg.Transform(child.attribute('transform').value);
                            transform.apply(ctx);
                        }
                        child.path(ctx);
                        ctx.clip();
                        if (transform) { transform.unapply(ctx); }
                    }
                }
            };
            
            this.render = function(ctx) {
                // NO RENDER
            }
        };
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;

        // filters
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
                        
            this.apply = function(ctx, element) {
                // render as temp svg   
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var height = Math.floor(bb.height());

                // temporarily remove filter to avoid recursion
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                
                var px = 0, py = 0;
                for (var i=0; i<this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd);
                }
                
                var c = document.createElement('canvas');
                c.width = width + 2*px;
                c.height = height + 2*py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
            
                // apply filters
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
                }
                
                // render on me
                ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);
                
                // reassign filter
                element.style('filter', true).value = filter;   
            };
            
            this.render = function(ctx) {
                // NO RENDER
            }       
        };
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        
        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        };
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
        
        svg.Element.feComposite = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        };
        svg.Element.feComposite.prototype = new svg.Element.ElementBase;
        
        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            
            var matrix = svg.ToNumberArray(this.attribute('values').value);
            switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
                case 'saturate':
                    var s = matrix[0];
                    matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
                              0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'hueRotate':
                    var a = matrix[0] * Math.PI / 180.0;
                    var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
                    matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
                              c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
                              c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
                              0,0,0,1,0,
                              0,0,0,0,1];
                    break;
                case 'luminanceToAlpha':
                    matrix = [0,0,0,0,0,
                              0,0,0,0,0,
                              0,0,0,0,0,
                              0.2125,0.7154,0.0721,0,0,
                              0,0,0,0,1];
                    break;
            }
            
            function imGet(img, x, y, width, height, rgba) {
                return img[y*width*4 + x*4 + rgba];
            }
            
            function imSet(img, x, y, width, height, rgba, val) {
                img[y*width*4 + x*4 + rgba] = val;
            }
            
            function m(i, v) {
                var mi = matrix[i];
                return mi * (mi < 0 ? v - 255 : v);
            }
                        
            this.apply = function(ctx, x, y, width, height) {
                // assuming x==0 && y==0 for now
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var a = imGet(srcData.data, x, y, width, height, 3);
                        imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
                        imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
                        imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
                        imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }
        };
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
        
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
            this.extraFilterDistance = this.blurRadius;
            
            this.apply = function(ctx, x, y, width, height) {
                if (typeof(stackBlurCanvasRGBA) == 'undefined') {
                    svg.log('ERROR: StackBlur.js must be included for blur to work');
                    return;
                }
                
                // StackBlur requires canvas be on document
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = 'none';
                document.body.appendChild(ctx.canvas);
                stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas);
            }
        };
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
        
        // title element, do nothing
        svg.Element.title = function(node) {
        };
        svg.Element.title.prototype = new svg.Element.ElementBase;

        // desc element, do nothing
        svg.Element.desc = function(node) {
        };
        svg.Element.desc.prototype = new svg.Element.ElementBase;       
        
        svg.Element.MISSING = function(node) {
            svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
        };
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        
        // element factory
        svg.CreateElement = function(node) {    
            var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
            className = className.replace(/\-/g,''); // remove dashes
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            }
            else {
                e = new svg.Element.MISSING(node);
            }

            e.type = node.nodeName;
            return e;
        };
                
        // load from url
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        };
        
        // load from xml
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml));
        };
        
        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);
            
            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) p.x += window.scrollX;
                if (window.scrollY) p.y += window.scrollY;
                return p;
            };
            
            // bind mouse
            if (svg.opts['ignoreMouse'] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y);
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y);
                };
            }
        
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
                    
            // render loop
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
            
                if (svg.opts['ignoreDimensions'] != true) {
                    // set canvas size
                    if (e.style('width').hasValue()) {
                        ctx.canvas.width = e.style('width').toPixels('x');
                        ctx.canvas.style.width = ctx.canvas.width + 'px';
                    }
                    if (e.style('height').hasValue()) {
                        ctx.canvas.height = e.style('height').toPixels('y');
                        ctx.canvas.style.height = ctx.canvas.height + 'px';
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                    cWidth = e.style('width').toPixels('x');
                    cHeight = e.style('height').toPixels('y');
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);       
                
                if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
                if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
                if (svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null) {
                    var xRatio = 1, yRatio = 1, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
                    if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                    else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
                    if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                    else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
                    
                    e.attribute('width', true).value = svg.opts['scaleWidth'];
                    e.attribute('height', true).value = svg.opts['scaleHeight'];            
                    e.attribute('viewBox', true).value = '0 0 ' + (cWidth * xRatio) + ' ' + (cHeight * yRatio);
                    e.attribute('preserveAspectRatio', true).value = 'none';
                }
            
                // clear and render
                if (svg.opts['ignoreClear'] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight);
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
                }           
            };
            
            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw();
            }
            svg.intervalID = setInterval(function() { 
                var needUpdate = false;
                
                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true;
                }
            
                // need update from mouse events?
                if (svg.opts['ignoreMouse'] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents();
                }
            
                // need update from animations?
                if (svg.opts['ignoreAnimation'] != true) {
                    for (var i=0; i<svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                    }
                }
                
                // need update from redraw?
                if (typeof(svg.opts['forceRedraw']) == 'function') {
                    if (svg.opts['forceRedraw']() == true) needUpdate = true;
                }
                
                // render if needed
                if (needUpdate) {
                    draw();             
                    svg.Mouse.runEvents(); // run and clear our events
                }
            }, 1000 / svg.FRAMERATE);
        };
        
        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID);
            }
        };
        
        svg.Mouse = new (function() {
            this.events = [];
            this.hasEvents = function() { return this.events.length != 0; };
        
            this.onclick = function(x, y) {
                this.events.push({ type: 'onclick', x: x, y: y, 
                    run: function(e) { if (e.onclick) e.onclick(); }
                });
            };
            
            this.onmousemove = function(x, y) {
                this.events.push({ type: 'onmousemove', x: x, y: y,
                    run: function(e) { if (e.onmousemove) e.onmousemove(); }
                });
            };
            
            this.eventElements = [];
            
            this.checkPath = function(element, ctx) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
                }
            };
            
            this.checkBoundingBox = function(element, bb) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
                }           
            };
            
            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = '';
                
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent;
                    }
                }       
            
                // done running, clear
                this.events = []; 
                this.eventElements = [];
            }
        });
        
        return svg;
    }
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
        canvg(this.canvas, s, { 
            ignoreMouse: true, 
            ignoreAnimation: true, 
            ignoreDimensions: true, 
            ignoreClear: true, 
            offsetX: dx, 
            offsetY: dy, 
            scaleWidth: dw, 
            scaleHeight: dh
        });
    }
}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var PF=function(){var e=function(t,n){var r=e.resolve(t,n||"/"),i=e.modules[r];if(!i)throw new Error("Failed to resolve module "+t+", tried "+r);var s=i._cached?i._cached:i();return s};return e.paths=[],e.modules={},e.extensions=[".js",".coffee"],e._core={assert:!0,events:!0,fs:!0,path:!0,vm:!0},e.resolve=function(){return function(t,n){function u(t){if(e.modules[t])return t;for(var n=0;n<e.extensions.length;n++){var r=e.extensions[n];if(e.modules[t+r])return t+r}}function a(t){t=t.replace(/\/+$/,"");var n=t+"/package.json";if(e.modules[n]){var i=e.modules[n](),s=i.browserify;if(typeof s=="object"&&s.main){var o=u(r.resolve(t,s.main));if(o)return o}else if(typeof s=="string"){var o=u(r.resolve(t,s));if(o)return o}else if(i.main){var o=u(r.resolve(t,i.main));if(o)return o}}return u(t+"/index")}function f(e,t){var n=l(t);for(var r=0;r<n.length;r++){var i=n[r],s=u(i+"/"+e);if(s)return s;var o=a(i+"/"+e);if(o)return o}var s=u(e);if(s)return s}function l(e){var t;e==="/"?t=[""]:t=r.normalize(e).split("/");var n=[];for(var i=t.length-1;i>=0;i--){if(t[i]==="node_modules")continue;var s=t.slice(0,i+1).join("/")+"/node_modules";n.push(s)}return n}n||(n="/");if(e._core[t])return t;var r=e.modules.path();n=r.resolve("/",n);var i=n||"/";if(t.match(/^(?:\.\.?\/|\/)/)){var s=u(r.resolve(i,t))||a(r.resolve(i,t));if(s)return s}var o=f(t,i);if(o)return o;throw new Error("Cannot find module '"+t+"'")}}(),e.alias=function(t,n){var r=e.modules.path(),i=null;try{i=e.resolve(t+"/package.json","/")}catch(s){i=e.resolve(t,"/")}var o=r.dirname(i),u=(Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t})(e.modules);for(var a=0;a<u.length;a++){var f=u[a];if(f.slice(0,o.length+1)===o+"/"){var l=f.slice(o.length);e.modules[n+l]=e.modules[o+l]}else f===o&&(e.modules[n]=e.modules[o])}},e.define=function(t,n){var r=e._core[t]?"":e.modules.path().dirname(t),i=function(t){return e(t,r)};i.resolve=function(t){return e.resolve(t,r)},i.modules=e.modules,i.define=e.define;var s={exports:{}};e.modules[t]=function(){return e.modules[t]._cached=s.exports,n.call(s.exports,i,s,s.exports,r,t),e.modules[t]._cached=s.exports,s.exports}},typeof process=="undefined"&&(process={}),process.nextTick||(process.nextTick=function(){var e=[],t=typeof window!="undefined"&&window.postMessage&&window.addEventListener;return t&&window.addEventListener("message",function(t){if(t.source===window&&t.data==="browserify-tick"){t.stopPropagation();if(e.length>0){var n=e.shift();n()}}},!0),function(n){t?(e.push(n),window.postMessage("browserify-tick","*")):setTimeout(n,0)}}()),process.title||(process.title="browser"),process.binding||(process.binding=function(t){if(t==="evals")return e("vm");throw new Error("No such module")}),process.cwd||(process.cwd=function(){return"."}),process.env||(process.env={}),process.argv||(process.argv=[]),e.define("path",function(e,t,n,r,i){function s(e,t){var n=[];for(var r=0;r<e.length;r++)t(e[r],r,e)&&n.push(e[r]);return n}function o(e,t){var n=0;for(var r=e.length;r>=0;r--){var i=e[r];i=="."?e.splice(r,1):i===".."?(e.splice(r,1),n++):n&&(e.splice(r,1),n--)}if(t)for(;n--;n)e.unshift("..");return e}var u=/^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;n.resolve=function(){var e="",t=!1;for(var n=arguments.length;n>=-1&&!t;n--){var r=n>=0?arguments[n]:process.cwd();if(typeof r!="string"||!r)continue;e=r+"/"+e,t=r.charAt(0)==="/"}return e=o(s(e.split("/"),function(e){return!!e}),!t).join("/"),(t?"/":"")+e||"."},n.normalize=function(e){var t=e.charAt(0)==="/",n=e.slice(-1)==="/";return e=o(s(e.split("/"),function(e){return!!e}),!t).join("/"),!e&&!t&&(e="."),e&&n&&(e+="/"),(t?"/":"")+e},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(s(e,function(e,t){return e&&typeof e=="string"}).join("/"))},n.dirname=function(e){var t=u.exec(e)[1]||"",n=!1;return t?t.length===1||n&&t.length<=3&&t.charAt(1)===":"?t:t.substring(0,t.length-1):"."},n.basename=function(e,t){var n=u.exec(e)[2]||"";return t&&n.substr(-1*t.length)===t&&(n=n.substr(0,n.length-t.length)),n},n.extname=function(e){return u.exec(e)[3]||""}}),e.define("/core/Node.js",function(e,t,n,r,i){function s(e,t,n){this.x=e,this.y=t,this.walkable=n===undefined?!0:n}t.exports=s}),e.define("/core/Grid.js",function(e,t,n,r,i){function o(e,t,n){this.width=e,this.height=t,this.nodes=this._buildNodes(e,t,n)}var s=e("./Node");o.prototype._buildNodes=function(e,t,n){var r,i,o=new Array(t),u;for(r=0;r<t;++r){o[r]=new Array(e);for(i=0;i<e;++i)o[r][i]=new s(i,r)}if(n===undefined)return o;if(n.length!==t||n[0].length!==e)throw new Error("Matrix size does not fit");for(r=0;r<t;++r)for(i=0;i<e;++i)n[r][i]&&(o[r][i].walkable=!1);return o},o.prototype.getNodeAt=function(e,t){return this.nodes[t][e]},o.prototype.isWalkableAt=function(e,t){return this.isInside(e,t)&&this.nodes[t][e].walkable},o.prototype.isInside=function(e,t){return e>=0&&e<this.width&&t>=0&&t<this.height},o.prototype.setWalkableAt=function(e,t,n){this.nodes[t][e].walkable=n},o.prototype.getNeighbors=function(e,t,n){var r=e.x,i=e.y,s=[],o=!1,u=!1,a=!1,f=!1,l=!1,c=!1,h=!1,p=!1,d=this.nodes;return this.isWalkableAt(r,i-1)&&(s.push(d[i-1][r]),o=!0),this.isWalkableAt(r+1,i)&&(s.push(d[i][r+1]),a=!0),this.isWalkableAt(r,i+1)&&(s.push(d[i+1][r]),l=!0),this.isWalkableAt(r-1,i)&&(s.push(d[i][r-1]),h=!0),t?(n?(u=h&&o,f=o&&a,c=a&&l,p=l&&h):(u=h||o,f=o||a,c=a||l,p=l||h),u&&this.isWalkableAt(r-1,i-1)&&s.push(d[i-1][r-1]),f&&this.isWalkableAt(r+1,i-1)&&s.push(d[i-1][r+1]),c&&this.isWalkableAt(r+1,i+1)&&s.push(d[i+1][r+1]),p&&this.isWalkableAt(r-1,i+1)&&s.push(d[i+1][r-1]),s):s},o.prototype.clone=function(){var e,t,n=this.width,r=this.height,i=this.nodes,u=new o(n,r),a=new Array(r),f;for(e=0;e<r;++e){a[e]=new Array(n);for(t=0;t<n;++t)a[e][t]=new s(t,e,i[e][t].walkable)}return u.nodes=a,u},t.exports=o}),e.define("/core/Heap.js",function(e,t,n,r,i){(function(){var e,n,r,i,s,o,u,a,f,l,c,h,p,d,v;r=Math.floor,l=Math.min,n=function(e,t){return e<t?-1:e>t?1:0},f=function(e,t,i,s,o){var u;i==null&&(i=0),o==null&&(o=n);if(i<0)throw new Error("lo must be non-negative");s==null&&(s=e.length);while(o(i,s)<0)u=r((i+s)/2),o(t,e[u])<0?s=u:i=u+1;return[].splice.apply(e,[i,i-i].concat(t)),t},o=function(e,t,r){return r==null&&(r=n),e.push(t),d(e,0,e.length-1,r)},s=function(e,t){var r,i;return t==null&&(t=n),r=e.pop(),e.length?(i=e[0],e[0]=r,v(e,0,t)):i=r,i},a=function(e,t,r){var i;return r==null&&(r=n),i=e[0],e[0]=t,v(e,0,r),i},u=function(e,t,r){var i;return r==null&&(r=n),e.length&&r(e[0],t)<0&&(i=[e[0],t],t=i[0],e[0]=i[1],v(e,0,r)),t},i=function(e,t){var i,s,o,u,a,f,l,c;t==null&&(t=n),f=function(){c=[];for(var t=0,n=r(e.length/2);0<=n?t<n:t>n;0<=n?t++:t--)c.push(t);return c}.apply(this).reverse(),l=[];for(s=0,u=f.length;s<u;s++)i=f[s],l.push(v(e,i,t));return l},p=function(e,t,r){var i;return r==null&&(r=n),i=e.indexOf(t),d(e,0,i,r),v(e,i,r)},c=function(e,t,r){var s,o,a,f,l;r==null&&(r=n),o=e.slice(0,t);if(!o.length)return o;i(o,r),l=e.slice(t);for(a=0,f=l.length;a<f;a++)s=l[a],u(o,s,r);return o.sort(r).reverse()},h=function(e,t,r){var o,u,a,c,h,p,d,v,m,g;r==null&&(r=n);if(t*10<=e.length){c=e.slice(0,t).sort(r);if(!c.length)return c;a=c[c.length-1],v=e.slice(t);for(h=0,d=v.length;h<d;h++)o=v[h],r(o,a)<0&&(f(c,o,0,null,r),c.pop(),a=c[c.length-1]);return c}i(e,r),g=[];for(u=p=0,m=l(t,e.length);0<=m?p<m:p>m;u=0<=m?++p:--p)g.push(s(e,r));return g},d=function(e,t,r,i){var s,o,u;i==null&&(i=n),s=e[r];while(r>t){u=r-1>>1,o=e[u];if(i(s,o)<0){e[r]=o,r=u;continue}break}return e[r]=s},v=function(e,t,r){var i,s,o,u,a;r==null&&(r=n),s=e.length,a=t,o=e[t],i=2*t+1;while(i<s)u=i+1,u<s&&!(r(e[i],e[u])<0)&&(i=u),e[t]=e[i],t=i,i=2*t+1;return e[t]=o,d(e,a,t,r)},e=function(){function e(e){this.cmp=e!=null?e:n,this.nodes=[]}return e.name="Heap",e.push=o,e.pop=s,e.replace=a,e.pushpop=u,e.heapify=i,e.nlargest=c,e.nsmallest=h,e.prototype.push=function(e){return o(this.nodes,e,this.cmp)},e.prototype.pop=function(){return s(this.nodes,this.cmp)},e.prototype.peek=function(){return this.nodes[0]},e.prototype.contains=function(e){return this.nodes.indexOf(e)!==-1},e.prototype.replace=function(e){return a(this.nodes,e,this.cmp)},e.prototype.pushpop=function(e){return u(this.nodes,e,this.cmp)},e.prototype.heapify=function(){return i(this.nodes,this.cmp)},e.prototype.updateItem=function(e){return p(this.nodes,e,this.cmp)},e.prototype.clear=function(){return this.nodes=[]},e.prototype.empty=function(){return this.nodes.length===0},e.prototype.size=function(){return this.nodes.length},e.prototype.clone=function(){var t;return t=new e,t.nodes=this.nodes.slice(0),t},e.prototype.toArray=function(){return this.nodes.slice(0)},e.prototype.insert=e.prototype.push,e.prototype.remove=e.prototype.pop,e.prototype.top=e.prototype.peek,e.prototype.front=e.prototype.peek,e.prototype.has=e.prototype.contains,e.prototype.copy=e.prototype.clone,e}(),(typeof t!="undefined"&&t!==null?t.exports:void 0)?t.exports=e:window.Heap=e}).call(this)}),e.define("/core/Util.js",function(e,t,n,r,i){function s(e){var t=[[e.x,e.y]];while(e.parent)e=e.parent,t.push([e.x,e.y]);return t.reverse()}function o(e,t){var n=s(e),r=s(t);return n.concat(r.reverse())}function u(e){var t,n=0,r,i,s,o;for(t=1;t<e.length;++t)r=e[t-1],i=e[t],s=r[0]-i[0],o=r[1]-i[1],n+=Math.sqrt(s*s+o*o);return n}function a(e,t,n,r){var i=Math.abs,s=[],o,u,a,f,l,c;a=i(n-e),f=i(r-t),o=e<n?1:-1,u=t<r?1:-1,l=a-f;for(;;){s.push([e,t]);if(e===n&&t===r)break;c=2*l,c>-f&&(l-=f,e+=o),c<a&&(l+=a,t+=u)}return s}function f(e,t){var n=t.length,r=t[0][0],i=t[0][1],s=t[n-1][0],o=t[n-1][1],u,f,l,c,h,p,d,v,m,g,y,b,w;u=r,f=i,h=t[1][0],p=t[1][1],d=[[u,f]];for(v=2;v<n;++v){g=t[v],l=g[0],c=g[1],y=a(u,f,l,c),w=!1;for(m=1;m<y.length;++m){b=y[m];if(!e.isWalkableAt(b[0],b[1])){w=!0,d.push([h,p]),u=h,f=p;break}}w||(h=l,p=c)}return d.push([s,o]),d}n.backtrace=s,n.biBacktrace=o,n.pathLength=u,n.getLine=a,n.smoothenPath=f}),e.define("/core/Heuristic.js",function(e,t,n,r,i){t.exports={manhattan:function(e,t){return e+t},euclidean:function(e,t){return Math.sqrt(e*e+t*t)},chebyshev:function(e,t){return Math.max(e,t)}}}),e.define("/finders/AStarFinder.js",function(e,t,n,r,i){function a(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners,this.heuristic=e.heuristic||u.manhattan}var s=e("../core/Heap"),o=e("../core/Util"),u=e("../core/Heuristic");a.prototype.findPath=function(e,t,n,r,i){var u=new s(function(e,t){return e.f-t.f}),a=i.getNodeAt(e,t),f=i.getNodeAt(n,r),l=this.heuristic,c=this.allowDiagonal,h=this.dontCrossCorners,p=Math.abs,d=Math.SQRT2,v,m,g,y,b,w,E,S;a.g=0,a.f=0,u.push(a),a.opened=!0;while(!u.empty()){v=u.pop(),v.closed=!0;if(v===f)return o.backtrace(f);m=i.getNeighbors(v,c,h);for(y=0,b=m.length;y<b;++y){g=m[y];if(g.closed)continue;w=g.x,E=g.y,S=v.g+(w-v.x===0||E-v.y===0?1:d);if(!g.opened||S<g.g)g.g=S,g.h=g.h||l(p(w-n),p(E-r)),g.f=g.g+g.h,g.parent=v,g.opened?u.updateItem(g):(u.push(g),g.opened=!0)}}return[]},t.exports=a}),e.define("/finders/BestFirstFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e);var t=this.heuristic;this.heuristic=function(e,n){return t(e,n)*1e6}}var s=e("./AStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/BreadthFirstFinder.js",function(e,t,n,r,i){function o(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners}var s=e("../core/Util");o.prototype.findPath=function(e,t,n,r,i){var o=[],u=this.allowDiagonal,a=this.dontCrossCorners,f=i.getNodeAt(e,t),l=i.getNodeAt(n,r),c,h,p,d,v;o.push(f),f.opened=!0;while(o.length){p=o.shift(),p.closed=!0;if(p===l)return s.backtrace(l);c=i.getNeighbors(p,u,a);for(d=0,v=c.length;d<v;++d){h=c[d];if(h.closed||h.opened)continue;o.push(h),h.opened=!0,h.parent=p}}return[]},t.exports=o}),e.define("/finders/DijkstraFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e),this.heuristic=function(e,t){return 0}}var s=e("./AStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/BiAStarFinder.js",function(e,t,n,r,i){function a(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners,this.heuristic=e.heuristic||u.manhattan}var s=e("../core/Heap"),o=e("../core/Util"),u=e("../core/Heuristic");a.prototype.findPath=function(e,t,n,r,i){var u=function(e,t){return e.f-t.f},a=new s(u),f=new s(u),l=i.getNodeAt(e,t),c=i.getNodeAt(n,r),h=this.heuristic,p=this.allowDiagonal,d=this.dontCrossCorners,v=Math.abs,m=Math.SQRT2,g,y,b,w,E,S,x,T,N=1,C=2;l.g=0,l.f=0,a.push(l),l.opened=N,c.g=0,c.f=0,f.push(c),c.opened=C;while(!a.empty()&&!f.empty()){g=a.pop(),g.closed=!0,y=i.getNeighbors(g,p,d);for(w=0,E=y.length;w<E;++w){b=y[w];if(b.closed)continue;if(b.opened===C)return o.biBacktrace(g,b);S=b.x,x=b.y,T=g.g+(S-g.x===0||x-g.y===0?1:m);if(!b.opened||T<b.g)b.g=T,b.h=b.h||h(v(S-n),v(x-r)),b.f=b.g+b.h,b.parent=g,b.opened?a.updateItem(b):(a.push(b),b.opened=N)}g=f.pop(),g.closed=!0,y=i.getNeighbors(g,p,d);for(w=0,E=y.length;w<E;++w){b=y[w];if(b.closed)continue;if(b.opened===N)return o.biBacktrace(b,g);S=b.x,x=b.y,T=g.g+(S-g.x===0||x-g.y===0?1:m);if(!b.opened||T<b.g)b.g=T,b.h=b.h||h(v(S-e),v(x-t)),b.f=b.g+b.h,b.parent=g,b.opened?f.updateItem(b):(f.push(b),b.opened=C)}}return[]},t.exports=a}),e.define("/finders/BiBestFirstFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e);var t=this.heuristic;this.heuristic=function(e,n){return t(e,n)*1e6}}var s=e("./BiAStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/BiBreadthFirstFinder.js",function(e,t,n,r,i){function o(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners}var s=e("../core/Util");o.prototype.findPath=function(e,t,n,r,i){var o=i.getNodeAt(e,t),u=i.getNodeAt(n,r),a=[],f=[],l,c,h,p=this.allowDiagonal,d=this.dontCrossCorners,v=0,m=1,g,y;a.push(o),o.opened=!0,o.by=v,f.push(u),u.opened=!0,u.by=m;while(a.length&&f.length){h=a.shift(),h.closed=!0,l=i.getNeighbors(h,p,d);for(g=0,y=l.length;g<y;++g){c=l[g];if(c.closed)continue;if(c.opened){if(c.by===m)return s.biBacktrace(h,c);continue}a.push(c),c.parent=h,c.opened=!0,c.by=v}h=f.shift(),h.closed=!0,l=i.getNeighbors(h,p,d);for(g=0,y=l.length;g<y;++g){c=l[g];if(c.closed)continue;if(c.opened){if(c.by===v)return s.biBacktrace(c,h);continue}f.push(c),c.parent=h,c.opened=!0,c.by=m}}return[]},t.exports=o}),e.define("/finders/BiDijkstraFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e),this.heuristic=function(e,t){return 0}}var s=e("./BiAStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/JumpPointFinder.js",function(e,t,n,r,i){function a(e){e=e||{},this.heuristic=e.heuristic||u.manhattan}var s=e("../core/Heap"),o=e("../core/Util"),u=e("../core/Heuristic");a.prototype.findPath=function(e,t,n,r,i){var u=this.openList=new s(function(e,t){return e.f-t.f}),a=this.startNode=i.getNodeAt(e,t),f=this.endNode=i.getNodeAt(n,r),l;this.grid=i,a.g=0,a.f=0,u.push(a),a.opened=!0;while(!u.empty()){l=u.pop(),l.closed=!0;if(l===f)return o.backtrace(f);this._identifySuccessors(l)}return[]},a.prototype._identifySuccessors=function(e){var t=this.grid,n=this.heuristic,r=this.openList,i=this.endNode.x,s=this.endNode.y,o,a,f,l,c,h=e.x,p=e.y,d,v,m,g,y,b,w,E=Math.abs,S=Math.max;o=this._findNeighbors(e);for(l=0,c=o.length;l<c;++l){a=o[l],f=this._jump(a[0],a[1],h,p);if(f){d=f[0],v=f[1],w=t.getNodeAt(d,v);if(w.closed)continue;y=u.euclidean(E(d-h),E(v-p)),b=e.g+y;if(!w.opened||b<w.g)w.g=b,w.h=w.h||n(E(d-i),E(v-s)),w.f=w.g+w.h,w.parent=e,w.opened?r.updateItem(w):(r.push(w),w.opened=!0)}}},a.prototype._jump=function(e,t,n,r){var i=this.grid,s=e-n,o=t-r,u,a;if(!i.isWalkableAt(e,t))return null;if(i.getNodeAt(e,t)===this.endNode)return[e,t];if(s!==0&&o!==0){if(i.isWalkableAt(e-s,t+o)&&!i.isWalkableAt(e-s,t)||i.isWalkableAt(e+s,t-o)&&!i.isWalkableAt(e,t-o))return[e,t]}else if(s!==0){if(i.isWalkableAt(e+s,t+1)&&!i.isWalkableAt(e,t+1)||i.isWalkableAt(e+s,t-1)&&!i.isWalkableAt(e,t-1))return[e,t]}else if(i.isWalkableAt(e+1,t+o)&&!i.isWalkableAt(e+1,t)||i.isWalkableAt(e-1,t+o)&&!i.isWalkableAt(e-1,t))return[e,t];if(s!==0&&o!==0){u=this._jump(e+s,t,e,t),a=this._jump(e,t+o,e,t);if(u||a)return[e,t]}return i.isWalkableAt(e+s,t)||i.isWalkableAt(e,t+o)?this._jump(e+s,t+o,e,t):null},a.prototype._findNeighbors=function(e){var t=e.parent,n=e.x,r=e.y,i=this.grid,s,o,u,a,f,l,c=[],h,p,d,v;if(t)s=t.x,o=t.y,f=(n-s)/Math.max(Math.abs(n-s),1),l=(r-o)/Math.max(Math.abs(r-o),1),f!==0&&l!==0?(i.isWalkableAt(n,r+l)&&c.push([n,r+l]),i.isWalkableAt(n+f,r)&&c.push([n+f,r]),(i.isWalkableAt(n,r+l)||i.isWalkableAt(n+f,r))&&c.push([n+f,r+l]),!i.isWalkableAt(n-f,r)&&i.isWalkableAt(n,r+l)&&c.push([n-f,r+l]),!i.isWalkableAt(n,r-l)&&i.isWalkableAt(n+f,r)&&c.push([n+f,r-l])):f===0?i.isWalkableAt(n,r+l)&&(i.isWalkableAt(n,r+l)&&c.push([n,r+l]),i.isWalkableAt(n+1,r)||c.push([n+1,r+l]),i.isWalkableAt(n-1,r)||c.push([n-1,r+l])):i.isWalkableAt(n+f,r)&&(i.isWalkableAt(n+f,r)&&c.push([n+f,r]),i.isWalkableAt(n,r+1)||c.push([n+f,r+1]),i.isWalkableAt(n,r-1)||c.push([n+f,r-1]));else{h=i.getNeighbors(e,!0);for(d=0,v=h.length;d<v;++d)p=h[d],c.push([p.x,p.y])}return c},t.exports=a}),e.define("/PathFinding.js",function(e,t,n,r,i){t.exports={Node:e("./core/Node"),Grid:e("./core/Grid"),Heap:e("./core/Heap"),Util:e("./core/Util"),Heuristic:e("./core/Heuristic"),AStarFinder:e("./finders/AStarFinder"),BestFirstFinder:e("./finders/BestFirstFinder"),BreadthFirstFinder:e("./finders/BreadthFirstFinder"),DijkstraFinder:e("./finders/DijkstraFinder"),BiAStarFinder:e("./finders/BiAStarFinder"),BiBestFirstFinder:e("./finders/BiBestFirstFinder"),BiBreadthFirstFinder:e("./finders/BiBreadthFirstFinder"),BiDijkstraFinder:e("./finders/BiDijkstraFinder"),JumpPointFinder:e("./finders/JumpPointFinder")}}),e("/PathFinding.js"),e("/PathFinding")}()
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.0 - JavaScript Vector Library                          │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

// ┌──────────────────────────────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.3.4 - JavaScript Events Library                                                │ \\
// ├──────────────────────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)          │ \\
// │ Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license. │ \\
// └──────────────────────────────────────────────────────────────────────────────────────┘ \\

// THIS FILES IS PATCHED BY FREEGROUP
// you can't replace this file with a new version without migrate all changes
// tagged with "FREEGROUP"
//
(function (glob) {
    var version = "0.3.4",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    
        eve = function (name, scope) {
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
    
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    
    
    eve.on = function (name, f) {
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            !e[names[i]] && (e[names[i]] = {n: {}});
            e = e[names[i]];
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    
    eve.stop = function () {
        stop = 1;
    };
    
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    
    
    eve.off = eve.unbind = function (name, f) {
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    
    eve.once = function (name, f) {
        var f2 = function () {
            var res = f.apply(this, arguments);
            eve.unbind(name, f2);
            return res;
        };
        return eve.on(name, f2);
    };
    
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));
})(this);


// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ "Raphaël 2.1.0" - JavaScript Vector Library                         │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
(function () {
    
    function R(first) {
        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        } else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        } else {
            var args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                var f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = "2.1.0";
    R.eve = eve;
    var loaded,
        separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function () {
            
            
            this.ca = this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = "createTouch" in g.doc,
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            "stroke-scale": true, // FreeGroup: draw2d enhancement
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
        eldata = {},
        sortByKey = function (a, b) {
            return a.key - b.key;
        },
        sortByNumber = function (a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function () {},
        pipe = function (x) {
            return x;
        },
        rectPath = R._rectPath = function (x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function (x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
        
        mapPath = R.mapPath = function (path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        };

    R._g = g;
    
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = g.doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return (R.type = E);
        }
        d = null;
    }
    
    
    R.svg = !(R.vml = R.type == "VML");
    R._Paper = Paper;
    
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    R._oid = 0;
    
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        if (type == "array") {
            return o instanceof Array;
        }
        return  (type == "null" && o === null) ||
                (type == typeof o && o !== null) ||
                (type == "object" && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };

    function clone(obj) {
        if (Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor;
        for (var key in obj) if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        return res;
    }

    
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    
    R.deg = function (rad) {
        return rad * 180 / PI % 360;
    };
    
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };
    
    
    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
        return function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function (c) {
        var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    });

    
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    var toHex = function (color) {
        if (R.vml) {
            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
            var trim = /^\s+|\s+$/g;
            var bod;
            try {
                var docum = new ActiveXObject("htmlfile");
                docum.write("<body>");
                docum.close();
                bod = docum.body;
            } catch(e) {
                bod = createPopup().document.body;
            }
            var range = bod.createTextRange();
            toHex = cacher(function (color) {
                try {
                    bod.style.color = Str(color).replace(trim, E);
                    var value = range.queryCommandValue("ForeColor");
                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                    return "#" + ("000000" + value.toString(16)).slice(-6);
                } catch(e) {
                    return "none";
                }
            });
        } else {
            var i = g.doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            g.doc.body.appendChild(i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
    hsbtoString = function () {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
        return this.hex;
    },
    prepareRGB = function (r, g, b) {
        if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && R.is(r, string)) {
            var clr = R.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }
        
        return [r, g, b];
    },
    packageRGB = function (r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        var rgb = {
            r: r,
            g: g,
            b: b,
            hex: R.rgb(r, g, b),
            toString: rgbtoString
        };
        R.is(o, "finite") && (rgb.opacity = o);
        return rgb;
    };
    
    
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {hex: "none"};
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
             V == r ? (g - b) / C :
             V == g ? (b - r) / C + 2 :
                      (r - g) / C + 4
            );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {h: H, s: S, b: V, toString: hsbtoString};
    };
    
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
             M == r ? (g - b) / C :
             M == g ? (b - r) / C + 2 :
                      (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
             L < .5 ? C / (2 * L) :
                      C / (2 - 2 * L));
        return {h: H, s: S, l: L, toString: hsltoString};
    };
    R._path2string = function () {
        return this.join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };
    
    function clrToString() {
        return this.hex;
    }

    
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue, toString: clrToString};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
    }, R);
    
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    
    R.rgb = cacher(function (r, g, b) {
        return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
    });
    
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    
    R.getColor.reset = function () {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }
    
    R.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }
        
        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    
    R.parseTransformString = cacher(function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {r: 3, s: 4, t: 2, m: 6},
            data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function (ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    };
    
    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    
    R.isPointInsideBBox = function (bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    
    R.isBBoxIntersect = function (bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 5),
            n2 = ~~(l2 / 5),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    
    R.pathIntersection = function (path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function (path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    
    R.isPointInsidePath = function (path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    };
    R._removedFactory = function (methodname) {
        return function () {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };
    
    var pathDimensions = R.pathBBox = function (path) {
        var pth = paths(path);
        if (pth.bbox) {
            var b= pth.bbox;
            return {x: b.x, y: b.y, width: b.width, height: b.height, x2: b.x2, y2: b.y2} ; // FREEGROUP FIX!!!!!!
            // raphael reuse the returned bbox. You must clone it here if the caller need the bbxo for
            //further calculation
        }
        if (!path) {
            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
        }
        path = path2curve(path);
        var x = 0, 
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y),
            xmax = mmax[apply](0, X),
            ymax = mmax[apply](0, Y),
            bb = {
                x: xmin,
                y: ymin,
                x2: xmax,
                y2: ymax,
                width: xmax - xmin,
                height: ymax - ymin
            };
        pth.bbox = clone(bb);
        return bb;
    },
        pathClone = function (pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                    _13 * x1 + _23 * ax,
                    _13 * y1 + _23 * ay,
                    _13 * x2 + _23 * ax,
                    _13 * y2 + _23 * ay,
                    x2,
                    y2
                ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = R._path2curve = cacher(function (path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d) {
                    var nx, ny;
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in {T:1, Q:1}) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            nx = d.x + (d.x - (d.bx || d.x));
                            ny = d.y + (d.y - (d.by || d.y));
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            d.qx = d.x + (d.x - (d.qx || d.x));
                            d.qy = d.y + (d.y - (d.qy || d.y));
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi.length) {
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                };
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 && (p2[i] = processPath(p2[i], attrs2));
                p2 && fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.color = dot.color.hex;
                
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        
        toMatrix = R.toMatrix = function (path, transform) {
            var bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: function () {
                        return bb;
                    }
                };
            extractTransform(el, transform);
            return el.matrix;
        },
        
        transformPath = R.transformPath = function (path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function (el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
                deg = 0,
                dx = 0,
                dy = 0,
                sx = 1,
                sy = 1,
                _ = el._,
                m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }

            
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function (item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t": return [l, 0, 0];
                case "m": return [l, 1, 0, 0, 1, 0, 0];
                case "r": if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
                case "s": if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = function (t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = 0, j, jj,
                tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                    ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
    R._getContainer = function (x, y, w, h) {
        var container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    
    R.pathToRelative = pathToRelative;
    R._engine = {};
    
    R.path2curve = path2curve;
    
    R.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        
        matrixproto.add = function (a, b, c, d, e, f) {
            var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        
        matrixproto.translate = function (x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        
        matrixproto.rotate = function (a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return R.svg ?
                "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toFilter = function () {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) + 
                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                        (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
        (navigator.vendor == "Google Inc." && version && version[1] < 8)) {
        
        paperproto.safari = function () {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
            setTimeout(function () {rect.remove();});
        };
    } else {
        paperproto.safari = fun;
    }
 
    var preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = (function () {
        if (g.doc.addEventListener) {
            return function (obj, type, fn, element) {
                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                    f = function (e) {
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                            x = e.clientX + scrollX,
                            y = e.clientY + scrollY;
                    if (supportsTouch && touchMap[has](type)) {
                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                var olde = e;
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }
                    }
                    return fn.call(element, e, x, y);
                };
                obj.addEventListener(realName, f, false);
                return function () {
                    obj.removeEventListener(realName, f, false);
                    return true;
                };
            };
        } else if (g.doc.attachEvent) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    e = e || g.win.event;
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                        x = e.clientX + scrollX,
                        y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e, x, y);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function () {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            g.win.opera && parent.removeChild(node);
            node.style.display = "none";
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    },
    
    elproto = R.el = {};
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    for (var i = events.length; i--;) {
        (function (eventName) {
            R[eventName] = elproto[eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) if (events[l].name == eventName && events[l].f == fn) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    
    
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };
    
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.x = e.clientX + scrollX;
            this._drag.y = e.clientY + scrollY;
            this._drag.id = e.identifier;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({el: this, start: start});
        this.mousedown(start);
        return this;
    };
    
    elproto.onDragOver = function (f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };
    
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("raphael.drag.*." + this.id);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
    };
    
    paperproto.circle = function (x, y, r) {
        var out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.rect = function (x, y, w, h, r) {
        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.ellipse = function (x, y, rx, ry) {
        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        var out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.image = function (src, x, y, w, h) {
        var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.text = function (x, y, text) {
        var out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.set = function (itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    paperproto.setStart = function (set) {
        this.__set__ = set || this.set();
    };
    
    paperproto.setFinish = function (set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };
    
    paperproto.setSize = function (width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    
    paperproto.setViewBox = function (x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    
    
    paperproto.top = paperproto.bottom = null;
    
    paperproto.raphael = R;
    var getOffset = function (elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    
    paperproto.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };
    
    paperproto.getById = function (id) {
        var bot = this.bottom;
        while (bot) {
            if (bot.id == id) {
                return bot;
            }
            bot = bot.next;
        }
        return null;
    };
    
    paperproto.forEach = function (callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };
    
    paperproto.getElementsByPoint = function (x, y) {
        var set = this.set();
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }
    
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = this.realPath || getPath[this.type](this);
        return R.isPointInsidePath(rp, x, y);
    };
    
    elproto.getBBox = function (isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    
    elproto.glow = function (glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity || .5,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    },
    getLengthFactory = function (istotal, subpath) {
        return function (path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {x: point.x, y: point.y, alpha: point.alpha};
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    
    R.getTotalLength = getTotalLength;
    
    R.getPointAtLength = getPointAtLength;
    
    R.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    
    elproto.getTotalLength = function () {
        if (this.type != "path") {return;}
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
        return getTotalLength(this.attrs.path);
    };
    
    elproto.getPointAtLength = function (length) {
        if (this.type != "path") {return;}
        return getPointAtLength(this.attrs.path, length);
    };
    
    elproto.getSubpath = function (from, to) {
        if (this.type != "path") {return;}
        return R.getSubpath(this.attrs.path, from, to);
    };
    
    var ef = R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 1.7);
        },
        ">": function (n) {
            return pow(n, .48);
        },
        "<>": function (n) {
            var q = .48 - n / 1.04,
                Q = math.sqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame       ||
                           window.webkitRequestAnimationFrame ||
                           window.mozRequestAnimationFrame    ||
                           window.oRequestAnimationFrame      ||
                           window.msRequestAnimationFrame     ||
                           function (callback) {
                               setTimeout(callback, 16);
                           },
        animation = function () {
            var Now = +new Date,
                l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function (i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (function (id, that, anim) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function(f, el, a) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to) if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            R.svg && that && that.paper && that.paper.safari();
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function (color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };
    
    elproto.animateWith = function (el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
        // 
        // 
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
            newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim) if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    
    Animation.prototype.delay = function (delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    
    Animation.prototype.repeat = function (times) { 
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params) if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {transform: _.transform},
                                        getBBox: function () {
                                            return element.getBBox(1);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while (i--) {
                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            }
                            break;
                    }
                }
            }
            var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }
    
    R.animation = function (params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
            json,
            attr;
        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({100: p}, ms);
        }
    };
    
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    
    elproto.setTime = function (anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };
    
    elproto.status = function (anim, value) {
        var out = [],
            i = 0,
            len,
            e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };
    
    elproto.pause = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                animationElements[i].paused = true;
            }
        }
        return this;
    };
    
    elproto.resume = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            var e = animationElements[i];
            if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    
    elproto.stop = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                animationElements.splice(i--, 1);
            }
        }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function () {
        return "Rapha\xebl\u2019s object";
    };

    // Set
    var Set = function (items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto) if (elproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
        if (!len) {
            return this;
        }
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
        }
        return this;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    // FREEGROUP FIX: Adding "isWithoutTransform" to the function and redirect them to the elements
    setproto.getBBox = function (isWithoutTransform) {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox(isWithoutTransform);
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Rapha\xebl\u2018s set";
    };

    
    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                        }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
        R.is(font, string) && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    
    paperproto.add = function (json) {
        if (R.is(json, "array")) {
            var res = this.set(),
                i = 0,
                ii = json.length,
                j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    
    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    
    R.fullfill = (function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
        return function (str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    })();
    
    R.ninja = function () {
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    
    R.st = setproto;
    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function (doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener){
            doc.addEventListener(loaded, f = function () {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);
    
    eve.on("raphael.DOMload", function () {
        loaded = true;
    });
})();


// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël - JavaScript Vector Library                                 │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ SVG Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
window.Raphael.svg && function (R) {
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        separator = /[, ]+/,
        eve = R.eve,
        E = "",
        S = " ";
    var xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {};
    R.toString = function () {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };
    var $ = function (el, attr) {
        if (attr) {
            if (typeof el == "string") {
                el = $(el);
            }
            for (var key in attr) if (attr[has](key)) {
                if (key.substring(0, 6) == "xlink:") {
                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                } else {
                    el.setAttribute(key, Str(attr[key]));
                }
            }
        } else {
            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
            el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
        }
        return el;
    },
    addGradientFill = function (element, gradient) {
        var type = "linear",
            id = element.id + gradient,
            fx = .5, fy = .5,
            o = element.node,
            SVG = element.paper,
            s = o.style,
            el = R._g.doc.getElementById(id);
        if (!el) {
            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                type = "radial";
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    var dir = ((fy > .5) * 2 - 1);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }
            id = id.replace(/[\(\)\s,\xb0#]/g, "_");
            
            if (element.gradient && id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                delete element.gradient;
            }

            if (!element.gradient) {
                el = $(type + "Gradient", {id: id});
                element.gradient = el;
                $(el, type == "radial" ? {
                    fx: fx,
                    fy: fy
                } : {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                for (var i = 0, ii = dots.length; i < ii; i++) {
                    el.appendChild($("stop", {
                        offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                        "stop-color": dots[i].color || "#fff"
                    }));
                }
            }
        }
        $(o, {
            fill: "url(#" + id + ")",
            opacity: 1,
            "fill-opacity": 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    },
    updatePosition = function (o) {
        var bbox = o.getBBox(1);
        $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
    },
    addArrow = function (o, value, isEnd) {
        if (o.type == "path") {
            var values = Str(value).toLowerCase().split("-"),
                p = o.paper,
                se = isEnd ? "end" : "start",
                node = o.node,
                attrs = o.attrs,
                stroke = attrs["stroke-width"],
                i = values.length,
                type = "classic",
                from,
                to,
                dx,
                refX,
                attr,
                w = 3,
                h = 3,
                t = 5;
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide": h = 5; break;
                    case "narrow": h = 2; break;
                    case "long": w = 5; break;
                    case "short": w = 2; break;
                }
            }
            if (type == "open") {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: "none",
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: "none"
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else {
                o._.arrows = {};
            }
            if (type != "none") {
                var pathId = "raphael-marker-" + type,
                    markerId = "raphael-marker-" + se + type + w + h;
                if (!R._g.doc.getElementById(pathId)) {
                    p.defs.appendChild($($("path"), {
                        "stroke-linecap": "round",
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else {
                    markerCounter[pathId]++;
                }
                var marker = R._g.doc.getElementById(markerId),
                    use;
                if (!marker) {
                    marker = $($("marker"), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: "auto",
                        refX: refX,
                        refY: h / 2
                    });
                    use = $($("use"), {
                        "xlink:href": "#" + pathId,
                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName("use")[0];
                }
                $(use, attr);
                var delta = dx * (type != "diamond" && type != "oval");
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr["marker-" + se] = "url(#" + markerId + ")";
                if (to || from) {
                    attr.d = Raphael.getSubpath(attrs.path, from, to);
                }
                $(node, attr);
                o._.arrows[se + "Path"] = pathId;
                o._.arrows[se + "Marker"] = markerId;
                o._.arrows[se + "dx"] = delta;
                o._.arrows[se + "Type"] = type;
                o._.arrows[se + "String"] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[se + "Path"] && $(node, {d: Raphael.getSubpath(attrs.path, from, to)});
                delete o._.arrows[se + "Path"];
                delete o._.arrows[se + "Marker"];
                delete o._.arrows[se + "dx"];
                delete o._.arrows[se + "Type"];
                delete o._.arrows[se + "String"];
            }
            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                var item = R._g.doc.getElementById(attr);
                item && item.parentNode.removeChild(item);
            }
        }
    },
    dasharray = {
        "": [0],
        "none": [0],
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
    },
    addDashes = function (o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
            var width = o.attrs["stroke-width"] || "1",
                butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                dashes = [],
                i = value.length;
            while (i--) {
                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
            }
            $(o.node, {"stroke-dasharray": dashes.join(",")});
        }
    },
    setFillAndStroke = function (o, params) {
        var node = o.node,
            attrs = o.attrs,
            vis = node.style.visibility;
        node.style.visibility = "hidden";
        for (var att in params) {
            if (params[has](att)) {
                if (!R._availableAttrs[has](att)) {
                    continue;
                }
                var value = params[att];
                attrs[att] = value;
                switch (att) {
                    case "blur":
                        o.blur(value);
                        break;
                    case "href":
                    case "title":
                    case "target":
                        var pn = node.parentNode;
                        if (pn.tagName.toLowerCase() != "a") {
                            var hl = $("a");
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        if (att == "target") {
                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                        } else {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        break;
                    case "cursor":
                        node.style.cursor = value;
                        break;
                    case "transform":
                        o.transform(value);
                        break;
                    case "arrow-start":
                        addArrow(o, value);
                        break;
                    case "arrow-end":
                        addArrow(o, value, 1);
                        break;
                    case "clip-rect":
                        var rect = Str(value).split(separator);
                        if (rect.length == 4) {
                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            var el = $("clipPath"),
                                rc = $("rect");
                            el.id = R.createUUID();
                            $(rc, {
                                x: rect[0],
                                y: rect[1],
                                width: rect[2],
                                height: rect[3]
                            });
                            el.appendChild(rc);
                            o.paper.defs.appendChild(el);
                            $(node, {"clip-path": "url(#" + el.id + ")"});
                            o.clip = rc;
                        }
                        if (!value) {
                            var path = node.getAttribute("clip-path");
                            if (path) {
                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {"clip-path": E});
                                delete o.clip;
                            }
                        }
                    break;
                    case "path":
                        if (o.type == "path") {
                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                            o._.dirty = 1;
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "width":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fx) {
                            att = "x";
                            value = attrs.x;
                        } else {
                            break;
                        }
                    case "x":
                        if (attrs.fx) {
                            value = -attrs.x - (attrs.width || 0);
                        }
                    case "rx":
                        if (att == "rx" && o.type == "rect") {
                            break;
                        }
                    case "cx":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "height":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fy) {
                            att = "y";
                            value = attrs.y;
                        } else {
                            break;
                        }
                    case "y":
                        if (attrs.fy) {
                            value = -attrs.y - (attrs.height || 0);
                        }
                    case "ry":
                        if (att == "ry" && o.type == "rect") {
                            break;
                        }
                    case "cy":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "r":
                        if (o.type == "rect") {
                            $(node, {rx: value, ry: value});
                        } else {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = 1;
                        break;
                    case "src":
                        if (o.type == "image") {
                            node.setAttributeNS(xlink, "href", value);
                        }
                        break;
                    case "stroke-width":
                        /* FREEGROUP fix
                         * draw2d version 3.0.3
                         * 
                         * don't scale the line width if the user resize an shape/element.
                         * Obscure stroke-width in case of "Draw2D touch" usage
                         */
                        if(!attrs["stroke-scale"]){
                            if (o._.sx != 1 || o._.sy != 1) {
                                value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                            }
                            if (o.paper._vbSize) {
                                value *= o.paper._vbSize;
                            }
                        }

                        
                        node.setAttribute(att, value);
                        if (attrs["stroke-dasharray"]) {
                            addDashes(o, attrs["stroke-dasharray"], params);
                        }
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "stroke-dasharray":
                        addDashes(o, value, params);
                        break;
                    case "fill":
                        var isURL = Str(value).match(R._ISURL);
                        if (isURL) {
                            el = $("pattern");
                            var ig = $("image");
                            el.id = R.createUUID();
                            $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                            $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                            el.appendChild(ig);

                            (function (el) {
                                R._preload(isURL[1], function () {
                                    var w = this.offsetWidth,
                                        h = this.offsetHeight;
                                    $(el, {width: w, height: h});
                                    $(ig, {width: w, height: h});
                                    o.paper.safari();
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {fill: "url(#" + el.id + ")"});
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                            break;
                        }
                        var clr = R.getRGB(value);
                        if (!clr.error) {
                            delete params.gradient;
                            delete attrs.gradient;
                            !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {opacity: attrs.opacity});
                            !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {"fill-opacity": attrs["fill-opacity"]});
                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                }
                            }
                            attrs.gradient = value;
                            attrs.fill = "none";
                            break;
                        }
                        clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                    case "stroke":
                        clr = R.getRGB(value);
                        node.setAttribute(att, clr.hex);
                        att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        if (att == "stroke" && o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "gradient":
                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                        break;
                    case "opacity":
                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                            $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                        }
                        // fall
                    case "fill-opacity":
                        if (attrs.gradient) {
                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                stops = gradient.getElementsByTagName("stop");
                                
                                // FREEGROUP FIX
                                for (gri = 0, grii = stops.length; gri < grii; gri++) {
                                    $(stops[gri], {"stop-opacity": value});
                                }
//                                $(stops[stops.length - 1], {"stop-opacity": value});
                                // END FIX
                                
                            }
                            break;
                        }
                    default:
                        att == "font-size" && (value = toInt(value, 10) + "px");
                        var cssrule = att.replace(/(\-.)/g, function (w) {
                            return w.substring(1).toUpperCase();
                        });
                        node.style[cssrule] = value;
                        o._.dirty = 1;
                        node.setAttribute(att, value);
                        break;
                }
            }
        }

        tuneText(o, params);
        node.style.visibility = vis;
    },
    leading = 1.2,
    tuneText = function (el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
            return;
        }
        var a = el.attrs,
            node = el.node,
            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

        if (params[has]("text")) {
            a.text = params.text;
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var texts = Str(params.text).split("\n"),
                tspans = [],
                tspan;
            for (var i = 0, ii = texts.length; i < ii; i++) {
                tspan = $("tspan");
                i && $(tspan, {dy: fontSize * leading, x: a.x});
                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } else {
            tspans = node.getElementsByTagName("tspan");
            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                $(tspans[i], {dy: fontSize * leading, x: a.x});
            } else {
                $(tspans[0], {dy: 0});
            }
        }
        $(node, {x: a.x, y: a.y});
        el._.dirty = 1;
        var bb = el._getBBox(),
            dif = a.y - (bb.y + bb.height / 2);
        dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
    },
    Element = function (node, svg) {
        var X = 0,
            Y = 0;
        
        this[0] = this.node = node;
        
        node.raphael = true;
        
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.matrix = R.matrix();
        this.realPath = null;
        
        this.paper = svg;
        this.attrs = this.attrs || {};
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        
        this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        
        this.next = null;
    },
    elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.path = function (pathString, SVG) {
        var el = $("path");
        SVG.canvas && SVG.canvas.appendChild(el);
        var p = new Element(el, SVG);
        p.type = "path";
        setFillAndStroke(p, {
            fill: "none",
            stroke: "#000",
            path: pathString
        });
        return p;
    };
    
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        return this;
    };
    
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(this, tstr);

        this.clip && $(this.clip, {transform: this.matrix.invert()});
        this.pattern && updatePosition(this);
        this.node && $(this.node, {transform: this.matrix});
    
        if (_.sx != 1 || _.sy != 1) {
            var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
            this.attr({"stroke-width": sw});
        }

        return this;
    };
    
    elproto.hide = function () {
        !this.removed && this.paper.safari(this.node.style.display = "none");
        return this;
    };
    
    elproto.show = function () {
        !this.removed && this.paper.safari(this.node.style.display = "");
        return this;
    };
    
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        var paper = this.paper;
        paper.__set__ && paper.__set__.exclude(this);
        eve.unbind("raphael.*.*." + this.id);
        if (this.gradient) {
            paper.defs.removeChild(this.gradient);
        }
        R._tear(this, paper);
        if (this.node.parentNode.tagName.toLowerCase() == "a") {
            this.node.parentNode.parentNode.removeChild(this.node.parentNode);
        } else {
            this.node.parentNode.removeChild(this.node);
        }
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto._getBBox = function () {
        if (this.node.style.display == "none") {
            this.show();
            var hide = true;
        }
        var bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch(e) {
            // Firefox 3.0.x plays badly here
        } finally {
            bbox = bbox || {};
        }
        hide && this.hide();
        return bbox;
    };
    
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (var subkey in par) if (par[has](subkey)) {
                params[subkey] = par[subkey];
            }
        }
        setFillAndStroke(this, params);
        return this;
    };
    
    elproto.toFront = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.tagName.toLowerCase() == "a") {
            this.node.parentNode.parentNode.appendChild(this.node.parentNode);
        } else {
            this.node.parentNode.appendChild(this.node);
        }
        var svg = this.paper;
        svg.top != this && R._tofront(this, svg);
        return this;
    };
    
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        var parent = this.node.parentNode;
        if (parent.tagName.toLowerCase() == "a") {
            parent.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild); 
        } else if (parent.firstChild != this.node) {
            parent.insertBefore(this.node, this.node.parentNode.firstChild);
        }
        R._toback(this, this.paper);
        var svg = this.paper;
        return this;
    };
    
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        var node = element.node || element[element.length - 1].node;
        if (node.nextSibling) {
            node.parentNode.insertBefore(this.node, node.nextSibling);
        } else {
            node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        var node = element.node || element[0].node;
        node.parentNode.insertBefore(this.node, node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
                blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {stdDeviation: +size || 1.5});
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {filter: "url(#" + fltr.id + ")"});
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
    };
    R._engine.circle = function (svg, x, y, r) {
        var el = $("circle");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
        res.type = "circle";
        $(el, res.attrs);
        return res;
    };
    R._engine.rect = function (svg, x, y, w, h, r) {
        var el = $("rect");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
        res.type = "rect";
        $(el, res.attrs);
        return res;
    };
    R._engine.ellipse = function (svg, x, y, rx, ry) {
        var el = $("ellipse");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
    };
    R._engine.image = function (svg, src, x, y, w, h) {
        var el = $("image");
        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
        el.setAttributeNS(xlink, "href", src);
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, src: src};
        res.type = "image";
        return res;
    };
    R._engine.text = function (svg, x, y, text) {
        var el = $("text");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {
            x: x,
            y: y,
            "text-anchor": "middle",
            text: text,
            font: R._availableAttrs.font,
            stroke: "none",
            fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
    };
    R._engine.setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con && con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
            css = "overflow:hidden;",
            isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function () {});
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var size = mmax(w / this.width, h / this.height),
            top = this.top,
            aspectRatio = fit ? "meet" : "xMinYMin",
            vb,
            sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({"stroke-width": sw});
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };
    
    R.prototype.renderfix = function () {
        var cnvs = this.canvas,
            s = cnvs.style,
            pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
            top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };
    
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        var c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
        c.appendChild(this.desc);
        c.appendChild(this.defs = $("defs"));
    };
    
    R.prototype.remove = function () {
        eve("raphael.remove", this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
    };
    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}(window.Raphael);

// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël - JavaScript Vector Library                                 │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ VML Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\
window.Raphael.vml && function (R) {
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = R.eve,
        ms = " progid:DXImageTransform.Microsoft",
        S = " ",
        E = "",
        map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
        zoom = 21600,
        pathTypes = {path: 1, rect: 1, image: 1},
        ovalTypes = {circle: 1, ellipse: 1},
        path2vml = function (path) {
            var total =  /[ahqstv]/ig,
                command = R._pathToAbsolute;
            Str(path).match(total) && (command = R._path2curve);
            total = /[clmz]/g;
            if (command == R._pathToAbsolute && !Str(path).match(total)) {
                var res = Str(path).replace(bites, function (all, command, args) {
                    var vals = [],
                        isMove = command.toLowerCase() == "m",
                        res = map[command];
                    args.replace(val, function (value) {
                        if (isMove && vals.length == 2) {
                            res += vals + map[command == "m" ? "l" : "L"];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    return res + vals;
                });
                return res;
            }
            var pa = command(path), p, r;
            res = [];
            for (var i = 0, ii = pa.length; i < ii; i++) {
                p = pa[i];
                r = pa[i][0].toLowerCase();
                r == "z" && (r = "x");
                for (var j = 1, jj = p.length; j < jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                }
                res.push(r);
            }
            return res.join(S);
        },
        compensation = function (deg, dx, dy) {
            var m = R.matrix();
            m.rotate(-deg, .5, .5);
            return {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = function (p, sx, sy, dx, dy, deg) {
            var _ = p._,
                m = p.matrix,
                fillpos = _.fillpos,
                o = p.node,
                s = o.style,
                y = 1,
                flip = "",
                dxdy,
                kx = zoom / sx,
                ky = zoom / sy;
            s.visibility = "hidden";
            if (!sx || !sy) {
                return;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy < 0 ? -1 : 1);
            if (deg) {
                var c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx < 0 && (flip += "x");
            sy < 0 && (flip += " y") && (y = -1);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            if (fillpos || _.fillsize) {
                var fill = o.getElementsByTagName(fillString);
                fill = fill && fill[0];
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = "visible";
        };
    R.toString = function () {
        return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    var addArrow = function (o, value, isEnd) {
        var values = Str(value).toLowerCase().split("-"),
            se = isEnd ? "end" : "start",
            i = values.length,
            type = "classic",
            w = "medium",
            h = "medium";
        while (i--) {
            switch (values[i]) {
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                    type = values[i];
                    break;
                case "wide":
                case "narrow": h = values[i]; break;
                case "long":
                case "short": w = values[i]; break;
            }
        }
        var stroke = o.node.getElementsByTagName("stroke")[0];
        stroke[se + "arrow"] = type;
        stroke[se + "arrowlength"] = w;
        stroke[se + "arrowwidth"] = h;
    },
    setFillAndStroke = function (o, params) {
        // o.paper.canvas.style.display = "none";
        o.attrs = o.attrs || {};
        var node = o.node,
            a = o.attrs,
            s = node.style,
            xy,
            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
            res = o;


        for (var par in params) if (params[has](par)) {
            a[par] = params[par];
        }
        if (newpath) {
            a.path = R._getPath[o.type](o);
            o._.dirty = 1;
        }
        params.href && (node.href = params.href);
        params.title && (node.title = params.title);
        params.target && (node.target = params.target);
        params.cursor && (s.cursor = params.cursor);
        "blur" in params && o.blur(params.blur);
        if (params.path && o.type == "path" || newpath) {
            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
            if (o.type == "image") {
                o._.fillpos = [a.x, a.y];
                o._.fillsize = [a.width, a.height];
                setCoords(o, 1, 1, 0, 0, 0);
            }
        }
        "transform" in params && o.transform(params.transform);
        if (isOval) {
            var cx = +a.cx,
                cy = +a.cy,
                rx = +a.rx || +a.r || 0,
                ry = +a.ry || +a.r || 0;
            node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
        }
        if ("clip-rect" in params) {
            var rect = Str(params["clip-rect"]).split(separator);
            if (rect.length == 4) {
                rect[2] = +rect[2] + (+rect[0]);
                rect[3] = +rect[3] + (+rect[1]);
                var div = node.clipRect || R._g.doc.createElement("div"),
                    dstyle = div.style;
                dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                if (!node.clipRect) {
                    dstyle.position = "absolute";
                    dstyle.top = 0;
                    dstyle.left = 0;
                    dstyle.width = o.paper.width + "px";
                    dstyle.height = o.paper.height + "px";
                    node.parentNode.insertBefore(div, node);
                    div.appendChild(node);
                    node.clipRect = div;
                }
            }
            if (!params["clip-rect"]) {
                node.clipRect && (node.clipRect.style.clip = "auto");
            }
        }
        if (o.textpath) {
            var textpathStyle = o.textpath.style;
            params.font && (textpathStyle.font = params.font);
            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
        }
        if ("arrow-start" in params) {
            addArrow(res, params["arrow-start"]);
        }
        if ("arrow-end" in params) {
            addArrow(res, params["arrow-end"], 1);
        }
        if (params.opacity != null || 
            params["stroke-width"] != null ||
            params.fill != null ||
            params.src != null ||
            params.stroke != null ||
            params["stroke-width"] != null ||
            params["stroke-opacity"] != null ||
            params["fill-opacity"] != null ||
            params["stroke-dasharray"] != null ||
            params["stroke-miterlimit"] != null ||
            params["stroke-linejoin"] != null ||
            params["stroke-linecap"] != null) {
            var fill = node.getElementsByTagName(fillString),
                newfill = false;
            fill = fill && fill[0];
            !fill && (newfill = fill = createNode(fillString));
            if (o.type == "image" && params.src) {
                fill.src = params.src;
            }
            params.fill && (fill.on = true);
            if (fill.on == null || params.fill == "none" || params.fill === null) {
                fill.on = false;
            }
            if (fill.on && params.fill) {
                var isURL = Str(params.fill).match(R._ISURL);
                if (isURL) {
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = isURL[1];
                    fill.type = "tile";
                    var bbox = o.getBBox(1);
                    fill.position = bbox.x + S + bbox.y;
                    o._.fillpos = [bbox.x, bbox.y];

                    R._preload(isURL[1], function () {
                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                    });
                } else {
                    fill.color = R.getRGB(params.fill).hex;
                    fill.src = E;
                    fill.type = "solid";
                    if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                        a.fill = "none";
                        a.gradient = params.fill;
                        fill.rotate = false;
                    }
                }
            }
            if ("fill-opacity" in params || "opacity" in params) {
                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                opacity = mmin(mmax(opacity, 0), 1);
                fill.opacity = opacity;
                if (fill.src) {
                    fill.color = "none";
                }
            }
            node.appendChild(fill);
            var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
            newstroke = false;
            !stroke && (newstroke = stroke = createNode("stroke"));
            if ((params.stroke && params.stroke != "none") ||
                params["stroke-width"] ||
                params["stroke-opacity"] != null ||
                params["stroke-dasharray"] ||
                params["stroke-miterlimit"] ||
                params["stroke-linejoin"] ||
                params["stroke-linecap"]) {
                stroke.on = true;
            }
            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
            var strokeColor = R.getRGB(params.stroke);
            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
            var width = (toFloat(params["stroke-width"]) || 1) * .75;
            opacity = mmin(mmax(opacity, 0), 1);
            params["stroke-width"] == null && (width = a["stroke-width"]);
            params["stroke-width"] && (stroke.weight = width);
            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
            stroke.opacity = opacity;
        
            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
            stroke.miterlimit = params["stroke-miterlimit"] || 8;
            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
            if (params["stroke-dasharray"]) {
                var dasharray = {
                    "-": "shortdash",
                    ".": "shortdot",
                    "-.": "shortdashdot",
                    "-..": "shortdashdotdot",
                    ". ": "dot",
                    "- ": "dash",
                    "--": "longdash",
                    "- .": "dashdot",
                    "--.": "longdashdot",
                    "--..": "longdashdotdot"
                };
                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
            }
            newstroke && node.appendChild(stroke);
        }
        if (res.type == "text") {
            res.paper.canvas.style.display = E;
            var span = res.paper.span,
                m = 100,
                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
            s = span.style;
            a.font && (s.font = a.font);
            a["font-family"] && (s.fontFamily = a["font-family"]);
            a["font-weight"] && (s.fontWeight = a["font-weight"]);
            a["font-style"] && (s.fontStyle = a["font-style"]);
            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
            s.fontSize = fontSize * m + "px";
            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
            var brect = span.getBoundingClientRect();
            res.W = a.w = (brect.right - brect.left) / m;
            res.H = a.h = (brect.bottom - brect.top) / m;
            // res.paper.canvas.style.display = "none";
            res.X = a.x;
            res.Y = a.y + res.H / 2;

            ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                res._.dirty = 1;
                break;
            }
        
            // text-anchor emulation
            switch (a["text-anchor"]) {
                case "start":
                    res.textpath.style["v-text-align"] = "left";
                    res.bbx = res.W / 2;
                break;
                case "end":
                    res.textpath.style["v-text-align"] = "right";
                    res.bbx = -res.W / 2;
                break;
                default:
                    res.textpath.style["v-text-align"] = "center";
                    res.bbx = 0;
                break;
            }
            res.textpath.style["v-text-kern"] = true;
        }
        // res.paper.canvas.style.display = E;
    },
    addGradientFill = function (o, gradient, fill) {
        o.attrs = o.attrs || {};
        var attrs = o.attrs,
            pow = Math.pow,
            opacity,
            oindex,
            type = "linear",
            fxfy = ".5 .5";
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
            type = "radial";
            if (fx && fy) {
                fx = toFloat(fx);
                fy = toFloat(fy);
                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                fxfy = fx + S + fy;
            }
            return E;
        });
        gradient = gradient.split(/\s*\-\s*/);
        if (type == "linear") {
            var angle = gradient.shift();
            angle = -toFloat(angle);
            if (isNaN(angle)) {
                return null;
            }
        }
        var dots = R._parseDots(gradient);
        if (!dots) {
            return null;
        }
        o = o.shape || o.node;
        if (dots.length) {
            o.removeChild(fill);
            fill.on = true;
            fill.method = "none";
            fill.color = dots[0].color;
            fill.color2 = dots[dots.length - 1].color;
            var clrs = [];
            for (var i = 0, ii = dots.length; i < ii; i++) {
                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
            }
            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
            if (type == "radial") {
                fill.type = "gradientTitle";
                fill.focus = "100%";
                fill.focussize = "0 0";
                fill.focusposition = fxfy;
                fill.angle = 0;
            } else {
                // fill.rotate= true;
                fill.type = "gradient";
                fill.angle = (270 - angle) % 360;
            }
            o.appendChild(fill);
        }
        return 1;
    },
    Element = function (node, vml) {
        this[0] = this.node = node;
        node.raphael = true;
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.X = 0;
        this.Y = 0;
        this.attrs = {};
        this.paper = vml;
        this.matrix = R.matrix();
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            dx: 0,
            dy: 0,
            deg: 0,
            dirty: 1,
            dirtyT: 1
        };
        !vml.bottom && (vml.bottom = this);
        this.prev = vml.top;
        vml.top && (vml.top.next = this);
        vml.top = this;
        this.next = null;
    };
    var elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;
        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }
        R._extractTransform(this, vbt + tstr);
        var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
        matrix.translate(-.5, -.5);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if ((isGrad && split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    dx = bb.x - bbt.x,
                    dy = bb.y - bbt.y;
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        oldt && (this._.transform = oldt);
        return this;
    };
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this._.dirtyT = 1;
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (this._.bbox) {
            this._.bbox.x += dx;
            this._.bbox.y += dy;
        }
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
    
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        this._.dirtyT = 1;
        return this;
    };
    elproto.hide = function () {
        !this.removed && (this.node.style.display = "none");
        return this;
    };
    elproto.show = function () {
        !this.removed && (this.node.style.display = E);
        return this;
    };
    elproto._getBBox = function () {
        if (this.removed) {
            return {};
        }
        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y - this.H,
            width: this.W,
            height: this.H
        };
    };
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        this.paper.__set__ && this.paper.__set__.exclude(this);
        R.eve.unbind("raphael.*.*." + this.id);
        R._tear(this, this.paper);
        this.node.parentNode.removeChild(this.node);
        this.shape && this.shape.parentNode.removeChild(this.shape);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && R.is(name, "object") && (params = name);
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        if (params) {
            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            // this.paper.canvas.style.display = "none";
            if (params.text && this.type == "text") {
                this.textpath.string = params.text;
            }
            setFillAndStroke(this, params);
            // this.paper.canvas.style.display = E;
        }
        return this;
    };
    elproto.toFront = function () {
        !this.removed && this.node.parentNode.appendChild(this.node);
        this.paper && this.paper.top != this && R._tofront(this, this.paper);
        return this;
    };
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.firstChild != this.node) {
            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
            R._toback(this, this.paper);
        }
        return this;
    };
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[element.length - 1];
        }
        if (element.node.nextSibling) {
            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
        } else {
            element.node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[0];
        }
        element.node.parentNode.insertBefore(this.node, element.node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        var s = this.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
    };

    R._engine.path = function (pathString, vml) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;
        var p = new Element(el, vml),
            attr = {fill: "none", stroke: "#000"};
        pathString && (attr.path = pathString);
        p.type = "path";
        p.path = [];
        p.Path = E;
        setFillAndStroke(p, attr);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.rect = function (vml, x, y, w, h, r) {
        var path = R._rectPath(x, y, w, h, r),
            res = vml.path(path),
            a = res.attrs;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.r = r;
        a.path = path;
        res.type = "rect";
        return res;
    };
    R._engine.ellipse = function (vml, x, y, rx, ry) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - rx;
        res.Y = y - ry;
        res.W = rx * 2;
        res.H = ry * 2;
        res.type = "ellipse";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            rx: rx,
            ry: ry
        });
        return res;
    };
    R._engine.circle = function (vml, x, y, r) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - r;
        res.Y = y - r;
        res.W = res.H = r * 2;
        res.type = "circle";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            r: r
        });
        return res;
    };
    R._engine.image = function (vml, src, x, y, w, h) {
        var path = R._rectPath(x, y, w, h),
            res = vml.path(path).attr({stroke: "none"}),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];
        a.src = src;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.path = path;
        res.type = "image";
        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = src;
        fill.type = "tile";
        res._.fillpos = [x, y];
        res._.fillsize = [w, h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    R._engine.text = function (vml, x, y, text) {
        var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
        x = x || 0;
        y = y || 0;
        text = text || "";
        path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(text);
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml),
            attr = {
                fill: "#000",
                stroke: "none",
                font: R._availableAttrs.font,
                text: text
            };
        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(text);
        p.attrs.x = x;
        p.attrs.y = y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        setFillAndStroke(p, attr);
        el.appendChild(o);
        el.appendChild(path);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.setSize = function (width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        cs.width = width;
        cs.height = height;
        cs.clip = "rect(0 " + width + " " + height + " 0)";
        if (this._viewBox) {
            R._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var width = this.width,
            height = this.height,
            size = 1 / mmax(w / width, h / height),
            H, W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: size
        };
        this.forEach(function (el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    R._engine.initWin = function (win) {
            var doc = win.document;
            doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
            try {
                !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                createNode = function (tagName) {
                    return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                };
            } catch (e) {
                createNode = function (tagName) {
                    return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                };
            }
        };
    R._engine.initWin(R._g.win);
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new R._Paper,
            c = res.canvas = R._g.doc.createElement("div"),
            cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        res.span = R._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            R._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function () {};
        return res;
    };
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    R.prototype.remove = function () {
        R.eve("raphael.remove", this);
        this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}(window.Raphael);

/***/ }),
/* 45 */
/***/ (function(module, exports) {

/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    };
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    };

    // help
    this.getHelpXML = function () {

        var examples = [];
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}



/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/*! shifty - v1.2.1 - 2014-04-26 - http://jeremyckahn.github.io/shifty */
(function(t){var n=function(){"use strict";function n(){}function e(t,n){var e;for(e in t)Object.hasOwnProperty.call(t,e)&&n(e)}function r(t,n){return e(n,function(e){t[e]=n[e]}),t}function i(t,n){e(n,function(e){t[e]===void 0&&(t[e]=n[e])})}function o(t,n,e,r,i,o,a){var s,c=(t-o)/i;for(s in n)n.hasOwnProperty(s)&&(n[s]=u(e[s],r[s],h[a[s]],c));return n}function u(t,n,e,r){return t+(n-t)*e(r)}function a(t,n){var r=f.prototype.filter,i=t._filterArgs;e(r,function(e){r[e][n]!==void 0&&r[e][n].apply(t,i)})}function s(t,n,e,r,i,u,s,c,f){d=n+e,v=Math.min(m(),d),y=v>=d,t.isPlaying()&&!y?(f(t._timeoutHandler,_),a(t,"beforeTween"),o(v,r,i,u,e,n,s),a(t,"afterTween"),c(r)):y&&(c(u),t.stop(!0))}function c(t,n){var r={};return"string"==typeof n?e(t,function(t){r[t]=n}):e(t,function(t){r[t]||(r[t]=n[t]||l)}),r}function f(t,n){this._currentState=t||{},this._configured=!1,this._scheduleFunction=p,n!==void 0&&this.setConfig(n)}var h,p,l="linear",w=500,_=1e3/60,g=Date.now?Date.now:function(){return+new Date},m=g;p="undefined"!=typeof window?window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||window.mozCancelRequestAnimationFrame&&window.mozRequestAnimationFrame||setTimeout:setTimeout;var d,v,y;return f.prototype.tween=function(t){return this._isTweening?this:(void 0===t&&this._configured||this.setConfig(t),this._start(this.get()),this.resume())},f.prototype.setConfig=function(t){t=t||{},this._configured=!0,this._pausedAtTime=null,this._start=t.start||n,this._step=t.step||n,this._finish=t.finish||n,this._duration=t.duration||w,this._currentState=t.from||this.get(),this._originalState=this.get(),this._targetState=t.to||this.get(),this._timestamp=m();var e=this._currentState,r=this._targetState;return i(r,e),this._easing=c(e,t.easing||l),this._filterArgs=[e,this._originalState,r,this._easing],a(this,"tweenCreated"),this},f.prototype.get=function(){return r({},this._currentState)},f.prototype.set=function(t){this._currentState=t},f.prototype.pause=function(){return this._pausedAtTime=m(),this._isPaused=!0,this},f.prototype.resume=function(){this._isPaused&&(this._timestamp+=m()-this._pausedAtTime),this._isPaused=!1,this._isTweening=!0;var t=this;return this._timeoutHandler=function(){s(t,t._timestamp,t._duration,t._currentState,t._originalState,t._targetState,t._easing,t._step,t._scheduleFunction)},this._timeoutHandler(),this},f.prototype.stop=function(t){return this._isTweening=!1,this._isPaused=!1,this._timeoutHandler=n,t&&(r(this._currentState,this._targetState),a(this,"afterTweenEnd"),this._finish.call(this,this._currentState)),this},f.prototype.isPlaying=function(){return this._isTweening&&!this._isPaused},f.prototype.setScheduleFunction=function(t){this._scheduleFunction=t},f.prototype.dispose=function(){var t;for(t in this)this.hasOwnProperty(t)&&delete this[t]},f.prototype.filter={},f.prototype.formula={linear:function(t){return t}},h=f.prototype.formula,r(f,{now:m,each:e,tweenProps:o,tweenProp:u,applyFilter:a,shallowCopy:r,defaults:i,composeEasingObject:c}), true?module.exports=f:"function"==typeof define&&define.amd?define(function(){return f}):t.Tweenable===void 0&&(t.Tweenable=f),f}();(function(){n.shallowCopy(n.prototype.formula,{easeInQuad:function(t){return Math.pow(t,2)},easeOutQuad:function(t){return-(Math.pow(t-1,2)-1)},easeInOutQuad:function(t){return 1>(t/=.5)?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},easeInCubic:function(t){return Math.pow(t,3)},easeOutCubic:function(t){return Math.pow(t-1,3)+1},easeInOutCubic:function(t){return 1>(t/=.5)?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},easeInQuart:function(t){return Math.pow(t,4)},easeOutQuart:function(t){return-(Math.pow(t-1,4)-1)},easeInOutQuart:function(t){return 1>(t/=.5)?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeInQuint:function(t){return Math.pow(t,5)},easeOutQuint:function(t){return Math.pow(t-1,5)+1},easeInOutQuint:function(t){return 1>(t/=.5)?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},easeInSine:function(t){return-Math.cos(t*(Math.PI/2))+1},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:-Math.pow(2,-10*t)+1},easeInOutExpo:function(t){return 0===t?0:1===t?1:1>(t/=.5)?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-Math.pow(t-1,2))},easeInOutCirc:function(t){return 1>(t/=.5)?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeOutBounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInBack:function(t){var n=1.70158;return t*t*((n+1)*t-n)},easeOutBack:function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},easeInOutBack:function(t){var n=1.70158;return 1>(t/=.5)?.5*t*t*(((n*=1.525)+1)*t-n):.5*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)},elastic:function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*2*Math.PI/2)+1},swingFromTo:function(t){var n=1.70158;return 1>(t/=.5)?.5*t*t*(((n*=1.525)+1)*t-n):.5*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)},swingFrom:function(t){var n=1.70158;return t*t*((n+1)*t-n)},swingTo:function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},bounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},bouncePast:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?2-(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},easeFromTo:function(t){return 1>(t/=.5)?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeFrom:function(t){return Math.pow(t,4)},easeTo:function(t){return Math.pow(t,.25)}})})(),function(){function t(t,n,e,r,i,o){function u(t){return((l*t+w)*t+_)*t}function a(t){return((g*t+m)*t+d)*t}function s(t){return(3*l*t+2*w)*t+_}function c(t){return 1/(200*t)}function f(t,n){return a(p(t,n))}function h(t){return t>=0?t:0-t}function p(t,n){var e,r,i,o,a,c;for(i=t,c=0;8>c;c++){if(o=u(i)-t,n>h(o))return i;if(a=s(i),1e-6>h(a))break;i-=o/a}if(e=0,r=1,i=t,e>i)return e;if(i>r)return r;for(;r>e;){if(o=u(i),n>h(o-t))return i;t>o?e=i:r=i,i=.5*(r-e)+e}return i}var l=0,w=0,_=0,g=0,m=0,d=0;return _=3*n,w=3*(r-n)-_,l=1-_-w,d=3*e,m=3*(i-e)-d,g=1-d-m,f(t,c(o))}function e(n,e,r,i){return function(o){return t(o,n,e,r,i,1)}}n.setBezierFunction=function(t,r,i,o,u){var a=e(r,i,o,u);return a.x1=r,a.y1=i,a.x2=o,a.y2=u,n.prototype.formula[t]=a},n.unsetBezierFunction=function(t){delete n.prototype.formula[t]}}(),function(){function t(t,e,r,i,o){return n.tweenProps(i,e,t,r,1,0,o)}var e=new n;e._filterArgs=[],n.interpolate=function(r,i,o,u){var a=n.shallowCopy({},r),s=n.composeEasingObject(r,u||"linear");e.set({});var c=e._filterArgs;c.length=0,c[0]=a,c[1]=r,c[2]=i,c[3]=s,n.applyFilter(e,"tweenCreated"),n.applyFilter(e,"beforeTween");var f=t(r,a,i,o,s);return n.applyFilter(e,"afterTween"),f}}(),function(t){function n(t,n){k.length=0;var e,r=t.length;for(e=0;r>e;e++)k.push("_"+n+"_"+e);return k}function e(t){var n=t.match(y);return n?1===n.length&&n.unshift(""):n=["",""],n.join(T)}function r(n){t.each(n,function(t){var e=n[t];"string"==typeof e&&e.match(I)&&(n[t]=i(e))})}function i(t){return s(I,t,o)}function o(t){var n=u(t);return"rgb("+n[0]+","+n[1]+","+n[2]+")"}function u(t){return t=t.replace(/#/,""),3===t.length&&(t=t.split(""),t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]),F[0]=a(t.substr(0,2)),F[1]=a(t.substr(2,2)),F[2]=a(t.substr(4,2)),F}function a(t){return parseInt(t,16)}function s(t,n,e){var r=n.match(t),i=n.replace(t,T);if(r)for(var o,u=r.length,a=0;u>a;a++)o=r.shift(),i=i.replace(T,e(o));return i}function c(t){return s(O,t,f)}function f(t){for(var n=t.match(M),e=n.length,r=t.match(b)[0],i=0;e>i;i++)r+=parseInt(n[i],10)+",";return r=r.slice(0,-1)+")"}function h(r){var i={};return t.each(r,function(t){var o=r[t];if("string"==typeof o){var u=m(o);i[t]={formatString:e(o),chunkNames:n(u,t)}}}),i}function p(n,e){t.each(e,function(t){for(var r=n[t],i=m(r),o=i.length,u=0;o>u;u++)n[e[t].chunkNames[u]]=+i[u];delete n[t]})}function l(n,e){t.each(e,function(t){var r=n[t],i=w(n,e[t].chunkNames),o=_(i,e[t].chunkNames);r=g(e[t].formatString,o),n[t]=c(r)})}function w(t,n){for(var e,r={},i=n.length,o=0;i>o;o++)e=n[o],r[e]=t[e],delete t[e];return r}function _(t,n){S.length=0;for(var e=n.length,r=0;e>r;r++)S.push(t[n[r]]);return S}function g(t,n){for(var e=t,r=n.length,i=0;r>i;i++)e=e.replace(T,+n[i].toFixed(4));return e}function m(t){return t.match(M)}function d(n,e){t.each(e,function(t){for(var r=e[t],i=r.chunkNames,o=i.length,u=n[t].split(" "),a=u[u.length-1],s=0;o>s;s++)n[i[s]]=u[s]||a;delete n[t]})}function v(n,e){t.each(e,function(t){for(var r=e[t],i=r.chunkNames,o=i.length,u="",a=0;o>a;a++)u+=" "+n[i[a]],delete n[i[a]];n[t]=u.substr(1)})}var y=/([^\-0-9\.]+)/g,M=/[0-9.\-]+/g,O=RegExp("rgb\\("+M.source+/,\s*/.source+M.source+/,\s*/.source+M.source+"\\)","g"),b=/^.*\(/,I=/#([0-9]|[a-f]){3,6}/gi,T="VAL",k=[],F=[],S=[];t.prototype.filter.token={tweenCreated:function(t,n,e){r(t),r(n),r(e),this._tokenData=h(t)},beforeTween:function(t,n,e,r){d(r,this._tokenData),p(t,this._tokenData),p(n,this._tokenData),p(e,this._tokenData)},afterTween:function(t,n,e,r){l(t,this._tokenData),l(n,this._tokenData),l(e,this._tokenData),v(r,this._tokenData)}}}(n)})(this);

/***/ }),
/* 47 */
/***/ (function(module, exports) {

/**
 * Created by David on 2017/3/29.
 */

var XML;
if (!XML) {
    XML = {};
}

(function () {
    'use strict';

    XML.toXML = function(obj, config){
    // include XML header
    config = config || {};
    var out = '';
    if(config.header) {
        if(typeof config.header == 'string') {
            out = config.header;
        } else {
            out = '<?xml version="1.0" encoding="UTF-8"?>\n';
        }
    }

    var origIndent = config.indent || '';
    var indent = '';

    var filter = function customFilter(txt) {
        if(!config.filter) return txt;
        var mappings = config.filter;
        var replacements = [];
        for(var map in mappings) {
            if(!mappings.hasOwnProperty(map)) continue;
            replacements.push(map);
        }
        return String(txt).replace(new RegExp('(' + replacements.join('|') + ')', 'g'), function(str, entity) {
            return mappings[entity] || '';
        });
    };

    // helper function to push a new line to the output
    var push = function(string){
        out += string + (origIndent ? '\n' : '');
    };

    /* create a tag and add it to the output
     Example:
     outputTag({
     name: 'myTag',      // creates a tag <myTag>
     indent: '  ',       // indent string to prepend
     closeTag: true,     // starts and closes a tag on the same line
     selfCloseTag: true,
     attrs: {            // attributes
     foo: 'bar',       // results in <myTag foo="bar">
     foo2: 'bar2'
     }
     });
     */
    var outputTag = function(tag){
        var attrsString = '';
        var outputString = '';
        var attrs = tag.attrs || '';

        // turn the attributes object into a string with key="value" pairs
        for(var attr in attrs){
            if(attrs.hasOwnProperty(attr)) {
                attrsString += ' ' + attr + '="' + attrs[attr] + '"';
            }
        }

        // assemble the tag
        outputString += (tag.indent || '') + '<' + (tag.closeTag ? '/' : '') + tag.name + (!tag.closeTag ? attrsString : '') + (tag.selfCloseTag ? '/' : '') + '>';

        // if the tag only contains a text string, output it and close the tag
        if(tag.text || tag.text === ''){
            outputString += filter(tag.text) + '</' + tag.name + '>';
        }

        push(outputString);
    };

    // custom-tailored iterator for input arrays/objects (NOT a general purpose iterator)
    var every = function(obj, fn, indent){
        // array
        if(Array.isArray(obj)){
            obj.every(function(elt){  // for each element in the array
                fn(elt, indent);
                return true;            // continue to iterate
            });

            return;
        }

        // object with tag name
        if(obj._name){
            fn(obj, indent);
            return;
        }

        // iterable object
        for(var key in obj){
            var type = typeof obj[key];

            if(obj.hasOwnProperty(key) && (obj[key] || type === 'boolean' || type === 'number')){
                fn({_name: key, _content: obj[key]}, indent);
                //} else if(!obj[key]) {   // null value (foo:'')
            } else if(obj.hasOwnProperty(key) && obj[key] === null) {   // null value (foo:null)
                fn(key, indent);       // output the keyname as a string ('foo')
            } else if(obj.hasOwnProperty(key) && obj[key] === '') {
                // blank string
                outputTag({
                    name: key,
                    text: ''
                });
            }
        }
    };

    var convert = function convert(input, indent){
        var type = typeof input;

        if(!indent) {
            indent = '';
        }

        if(Array.isArray(input))  {
            type = 'array';
        }

        var path = {
            'string': function(){
                push(indent + filter(input));
            },

            'boolean': function(){
                push(indent + (input ? 'true' : 'false'));
            },

            'number': function(){
                push(indent + input);
            },

            'array': function(){
                every(input, convert, indent);
            },

            'function': function(){
                push(indent + input());
            },

            'object': function(){
                if(!input._name){
                    every(input, convert, indent);
                    return;
                }

                var outputTagObj = {
                    name: input._name,
                    indent: indent,
                    attrs: input._attrs
                };

                var type = typeof input._content;

                if(type === 'undefined' || input._content._selfCloseTag === true){
                    if (input._content && input._content._attrs) {
                        outputTagObj.attrs = input._content._attrs;
                    }
                    outputTagObj.selfCloseTag = true;
                    outputTag(outputTagObj);
                    return;
                }

                var objContents = {
                    'string': function(){
                        outputTagObj.text = input._content;
                        outputTag(outputTagObj);
                    },

                    'boolean': function(){
                        outputTagObj.text = (input._content ? 'true' : 'false');
                        outputTag(outputTagObj);
                    },

                    'number': function(){
                        outputTagObj.text = input._content.toString();
                        outputTag(outputTagObj);
                    },

                    'object': function(){  // or Array
                        outputTag(outputTagObj);

                        every(input._content, convert, indent + origIndent);

                        outputTagObj.closeTag = true;
                        outputTag(outputTagObj);
                    },

                    'function': function(){
                        outputTagObj.text = input._content();  // () to execute the fn
                        outputTag(outputTagObj);
                    }
                };

                if(objContents[type]) objContents[type]();
            }

        };

        if(path[type]) path[type]();
    };

    convert(obj, indent);

    return out;
}}());

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v1.9.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-2-4
 */
(function( window, undefined ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//"use strict";
var
	// The deferred used on DOM ready
	readyList,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// Support: IE<9
	// For `typeof node.method` instead of `node.method !== undefined`
	core_strundefined = typeof undefined,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// [[Class]] -> type pairs
	class2type = {},

	// List of deleted data cache ids, so we can reuse them
	core_deletedIds = [],

	core_version = "1.9.1",

	// Save a reference to some core methods
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

	// Used for splitting on whitespace
	core_rnotwhite = /\S+/g,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	// The ready event handler
	completed = function( event ) {

		// readyState === "complete" is good enough for us to call the dom ready in oldIE
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	},
	// Clean-up method for dom ready events
	detach = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );

		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );
		if ( scripts ) {
			jQuery( scripts ).remove();
		}
		return jQuery.merge( [], parsed.childNodes );
	},

	parseJSON: function( data ) {
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		if ( data === null ) {
			return data;
		}

		if ( typeof data === "string" ) {

			// Make sure leading/trailing whitespace is removed (IE can't handle it)
			data = jQuery.trim( data );

			if ( data ) {
				// Make sure the incoming data is actual JSON
				// Logic borrowed from http://json.org/json2.js
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return core_concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support, all, a,
		input, select, fragment,
		opt, eventName, isSupported, i,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Support tests won't run in some limited or non-browser environments
	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !all || !a || !all.length ) {
		return {};
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";
	support = {
		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: div.firstChild.nodeType === 3,

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: a.getAttribute("href") === "/a",

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
		checkOn: !!input.value,

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Tests for enctype support on a form (#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: document.compatMode === "CSS1Compat",

		// Will be defined later
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<9
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	// Check if we can trust getAttribute("value")
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, marginDiv, tds,
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

		body.appendChild( container ).appendChild( div );

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Support: IE8
		// Check if empty table cells still have offsetWidth/Height
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = div.appendChild( document.createElement("div") );
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";

			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== core_strundefined ) {
			// Support: IE<8
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Support: IE6
			// Check if elements with layout shrink-wrap their children
			div.style.display = "block";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			if ( support.inlineBlockNeedsLayout ) {
				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				// Support: IE<8
				body.style.zoom = 1;
			}
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	all = select = fragment = opt = a = input = null;

	return support;
})();

var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

function internalData( elem, name, data, pvt /* Internal Use Only */ ){
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, ret,
		internalKey = jQuery.expando,
		getByName = typeof name === "string",

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			elem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		cache[ id ] = {};

		// Avoids exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		if ( !isNode ) {
			cache[ id ].toJSON = jQuery.noop;
		}
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( getByName ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var i, l, thisCache,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			for ( i = 0, l = name.length; i < l; i++ ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		// Do not set data on non-element because it will not be cleared (#8335).
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
			return false;
		}

		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var attrs, name,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attrs = elem.attributes;
					for ( ; i < attrs.length; i++ ) {
						name = attrs[i].name;

						if ( !name.indexOf( "data-" ) ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				// Try to fetch any internally stored data first
				return elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
			}

			this.each(function() {
				jQuery.data( this, key, value );
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		hooks.cur = fn;
		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i,
	rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	getSetInput = jQuery.support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}
					elem.className = jQuery.trim( cur );

				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}
					elem.className = value ? jQuery.trim( cur ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.match( core_rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			// Toggle whole class name
			} else if ( type === core_strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attr: function( elem, name, value ) {
		var hooks, notxml, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && notxml && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && notxml && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			// In IE9+, Flash objects don't have .getAttribute (#12945)
			// Support: IE9+
			if ( typeof elem.getAttribute !== core_strundefined ) {
				ret =  elem.getAttribute( name );
			}

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( rboolean.test( name ) ) {
					// Set corresponding property to false for boolean attributes
					// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8
					if ( !getSetAttribute && ruseDefault.test( name ) ) {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					} else {
						elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		var
			// Use .prop to determine if this attribute is understood as boolean
			prop = jQuery.prop( elem, name ),

			// Fetch it accordingly
			attr = typeof prop === "boolean" && elem.getAttribute( name ),
			detail = typeof prop === "boolean" ?

				getSetInput && getSetAttribute ?
					attr != null :
					// oldIE fabricates an empty string for missing boolean attributes
					// and conflates checked/selected into attroperties
					ruseDefault.test( name ) ?
						elem[ jQuery.camelCase( "default-" + name ) ] :
						!!attr :

				// fetch an attribute node for properties not recognized as boolean
				elem.getAttributeNode( name );

		return detail && detail.value !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// fix oldIE value attroperty
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return jQuery.nodeName( elem, "input" ) ?

				// Ignore the value *property* by using defaultValue
				elem.defaultValue :

				ret && ret.specified ? ret.value : undefined;
		},
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return ret && ( name === "id" || name === "name" || name === "coords" ? ret.value !== "" : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			return name === "value" || value === elem.getAttribute( name ) ?
				value :
				undefined;
		}
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});
}


// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret == null ? undefined : ret;
			}
		});
	});

	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = core_hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		event.isTrigger = true;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = core_slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur != this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			}
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== document.activeElement && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === document.activeElement && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var i,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	hasDuplicate,
	outermostContext,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsXML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,
	sortOrder,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	support = {},
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Array methods
	arr = [],
	pop = arr.pop,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},


	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rsibling = /[\x20\t\r\n\f]*[+~]/,

	rnative = /^[^{]+\{\s*\[native code/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rescape = /'|\\/g,
	rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
	funescape = function( _, escaped ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		return high !== high ?
			escaped :
			// BMP codepoint
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Use a stripped-down slice if we can't use a native one
try {
	slice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		while ( (elem = this[i++]) ) {
			results.push( elem );
		}
		return results;
	};
}

/**
 * For feature detection
 * @param {Function} fn The function to test for native support
 */
function isNative( fn ) {
	return rnative.test( fn + "" );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var cache,
		keys = [];

	return (cache = function( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	});
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return fn( div );
	} catch (e) {
		return false;
	} finally {
		// release memory in IE
		div = null;
	}
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( !documentIsXML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && !rbuggyQSA.test(selector) ) {
			old = true;
			nid = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results, slice.call( newContext.querySelectorAll(
						newSelector
					), 0 ) );
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsXML = isXML( doc );

	// Check if getElementsByTagName("*") returns only elements
	support.tagNameNoComments = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if attributes should be retrieved by attribute nodes
	support.attributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	});

	// Check if getElementsByClassName can be trusted
	support.getByClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	});

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	support.getByName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = doc.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			doc.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			doc.getElementsByName( expando + 0 ).length;
		support.getIdNotName = !doc.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

	// IE6/7 return modified attributes
	Expr.attrHandle = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}) ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		};

	// ID find and filter
	if ( support.getIdNotName ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && !documentIsXML ) {
				var m = context.getElementById( id );

				return m ?
					m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
						[m] :
						undefined :
					[];
			}
		};
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.tagNameNoComments ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Name
	Expr.find["NAME"] = support.getByName && function( tag, context ) {
		if ( typeof context.getElementsByName !== strundefined ) {
			return context.getElementsByName( name );
		}
	};

	// Class
	Expr.find["CLASS"] = support.getByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {
			return context.getElementsByClassName( className );
		}
	};

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21),
	// no need to also add to buggyMatches since matches checks buggyQSA
	// A support test would require too much code (would include document ready)
	rbuggyQSA = [ ":focus" ];

	if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE8 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<input type='hidden' i=''/>";
			if ( div.querySelectorAll("[i^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.webkitMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = new RegExp( rbuggyMatches.join("|") );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	// Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		var compare;

		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {
			if ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {
				if ( a === doc || contains( preferredDoc, a ) ) {
					return -1;
				}
				if ( b === doc || contains( preferredDoc, b ) ) {
					return 1;
				}
				return 0;
			}
			return compare & 4 ? -1 : 1;
		}

		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	// Always assume the presence of duplicates if sort doesn't
	// pass them to our comparison function (as in Google Chrome).
	hasDuplicate = false;
	[0, 0].sort( sortOrder );
	support.detectDuplicates = hasDuplicate;

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	// rbuggyQSA always contains :focus, so no need for an existence check
	if ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {
		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	var val;

	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( !documentIsXML ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( documentIsXML || support.attributes ) {
		return elem.getAttribute( name );
	}
	return ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?
		name :
		val && val.specified ? val.value : null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		i = 1,
		j = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (see #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[4] ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}

			nodeName = nodeName.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifider
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsXML ?
						elem.getAttribute("xml:lang") || elem.getAttribute("lang") :
						elem.lang) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + " " + doneName;

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	// A counter to specify which element is currently being matched
	var matcherCachedRuns = 0,
		bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = matcherCachedRuns;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !documentIsXML &&
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find["ID"]( token.matches[0].replace( runescape, funescape ), context )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && context.parentNode || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		documentIsXML,
		results,
		rsibling.test( selector )
	);
	return results;
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Easy API for creating new setFilters
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Initialize with the default document
setDocument();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, ret, self,
			len = this.length;

		if ( typeof selector !== "string" ) {
			self = this;
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		ret = [];
		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, this[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = ( this.selector ? this.selector + " " : "" ) + selector;
		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false) );
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true) );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( jQuery.unique(all) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, false, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, false, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}

				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		var isFunc = jQuery.isFunction( value );

		// Make sure that the elements are removed from the DOM before they are inserted
		// this can help fix replacing a parent with child elements
		if ( !isFunc && typeof value !== "string" ) {
			value = jQuery( value ).not( this ).detach();
		}

		return this.domManip( [ value ], true, function( elem ) {
			var next = this.nextSibling,
				parent = this.parentNode;

			if ( parent ) {
				jQuery( this ).remove();
				parent.insertBefore( elem, next );
			}
		});
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = core_concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, table ? self.html() : undefined );
				}
				self.domManip( args, table, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						node,
						i
					);
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Hope ajax is available...
								jQuery.ajax({
									url: node.src,
									type: "GET",
									dataType: "script",
									async: false,
									global: false,
									"throws": true
								});
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	var attr = elem.getAttributeNode("type");
	elem.type = ( attr && attr.specified ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			core_push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( manipulation_rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== core_strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						core_deletedIds.push( id );
					}
				}
			}
		}
	}
});
var iframe, getStyles, curCSS,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	// isHidden might be called from jQuery#filter function;
	// in that case, element will be second argument
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			var len, styles,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		var bool = typeof state === "boolean";

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {
			// Use the already-created iframe if possible
			iframe = ( iframe ||
				jQuery("<iframe frameborder='0' width='0' height='0'/>")
				.css( "cssText", "display:block !important" )
			).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
			doc.write("<!doctype html><html><body>");
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}

// Called ONLY from within css_defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
		display = jQuery.css( elem[0], "display" );
	elem.remove();
	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				if ( computed ) {
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// Work around by temporarily setting element display to inline-block
					return jQuery.swap( elem, { "display": "inline-block" },
						curCSS, [ elem, "marginRight" ] );
				}
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function(){
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !manipulation_rcheckableType.test( type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.hover = function( fnOver, fnOut ) {
	return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
};
var
	// Document location
	ajaxLocParts,
	ajaxLocation,
	ajax_nonce = jQuery.now(),

	ajax_rquery = /\?/,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
	jQuery.fn[ type ] = function( fn ){
		return this.on( type, fn );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 ) {
					isSuccess = true;
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					isSuccess = true;
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	}
});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {
	var conv2, current, conv, tmp,
		converters = {},
		i = 0,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ];

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject && function() {
		// Abort all pending requests
		var key;
		for ( key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	};

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject("Microsoft.XMLHTTP");
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
xhrSupported = jQuery.ajaxSettings.xhr();
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = jQuery.support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( err ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var value, name, index, easing, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	/*jshint validthis:true */
	var prop, index, length,
		value, dataShow, toggle,
		tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( "hidden" in dataShow ) {
			hidden = dataShow.hidden;
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
				doAnimation.finish = function() {
					anim.stop( true );
				};
				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.cur && hooks.cur.finish ) {
				hooks.cur.finish.call( this );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.documentElement;
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.documentElement;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Limit scope pollution from any deprecated API
// (function() {

// })();
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( "function" === "function" && __webpack_require__(16) && __webpack_require__(16).jQuery ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return jQuery; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

})( window );


/***/ }),
/* 49 */
/***/ (function(module, exports) {

/*
 * jQuery.fn.autoResize 1.14
 * --
 * https://github.com/padolsey/jQuery.fn.autoResize
 * --
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. */

(function($){

	var uid = 'ar' + +new Date,

		defaults = autoResize.defaults = {
			onResize: function(){},
			onBeforeResize: function(){return 123},
			onAfterResize: function(){return 555},
			animate: {
				duration: 200,
				complete: function(){}
			},
			extraSpace: 50,
			minHeight: 'original',
			maxHeight: 500,
			minWidth: 'original',
			maxWidth: 500
		};

	autoResize.cloneCSSProperties = [
		'lineHeight', 'textDecoration', 'letterSpacing',
		'fontSize', 'fontFamily', 'fontStyle', 'fontWeight',
		'textTransform', 'textAlign', 'direction', 'wordSpacing', 'fontSizeAdjust',
		'paddingTop', 'paddingLeft', 'paddingBottom', 'paddingRight', 'width'
	];

	autoResize.cloneCSSValues = {
		position: 'absolute',
		top: -9999,
		left: -9999,
		opacity: 0,
		overflow: 'hidden'
	};

	autoResize.resizableFilterSelector = [
		'textarea:not(textarea.' + uid + ')',
		'input:not(input[type])',
		'input[type=text]',
		'input[type=password]',
		'input[type=email]',
		'input[type=url]'
	].join(',');

	autoResize.AutoResizer = AutoResizer;

	$.fn.autoResize = autoResize;

	function autoResize(config) {
		this.filter(autoResize.resizableFilterSelector).each(function(){
			new AutoResizer( $(this), config );
		});
		return this;
	}

	function AutoResizer(el, config) {

		if (el.data('AutoResizer')) {
			el.data('AutoResizer').destroy();
		}

		config = this.config = $.extend({}, autoResize.defaults, config);
		this.el = el;

		this.nodeName = el[0].nodeName.toLowerCase();

		this.originalHeight = el.height();
		this.previousScrollTop = null;

		this.value = el.val();

		if (config.maxWidth === 'original') config.maxWidth = el.width();
		if (config.minWidth === 'original') config.minWidth = el.width();
		if (config.maxHeight === 'original') config.maxHeight = el.height();
		if (config.minHeight === 'original') config.minHeight = el.height();

		if (this.nodeName === 'textarea') {
			el.css({
				resize: 'none',
				overflowY: 'hidden'
			});
		}

		el.data('AutoResizer', this);

		// Make sure onAfterResize is called upon animation completion
		config.animate.complete = (function(f){
			return function() {
				config.onAfterResize.call(el);
				return f.apply(this, arguments);
			};
		}(config.animate.complete));

		this.bind();
	}

	AutoResizer.prototype = {

		bind: function() {

			var check = $.proxy(function(){
				this.check();
				return true;
			}, this);

			this.unbind();

			this.el
				.bind('keyup.autoResize', check)
				//.bind('keydown.autoResize', check)
				.bind('change.autoResize', check)
				.bind('paste.autoResize', function() {
					setTimeout(function() { check(); }, 0);
				});

			if (!this.el.is(':hidden')) {
				this.check(null, true);
			}

		},

		unbind: function() {
			this.el.unbind('.autoResize');
		},

		createClone: function() {

			var el = this.el,
				clone = this.nodeName === 'textarea' ? el.clone() : $('<span/>');

			this.clone = clone;

			$.each(autoResize.cloneCSSProperties, function(i, p){
				clone[0].style[p] = el.css(p);
			});

			clone
				.removeAttr('name')
				.removeAttr('id')
				.addClass(uid)
				.attr('tabIndex', -1)
				.css(autoResize.cloneCSSValues);

			if (this.nodeName === 'textarea') {
				clone.height('auto');
			} else {
				clone.width('auto').css({
					whiteSpace: 'nowrap'
				});
			}

		},

		check: function(e, immediate) {

			if (!this.clone) {
		this.createClone();
		this.injectClone();
			}

			var config = this.config,
				clone = this.clone,
				el = this.el,
				value = el.val();

			// Do nothing if value hasn't changed
			if (value === this.prevValue) { return true; }
			this.prevValue = value;

			if (this.nodeName === 'input') {

				clone.text(value);

				// Calculate new width + whether to change
				var cloneWidth = clone.width(),
					newWidth = (cloneWidth + config.extraSpace) >= config.minWidth ?
						cloneWidth + config.extraSpace : config.minWidth,
					currentWidth = el.width();

				newWidth = Math.min(newWidth, config.maxWidth);

				if (
					(newWidth < currentWidth && newWidth >= config.minWidth) ||
					(newWidth >= config.minWidth && newWidth <= config.maxWidth)
				) {

					config.onBeforeResize.call(el);
					config.onResize.call(el);

					el.scrollLeft(0);

					if (config.animate && !immediate) {
						el.stop(1,1).animate({
							width: newWidth
						}, config.animate);
					} else {
						el.width(newWidth);
						config.onAfterResize.call(el);
					}

				}

				return;

			}

			// TEXTAREA

			clone.width(el.width()).height(0).val(value).scrollTop(10000);

			var scrollTop = clone[0].scrollTop;

			if(!value) {
				// empty textarea should be exactly minHeight
				scrollTop = config.minHeight;
				this.previousScrollTop = null;   // reset state
			} else {
				// Don't do anything if scrollTop hasen't changed:
				if (this.previousScrollTop === scrollTop) {
					return;
				}

				this.previousScrollTop = scrollTop;

				if (scrollTop + config.extraSpace >= config.maxHeight) {
					el.css('overflowY', '');
					scrollTop = config.maxHeight;
					immediate = true;
				} else if (scrollTop + config.extraSpace <= config.minHeight) {
						// include extraSpace in calculations so the code works correctly
						// when there are few lines
					scrollTop = config.minHeight;
				} else {
					el.css('overflowY', 'hidden');
					scrollTop += config.extraSpace;
				}
			}

			config.onBeforeResize.call(el);
			config.onResize.call(el);

			// Either animate or directly apply height:
			if (config.animate && !immediate) {
					el.stop(1,1).animate({
							height: scrollTop
					}, config.animate);
			} else {
					el.height(scrollTop);
					config.onAfterResize.call(el);
			}
		},

		destroy: function() {
			this.unbind();
			this.el.removeData('AutoResizer');
			this.clone.remove();
			delete this.el;
			delete this.clone;
		},

		injectClone: function() {
			(
				autoResize.cloneContainer ||
				(autoResize.cloneContainer = $('<arclones/>').appendTo('body'))
			).append(this.clone);
		}

	};

})(jQuery);

/***/ }),
/* 50 */
/***/ (function(module, exports) {

/*!
 * jQuery contextMenu - Plugin for simple contextMenu handling
 *
 * Version: 1.6.5
 *
 * Authors: Rodney Rehm, Addy Osmani (patches for FF)
 * Web: http://medialize.github.com/jQuery-contextMenu/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */

(function($, undefined){
    
    // TODO: -
        // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
        // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative

// determine html5 compatibility
$.support.htmlMenuitem = ('HTMLMenuItemElement' in window);
$.support.htmlCommand = ('HTMLCommandElement' in window);
$.support.eventSelectstart = ("onselectstart" in document.documentElement);
/* // should the need arise, test for css user-select
$.support.cssUserSelect = (function(){
    var t = false,
        e = document.createElement('div');
    
    $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
        var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
            prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';
            
        e.style.cssText = prop + ': text;';
        if (e.style[propCC] == 'text') {
            t = true;
            return false;
        }
        
        return true;
    });
    
    return t;
})();
*/

if (!$.ui || !$.ui.widget) {
    // duck punch $.cleanData like jQueryUI does to get that remove event
    // https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js#L16-24
    var _cleanData = $.cleanData;
    $.cleanData = function( elems ) {
        for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
            try {
                $( elem ).triggerHandler( "remove" );
                // http://bugs.jquery.com/ticket/8235
            } catch( e ) {}
        }
        _cleanData( elems );
    };
}

var // currently active contextMenu trigger
    $currentTrigger = null,
    // is contextMenu initialized with at least one menu?
    initialized = false,
    // window handle
    $win = $(window),
    // number of registered menus
    counter = 0,
    // mapping selector to namespace
    namespaces = {},
    // mapping namespace to options
    menus = {},
    // custom command type handlers
    types = {},
    // default values
    defaults = {
        // selector of contextMenu trigger
        selector: null,
        // where to append the menu to
        appendTo: null,
        // method to trigger context menu ["right", "left", "hover"]
        trigger: "right",
        // hide menu when mouse leaves trigger / menu elements
        autoHide: false,
        // ms to wait before showing a hover-triggered context menu
        delay: 200,
        // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
        // as long as the trigger happened on one of the trigger-element's child nodes
        reposition: false,
        // determine position to show menu at
        determinePosition: function($menu) {
            // position to the lower middle of the trigger element
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "center top",
                    at: "center bottom",
                    of: this,
                    offset: "0 5",
                    collision: "fit"
                }).css('display', 'none');
            } else {
                // determine contextMenu position
                var offset = this.offset();
                offset.top += this.outerHeight();
                offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                $menu.css(offset);
            }
        },
        // position menu
        position: function(opt, x, y) {
            var $this = this,
                offset;
            // determine contextMenu position
            if (!x && !y) {
                opt.determinePosition.call(this, opt.$menu);
                return;
            } else if (x === "maintain" && y === "maintain") {
                // x and y must not be changed (after re-show on command click)
                offset = opt.$menu.position();
            } else {
                // x and y are given (by mouse event)
                offset = {top: y, left: x};
            }
            
            // correct offset if viewport demands it
            var bottom = $win.scrollTop() + $win.height(),
                right = $win.scrollLeft() + $win.width(),
                height = opt.$menu.height(),
                width = opt.$menu.width();
            
            if (offset.top + height > bottom) {
                offset.top -= height;
            }
            
            if (offset.left + width > right) {
                offset.left -= width;
            }
            
            opt.$menu.css(offset);
        },
        // position the sub-menu
        positionSubmenu: function($menu) {
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "left top",
                    at: "right top",
                    of: this,
                    collision: "flipfit fit"
                }).css('display', '');
            } else {
                // determine contextMenu position
                var offset = {
                    top: 0,
                    left: this.outerWidth()
                };
                $menu.css(offset);
            }
        },
        // offset to add to zIndex
        zIndex: 1,
        // show hide animation settings
        animation: {
            duration: 50,
            show: 'slideDown',
            hide: 'slideUp'
        },
        // events
        events: {
            show: $.noop,
            hide: $.noop
        },
        // default callback
        callback: null,
        // list of contextMenu items
        items: {}
    },
    // mouse position for hover activation
    hoveract = {
        timer: null,
        pageX: null,
        pageY: null
    },
    // determine zIndex
    zindex = function($t) {
        var zin = 0,
            $tt = $t;

        while (true) {
            zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
            $tt = $tt.parent();
            if (!$tt || !$tt.length || "html body".indexOf($tt.prop('nodeName').toLowerCase()) > -1 ) {
                break;
            }
        }
        
        return zin;
    },
    // event handlers
    handle = {
        // abort anything
        abortevent: function(e){
            e.preventDefault();
            e.stopImmediatePropagation();
        },
        
        // contextmenu show dispatcher
        contextmenu: function(e) {
            var $this = $(this);
            
            // disable actual context-menu
            e.preventDefault();
            e.stopImmediatePropagation();
            
            // abort native-triggered events unless we're triggering on right click
            if (e.data.trigger != 'right' && e.originalEvent) {
                return;
            }
            
            // abort event if menu is visible for this trigger
            if ($this.hasClass('context-menu-active')) {
                return;
            }
            
            if (!$this.hasClass('context-menu-disabled')) {
                // theoretically need to fire a show event at <menu>
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
                // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
                // e.data.$menu.trigger(evt);
                
                $currentTrigger = $this;
                if (e.data.build) {
                    var built = e.data.build($currentTrigger, e);
                    // abort if build() returned false
                    if (built === false) {
                        return;
                    }
                    
                    // dynamically build menu on invocation
                    e.data = $.extend(true, {}, defaults, e.data, built || {});

                    // abort if there are no items to display
                    if (!e.data.items || $.isEmptyObject(e.data.items)) {
                        // Note: jQuery captures and ignores errors from event handlers
                        if (window.console) {
                            (console.error || console.log)("No items specified to show in contextMenu");
                        }
                        
                        throw new Error('No Items sepcified');
                    }
                    
                    // backreference for custom command type creation
                    e.data.$trigger = $currentTrigger;
                    
                    op.create(e.data);
                }
                // show menu
                op.show.call($this, e.data, e.pageX, e.pageY);
            }
        },
        // contextMenu left-click trigger
        click: function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            $(this).trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
        },
        // contextMenu right-click trigger
        mousedown: function(e) {
            // register mouse down
            var $this = $(this);
            
            // hide any previous menus
            if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
            }
            
            // activate on right click
            if (e.button == 2) {
                $currentTrigger = $this.data('contextMenuActive', true);
            }
        },
        // contextMenu right-click trigger
        mouseup: function(e) {
            // show menu
            var $this = $(this);
            if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
            }
            
            $this.removeData('contextMenuActive');
        },
        // contextMenu hover trigger
        mouseenter: function(e) {
            var $this = $(this),
                $related = $(e.relatedTarget),
                $document = $(document);
            
            // abort if we're coming from a menu
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }
            
            // abort if a menu is shown
            if ($currentTrigger && $currentTrigger.length) {
                return;
            }
            
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
            hoveract.data = e.data;
            $document.on('mousemove.contextMenuShow', handle.mousemove);
            hoveract.timer = setTimeout(function() {
                hoveract.timer = null;
                $document.off('mousemove.contextMenuShow');
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: hoveract.data, pageX: hoveract.pageX, pageY: hoveract.pageY }));
            }, e.data.delay );
        },
        // contextMenu hover trigger
        mousemove: function(e) {
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
        },
        // contextMenu hover trigger
        mouseleave: function(e) {
            // abort if we're leaving for a menu
            var $related = $(e.relatedTarget);
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }
            
            try {
                clearTimeout(hoveract.timer);
            } catch(e) {}
            
            hoveract.timer = null;
        },
        
        // click on layer to hide contextMenu
        layerClick: function(e) {
            var $this = $(this),
                root = $this.data('contextMenuRoot'),
                mouseup = false,
                button = e.button,
                x = e.pageX,
                y = e.pageY,
                target, 
                offset,
                selectors;
                
            e.preventDefault();
            e.stopImmediatePropagation();
            
            setTimeout(function() {
                var $window, hideshow, possibleTarget;
                var triggerAction = ((root.trigger == 'left' && button === 0) || (root.trigger == 'right' && button === 2));
                
                // find the element that would've been clicked, wasn't the layer in the way
                if (document.elementFromPoint) {
                    root.$layer.hide();
                    target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
                    root.$layer.show();
                }
                
                if (root.reposition && triggerAction) {
                    if (document.elementFromPoint) {
                        if (root.$trigger.is(target) || root.$trigger.has(target).length) {
                            root.position.call(root.$trigger, root, x, y);
                            return;
                        }
                    } else {
                        offset = root.$trigger.offset();
                        $window = $(window);
                        // while this looks kinda awful, it's the best way to avoid
                        // unnecessarily calculating any positions
                        offset.top += $window.scrollTop();
                        if (offset.top <= e.pageY) {
                            offset.left += $window.scrollLeft();
                            if (offset.left <= e.pageX) {
                                offset.bottom = offset.top + root.$trigger.outerHeight();
                                if (offset.bottom >= e.pageY) {
                                    offset.right = offset.left + root.$trigger.outerWidth();
                                    if (offset.right >= e.pageX) {
                                        // reposition
                                        root.position.call(root.$trigger, root, x, y);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (target && triggerAction) {
                    root.$trigger.one('contextmenu:hidden', function() {
                        $(target).contextMenu({x: x, y: y});
                    });
                }

                root.$menu.trigger('contextmenu:hide');
            }, 50);
        },
        // key handled :hover
        keyStop: function(e, opt) {
            if (!opt.isInput) {
                e.preventDefault();
            }
            
            e.stopPropagation();
        },
        key: function(e) {
            var opt = $currentTrigger.data('contextMenu') || {};

            switch (e.keyCode) {
                case 9:
                case 38: // up
                    handle.keyStop(e, opt);
                    // if keyCode is [38 (up)] or [9 (tab) with shift]
                    if (opt.isInput) {
                        if (e.keyCode == 9 && e.shiftKey) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('prevcommand');
                            return;
                        } else if (e.keyCode == 38 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else if (e.keyCode != 9 || e.shiftKey) {
                        opt.$menu.trigger('prevcommand');
                        return;
                    }
                    // omitting break;
                    
                // case 9: // tab - reached through omitted break;
                case 40: // down
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (e.keyCode == 9) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('nextcommand');
                            return;
                        } else if (e.keyCode == 40 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else {
                        opt.$menu.trigger('nextcommand');
                        return;
                    }
                    break;
                
                case 37: // left
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }
                
                    if (!opt.$selected.parent().hasClass('context-menu-root')) {
                        var $parent = opt.$selected.parent().parent();
                        opt.$selected.trigger('contextmenu:blur');
                        opt.$selected = $parent;
                        return;
                    }
                    break;
                    
                case 39: // right
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }
                    
                    var itemdata = opt.$selected.data('contextMenu') || {};
                    if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
                        opt.$selected = null;
                        itemdata.$selected = null;
                        itemdata.$menu.trigger('nextcommand');
                        return;
                    }
                    break;
                
                case 35: // end
                case 36: // home
                    if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
                        return;
                    } else {
                        (opt.$selected && opt.$selected.parent() || opt.$menu)
                            .children(':not(.disabled, .not-selectable)')[e.keyCode == 36 ? 'first' : 'last']()
                            .trigger('contextmenu:focus');
                        e.preventDefault();
                        return;
                    }
                    break;
                    
                case 13: // enter
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (opt.$selected && !opt.$selected.is('textarea, select')) {
                            e.preventDefault();
                            return;
                        }
                        break;
                    }
                    opt.$selected && opt.$selected.trigger('mouseup');
                    return;
                    
                case 32: // space
                case 33: // page up
                case 34: // page down
                    // prevent browser from scrolling down while menu is visible
                    handle.keyStop(e, opt);
                    return;
                    
                case 27: // esc
                    handle.keyStop(e, opt);
                    opt.$menu.trigger('contextmenu:hide');
                    return;
                    
                default: // 0-9, a-z
                    var k = (String.fromCharCode(e.keyCode)).toUpperCase();
                    if (opt.accesskeys[k]) {
                        // according to the specs accesskeys must be invoked immediately
                        opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu
                            ? 'contextmenu:focus'
                            : 'mouseup'
                        );
                        return;
                    }
                    break;
            }
            // pass event to selected item, 
            // stop propagation to avoid endless recursion
            e.stopPropagation();
            opt.$selected && opt.$selected.trigger(e);
        },

        // select previous possible command in menu
        prevItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }
            
            var $children = opt.$menu.children(),
                $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
                $round = $prev;
            
            // skip disabled
            while ($prev.hasClass('disabled') || $prev.hasClass('not-selectable')) {
                if ($prev.prev().length) {
                    $prev = $prev.prev();
                } else {
                    $prev = $children.last();
                }
                if ($prev.is($round)) {
                    // break endless loop
                    return;
                }
            }
            
            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }
            
            // activate next
            handle.itemMouseenter.call($prev.get(0), e);
            
            // focus input
            var $input = $prev.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },
        // select next possible command in menu
        nextItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }

            var $children = opt.$menu.children(),
                $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
                $round = $next;

            // skip disabled
            while ($next.hasClass('disabled') || $next.hasClass('not-selectable')) {
                if ($next.next().length) {
                    $next = $next.next();
                } else {
                    $next = $children.first();
                }
                if ($next.is($round)) {
                    // break endless loop
                    return;
                }
            }
            
            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }
            
            // activate next
            handle.itemMouseenter.call($next.get(0), e);
            
            // focus input
            var $input = $next.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },
        
        // flag that we're inside an input so the key handler can act accordingly
        focusInput: function(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.$selected = opt.$selected = $this;
            root.isInput = opt.isInput = true;
        },
        // flag that we're inside an input so the key handler can act accordingly
        blurInput: function(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.isInput = opt.isInput = false;
        },
        
        // :hover on menu
        menuMouseenter: function(e) {
            var root = $(this).data().contextMenuRoot;
            root.hovering = true;
        },
        // :hover on menu
        menuMouseleave: function(e) {
            var root = $(this).data().contextMenuRoot;
            if (root.$layer && root.$layer.is(e.relatedTarget)) {
                root.hovering = false;
            }
        },
        
        // :hover done manually so key handling is possible
        itemMouseenter: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;
            
            root.hovering = true;

            // abort if we're re-entering
            if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }

            // make sure only one item is selected
            (opt.$menu ? opt : root).$menu
                .children('.hover').trigger('contextmenu:blur');

            if ($this.hasClass('disabled') || $this.hasClass('not-selectable')) {
                opt.$selected = null;
                return;
            }
            
            $this.trigger('contextmenu:focus');
        },
        // :hover done manually so key handling is possible
        itemMouseleave: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                root.$selected && root.$selected.trigger('contextmenu:blur');
                e.preventDefault();
                e.stopImmediatePropagation();
                root.$selected = opt.$selected = opt.$node;
                return;
            }
            
            $this.trigger('contextmenu:blur');
        },
        // contextMenu item click
        itemClick: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot,
                key = data.contextMenuKey,
                callback;

            // abort if the key is unknown or disabled or is a menu
            if (!opt.items[key] || $this.is('.disabled, .context-menu-submenu, .context-menu-separator, .not-selectable')) {
                return;
            }

            e.preventDefault();
            e.stopImmediatePropagation();

            if ($.isFunction(root.callbacks[key]) && Object.prototype.hasOwnProperty.call(root.callbacks, key)) {
                // item-specific callback
                callback = root.callbacks[key];
            } else if ($.isFunction(root.callback)) {
                // default callback
                callback = root.callback;                
            } else {
                // no callback, no action
                return;
            }

            // hide menu if callback doesn't stop that
            if (callback.call(root.$trigger, key, root) !== false) {
                root.$menu.trigger('contextmenu:hide');
            } else if (root.$menu.parent().length) {
                op.update.call(root.$trigger, root);
            }
        },
        // ignore click events on input elements
        inputClick: function(e) {
            e.stopImmediatePropagation();
        },
        
        // hide <menu>
        hideMenu: function(e, data) {
            var root = $(this).data('contextMenuRoot');
            op.hide.call(root.$trigger, root, data && data.force);
        },
        // focus <command>
        focusItem: function(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            $this.addClass('hover')
                .siblings('.hover').trigger('contextmenu:blur');
            
            // remember selected
            opt.$selected = root.$selected = $this;
            
            // position sub-menu - do after show so dumb $.ui.position can keep up
            if (opt.$node) {
                root.positionSubmenu.call(opt.$node, opt.$menu);
            }
        },
        // blur <command>
        blurItem: function(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;
            
            $this.removeClass('hover');
            opt.$selected = null;
        }
    },
    // operations
    op = {
        show: function(opt, x, y) {
            var $trigger = $(this),
                offset,
                css = {};

            // hide any open menus
            $('#context-menu-layer').trigger('mousedown');

            // backreference for callbacks
            opt.$trigger = $trigger;

            // show event
            if (opt.events.show.call($trigger, opt) === false) {
                $currentTrigger = null;
                return;
            }

            // create or update context menu
            op.update.call($trigger, opt);
            
            // position menu
            opt.position.call($trigger, opt, x, y);

            // make sure we're in front
            if (opt.zIndex) {
                css.zIndex = zindex($trigger) + opt.zIndex;
            }
            
            // add layer
            op.layer.call(opt.$menu, opt, css.zIndex);
            
            // adjust sub-menu zIndexes
            opt.$menu.find('ul').css('zIndex', css.zIndex + 1);
            
            // position and show context menu
            opt.$menu.css( css )[opt.animation.show](opt.animation.duration, function() {
                $trigger.trigger('contextmenu:visible');
            });
            // make options available and set state
            $trigger
                .data('contextMenu', opt)
                .addClass("context-menu-active");
            
            // register key handler
            $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
            // register autoHide handler
            if (opt.autoHide) {
                // mouse position handler
                $(document).on('mousemove.contextMenuAutoHide', function(e) {
                    // need to capture the offset on mousemove,
                    // since the page might've been scrolled since activation
                    var pos = $trigger.offset();
                    pos.right = pos.left + $trigger.outerWidth();
                    pos.bottom = pos.top + $trigger.outerHeight();
                    
                    if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                        // if mouse in menu...
                        opt.$menu.trigger('contextmenu:hide');
                    }
                });
            }
        },
        hide: function(opt, force) {
            var $trigger = $(this);
            if (!opt) {
                opt = $trigger.data('contextMenu') || {};
            }
            
            // hide event
            if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                return;
            }
            
            // remove options and revert state
            $trigger
                .removeData('contextMenu')
                .removeClass("context-menu-active");
            
            if (opt.$layer) {
                // keep layer for a bit so the contextmenu event can be aborted properly by opera
                setTimeout((function($layer) {
                    return function(){
                        $layer.remove();
                    };
                })(opt.$layer), 10);
                
                try {
                    delete opt.$layer;
                } catch(e) {
                    opt.$layer = null;
                }
            }
            
            // remove handle
            $currentTrigger = null;
            // remove selected
            opt.$menu.find('.hover').trigger('contextmenu:blur');
            opt.$selected = null;
            // unregister key and mouse handlers
            //$(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
            $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
            // hide menu
            opt.$menu && opt.$menu[opt.animation.hide](opt.animation.duration, function (){
                // tear down dynamically built menu after animation is completed.
                if (opt.build) {
                    opt.$menu.remove();
                    $.each(opt, function(key, value) {
                        switch (key) {
                            case 'ns':
                            case 'selector':
                            case 'build':
                            case 'trigger':
                                return true;

                            default:
                                opt[key] = undefined;
                                try {
                                    delete opt[key];
                                } catch (e) {}
                                return true;
                        }
                    });
                }
                
                setTimeout(function() {
                    $trigger.trigger('contextmenu:hidden');
                }, 10);
            });
        },
        create: function(opt, root) {
            if (root === undefined) {
                root = opt;
            }
            // create contextMenu
            opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || "").data({
                'contextMenu': opt,
                'contextMenuRoot': root
            });
            
            $.each(['callbacks', 'commands', 'inputs'], function(i,k){
                opt[k] = {};
                if (!root[k]) {
                    root[k] = {};
                }
            });
            
            root.accesskeys || (root.accesskeys = {});
            
            // create contextMenu items
            $.each(opt.items, function(key, item){
                var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ""),
                    $label = null,
                    $input = null;
                
                // iOS needs to see a click-event bound to an element to actually
                // have the TouchEvents infrastructure trigger the click event
                $t.on('click', $.noop);
                
                item.$node = $t.data({
                    'contextMenu': opt,
                    'contextMenuRoot': root,
                    'contextMenuKey': key
                });
                
                // register accesskey
                // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
                if (item.accesskey) {
                    var aks = splitAccesskey(item.accesskey);
                    for (var i=0, ak; ak = aks[i]; i++) {
                        if (!root.accesskeys[ak]) {
                            root.accesskeys[ak] = item;
                            item._name = item.name.replace(new RegExp('(' + ak + ')', 'i'), '<span class="context-menu-accesskey">$1</span>');
                            break;
                        }
                    }
                }
                
                if (typeof item == "string") {
                    $t.addClass('context-menu-separator not-selectable');
                } else if (item.type && types[item.type]) {
                    // run custom type handler
                    types[item.type].call($t, item, opt, root);
                    // register commands
                    $.each([opt, root], function(i,k){
                        k.commands[key] = item;
                        if ($.isFunction(item.callback)) {
                            k.callbacks[key] = item.callback;
                        }
                    });
                } else {
                    // add label for input
                    if (item.type == 'html') {
                        $t.addClass('context-menu-html not-selectable');
                    } else if (item.type) {
                        $label = $('<label></label>').appendTo($t);
                        $('<span></span>').html(item._name || item.name).appendTo($label);
                        $t.addClass('context-menu-input');
                        opt.hasTypes = true;
                        $.each([opt, root], function(i,k){
                            k.commands[key] = item;
                            k.inputs[key] = item;
                        });
                    } else if (item.items) {
                        item.type = 'sub';
                    }
                
                    switch (item.type) {
                        case 'text':
                            $input = $('<input type="text" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .appendTo($label);
                            break;
                    
                        case 'textarea':
                            $input = $('<textarea name=""></textarea>')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .appendTo($label);

                            if (item.height) {
                                $input.height(item.height);
                            }
                            break;

                        case 'checkbox':
                            $input = $('<input type="checkbox" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .prop("checked", !!item.selected)
                                .prependTo($label);
                            break;

                        case 'radio':
                            $input = $('<input type="radio" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + item.radio)
                                .val(item.value || "")
                                .prop("checked", !!item.selected)
                                .prependTo($label);
                            break;
                    
                        case 'select':
                            $input = $('<select name="">')
                                .attr('name', 'context-menu-input-' + key)
                                .appendTo($label);
                            if (item.options) {
                                $.each(item.options, function(value, text) {
                                    $('<option></option>').val(value).text(text).appendTo($input);
                                });
                                $input.val(item.selected);
                            }
                            break;
                        
                        case 'sub':
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name).appendTo($t);
                            item.appendTo = item.$node;
                            op.create(item, root);
                            $t.data('contextMenu', item).addClass('context-menu-submenu');
                            item.callback = null;
                            break;
                        
                        case 'html':
                            $(item.html).appendTo($t);
                            break;
                        
                        default:
                            $.each([opt, root], function(i,k){
                                k.commands[key] = item;
                                if ($.isFunction(item.callback)) {
                                    k.callbacks[key] = item.callback;
                                }
                            });
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name || "").appendTo($t);
                            break;
                    }
                    
                    // disable key listener in <input>
                    if (item.type && item.type != 'sub' && item.type != 'html') {
                        $input
                            .on('focus', handle.focusInput)
                            .on('blur', handle.blurInput);
                        
                        if (item.events) {
                            $input.on(item.events, opt);
                        }
                    }
                
                    // add icons
                    if (item.icon) {
                        $t.addClass("icon icon-" + item.icon);
                    }
                }
                
                // cache contained elements
                item.$input = $input;
                item.$label = $label;

                // attach item to menu
                $t.appendTo(opt.$menu);
                
                // Disable text selection
                if (!opt.hasTypes && $.support.eventSelectstart) {
                    // browsers support user-select: none, 
                    // IE has a special event for text-selection
                    // browsers supporting neither will not be preventing text-selection
                    $t.on('selectstart.disableTextSelect', handle.abortevent);
                }
            });
            // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
            if (!opt.$node) {
                opt.$menu.css('display', 'none').addClass('context-menu-root');
            }
            opt.$menu.appendTo(opt.appendTo || document.body);
        },
        resize: function($menu, nested) {
            // determine widths of submenus, as CSS won't grow them automatically
            // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
            // kinda sucks hard...

            // determine width of absolutely positioned element
            $menu.css({position: 'absolute', display: 'block'});
            // don't apply yet, because that would break nested elements' widths
            // add a pixel to circumvent word-break issue in IE9 - #80
            $menu.data('width', Math.ceil($menu.width()) + 1);
            // reset styles so they allow nested elements to grow/shrink naturally
            $menu.css({
                position: 'static',
                minWidth: '0px',
                maxWidth: '100000px'
            });
            // identify width of nested menus
            $menu.find('> li > ul').each(function() {
                op.resize($(this), true);
            });
            // reset and apply changes in the end because nested
            // elements' widths wouldn't be calculatable otherwise
            if (!nested) {
                $menu.find('ul').andSelf().css({
                    position: '', 
                    display: '',
                    minWidth: '',
                    maxWidth: ''
                }).width(function() {
                    return $(this).data('width');
                });
            }
        },
        update: function(opt, root) {
            var $trigger = this;
            if (root === undefined) {
                root = opt;
                op.resize(opt.$menu);
            }
            // re-check disabled for each item
            opt.$menu.children().each(function(){
                var $item = $(this),
                    key = $item.data('contextMenuKey'),
                    item = opt.items[key],
                    disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true;

                // dis- / enable item
                $item[disabled ? 'addClass' : 'removeClass']('disabled');
                
                if (item.type) {
                    // dis- / enable input elements
                    $item.find('input, select, textarea').prop('disabled', disabled);
                    
                    // update input states
                    switch (item.type) {
                        case 'text':
                        case 'textarea':
                            item.$input.val(item.value || "");
                            break;
                            
                        case 'checkbox':
                        case 'radio':
                            item.$input.val(item.value || "").prop('checked', !!item.selected);
                            break;
                            
                        case 'select':
                            item.$input.val(item.selected || "");
                            break;
                    }
                }
                
                if (item.$menu) {
                    // update sub-menu
                    op.update.call($trigger, item, root);
                }
            });
        },
        layer: function(opt, zIndex) {
            // add transparent layer for click area
            // filter and background for Internet Explorer, Issue #23
            var $layer = opt.$layer = $('<div id="context-menu-layer" style="position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;"></div>')
                .css({height: $win.height(), width: $win.width(), display: 'block'})
                .data('contextMenuRoot', opt)
                .insertBefore(this)
                .on('contextmenu', handle.abortevent)
                .on('mousedown', handle.layerClick);
            
            // IE6 doesn't know position:fixed;
            if (!$.support.fixedPosition) {
                $layer.css({
                    'position' : 'absolute',
                    'height' : $(document).height()
                });
            }
            
            return $layer;
        }
    };

// split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
function splitAccesskey(val) {
    var t = val.split(/\s+/),
        keys = [];
        
    for (var i=0, k; k = t[i]; i++) {
        k = k[0].toUpperCase(); // first character only
        // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
        // a map to look up already used access keys would be nice
        keys.push(k);
    }
    
    return keys;
}

// handle contextMenu triggers
$.fn.contextMenu = function(operation) {
    if (operation === undefined) {
        this.first().trigger('contextmenu');
    } else if (operation.x && operation.y) {
        this.first().trigger($.Event("contextmenu", {pageX: operation.x, pageY: operation.y}));
    } else if (operation === "hide") {
        var $menu = this.data('contextMenu').$menu;
        $menu && $menu.trigger('contextmenu:hide');
    } else if (operation === "destroy") {
        $.contextMenu("destroy", {context: this});
    } else if ($.isPlainObject(operation)) {
        operation.context = this;
        $.contextMenu("create", operation);
    } else if (operation) {
        this.removeClass('context-menu-disabled');
    } else if (!operation) {
        this.addClass('context-menu-disabled');
    }
    
    return this;
};

// manage contextMenu instances
$.contextMenu = function(operation, options) {
    if (typeof operation != 'string') {
        options = operation;
        operation = 'create';
    }
    
    if (typeof options == 'string') {
        options = {selector: options};
    } else if (options === undefined) {
        options = {};
    }
    
    // merge with default options
    var o = $.extend(true, {}, defaults, options || {});
    var $document = $(document);
    var $context = $document;
    var _hasContext = false;
    
    if (!o.context || !o.context.length) {
        o.context = document;
    } else {
        // you never know what they throw at you...
        $context = $(o.context).first();
        o.context = $context.get(0);
        _hasContext = o.context !== document;
    }
    
    switch (operation) {
        case 'create':
            // no selector no joy
            if (!o.selector) {
                throw new Error('No selector specified');
            }
            // make sure internal classes are not bound to
            if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
            }
            if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                throw new Error('No Items sepcified');
            }
            counter ++;
            o.ns = '.contextMenu' + counter;
            if (!_hasContext) {
                namespaces[o.selector] = o.ns;
            }
            menus[o.ns] = o;
            
            // default to right click
            if (!o.trigger) {
                o.trigger = 'right';
            }
            
            if (!initialized) {
                // make sure item click is registered first
                $document
                    .on({
                        'contextmenu:hide.contextMenu': handle.hideMenu,
                        'prevcommand.contextMenu': handle.prevItem,
                        'nextcommand.contextMenu': handle.nextItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.menuMouseenter,
                        'mouseleave.contextMenu': handle.menuMouseleave
                    }, '.context-menu-list')
                    .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)
                    .on({
                        'mouseup.contextMenu': handle.itemClick,
                        'contextmenu:focus.contextMenu': handle.focusItem,
                        'contextmenu:blur.contextMenu': handle.blurItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.itemMouseenter,
                        'mouseleave.contextMenu': handle.itemMouseleave
                    }, '.context-menu-item');

                initialized = true;
            }
            
            // engage native contextmenu event
            $context
                .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);
            
            if (_hasContext) {
                // add remove hook, just in case
                $context.on('remove' + o.ns, function() {
                    $(this).contextMenu("destroy");
                });
            }
            
            switch (o.trigger) {
                case 'hover':
                        $context
                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)
                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);                    
                    break;
                    
                case 'left':
                        $context.on('click' + o.ns, o.selector, o, handle.click);
                    break;
                /*
                default:
                    // http://www.quirksmode.org/dom/events/contextmenu.html
                    $document
                        .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
                        .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
                    break;
                */
            }
            
            // create menu
            if (!o.build) {
                op.create(o);
            }
            break;
        
        case 'destroy':
            var $visibleMenu;
            if (_hasContext) {
                // get proper options 
                var context = o.context;
                $.each(menus, function(ns, o) {
                    if (o.context !== context) {
                        return true;
                    }
                    
                    $visibleMenu = $('.context-menu-list').filter(':visible');
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                        $visibleMenu.trigger('contextmenu:hide', {force: true});
                    }

                    try {
                        if (menus[o.ns].$menu) {
                            menus[o.ns].$menu.remove();
                        }

                        delete menus[o.ns];
                    } catch(e) {
                        menus[o.ns] = null;
                    }

                    $(o.context).off(o.ns);
                    
                    return true;
                });
            } else if (!o.selector) {
                $document.off('.contextMenu .contextMenuAutoHide');
                $.each(menus, function(ns, o) {
                    $(o.context).off(o.ns);
                });
                
                namespaces = {};
                menus = {};
                counter = 0;
                initialized = false;
                
                $('#context-menu-layer, .context-menu-list').remove();
            } else if (namespaces[o.selector]) {
                $visibleMenu = $('.context-menu-list').filter(':visible');
                if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                    $visibleMenu.trigger('contextmenu:hide', {force: true});
                }
                
                try {
                    if (menus[namespaces[o.selector]].$menu) {
                        menus[namespaces[o.selector]].$menu.remove();
                    }
                    
                    delete menus[namespaces[o.selector]];
                } catch(e) {
                    menus[namespaces[o.selector]] = null;
                }
                
                $document.off(namespaces[o.selector]);
            }
            break;
        
        case 'html5':
            // if <command> or <menuitem> are not handled by the browser,
            // or options was a bool true,
            // initialize $.contextMenu for them
            if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options == "boolean" && options)) {
                $('menu[type="context"]').each(function() {
                    if (this.id) {
                        $.contextMenu({
                            selector: '[contextmenu=' + this.id +']',
                            items: $.contextMenu.fromMenu(this)
                        });
                    }
                }).css('display', 'none');
            }
            break;
        
        default:
            throw new Error('Unknown operation "' + operation + '"');
    }
    
    return this;
};

// import values into <input> commands
$.contextMenu.setInputValues = function(opt, data) {
    if (data === undefined) {
        data = {};
    }
    
    $.each(opt.inputs, function(key, item) {
        switch (item.type) {
            case 'text':
            case 'textarea':
                item.value = data[key] || "";
                break;

            case 'checkbox':
                item.selected = data[key] ? true : false;
                break;
                
            case 'radio':
                item.selected = (data[item.radio] || "") == item.value ? true : false;
                break;
            
            case 'select':
                item.selected = data[key] || "";
                break;
        }
    });
};

// export values from <input> commands
$.contextMenu.getInputValues = function(opt, data) {
    if (data === undefined) {
        data = {};
    }
    
    $.each(opt.inputs, function(key, item) {
        switch (item.type) {
            case 'text':
            case 'textarea':
            case 'select':
                data[key] = item.$input.val();
                break;

            case 'checkbox':
                data[key] = item.$input.prop('checked');
                break;
                
            case 'radio':
                if (item.$input.prop('checked')) {
                    data[item.radio] = item.value;
                }
                break;
        }
    });
    
    return data;
};

// find <label for="xyz">
function inputLabel(node) {
    return (node.id && $('label[for="'+ node.id +'"]').val()) || node.name;
}

// convert <menu> to items object
function menuChildren(items, $children, counter) {
    if (!counter) {
        counter = 0;
    }
    
    $children.each(function() {
        var $node = $(this),
            node = this,
            nodeName = this.nodeName.toLowerCase(),
            label,
            item;
        
        // extract <label><input>
        if (nodeName == 'label' && $node.find('input, textarea, select').length) {
            label = $node.text();
            $node = $node.children().first();
            node = $node.get(0);
            nodeName = node.nodeName.toLowerCase();
        }
        
        /*
         * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
         * Not being the sadistic kind, $.contextMenu only accepts:
         * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
         * Everything else will be imported as an html node, which is not interfaced with contextMenu.
         */
        
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
        switch (nodeName) {
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
            case 'menu':
                item = {name: $node.attr('label'), items: {}};
                counter = menuChildren(item.items, $node.children(), counter);
                break;
            
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
            case 'a':
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
            case 'button':
                item = {
                    name: $node.text(),
                    disabled: !!$node.attr('disabled'),
                    callback: (function(){ return function(){ $node.click(); }; })()
                };
                break;
            
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command

            case 'menuitem':
            case 'command':
                switch ($node.attr('type')) {
                    case undefined:
                    case 'command':
                    case 'menuitem':
                        item = {
                            name: $node.attr('label'),
                            disabled: !!$node.attr('disabled'),
                            callback: (function(){ return function(){ $node.click(); }; })()
                        };
                        break;
                        
                    case 'checkbox':
                        item = {
                            type: 'checkbox',
                            disabled: !!$node.attr('disabled'),
                            name: $node.attr('label'),
                            selected: !!$node.attr('checked')
                        };
                        break;
                        
                    case 'radio':
                        item = {
                            type: 'radio',
                            disabled: !!$node.attr('disabled'),
                            name: $node.attr('label'),
                            radio: $node.attr('radiogroup'),
                            value: $node.attr('id'),
                            selected: !!$node.attr('checked')
                        };
                        break;
                        
                    default:
                        item = undefined;
                }
                break;
 
            case 'hr':
                item = '-------';
                break;
                
            case 'input':
                switch ($node.attr('type')) {
                    case 'text':
                        item = {
                            type: 'text',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            value: $node.val()
                        };
                        break;
                        
                    case 'checkbox':
                        item = {
                            type: 'checkbox',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            selected: !!$node.attr('checked')
                        };
                        break;
                        
                    case 'radio':
                        item = {
                            type: 'radio',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            radio: !!$node.attr('name'),
                            value: $node.val(),
                            selected: !!$node.attr('checked')
                        };
                        break;
                    
                    default:
                        item = undefined;
                        break;
                }
                break;
                
            case 'select':
                item = {
                    type: 'select',
                    name: label || inputLabel(node),
                    disabled: !!$node.attr('disabled'),
                    selected: $node.val(),
                    options: {}
                };
                $node.children().each(function(){
                    item.options[this.value] = $(this).text();
                });
                break;
                
            case 'textarea':
                item = {
                    type: 'textarea',
                    name: label || inputLabel(node),
                    disabled: !!$node.attr('disabled'),
                    value: $node.val()
                };
                break;
            
            case 'label':
                break;
            
            default:
                item = {type: 'html', html: $node.clone(true)};
                break;
        }
        
        if (item) {
            counter++;
            items['key' + counter] = item;
        }
    });
    
    return counter;
}

// convert html5 menu
$.contextMenu.fromMenu = function(element) {
    var $this = $(element),
        items = {};
        
    menuChildren(items, $this.children());
    
    return items;
};

// make defaults accessible
$.contextMenu.defaults = defaults;
$.contextMenu.types = types;
// export internal functions - undocumented, for hacking only!
$.contextMenu.handle = handle;
$.contextMenu.op = op;
$.contextMenu.menus = menus;

})(jQuery);


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! pace 0.4.17 */
(function(){var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V=[].slice,W={}.hasOwnProperty,X=function(a,b){function c(){this.constructor=a}for(var d in b)W.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},Y=[].indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(b in this&&this[b]===a)return b;return-1};for(t={catchupTime:500,initialRate:.03,minTime:500,ghostTime:500,maxProgressPerFrame:10,easeFactor:1.25,startOnPageLoad:!0,restartOnPushState:!0,restartOnRequestAfter:500,target:"body",elements:{checkInterval:100,selectors:["body"]},eventLag:{minSamples:10,sampleCount:3,lagThreshold:3},ajax:{trackMethods:["GET"],trackWebSockets:!1}},B=function(){var a;return null!=(a="undefined"!=typeof performance&&null!==performance?"function"==typeof performance.now?performance.now():void 0:void 0)?a:+new Date},D=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,s=window.cancelAnimationFrame||window.mozCancelAnimationFrame,null==D&&(D=function(a){return setTimeout(a,50)},s=function(a){return clearTimeout(a)}),F=function(a){var b,c;return b=B(),(c=function(){var d;return d=B()-b,d>=33?(b=B(),a(d,function(){return D(c)})):setTimeout(c,33-d)})()},E=function(){var a,b,c;return c=arguments[0],b=arguments[1],a=3<=arguments.length?V.call(arguments,2):[],"function"==typeof c[b]?c[b].apply(c,a):c[b]},u=function(){var a,b,c,d,e,f,g;for(b=arguments[0],d=2<=arguments.length?V.call(arguments,1):[],f=0,g=d.length;g>f;f++)if(c=d[f])for(a in c)W.call(c,a)&&(e=c[a],null!=b[a]&&"object"==typeof b[a]&&null!=e&&"object"==typeof e?u(b[a],e):b[a]=e);return b},p=function(a){var b,c,d,e,f;for(c=b=0,e=0,f=a.length;f>e;e++)d=a[e],c+=Math.abs(d),b++;return c/b},w=function(a,b){var c,d,e;if(null==a&&(a="options"),null==b&&(b=!0),e=document.querySelector("[data-pace-"+a+"]")){if(c=e.getAttribute("data-pace-"+a),!b)return c;try{return JSON.parse(c)}catch(f){return d=f,"undefined"!=typeof console&&null!==console?console.error("Error parsing inline pace options",d):void 0}}},g=function(){function a(){}return a.prototype.on=function(a,b,c,d){var e;return null==d&&(d=!1),null==this.bindings&&(this.bindings={}),null==(e=this.bindings)[a]&&(e[a]=[]),this.bindings[a].push({handler:b,ctx:c,once:d})},a.prototype.once=function(a,b,c){return this.on(a,b,c,!0)},a.prototype.off=function(a,b){var c,d,e;if(null!=(null!=(d=this.bindings)?d[a]:void 0)){if(null==b)return delete this.bindings[a];for(c=0,e=[];c<this.bindings[a].length;)this.bindings[a][c].handler===b?e.push(this.bindings[a].splice(c,1)):e.push(c++);return e}},a.prototype.trigger=function(){var a,b,c,d,e,f,g,h,i;if(c=arguments[0],a=2<=arguments.length?V.call(arguments,1):[],null!=(g=this.bindings)?g[c]:void 0){for(e=0,i=[];e<this.bindings[c].length;)h=this.bindings[c][e],d=h.handler,b=h.ctx,f=h.once,d.apply(null!=b?b:this,a),f?i.push(this.bindings[c].splice(e,1)):i.push(e++);return i}},a}(),null==window.Pace&&(window.Pace={}),u(Pace,g.prototype),C=Pace.options=u({},t,window.paceOptions,w()),S=["ajax","document","eventLag","elements"],O=0,Q=S.length;Q>O;O++)I=S[O],C[I]===!0&&(C[I]=t[I]);i=function(a){function b(){return T=b.__super__.constructor.apply(this,arguments)}return X(b,a),b}(Error),b=function(){function a(){this.progress=0}return a.prototype.getElement=function(){var a;if(null==this.el){if(a=document.querySelector(C.target),!a)throw new i;this.el=document.createElement("div"),this.el.className="pace pace-active",document.body.className=document.body.className.replace("pace-done",""),document.body.className+=" pace-running",this.el.innerHTML='<div class="pace-progress">\n  <div class="pace-progress-inner"></div>\n</div>\n<div class="pace-activity"></div>',null!=a.firstChild?a.insertBefore(this.el,a.firstChild):a.appendChild(this.el)}return this.el},a.prototype.finish=function(){var a;return a=this.getElement(),a.className=a.className.replace("pace-active",""),a.className+=" pace-inactive",document.body.className=document.body.className.replace("pace-running",""),document.body.className+=" pace-done"},a.prototype.update=function(a){return this.progress=a,this.render()},a.prototype.destroy=function(){try{this.getElement().parentNode.removeChild(this.getElement())}catch(a){i=a}return this.el=void 0},a.prototype.render=function(){var a,b;return null==document.querySelector(C.target)?!1:(a=this.getElement(),a.children[0].style.width=""+this.progress+"%",(!this.lastRenderedProgress||this.lastRenderedProgress|0!==this.progress|0)&&(a.children[0].setAttribute("data-progress-text",""+(0|this.progress)+"%"),this.progress>=100?b="99":(b=this.progress<10?"0":"",b+=0|this.progress),a.children[0].setAttribute("data-progress",""+b)),this.lastRenderedProgress=this.progress)},a.prototype.done=function(){return this.progress>=100},a}(),h=function(){function a(){this.bindings={}}return a.prototype.trigger=function(a,b){var c,d,e,f,g;if(null!=this.bindings[a]){for(f=this.bindings[a],g=[],d=0,e=f.length;e>d;d++)c=f[d],g.push(c.call(this,b));return g}},a.prototype.on=function(a,b){var c;return null==(c=this.bindings)[a]&&(c[a]=[]),this.bindings[a].push(b)},a}(),N=window.XMLHttpRequest,M=window.XDomainRequest,L=window.WebSocket,v=function(a,b){var c,d,e,f;f=[];for(d in b.prototype)try{e=b.prototype[d],null==a[d]&&"function"!=typeof e?f.push(a[d]=e):f.push(void 0)}catch(g){c=g}return f},z=[],Pace.ignore=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?V.call(arguments,1):[],z.unshift("ignore"),c=b.apply(null,a),z.shift(),c},Pace.track=function(){var a,b,c;return b=arguments[0],a=2<=arguments.length?V.call(arguments,1):[],z.unshift("track"),c=b.apply(null,a),z.shift(),c},H=function(a){var b;if(null==a&&(a="GET"),"track"===z[0])return"force";if(!z.length&&C.ajax){if("socket"===a&&C.ajax.trackWebSockets)return!0;if(b=a.toUpperCase(),Y.call(C.ajax.trackMethods,b)>=0)return!0}return!1},j=function(a){function b(){var a,c=this;b.__super__.constructor.apply(this,arguments),a=function(a){var b;return b=a.open,a.open=function(d,e){return H(d)&&c.trigger("request",{type:d,url:e,request:a}),b.apply(a,arguments)}},window.XMLHttpRequest=function(b){var c;return c=new N(b),a(c),c},v(window.XMLHttpRequest,N),null!=M&&(window.XDomainRequest=function(){var b;return b=new M,a(b),b},v(window.XDomainRequest,M)),null!=L&&C.ajax.trackWebSockets&&(window.WebSocket=function(a,b){var d;return d=new L(a,b),H("socket")&&c.trigger("request",{type:"socket",url:a,protocols:b,request:d}),d},v(window.WebSocket,L))}return X(b,a),b}(h),P=null,x=function(){return null==P&&(P=new j),P},x().on("request",function(b){var c,d,e,f;return f=b.type,e=b.request,Pace.running||C.restartOnRequestAfter===!1&&"force"!==H(f)?void 0:(d=arguments,c=C.restartOnRequestAfter||0,"boolean"==typeof c&&(c=0),setTimeout(function(){var b,c,g,h,i,j;if(b="socket"===f?e.readyState<2:0<(h=e.readyState)&&4>h){for(Pace.restart(),i=Pace.sources,j=[],c=0,g=i.length;g>c;c++){if(I=i[c],I instanceof a){I.watch.apply(I,d);break}j.push(void 0)}return j}},c))}),a=function(){function a(){var a=this;this.elements=[],x().on("request",function(){return a.watch.apply(a,arguments)})}return a.prototype.watch=function(a){var b,c,d;return d=a.type,b=a.request,c="socket"===d?new m(b):new n(b),this.elements.push(c)},a}(),n=function(){function a(a){var b,c,d,e,f,g,h=this;if(this.progress=0,null!=window.ProgressEvent)for(c=null,a.addEventListener("progress",function(a){return h.progress=a.lengthComputable?100*a.loaded/a.total:h.progress+(100-h.progress)/2}),g=["load","abort","timeout","error"],d=0,e=g.length;e>d;d++)b=g[d],a.addEventListener(b,function(){return h.progress=100});else f=a.onreadystatechange,a.onreadystatechange=function(){var b;return 0===(b=a.readyState)||4===b?h.progress=100:3===a.readyState&&(h.progress=50),"function"==typeof f?f.apply(null,arguments):void 0}}return a}(),m=function(){function a(a){var b,c,d,e,f=this;for(this.progress=0,e=["error","open"],c=0,d=e.length;d>c;c++)b=e[c],a.addEventListener(b,function(){return f.progress=100})}return a}(),d=function(){function a(a){var b,c,d,f;for(null==a&&(a={}),this.elements=[],null==a.selectors&&(a.selectors=[]),f=a.selectors,c=0,d=f.length;d>c;c++)b=f[c],this.elements.push(new e(b))}return a}(),e=function(){function a(a){this.selector=a,this.progress=0,this.check()}return a.prototype.check=function(){var a=this;return document.querySelector(this.selector)?this.done():setTimeout(function(){return a.check()},C.elements.checkInterval)},a.prototype.done=function(){return this.progress=100},a}(),c=function(){function a(){var a,b,c=this;this.progress=null!=(b=this.states[document.readyState])?b:100,a=document.onreadystatechange,document.onreadystatechange=function(){return null!=c.states[document.readyState]&&(c.progress=c.states[document.readyState]),"function"==typeof a?a.apply(null,arguments):void 0}}return a.prototype.states={loading:0,interactive:50,complete:100},a}(),f=function(){function a(){var a,b,c,d,e,f=this;this.progress=0,a=0,e=[],d=0,c=B(),b=setInterval(function(){var g;return g=B()-c-50,c=B(),e.push(g),e.length>C.eventLag.sampleCount&&e.shift(),a=p(e),++d>=C.eventLag.minSamples&&a<C.eventLag.lagThreshold?(f.progress=100,clearInterval(b)):f.progress=100*(3/(a+3))},50)}return a}(),l=function(){function a(a){this.source=a,this.last=this.sinceLastUpdate=0,this.rate=C.initialRate,this.catchup=0,this.progress=this.lastProgress=0,null!=this.source&&(this.progress=E(this.source,"progress"))}return a.prototype.tick=function(a,b){var c;return null==b&&(b=E(this.source,"progress")),b>=100&&(this.done=!0),b===this.last?this.sinceLastUpdate+=a:(this.sinceLastUpdate&&(this.rate=(b-this.last)/this.sinceLastUpdate),this.catchup=(b-this.progress)/C.catchupTime,this.sinceLastUpdate=0,this.last=b),b>this.progress&&(this.progress+=this.catchup*a),c=1-Math.pow(this.progress/100,C.easeFactor),this.progress+=c*this.rate*a,this.progress=Math.min(this.lastProgress+C.maxProgressPerFrame,this.progress),this.progress=Math.max(0,this.progress),this.progress=Math.min(100,this.progress),this.lastProgress=this.progress,this.progress},a}(),J=null,G=null,q=null,K=null,o=null,r=null,Pace.running=!1,y=function(){return C.restartOnPushState?Pace.restart():void 0},null!=window.history.pushState&&(R=window.history.pushState,window.history.pushState=function(){return y(),R.apply(window.history,arguments)}),null!=window.history.replaceState&&(U=window.history.replaceState,window.history.replaceState=function(){return y(),U.apply(window.history,arguments)}),k={ajax:a,elements:d,document:c,eventLag:f},(A=function(){var a,c,d,e,f,g,h,i;for(Pace.sources=J=[],g=["ajax","elements","document","eventLag"],c=0,e=g.length;e>c;c++)a=g[c],C[a]!==!1&&J.push(new k[a](C[a]));for(i=null!=(h=C.extraSources)?h:[],d=0,f=i.length;f>d;d++)I=i[d],J.push(new I(C));return Pace.bar=q=new b,G=[],K=new l})(),Pace.stop=function(){return Pace.trigger("stop"),Pace.running=!1,q.destroy(),r=!0,null!=o&&("function"==typeof s&&s(o),o=null),A()},Pace.restart=function(){return Pace.trigger("restart"),Pace.stop(),Pace.start()},Pace.go=function(){return Pace.running=!0,q.render(),r=!1,o=F(function(a,b){var c,d,e,f,g,h,i,j,k,m,n,o,p,s,t,u,v;for(j=100-q.progress,d=o=0,e=!0,h=p=0,t=J.length;t>p;h=++p)for(I=J[h],m=null!=G[h]?G[h]:G[h]=[],g=null!=(v=I.elements)?v:[I],i=s=0,u=g.length;u>s;i=++s)f=g[i],k=null!=m[i]?m[i]:m[i]=new l(f),e&=k.done,k.done||(d++,o+=k.tick(a));return c=o/d,q.update(K.tick(a,c)),n=B(),q.done()||e||r?(q.update(100),Pace.trigger("done"),setTimeout(function(){return q.finish(),Pace.running=!1,Pace.trigger("hide")},Math.max(C.ghostTime,Math.min(C.minTime,B()-n)))):b()})},Pace.start=function(a){u(C,a),Pace.running=!0;try{q.render()}catch(b){i=b}return document.querySelector(".pace")?(Pace.trigger("start"),Pace.go()):setTimeout(Pace.start,50)}, true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return Pace}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof exports?module.exports=Pace:C.startOnPageLoad&&Pace.start()}).call(this);

/***/ }),
/* 52 */
/***/ (function(module, exports) {

/*!
 * jQuery UI Touch Punch 0.2.1
 *
 * Copyright 2011, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
(function ($) {

  // Detect touch support
  $.support.touch = 'ontouchend' in document;

  // Ignore browsers without touch support
  if (!$.support.touch) {
    return;
  }

  var mouseProto = $.ui.mouse.prototype,
      _mouseInit = mouseProto._mouseInit,
      touchHandled;

  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
  function simulateMouseEvent (event, simulatedType) {

    // Ignore multi-touch events
    if (event.originalEvent.touches.length > 1) {
      return;
    }

    event.preventDefault();

    var touch = event.originalEvent.changedTouches[0],
        simulatedEvent = document.createEvent('MouseEvents');
    
    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(
      simulatedType,    // type
      true,             // bubbles                    
      true,             // cancelable                 
      window,           // view                       
      1,                // detail                     
      touch.screenX,    // screenX                    
      touch.screenY,    // screenY                    
      touch.clientX,    // clientX                    
      touch.clientY,    // clientY                    
      false,            // ctrlKey                    
      false,            // altKey                     
      false,            // shiftKey                   
      false,            // metaKey                    
      0,                // button                     
      null              // relatedTarget              
    );

    // Dispatch the simulated event to the target element
    event.target.dispatchEvent(simulatedEvent);
  }

  /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
  mouseProto._touchStart = function (event) {

    var self = this;
    // Ignore the event if another widget is already being handled
    if (touchHandled || !self._mouseCapture(event)) {
      return;
    }

    // Set the flag to prevent other widgets from inheriting the touch event
    touchHandled = true;

    // Track movement to determine if interaction was a click
    self._touchMoved = false;

    // Simulate the mouseover event
    simulateMouseEvent(event, 'mouseover');

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');

    // Simulate the mousedown event
    simulateMouseEvent(event, 'mousedown');
  };

  /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
  mouseProto._touchMove = function (event) {

    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }

    // Interaction was not a click
    this._touchMoved = true;

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');
  };

  /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
  mouseProto._touchEnd = function (event) {

    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }

    // Simulate the mouseup event
    simulateMouseEvent(event, 'mouseup');

    // Simulate the mouseout event
    simulateMouseEvent(event, 'mouseout');

    // If the touch interaction did not move, it should trigger a click
    if (!this._touchMoved) {

      // Simulate the click event
      simulateMouseEvent(event, 'click');
    }

    // Unset the flag to allow other widgets to inherit the touch event
    touchHandled = false;
  };

  /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
  mouseProto._mouseInit = function () {
    
    var self = this;

    // Delegate the touch handlers to the widget's element
    self.element
      .bind('touchstart', $.proxy(self, '_touchStart'))
      .bind('touchmove', $.proxy(self, '_touchMove'))
      .bind('touchend', $.proxy(self, '_touchEnd'));

    // Call the original $.ui.mouse init method
    _mouseInit.call(self);
  };

})(jQuery);

/***/ }),
/* 53 */
/***/ (function(module, exports) {

/* ------------------------ WELCOME TO WIZARD.JS -------------------------
 * This wizard turns html markup like so:
 *
 *	<div class="wizard" id="myWizard">
 *			<div class="step">
 *					bla bla bla
 *					<button data-action="next">Next</button>
 *					<button data-action="prev">Back</button>
 *			</div>
 *			<div class="step">
 *					bla bla bla
 *					<button data-action="cancel">Cancel</button>
 *			</div>
 *  </div>
 *
 * ...into a "setup wizard" series of steps kind of thing.
 *
 * To use just do something like:
 *
 * 		var myWizard = $('#myWizard').wizard();
 *
 * ...and you should be all set to do things like myWizard.percentComplete(), 
 * myWizard.onNext = function(){ //my stuff here }, etc.
 *
 * Things in each wizard with specific data-actions (next, prev, and cancel) 
 * are automatically all set up to do their thing.
 *
 * TIP: When attaching custom events, attach them to myWizard.parent 
 *			This is because the wizard resets its html every cancel.
 *			ie. myWizard.parent.on(), no $("thing in wizard").on()
 * --------------------------------------------------------------------------
 */

function Wizard( parent ){

	this.parent = parent;
	this.initState = parent.html();	//save initial state for reset on cancel
	this.steps;
	this.current;
	this.onNext = function(){}; //client defined actions that happen at every next
	this.onPrev = function(){}; //client defined actions that happen at every prev
	this.onStep = function(){}; //client defined actions that happen at every step
	this.onChange = function(){}; //client defined actions that happen at every prev, next, or step
	this.onInit = function(){}; //client defined actions that happen at every init
	this.onEnd = function(){}; //client defined actions that happen when user tries to advance past the end
	this.onBeforeStart = function(){}; //client defined actions that happen when user tries to go back past the beginning
	this.onCancel = function(){}; //client defined actions that happen on cancel
	this.onEnable = function( $steps ){}; //client defined actions that happen on enable, is passed enabled steps
	this.onDisable = function( $steps ){}; //client defined actions that happen on cancel, is passed disabled steps
	
	/* initializes the wizard, and resets on cancel
	 *
	 * options = {
	 * 		reset: true/false/string,		< if the wizard should reset to the init state, or to an html string
	 *		startAt: number							< the step to start at, 0 is default
	 * } 
	 *
	 */
	this.init = function( options ){ 
		//make sure options is an array
		if( typeof options != 'object' ){
			options = {};
		}
		//resetting the wizard to this.initState
		if( options['reset'] ){
			if( typeof options['reset'] == 'string' ){
				this.initState = options['reset']; //set initState to html string
			}
			this.parent.html(this.initState); //revert to previous initial state
		}
		//gathering steps
		this.steps = parent.find('.step').not('.disabled');
		$('.step.disabled').hide();
		if( options['startAt'] && typeof options['startAt'] == 'number' && options['startAt'] >= 0 && options['startAt'] < this.steps.length ){
			this.current = options['startAt'];
		}else{
			this.current = 0;
		}
		//setting visibility of steps
		for( var i=0; i<this.steps.length; i++){
			if( i == this.current ){
				$(this.steps[i]).show();
			}else{
				$(this.steps[i]).hide();
			}
		}
		this.onInit();
		return this;
	};
	
	//advances the wizard one step
	//won't go past the last step
	this.next = function(){
		this.scrollIntoView();
		if(this.current<this.steps.length-1){
			var toHide = $(this.steps[this.current]);
			var toShow = $(this.steps[++this.current]);
			toHide.fadeOut(200, function(){
				toShow.fadeIn(100);
			});
			this.onChange();
			this.onNext();
		}else{
			this.onChange();
			this.onEnd();
		}
		return this;
	};
	
	//moves the wizard back one step
	//won't go past the first step
	this.prev = function(){
		this.scrollIntoView();
		if(this.current > 0){
			var toHide = $(this.steps[this.current]);
			var toShow = $(this.steps[--this.current])
			toHide.fadeOut(200, function(){
				toShow.fadeIn(100);
			});
			this.onChange();
			this.onPrev();
		}else{
			this.onChange();
			this.onBeforeStart();
		}
		return this;
	};
	
	//moves the wizard to the desiered step number
	//(step is an integer, not a jQuery object)
	this.step = function(step){
		if(step>=0 && step<this.steps.length){
			this.scrollIntoView();
			var toShow = $(this.steps[step]);
			$(this.steps[this.current]).fadeOut(400, function(){
				toShow.show(400);
			});
			this.current = step;
			this.onChange();
			this.onStep();
		}
		return this;
	};
	
	//reverts wizard back to original state
	this.cancel = function(){
		this.scrollIntoView();
		var thisWizard = this;
		$(this.steps[this.current]).fadeOut(400, function(){
			thisWizard.init({reset:true});
		});
		this.onCancel();
		return this;
	};
	
	//get steps DOM object, indexed starting at 0 
	this.getStep = function(n){
		if( n > this.steps.length || n < 0 ){
			return null
		}
		return $(this.steps[n]);
	};
	
	//returns an integer between 0 and 100 inclusive
	this.percentComplete = function(){
		return Math.floor(this.current/this.steps.length*100);
	};

	//removes the given step n from the wizard, or any step matching a query string
	this.disable = function(step){
		var $step;
		if( typeof step == 'number' ){
			if(step>=0 && step<this.steps.length){
				$step = $(this.steps[step]);
				$step.addClass('disabled').hide();
			}
		}else if( typeof step == 'string' ){
			$step = $(step+".step", this.parent);
			$step.addClass('disabled').hide();
		} 
		this.init({reset:false, startAt:this.current});
		this.onDisable( $step );
		return this;
	};

	//add the given step n to the wizard, or any step matching a query string
	this.enable = function(step){
		var $step;
		if( typeof step == 'number' ){
			if(step>=0 && step<this.steps.length){
				$step = $(this.steps[step]);
				$step.removeClass('disabled').show();
			}
		}else if( typeof step == 'string' ){
			$step = $(step+".step", this.parent);
			$step.removeClass('disabled').show();
		}
		this.init({reset:false, startAt:this.current});
		this.onEnable( $step );
		return this;
	};

	//when going to another step, scroll the next step into view if it is off the screen
	this.scrollIntoView = function(){
		var position = this.parent[0].getBoundingClientRect();
		//if the top of the step is out of the window
		if( position.top < 0 || position.top > $(window).height()){
			//scroll top back into window
			$('html, body').animate({
	      scrollTop: this.parent.offset().top - 180
	  	}, 800);
		}
		return this;
	};

    //reverts wizard back to original state
    this.close = function(){
        var thisWizard = this;
        var domParent = this.parent[0];
        domParent.style.display="none";
        return this;
	};

	/* setup stuff */
	
	//calling initialization
	this.init();

	//listeners
	var thisWizard = this;
	this.parent.on('click', '[data-action=next]', function(e){
		e.preventDefault();
		thisWizard.next();
		thisWizard.scrollIntoView();
	});
	this.parent.on('click', '[data-action=prev]', function(e){
		e.preventDefault();
		thisWizard.prev();
		thisWizard.scrollIntoView();
	});
	this.parent.on('click', '[data-action=cancel]', function(e){
		e.preventDefault();
		thisWizard.cancel();
		thisWizard.scrollIntoView();
	});
    this.parent.on('click', '[data-action=close]', function(e){
        e.preventDefault();
        thisWizard.close();
    });
    this.parent.on('click', '[data-action=goto]', function(e){
        e.preventDefault();
        var stepNumber = e.target.attributes.getNamedItem("step").nodeValue;
        thisWizard.step(stepNumber);
        thisWizard.scrollIntoView();
    });
    this.parent.on('click', '[data-action=ok]', function(e){
        e.preventDefault();

        var v = null;

        [].slice.call(e.target.parentNode.childNodes).forEach(function (element, index) {
            if(element.attributes != null && element.attributes.getNamedItem("business-meta") != null) {
                if(element.attributes.getNamedItem("business-meta").nodeValue == 'case') {
                    if(v != null) {
                        v.push(element.value);
                    }
                    else {
                        v = [];
                        v.push(element.value);
                    }
                }
                else {
                    v = element.value;
                }
                return false;
            }
        });

        var nodeType = e.target.attributes.getNamedItem("node").nodeValue;
        var lastTask = app.canvas.getLastTask();
        var shape = null;

        if(nodeType == 'BranchTask') {
            app.canvas.appendBranchTaskFromWizard(lastTask, v);
        }
        else if(nodeType != 'End'){
            var element = app.canvas.appendTask(lastTask, nodeType, v);
            element.setImage("");
        }
        else {
            app.canvas.appendTask(lastTask, nodeType);
            thisWizard.close();
            return;
        }

        var stepNumber = e.target.attributes.getNamedItem("step").nodeValue;
        thisWizard.step(stepNumber);
        thisWizard.scrollIntoView();
    });
}

//adding to jQuery
var w = {
	wizard: function(){
		$parent = $(this);
		return new Wizard($parent);
	}
}
jQuery.fn.extend(w);

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by David on 2017/3/30.
 */

__webpack_require__(37);
__webpack_require__(10);

__webpack_require__(10);
__webpack_require__(35);
__webpack_require__(36);
__webpack_require__(32);
__webpack_require__(34);
__webpack_require__(33);

document.write(__webpack_require__(51));
document.write(__webpack_require__(48));
document.write(__webpack_require__(11));
document.write(__webpack_require__(52));
document.write(__webpack_require__(49));
document.write(__webpack_require__(50));


document.write(__webpack_require__(46));
document.write(__webpack_require__(44));
document.write(__webpack_require__(45));
document.write(__webpack_require__(41));
document.write(__webpack_require__(40));
document.write(__webpack_require__(42));
document.write(__webpack_require__(47));
document.write(__webpack_require__(43));


document.write(__webpack_require__(39));
document.write(__webpack_require__(11));
document.write(__webpack_require__(38));
document.write(__webpack_require__(53));
document.write(__webpack_require__(29));

    <!-- 以下JS为应用的整体布局的JS -->
document.write(__webpack_require__(17));
document.write(__webpack_require__(19));
document.write(__webpack_require__(18));
document.write(__webpack_require__(31));

    <!-- 以下JS为各个节点的JS -->
document.write(__webpack_require__(25));
document.write(__webpack_require__(23));

    <!-- 固定人 -->
document.write(__webpack_require__(26));
    <!-- 角色 -->
document.write(__webpack_require__(24));
    <!-- 会签 -->
document.write(__webpack_require__(22));
    <!-- 分支 -->
document.write(__webpack_require__(20));

document.write(__webpack_require__(21));

document.write(__webpack_require__(30));

document.write(__webpack_require__(28));

document.write(__webpack_require__(27));


$(window).load(function(){
    Pace.stop();
});

paceOptions = {
    elements: true
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(55)
var ieee754 = __webpack_require__(64)
var isArray = __webpack_require__(65)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(129)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".draggable-model-proxy{\n\tbackground: #e2e2e2;\n\tborder: 1px solid #666;\n\tborder-radius: 6px;\n\topacity: 0.7;\n\tposition: absolute;\n\tz-index: 20;\n\tfilter: alpha(opacity=70);\n}\n\n\n/*控制左面手风琴菜单的样式，覆盖了easyui accordion的部分样式*/\n.accordion .accordion-header .panel-title{\n  font-weight: normal;\n}\n.accordion .accordion-header-selected {\n\tbackground: #f3f3f3;\n}\n.accordion .accordion-header-selected  .bpm-menu-icon{\n\tbackground:  url(" + __webpack_require__(74) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n\n.accordion .accordion-header-selected .panel-title { \n  font-weight: bold;\n  color: #000;\n}\n\n/*左边导航图标*/\n.bpm-nav-icon{\n\tbackground: url(" + __webpack_require__(70) + ") no-repeat scroll 0 0 rgba(0,0,0,0);\n}\n.bpm-menu{\n\toverflow: auto;\n\tpadding: 5px;\n}\n.bpm-menu-icon{\n\tbackground:  url(" + __webpack_require__(73) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n/*开始事件和结束事件图标*/\n.start-event-icon {\n    background: url(" + __webpack_require__(84) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.end-event-icon {\n    background: url(" + __webpack_require__(76) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.role-task-icon {\n    background: url(" + __webpack_require__(71) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n/*任务图标*/\n.user-task-icon {\n    background: url(" + __webpack_require__(86) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.manual-task-icon {\n    background: url(" + __webpack_require__(79) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.script-task-icon {\n    background: url(" + __webpack_require__(81) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.mail-task-icon {\n    background: url(" + __webpack_require__(82) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.service-task-icon {\n    background: url(" + __webpack_require__(83) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.receive-task-icon {\n    background: url(" + __webpack_require__(80) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.business-rule-task-icon {\n    background: url(" + __webpack_require__(75) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.subprocess-icon {\n    background: url(" + __webpack_require__(85) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.callactivity-icon {\n    background: url(" + __webpack_require__(68) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n/*网关图标*/\n.parallel-gateway-icon {\n    background: url(" + __webpack_require__(78) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.exclusive-gateway-icon {\n    background: url(" + __webpack_require__(77) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n/*边界事件图标*/\n.timer-boundary-event-icon {\n    background: url(" + __webpack_require__(72) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n.error-boundary-event-icon {\n    background: url(" + __webpack_require__(69) + ") no-repeat scroll 0 0 rgba(0, 0, 0, 0);\n}\n", ""]);

// exports


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, "/**\n * jqPropertyGrid\n * https://github.com/ValYouW/jqPropertyGrid\n * Author: YuvalW (ValYouW)\n * License: MIT\n */\n.pgTable {\n    border: solid 1px #95B8E7;\n    border-spacing: 0;\n    width: 298px;\n}\n\n.pgGroupRow {\n    background-color: #E0ECFF;\n    font-weight: bold;\n}\n\n.pgGroupCell {\n    padding: 5px;\n}\n\n.pgRow{\n}\n\n.pgCell {\n    border: dotted 1px #ccc;\n    padding: 5px;\n    width: 100px;\n}\n\n.pgTooltip {\n    margin-left: 5px;\n}", ""]);

// exports


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".wizard {\n    border: 1px solid #ddd;\n    padding: 15px;\n    overflow: hidden;\n    display: block;\n    position: relative;\n}\n.wizard .step {\n    border: 1px solid #ddd;\n    background: rgb(255,255,255);\n    width: 400px;\n    height: 400px;\n    /*position: relative; !*脱离文档流*!*/\n    /*top: calc(50%); !*偏移*!*/\n    /*margin: -150px auto 0;*/\n    /*text-align:right;*/\n    margin: auto;\n    position: absolute;\n    top: 0; left: 0; bottom: 0; right: 0;\n}\n.wizard .step .title {\n    text-align:center;\n}\n.wizard .step .dialog-content {\n    text-align:left;\n    padding: 15px;\n}\n.wizard .step .dialog-button {\n    text-align:left;\n    margin-right: 10px;\n    margin-bottom: 10px;\n}\n.wizard .step .left-icon-btn {\n    text-align:left;\n}\n.wizard .step .pull-right {\n    text-align:right;\n    margin-bottom: 10px;\n}", ""]);

// exports


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".panel {\n  overflow: hidden;\n  text-align: left;\n  margin: 0;\n  border: 0;\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.panel-header,\n.panel-body {\n  border-width: 1px;\n  border-style: solid;\n}\n.panel-header {\n  padding: 5px;\n  position: relative;\n}\n.panel-title {\n  background: url(" + __webpack_require__(87) + ") no-repeat;\n}\n.panel-header-noborder {\n  border-width: 0 0 1px 0;\n}\n.panel-body {\n  overflow: auto;\n  border-top-width: 0;\n  padding: 0;\n}\n.panel-body-noheader {\n  border-top-width: 1px;\n}\n.panel-body-noborder {\n  border-width: 0px;\n}\n.panel-body-nobottom {\n  border-bottom-width: 0;\n}\n.panel-with-icon {\n  padding-left: 18px;\n}\n.panel-icon,\n.panel-tool {\n  position: absolute;\n  top: 50%;\n  margin-top: -8px;\n  height: 16px;\n  overflow: hidden;\n}\n.panel-icon {\n  left: 5px;\n  width: 16px;\n}\n.panel-tool {\n  right: 5px;\n  width: auto;\n}\n.panel-tool a {\n  display: inline-block;\n  width: 16px;\n  height: 16px;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n  margin: 0 0 0 2px;\n  vertical-align: top;\n}\n.panel-tool a:hover {\n  opacity: 1;\n  filter: alpha(opacity=100);\n  background-color: #e2e2e2;\n  -moz-border-radius: 3px 3px 3px 3px;\n  -webkit-border-radius: 3px 3px 3px 3px;\n  border-radius: 3px 3px 3px 3px;\n}\n.panel-loading {\n  padding: 11px 0px 10px 30px;\n}\n.panel-noscroll {\n  overflow: hidden;\n}\n.panel-fit,\n.panel-fit body {\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  overflow: hidden;\n}\n.panel-loading {\n  background: url(" + __webpack_require__(8) + ") no-repeat 10px 10px;\n}\n.panel-tool-close {\n  background: url(" + __webpack_require__(4) + ") no-repeat -16px 0px;\n}\n.panel-tool-min {\n  background: url(" + __webpack_require__(4) + ") no-repeat 0px 0px;\n}\n.panel-tool-max {\n  background: url(" + __webpack_require__(4) + ") no-repeat 0px -16px;\n}\n.panel-tool-restore {\n  background: url(" + __webpack_require__(4) + ") no-repeat -16px -16px;\n}\n.panel-tool-collapse {\n  background: url(" + __webpack_require__(4) + ") no-repeat -32px 0;\n}\n.panel-tool-expand {\n  background: url(" + __webpack_require__(4) + ") no-repeat -32px -16px;\n}\n.panel-header,\n.panel-body {\n  border-color: #D3D3D3;\n}\n.panel-header {\n  background-color: #f3f3f3;\n  background: -webkit-linear-gradient(top,#F8F8F8 0,#eeeeee 100%);\n  background: -moz-linear-gradient(top,#F8F8F8 0,#eeeeee 100%);\n  background: -o-linear-gradient(top,#F8F8F8 0,#eeeeee 100%);\n  background: linear-gradient(to bottom,#F8F8F8 0,#eeeeee 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#F8F8F8,endColorstr=#eeeeee,GradientType=0);\n}\n.panel-body {\n  background-color: #ffffff;\n  color: #000000;\n  font-size: 12px;\n}\n.panel-title {\n  font-size: 12px;\n  font-weight: bold;\n  color: #575765;\n  height: 16px;\n  line-height: 16px;\n}\n.panel-footer {\n  border: 1px solid #D3D3D3;\n  overflow: hidden;\n  background: #fafafa;\n}\n.panel-footer-noborder {\n  border-width: 1px 0 0 0;\n}\n.accordion {\n  overflow: hidden;\n  border-width: 1px;\n  border-style: solid;\n}\n.accordion .accordion-header {\n  border-width: 0 0 1px;\n  cursor: pointer;\n}\n.accordion .accordion-body {\n  border-width: 0 0 1px;\n}\n.accordion-noborder {\n  border-width: 0;\n}\n.accordion-noborder .accordion-header {\n  border-width: 0 0 1px;\n}\n.accordion-noborder .accordion-body {\n  border-width: 0 0 1px;\n}\n.accordion-collapse {\n  background: url(" + __webpack_require__(13) + ") no-repeat 0 0;\n}\n.accordion-expand {\n  background: url(" + __webpack_require__(13) + ") no-repeat -16px 0;\n}\n.accordion {\n  background: #ffffff;\n  border-color: #D3D3D3;\n}\n.accordion .accordion-header {\n  background: #f3f3f3;\n  filter: none;\n}\n.accordion .accordion-header-selected {\n  background: #0092DC;\n}\n.accordion .accordion-header-selected .panel-title {\n  color: #fff;\n}\n.window {\n  overflow: hidden;\n  padding: 5px;\n  border-width: 1px;\n  border-style: solid;\n}\n.window .window-header {\n  background: transparent;\n  padding: 0px 0px 6px 0px;\n}\n.window .window-body {\n  border-width: 1px;\n  border-style: solid;\n  border-top-width: 0px;\n}\n.window .window-body-noheader {\n  border-top-width: 1px;\n}\n.window .panel-body-nobottom {\n  border-bottom-width: 0;\n}\n.window .window-header .panel-icon,\n.window .window-header .panel-tool {\n  top: 50%;\n  margin-top: -11px;\n}\n.window .window-header .panel-icon {\n  left: 1px;\n}\n.window .window-header .panel-tool {\n  right: 1px;\n}\n.window .window-header .panel-with-icon {\n  padding-left: 18px;\n}\n.window-proxy {\n  position: absolute;\n  overflow: hidden;\n}\n.window-proxy-mask {\n  position: absolute;\n  filter: alpha(opacity=5);\n  opacity: 0.05;\n}\n.window-mask {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  filter: alpha(opacity=40);\n  opacity: 0.40;\n  font-size: 1px;\n  overflow: hidden;\n}\n.window,\n.window-shadow {\n  position: absolute;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.window-shadow {\n  background: #ccc;\n  -moz-box-shadow: 2px 2px 3px #cccccc;\n  -webkit-box-shadow: 2px 2px 3px #cccccc;\n  box-shadow: 2px 2px 3px #cccccc;\n  filter: progid:DXImageTransform.Microsoft.Blur(pixelRadius=2,MakeShadow=false,ShadowOpacity=0.2);\n}\n.window,\n.window .window-body {\n  border-color: #D3D3D3;\n}\n.window {\n  background-color: #f3f3f3;\n  background: -webkit-linear-gradient(top,#F8F8F8 0,#eeeeee 20%);\n  background: -moz-linear-gradient(top,#F8F8F8 0,#eeeeee 20%);\n  background: -o-linear-gradient(top,#F8F8F8 0,#eeeeee 20%);\n  background: linear-gradient(to bottom,#F8F8F8 0,#eeeeee 20%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#F8F8F8,endColorstr=#eeeeee,GradientType=0);\n}\n.window-proxy {\n  border: 1px dashed #D3D3D3;\n}\n.window-proxy-mask,\n.window-mask {\n  background: #ccc;\n}\n.window .panel-footer {\n  border: 1px solid #D3D3D3;\n  position: relative;\n  top: -1px;\n}\n.dialog-content {\n  overflow: auto;\n}\n.dialog-toolbar {\n  padding: 2px 5px;\n}\n.dialog-tool-separator {\n  float: left;\n  height: 24px;\n  border-left: 1px solid #ccc;\n  border-right: 1px solid #fff;\n  margin: 2px 1px;\n}\n.dialog-button {\n  padding: 5px;\n  text-align: right;\n}\n.dialog-button .l-btn {\n  margin-left: 5px;\n}\n.dialog-toolbar,\n.dialog-button {\n  background: #fafafa;\n  border-width: 1px;\n  border-style: solid;\n}\n.dialog-toolbar {\n  border-color: #D3D3D3 #D3D3D3 #ddd #D3D3D3;\n}\n.dialog-button {\n  border-color: #ddd #D3D3D3 #D3D3D3 #D3D3D3;\n}\n.l-btn {\n  text-decoration: none;\n  display: inline-block;\n  overflow: hidden;\n  margin: 0;\n  padding: 0;\n  cursor: pointer;\n  outline: none;\n  text-align: center;\n  vertical-align: middle;\n}\n.l-btn-plain {\n  border: 0;\n  padding: 1px;\n}\n.l-btn-left {\n  display: inline-block;\n  position: relative;\n  overflow: hidden;\n  margin: 0;\n  padding: 0;\n  vertical-align: top;\n}\n.l-btn-text {\n  display: inline-block;\n  vertical-align: top;\n  width: auto;\n  line-height: 24px;\n  font-size: 12px;\n  padding: 0;\n  margin: 0 4px;\n}\n.l-btn-icon {\n  display: inline-block;\n  width: 16px;\n  height: 16px;\n  line-height: 16px;\n  position: absolute;\n  top: 50%;\n  margin-top: -8px;\n  font-size: 1px;\n}\n.l-btn span span .l-btn-empty {\n  display: inline-block;\n  margin: 0;\n  width: 16px;\n  height: 24px;\n  font-size: 1px;\n  vertical-align: top;\n}\n.l-btn span .l-btn-icon-left {\n  padding: 0 0 0 20px;\n  background-position: left center;\n}\n.l-btn span .l-btn-icon-right {\n  padding: 0 20px 0 0;\n  background-position: right center;\n}\n.l-btn-icon-left .l-btn-text {\n  margin: 0 4px 0 24px;\n}\n.l-btn-icon-left .l-btn-icon {\n  left: 4px;\n}\n.l-btn-icon-right .l-btn-text {\n  margin: 0 24px 0 4px;\n}\n.l-btn-icon-right .l-btn-icon {\n  right: 4px;\n}\n.l-btn-icon-top .l-btn-text {\n  margin: 20px 4px 0 4px;\n}\n.l-btn-icon-top .l-btn-icon {\n  top: 4px;\n  left: 50%;\n  margin: 0 0 0 -8px;\n}\n.l-btn-icon-bottom .l-btn-text {\n  margin: 0 4px 20px 4px;\n}\n.l-btn-icon-bottom .l-btn-icon {\n  top: auto;\n  bottom: 4px;\n  left: 50%;\n  margin: 0 0 0 -8px;\n}\n.l-btn-left .l-btn-empty {\n  margin: 0 4px;\n  width: 16px;\n}\n.l-btn-plain:hover {\n  padding: 0;\n}\n.l-btn-focus {\n  outline: #0000FF dotted thin;\n}\n.l-btn-large .l-btn-text {\n  line-height: 40px;\n}\n.l-btn-large .l-btn-icon {\n  width: 32px;\n  height: 32px;\n  line-height: 32px;\n  margin-top: -16px;\n}\n.l-btn-large .l-btn-icon-left .l-btn-text {\n  margin-left: 40px;\n}\n.l-btn-large .l-btn-icon-right .l-btn-text {\n  margin-right: 40px;\n}\n.l-btn-large .l-btn-icon-top .l-btn-text {\n  margin-top: 36px;\n  line-height: 24px;\n  min-width: 32px;\n}\n.l-btn-large .l-btn-icon-top .l-btn-icon {\n  margin: 0 0 0 -16px;\n}\n.l-btn-large .l-btn-icon-bottom .l-btn-text {\n  margin-bottom: 36px;\n  line-height: 24px;\n  min-width: 32px;\n}\n.l-btn-large .l-btn-icon-bottom .l-btn-icon {\n  margin: 0 0 0 -16px;\n}\n.l-btn-large .l-btn-left .l-btn-empty {\n  margin: 0 4px;\n  width: 32px;\n}\n.l-btn {\n  color: #444;\n  background: #fafafa;\n  background-repeat: repeat-x;\n  border: 1px solid #bbb;\n  background: -webkit-linear-gradient(top,#ffffff 0,#eeeeee 100%);\n  background: -moz-linear-gradient(top,#ffffff 0,#eeeeee 100%);\n  background: -o-linear-gradient(top,#ffffff 0,#eeeeee 100%);\n  background: linear-gradient(to bottom,#ffffff 0,#eeeeee 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffffff,endColorstr=#eeeeee,GradientType=0);\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.l-btn:hover {\n  background: #e2e2e2;\n  color: #000000;\n  border: 1px solid #ccc;\n  filter: none;\n}\n.l-btn-plain {\n  background: transparent;\n  border: 0;\n  filter: none;\n}\n.l-btn-plain:hover {\n  background: #e2e2e2;\n  color: #000000;\n  border: 1px solid #ccc;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.l-btn-disabled,\n.l-btn-disabled:hover {\n  opacity: 0.5;\n  cursor: default;\n  background: #fafafa;\n  color: #444;\n  background: -webkit-linear-gradient(top,#ffffff 0,#eeeeee 100%);\n  background: -moz-linear-gradient(top,#ffffff 0,#eeeeee 100%);\n  background: -o-linear-gradient(top,#ffffff 0,#eeeeee 100%);\n  background: linear-gradient(to bottom,#ffffff 0,#eeeeee 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffffff,endColorstr=#eeeeee,GradientType=0);\n}\n.l-btn-disabled .l-btn-text,\n.l-btn-disabled .l-btn-icon {\n  filter: alpha(opacity=50);\n}\n.l-btn-plain-disabled,\n.l-btn-plain-disabled:hover {\n  background: transparent;\n  filter: alpha(opacity=50);\n}\n.l-btn-selected,\n.l-btn-selected:hover {\n  background: #ddd;\n  filter: none;\n}\n.l-btn-plain-selected,\n.l-btn-plain-selected:hover {\n  background: #ddd;\n}\n.textbox {\n  position: relative;\n  border: 1px solid #D3D3D3;\n  background-color: #fff;\n  vertical-align: middle;\n  display: inline-block;\n  overflow: hidden;\n  white-space: nowrap;\n  margin: 0;\n  padding: 0;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.textbox .textbox-text {\n  font-size: 12px;\n  border: 0;\n  margin: 0;\n  padding: 4px;\n  white-space: normal;\n  vertical-align: top;\n  outline-style: none;\n  resize: none;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.textbox .textbox-prompt {\n  font-size: 12px;\n  color: #aaa;\n}\n.textbox-button,\n.textbox-button:hover {\n  position: absolute;\n  top: 0;\n  padding: 0;\n  vertical-align: top;\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.textbox-button-right,\n.textbox-button-right:hover {\n  border-width: 0 0 0 1px;\n}\n.textbox-button-left,\n.textbox-button-left:hover {\n  border-width: 0 1px 0 0;\n}\n.textbox-addon {\n  position: absolute;\n  top: 0;\n}\n.textbox-icon {\n  display: inline-block;\n  width: 18px;\n  height: 20px;\n  overflow: hidden;\n  vertical-align: top;\n  background-position: center center;\n  cursor: pointer;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n  text-decoration: none;\n  outline-style: none;\n}\n.textbox-icon-disabled,\n.textbox-icon-readonly {\n  cursor: default;\n}\n.textbox-icon:hover {\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n}\n.textbox-icon-disabled:hover {\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.textbox-focused {\n  -moz-box-shadow: 0 0 3px 0 #D3D3D3;\n  -webkit-box-shadow: 0 0 3px 0 #D3D3D3;\n  box-shadow: 0 0 3px 0 #D3D3D3;\n}\n.textbox-invalid {\n  border-color: #ffa8a8;\n  background-color: #fff3f3;\n}\n.filebox .textbox-value {\n  vertical-align: top;\n  position: absolute;\n  top: 0;\n  left: -5000px;\n}\n.combo {\n  display: inline-block;\n  white-space: nowrap;\n  margin: 0;\n  padding: 0;\n  border-width: 1px;\n  border-style: solid;\n  overflow: hidden;\n  vertical-align: middle;\n}\n.combo .combo-text {\n  font-size: 12px;\n  border: 0px;\n  margin: 0;\n  padding: 0px 2px;\n  vertical-align: baseline;\n}\n.combo-arrow {\n  width: 18px;\n  height: 20px;\n  overflow: hidden;\n  display: inline-block;\n  vertical-align: top;\n  cursor: pointer;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.combo-arrow-hover {\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n}\n.combo-panel {\n  overflow: auto;\n}\n.combo-arrow {\n  background: url(" + __webpack_require__(88) + ") no-repeat center center;\n}\n.combo-panel {\n  background-color: #ffffff;\n}\n.combo {\n  border-color: #D3D3D3;\n  background-color: #fff;\n}\n.combo-arrow {\n  background-color: #f3f3f3;\n}\n.combo-arrow-hover {\n  background-color: #e2e2e2;\n}\n.combo-arrow:hover {\n  background-color: #e2e2e2;\n}\n.combo .textbox-icon-disabled:hover {\n  cursor: default;\n}\n.textbox-invalid {\n  border-color: #ffa8a8;\n  background-color: #fff3f3;\n}\n.combobox-item,\n.combobox-group {\n  font-size: 12px;\n  padding: 3px;\n  padding-right: 0px;\n}\n.combobox-item-disabled {\n  opacity: 0.5;\n  filter: alpha(opacity=50);\n}\n.combobox-gitem {\n  padding-left: 10px;\n}\n.combobox-group {\n  font-weight: bold;\n}\n.combobox-item-hover {\n  background-color: #e2e2e2;\n  color: #000000;\n}\n.combobox-item-selected {\n  background-color: #0092DC;\n  color: #fff;\n}\n.layout {\n  position: relative;\n  overflow: hidden;\n  margin: 0;\n  padding: 0;\n  z-index: 0;\n}\n.layout-panel {\n  position: absolute;\n  overflow: hidden;\n}\n.layout-panel-east,\n.layout-panel-west {\n  z-index: 2;\n}\n.layout-panel-north,\n.layout-panel-south {\n  z-index: 3;\n}\n.layout-expand {\n  position: absolute;\n  padding: 0px;\n  font-size: 1px;\n  cursor: pointer;\n  z-index: 1;\n}\n.layout-expand .panel-header,\n.layout-expand .panel-body {\n  background: transparent;\n  filter: none;\n  overflow: hidden;\n}\n.layout-expand .panel-header {\n  border-bottom-width: 0px;\n}\n.layout-split-proxy-h,\n.layout-split-proxy-v {\n  position: absolute;\n  font-size: 1px;\n  display: none;\n  z-index: 5;\n}\n.layout-split-proxy-h {\n  width: 5px;\n  cursor: e-resize;\n}\n.layout-split-proxy-v {\n  height: 5px;\n  cursor: n-resize;\n}\n.layout-mask {\n  position: absolute;\n  background: #fafafa;\n  filter: alpha(opacity=10);\n  opacity: 0.10;\n  z-index: 4;\n}\n.layout-button-up {\n  background: url(" + __webpack_require__(7) + ") no-repeat -16px -16px;\n}\n.layout-button-down {\n  background: url(" + __webpack_require__(7) + ") no-repeat -16px 0;\n}\n.layout-button-left {\n  background: url(" + __webpack_require__(7) + ") no-repeat 0 0;\n}\n.layout-button-right {\n  background: url(" + __webpack_require__(7) + ") no-repeat 0 -16px;\n}\n.layout-split-proxy-h,\n.layout-split-proxy-v {\n  background-color: #bfbfbf;\n}\n.layout-split-north {\n  border-bottom: 5px solid #efefef;\n}\n.layout-split-south {\n  border-top: 5px solid #efefef;\n}\n.layout-split-east {\n  border-left: 5px solid #efefef;\n}\n.layout-split-west {\n  border-right: 5px solid #efefef;\n}\n.layout-expand {\n  background-color: #f3f3f3;\n}\n.layout-expand-over {\n  background-color: #f3f3f3;\n}\n.tabs-container {\n  overflow: hidden;\n}\n.tabs-header {\n  border-width: 1px;\n  border-style: solid;\n  border-bottom-width: 0;\n  position: relative;\n  padding: 0;\n  padding-top: 2px;\n  overflow: hidden;\n}\n.tabs-header-plain {\n  border: 0;\n  background: transparent;\n}\n.tabs-scroller-left,\n.tabs-scroller-right {\n  position: absolute;\n  top: auto;\n  bottom: 0;\n  width: 18px;\n  font-size: 1px;\n  display: none;\n  cursor: pointer;\n  border-width: 1px;\n  border-style: solid;\n}\n.tabs-scroller-left {\n  left: 0;\n}\n.tabs-scroller-right {\n  right: 0;\n}\n.tabs-tool {\n  position: absolute;\n  bottom: 0;\n  padding: 1px;\n  overflow: hidden;\n  border-width: 1px;\n  border-style: solid;\n}\n.tabs-header-plain .tabs-tool {\n  padding: 0 1px;\n}\n.tabs-wrap {\n  position: relative;\n  left: 0;\n  overflow: hidden;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n}\n.tabs-scrolling {\n  margin-left: 18px;\n  margin-right: 18px;\n}\n.tabs-disabled {\n  opacity: 0.3;\n  filter: alpha(opacity=30);\n}\n.tabs {\n  list-style-type: none;\n  height: 26px;\n  margin: 0px;\n  padding: 0px;\n  padding-left: 4px;\n  width: 50000px;\n  border-style: solid;\n  border-width: 0 0 1px 0;\n}\n.tabs li {\n  float: left;\n  display: inline-block;\n  margin: 0 4px -1px 0;\n  padding: 0;\n  position: relative;\n  border: 0;\n}\n.tabs li a.tabs-inner {\n  display: inline-block;\n  text-decoration: none;\n  margin: 0;\n  padding: 0 10px;\n  height: 25px;\n  line-height: 25px;\n  text-align: center;\n  white-space: nowrap;\n  border-width: 1px;\n  border-style: solid;\n  -moz-border-radius: 5px 5px 0 0;\n  -webkit-border-radius: 5px 5px 0 0;\n  border-radius: 5px 5px 0 0;\n}\n.tabs li.tabs-selected a.tabs-inner {\n  font-weight: bold;\n  outline: none;\n}\n.tabs li.tabs-selected a:hover.tabs-inner {\n  cursor: default;\n  pointer: default;\n}\n.tabs li a.tabs-close,\n.tabs-p-tool {\n  position: absolute;\n  font-size: 1px;\n  display: block;\n  height: 12px;\n  padding: 0;\n  top: 50%;\n  margin-top: -6px;\n  overflow: hidden;\n}\n.tabs li a.tabs-close {\n  width: 12px;\n  right: 5px;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.tabs-p-tool {\n  right: 16px;\n}\n.tabs-p-tool a {\n  display: inline-block;\n  font-size: 1px;\n  width: 12px;\n  height: 12px;\n  margin: 0;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.tabs li a:hover.tabs-close,\n.tabs-p-tool a:hover {\n  opacity: 1;\n  filter: alpha(opacity=100);\n  cursor: hand;\n  cursor: pointer;\n}\n.tabs-with-icon {\n  padding-left: 18px;\n}\n.tabs-icon {\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  left: 10px;\n  top: 50%;\n  margin-top: -8px;\n}\n.tabs-title {\n  font-size: 12px;\n}\n.tabs-closable {\n  padding-right: 8px;\n}\n.tabs-panels {\n  margin: 0px;\n  padding: 0px;\n  border-width: 1px;\n  border-style: solid;\n  border-top-width: 0;\n  overflow: hidden;\n}\n.tabs-header-bottom {\n  border-width: 0 1px 1px 1px;\n  padding: 0 0 2px 0;\n}\n.tabs-header-bottom .tabs {\n  border-width: 1px 0 0 0;\n}\n.tabs-header-bottom .tabs li {\n  margin: -1px 4px 0 0;\n}\n.tabs-header-bottom .tabs li a.tabs-inner {\n  -moz-border-radius: 0 0 5px 5px;\n  -webkit-border-radius: 0 0 5px 5px;\n  border-radius: 0 0 5px 5px;\n}\n.tabs-header-bottom .tabs-tool {\n  top: 0;\n}\n.tabs-header-bottom .tabs-scroller-left,\n.tabs-header-bottom .tabs-scroller-right {\n  top: 0;\n  bottom: auto;\n}\n.tabs-panels-top {\n  border-width: 1px 1px 0 1px;\n}\n.tabs-header-left {\n  float: left;\n  border-width: 1px 0 1px 1px;\n  padding: 0;\n}\n.tabs-header-right {\n  float: right;\n  border-width: 1px 1px 1px 0;\n  padding: 0;\n}\n.tabs-header-left .tabs-wrap,\n.tabs-header-right .tabs-wrap {\n  height: 100%;\n}\n.tabs-header-left .tabs {\n  height: 100%;\n  padding: 4px 0 0 4px;\n  border-width: 0 1px 0 0;\n}\n.tabs-header-right .tabs {\n  height: 100%;\n  padding: 4px 4px 0 0;\n  border-width: 0 0 0 1px;\n}\n.tabs-header-left .tabs li,\n.tabs-header-right .tabs li {\n  display: block;\n  width: 100%;\n  position: relative;\n}\n.tabs-header-left .tabs li {\n  left: auto;\n  right: 0;\n  margin: 0 -1px 4px 0;\n  float: right;\n}\n.tabs-header-right .tabs li {\n  left: 0;\n  right: auto;\n  margin: 0 0 4px -1px;\n  float: left;\n}\n.tabs-header-left .tabs li a.tabs-inner {\n  display: block;\n  text-align: left;\n  -moz-border-radius: 5px 0 0 5px;\n  -webkit-border-radius: 5px 0 0 5px;\n  border-radius: 5px 0 0 5px;\n}\n.tabs-header-right .tabs li a.tabs-inner {\n  display: block;\n  text-align: left;\n  -moz-border-radius: 0 5px 5px 0;\n  -webkit-border-radius: 0 5px 5px 0;\n  border-radius: 0 5px 5px 0;\n}\n.tabs-panels-right {\n  float: right;\n  border-width: 1px 1px 1px 0;\n}\n.tabs-panels-left {\n  float: left;\n  border-width: 1px 0 1px 1px;\n}\n.tabs-header-noborder,\n.tabs-panels-noborder {\n  border: 0px;\n}\n.tabs-header-plain {\n  border: 0px;\n  background: transparent;\n}\n.tabs-scroller-left {\n  background: #f3f3f3 url(" + __webpack_require__(12) + ") no-repeat 1px center;\n}\n.tabs-scroller-right {\n  background: #f3f3f3 url(" + __webpack_require__(12) + ") no-repeat -15px center;\n}\n.tabs li a.tabs-close {\n  background: url(" + __webpack_require__(12) + ") no-repeat -34px center;\n}\n.tabs li a.tabs-inner:hover {\n  background: #e2e2e2;\n  color: #000000;\n  filter: none;\n}\n.tabs li.tabs-selected a.tabs-inner {\n  background-color: #ffffff;\n  color: #575765;\n  background: -webkit-linear-gradient(top,#F8F8F8 0,#ffffff 100%);\n  background: -moz-linear-gradient(top,#F8F8F8 0,#ffffff 100%);\n  background: -o-linear-gradient(top,#F8F8F8 0,#ffffff 100%);\n  background: linear-gradient(to bottom,#F8F8F8 0,#ffffff 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#F8F8F8,endColorstr=#ffffff,GradientType=0);\n}\n.tabs-header-bottom .tabs li.tabs-selected a.tabs-inner {\n  background: -webkit-linear-gradient(top,#ffffff 0,#F8F8F8 100%);\n  background: -moz-linear-gradient(top,#ffffff 0,#F8F8F8 100%);\n  background: -o-linear-gradient(top,#ffffff 0,#F8F8F8 100%);\n  background: linear-gradient(to bottom,#ffffff 0,#F8F8F8 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffffff,endColorstr=#F8F8F8,GradientType=0);\n}\n.tabs-header-left .tabs li.tabs-selected a.tabs-inner {\n  background: -webkit-linear-gradient(left,#F8F8F8 0,#ffffff 100%);\n  background: -moz-linear-gradient(left,#F8F8F8 0,#ffffff 100%);\n  background: -o-linear-gradient(left,#F8F8F8 0,#ffffff 100%);\n  background: linear-gradient(to right,#F8F8F8 0,#ffffff 100%);\n  background-repeat: repeat-y;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#F8F8F8,endColorstr=#ffffff,GradientType=1);\n}\n.tabs-header-right .tabs li.tabs-selected a.tabs-inner {\n  background: -webkit-linear-gradient(left,#ffffff 0,#F8F8F8 100%);\n  background: -moz-linear-gradient(left,#ffffff 0,#F8F8F8 100%);\n  background: -o-linear-gradient(left,#ffffff 0,#F8F8F8 100%);\n  background: linear-gradient(to right,#ffffff 0,#F8F8F8 100%);\n  background-repeat: repeat-y;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffffff,endColorstr=#F8F8F8,GradientType=1);\n}\n.tabs li a.tabs-inner {\n  color: #575765;\n  background-color: #f3f3f3;\n  background: -webkit-linear-gradient(top,#F8F8F8 0,#eeeeee 100%);\n  background: -moz-linear-gradient(top,#F8F8F8 0,#eeeeee 100%);\n  background: -o-linear-gradient(top,#F8F8F8 0,#eeeeee 100%);\n  background: linear-gradient(to bottom,#F8F8F8 0,#eeeeee 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#F8F8F8,endColorstr=#eeeeee,GradientType=0);\n}\n.tabs-header,\n.tabs-tool {\n  background-color: #f3f3f3;\n}\n.tabs-header-plain {\n  background: transparent;\n}\n.tabs-header,\n.tabs-scroller-left,\n.tabs-scroller-right,\n.tabs-tool,\n.tabs,\n.tabs-panels,\n.tabs li a.tabs-inner,\n.tabs li.tabs-selected a.tabs-inner,\n.tabs-header-bottom .tabs li.tabs-selected a.tabs-inner,\n.tabs-header-left .tabs li.tabs-selected a.tabs-inner,\n.tabs-header-right .tabs li.tabs-selected a.tabs-inner {\n  border-color: #D3D3D3;\n}\n.tabs-p-tool a:hover,\n.tabs li a:hover.tabs-close,\n.tabs-scroller-over {\n  background-color: #e2e2e2;\n}\n.tabs li.tabs-selected a.tabs-inner {\n  border-bottom: 1px solid #ffffff;\n}\n.tabs-header-bottom .tabs li.tabs-selected a.tabs-inner {\n  border-top: 1px solid #ffffff;\n}\n.tabs-header-left .tabs li.tabs-selected a.tabs-inner {\n  border-right: 1px solid #ffffff;\n}\n.tabs-header-right .tabs li.tabs-selected a.tabs-inner {\n  border-left: 1px solid #ffffff;\n}\n.datagrid .panel-body {\n  overflow: hidden;\n  position: relative;\n}\n.datagrid-view {\n  position: relative;\n  overflow: hidden;\n}\n.datagrid-view1,\n.datagrid-view2 {\n  position: absolute;\n  overflow: hidden;\n  top: 0;\n}\n.datagrid-view1 {\n  left: 0;\n}\n.datagrid-view2 {\n  right: 0;\n}\n.datagrid-mask {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0.3;\n  filter: alpha(opacity=30);\n  display: none;\n}\n.datagrid-mask-msg {\n  position: absolute;\n  top: 50%;\n  margin-top: -20px;\n  padding: 10px 5px 10px 30px;\n  width: auto;\n  height: 16px;\n  border-width: 2px;\n  border-style: solid;\n  display: none;\n}\n.datagrid-sort-icon {\n  padding: 0;\n}\n.datagrid-toolbar {\n  height: auto;\n  padding: 1px 2px;\n  border-width: 0 0 1px 0;\n  border-style: solid;\n}\n.datagrid-btn-separator {\n  float: left;\n  height: 24px;\n  border-left: 1px solid #ccc;\n  border-right: 1px solid #fff;\n  margin: 2px 1px;\n}\n.datagrid .datagrid-pager {\n  display: block;\n  margin: 0;\n  border-width: 1px 0 0 0;\n  border-style: solid;\n}\n.datagrid .datagrid-pager-top {\n  border-width: 0 0 1px 0;\n}\n.datagrid-header {\n  overflow: hidden;\n  cursor: default;\n  border-width: 0 0 1px 0;\n  border-style: solid;\n}\n.datagrid-header-inner {\n  float: left;\n  width: 10000px;\n}\n.datagrid-header-row,\n.datagrid-row {\n  height: 25px;\n}\n.datagrid-header td,\n.datagrid-body td,\n.datagrid-footer td {\n  border-width: 0 1px 1px 0;\n  border-style: dotted;\n  margin: 0;\n  padding: 0;\n}\n.datagrid-cell,\n.datagrid-cell-group,\n.datagrid-header-rownumber,\n.datagrid-cell-rownumber {\n  margin: 0;\n  padding: 0 4px;\n  white-space: nowrap;\n  word-wrap: normal;\n  overflow: hidden;\n  height: 18px;\n  line-height: 18px;\n  font-size: 12px;\n}\n.datagrid-header .datagrid-cell {\n  height: auto;\n}\n.datagrid-header .datagrid-cell span {\n  font-size: 12px;\n}\n.datagrid-cell-group {\n  text-align: center;\n}\n.datagrid-header-rownumber,\n.datagrid-cell-rownumber {\n  width: 25px;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n}\n.datagrid-body {\n  margin: 0;\n  padding: 0;\n  overflow: auto;\n  zoom: 1;\n}\n.datagrid-view1 .datagrid-body-inner {\n  padding-bottom: 20px;\n}\n.datagrid-view1 .datagrid-body {\n  overflow: hidden;\n}\n.datagrid-footer {\n  overflow: hidden;\n}\n.datagrid-footer-inner {\n  border-width: 1px 0 0 0;\n  border-style: solid;\n  width: 10000px;\n  float: left;\n}\n.datagrid-row-editing .datagrid-cell {\n  height: auto;\n}\n.datagrid-header-check,\n.datagrid-cell-check {\n  padding: 0;\n  width: 27px;\n  height: 18px;\n  font-size: 1px;\n  text-align: center;\n  overflow: hidden;\n}\n.datagrid-header-check input,\n.datagrid-cell-check input {\n  margin: 0;\n  padding: 0;\n  width: 15px;\n  height: 18px;\n}\n.datagrid-resize-proxy {\n  position: absolute;\n  width: 1px;\n  height: 10000px;\n  top: 0;\n  cursor: e-resize;\n  display: none;\n}\n.datagrid-body .datagrid-editable {\n  margin: 0;\n  padding: 0;\n}\n.datagrid-body .datagrid-editable table {\n  width: 100%;\n  height: 100%;\n}\n.datagrid-body .datagrid-editable td {\n  border: 0;\n  margin: 0;\n  padding: 0;\n}\n.datagrid-view .datagrid-editable-input {\n  margin: 0;\n  padding: 2px 4px;\n  border: 1px solid #D3D3D3;\n  font-size: 12px;\n  outline-style: none;\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.datagrid-sort-desc .datagrid-sort-icon {\n  padding: 0 13px 0 0;\n  background: url(" + __webpack_require__(6) + ") no-repeat -16px center;\n}\n.datagrid-sort-asc .datagrid-sort-icon {\n  padding: 0 13px 0 0;\n  background: url(" + __webpack_require__(6) + ") no-repeat 0px center;\n}\n.datagrid-row-collapse {\n  background: url(" + __webpack_require__(6) + ") no-repeat -48px center;\n}\n.datagrid-row-expand {\n  background: url(" + __webpack_require__(6) + ") no-repeat -32px center;\n}\n.datagrid-mask-msg {\n  background: #ffffff url(" + __webpack_require__(8) + ") no-repeat scroll 5px center;\n}\n.datagrid-header,\n.datagrid-td-rownumber {\n  background-color: #fafafa;\n  background: -webkit-linear-gradient(top,#fdfdfd 0,#f5f5f5 100%);\n  background: -moz-linear-gradient(top,#fdfdfd 0,#f5f5f5 100%);\n  background: -o-linear-gradient(top,#fdfdfd 0,#f5f5f5 100%);\n  background: linear-gradient(to bottom,#fdfdfd 0,#f5f5f5 100%);\n  background-repeat: repeat-x;\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#fdfdfd,endColorstr=#f5f5f5,GradientType=0);\n}\n.datagrid-cell-rownumber {\n  color: #000000;\n}\n.datagrid-resize-proxy {\n  background: #bfbfbf;\n}\n.datagrid-mask {\n  background: #ccc;\n}\n.datagrid-mask-msg {\n  border-color: #D3D3D3;\n}\n.datagrid-toolbar,\n.datagrid-pager {\n  background: #fafafa;\n}\n.datagrid-header,\n.datagrid-toolbar,\n.datagrid-pager,\n.datagrid-footer-inner {\n  border-color: #ddd;\n}\n.datagrid-header td,\n.datagrid-body td,\n.datagrid-footer td {\n  border-color: #ccc;\n}\n.datagrid-htable,\n.datagrid-btable,\n.datagrid-ftable {\n  color: #000000;\n  border-collapse: separate;\n}\n.datagrid-row-alt {\n  background: #fafafa;\n}\n.datagrid-row-over,\n.datagrid-header td.datagrid-header-over {\n  background: #e2e2e2;\n  color: #000000;\n  cursor: default;\n}\n.datagrid-row-selected {\n  background: #0092DC;\n  color: #fff;\n}\n.datagrid-row-editing .textbox,\n.datagrid-row-editing .textbox-text {\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.propertygrid .datagrid-view1 .datagrid-body td {\n  padding-bottom: 1px;\n  border-width: 0 1px 0 0;\n}\n.propertygrid .datagrid-group {\n  height: 21px;\n  overflow: hidden;\n  border-width: 0 0 1px 0;\n  border-style: solid;\n}\n.propertygrid .datagrid-group span {\n  font-weight: bold;\n}\n.propertygrid .datagrid-view1 .datagrid-body td {\n  border-color: #ddd;\n}\n.propertygrid .datagrid-view1 .datagrid-group {\n  border-color: #f3f3f3;\n}\n.propertygrid .datagrid-view2 .datagrid-group {\n  border-color: #ddd;\n}\n.propertygrid .datagrid-group,\n.propertygrid .datagrid-view1 .datagrid-body,\n.propertygrid .datagrid-view1 .datagrid-row-over,\n.propertygrid .datagrid-view1 .datagrid-row-selected {\n  background: #f3f3f3;\n}\n.pagination {\n  zoom: 1;\n}\n.pagination table {\n  float: left;\n  height: 30px;\n}\n.pagination td {\n  border: 0;\n}\n.pagination-btn-separator {\n  float: left;\n  height: 24px;\n  border-left: 1px solid #ccc;\n  border-right: 1px solid #fff;\n  margin: 3px 1px;\n}\n.pagination .pagination-num {\n  border-width: 1px;\n  border-style: solid;\n  margin: 0 2px;\n  padding: 2px;\n  width: 2em;\n  height: auto;\n}\n.pagination-page-list {\n  margin: 0px 6px;\n  padding: 1px 2px;\n  width: auto;\n  height: auto;\n  border-width: 1px;\n  border-style: solid;\n}\n.pagination-info {\n  float: right;\n  margin: 0 6px 0 0;\n  padding: 0;\n  height: 30px;\n  line-height: 30px;\n  font-size: 12px;\n}\n.pagination span {\n  font-size: 12px;\n}\n.pagination-link .l-btn-text {\n  width: 24px;\n  text-align: center;\n  margin: 0;\n}\n.pagination-first {\n  background: url(" + __webpack_require__(5) + ") no-repeat 0 center;\n}\n.pagination-prev {\n  background: url(" + __webpack_require__(5) + ") no-repeat -16px center;\n}\n.pagination-next {\n  background: url(" + __webpack_require__(5) + ") no-repeat -32px center;\n}\n.pagination-last {\n  background: url(" + __webpack_require__(5) + ") no-repeat -48px center;\n}\n.pagination-load {\n  background: url(" + __webpack_require__(5) + ") no-repeat -64px center;\n}\n.pagination-loading {\n  background: url(" + __webpack_require__(8) + ") no-repeat center center;\n}\n.pagination-page-list,\n.pagination .pagination-num {\n  border-color: #D3D3D3;\n}\n.calendar {\n  border-width: 1px;\n  border-style: solid;\n  padding: 1px;\n  overflow: hidden;\n}\n.calendar table {\n  table-layout: fixed;\n  border-collapse: separate;\n  font-size: 12px;\n  width: 100%;\n  height: 100%;\n}\n.calendar table td,\n.calendar table th {\n  font-size: 12px;\n}\n.calendar-noborder {\n  border: 0;\n}\n.calendar-header {\n  position: relative;\n  height: 22px;\n}\n.calendar-title {\n  text-align: center;\n  height: 22px;\n}\n.calendar-title span {\n  position: relative;\n  display: inline-block;\n  top: 2px;\n  padding: 0 3px;\n  height: 18px;\n  line-height: 18px;\n  font-size: 12px;\n  cursor: pointer;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.calendar-prevmonth,\n.calendar-nextmonth,\n.calendar-prevyear,\n.calendar-nextyear {\n  position: absolute;\n  top: 50%;\n  margin-top: -7px;\n  width: 14px;\n  height: 14px;\n  cursor: pointer;\n  font-size: 1px;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.calendar-prevmonth {\n  left: 20px;\n  background: url(" + __webpack_require__(3) + ") no-repeat -18px -2px;\n}\n.calendar-nextmonth {\n  right: 20px;\n  background: url(" + __webpack_require__(3) + ") no-repeat -34px -2px;\n}\n.calendar-prevyear {\n  left: 3px;\n  background: url(" + __webpack_require__(3) + ") no-repeat -1px -2px;\n}\n.calendar-nextyear {\n  right: 3px;\n  background: url(" + __webpack_require__(3) + ") no-repeat -49px -2px;\n}\n.calendar-body {\n  position: relative;\n}\n.calendar-body th,\n.calendar-body td {\n  text-align: center;\n}\n.calendar-day {\n  border: 0;\n  padding: 1px;\n  cursor: pointer;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.calendar-other-month {\n  opacity: 0.3;\n  filter: alpha(opacity=30);\n}\n.calendar-disabled {\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n  cursor: default;\n}\n.calendar-menu {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 180px;\n  height: 150px;\n  padding: 5px;\n  font-size: 12px;\n  display: none;\n  overflow: hidden;\n}\n.calendar-menu-year-inner {\n  text-align: center;\n  padding-bottom: 5px;\n}\n.calendar-menu-year {\n  width: 40px;\n  text-align: center;\n  border-width: 1px;\n  border-style: solid;\n  margin: 0;\n  padding: 2px;\n  font-weight: bold;\n  font-size: 12px;\n}\n.calendar-menu-prev,\n.calendar-menu-next {\n  display: inline-block;\n  width: 21px;\n  height: 21px;\n  vertical-align: top;\n  cursor: pointer;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.calendar-menu-prev {\n  margin-right: 10px;\n  background: url(" + __webpack_require__(3) + ") no-repeat 2px 2px;\n}\n.calendar-menu-next {\n  margin-left: 10px;\n  background: url(" + __webpack_require__(3) + ") no-repeat -45px 2px;\n}\n.calendar-menu-month {\n  text-align: center;\n  cursor: pointer;\n  font-weight: bold;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.calendar-body th,\n.calendar-menu-month {\n  color: #4d4d4d;\n}\n.calendar-day {\n  color: #000000;\n}\n.calendar-sunday {\n  color: #CC2222;\n}\n.calendar-saturday {\n  color: #00ee00;\n}\n.calendar-today {\n  color: #0000ff;\n}\n.calendar-menu-year {\n  border-color: #D3D3D3;\n}\n.calendar {\n  border-color: #D3D3D3;\n}\n.calendar-header {\n  background: #f3f3f3;\n}\n.calendar-body,\n.calendar-menu {\n  background: #ffffff;\n}\n.calendar-body th {\n  background: #fafafa;\n  padding: 2px 0;\n}\n.calendar-hover,\n.calendar-nav-hover,\n.calendar-menu-hover {\n  background-color: #e2e2e2;\n  color: #000000;\n}\n.calendar-hover {\n  border: 1px solid #ccc;\n  padding: 0;\n}\n.calendar-selected {\n  background-color: #0092DC;\n  color: #fff;\n  border: 1px solid #0070a9;\n  padding: 0;\n}\n.datebox-calendar-inner {\n  height: 180px;\n}\n.datebox-button {\n  height: 18px;\n  padding: 2px 5px;\n  text-align: center;\n}\n.datebox-button a {\n  font-size: 12px;\n  font-weight: bold;\n  text-decoration: none;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.datebox-button a:hover {\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n}\n.datebox-current,\n.datebox-close {\n  float: left;\n}\n.datebox-close {\n  float: right;\n}\n.datebox .combo-arrow {\n  background-image: url(" + __webpack_require__(89) + ");\n  background-position: center center;\n}\n.datebox-button {\n  background-color: #fafafa;\n}\n.datebox-button a {\n  color: #444;\n}\n.numberbox {\n  border: 1px solid #D3D3D3;\n  margin: 0;\n  padding: 0 2px;\n  vertical-align: middle;\n}\n.textbox {\n  padding: 0;\n}\n.spinner {\n  display: inline-block;\n  white-space: nowrap;\n  margin: 0;\n  padding: 0;\n  border-width: 1px;\n  border-style: solid;\n  overflow: hidden;\n  vertical-align: middle;\n}\n.spinner .spinner-text {\n  font-size: 12px;\n  border: 0px;\n  margin: 0;\n  padding: 0 2px;\n  vertical-align: baseline;\n}\n.spinner-arrow {\n  background-color: #f3f3f3;\n  display: inline-block;\n  overflow: hidden;\n  vertical-align: top;\n  margin: 0;\n  padding: 0;\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n  width: 18px;\n}\n.spinner-arrow-up,\n.spinner-arrow-down {\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n  display: block;\n  font-size: 1px;\n  width: 18px;\n  height: 10px;\n  width: 100%;\n  height: 50%;\n  outline-style: none;\n}\n.spinner-arrow-hover {\n  background-color: #e2e2e2;\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n}\n.spinner-arrow-up:hover,\n.spinner-arrow-down:hover {\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n  background-color: #e2e2e2;\n}\n.textbox-icon-disabled .spinner-arrow-up:hover,\n.textbox-icon-disabled .spinner-arrow-down:hover {\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n  background-color: #f3f3f3;\n  cursor: default;\n}\n.spinner .textbox-icon-disabled {\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.spinner-arrow-up {\n  background: url(" + __webpack_require__(15) + ") no-repeat 1px center;\n}\n.spinner-arrow-down {\n  background: url(" + __webpack_require__(15) + ") no-repeat -15px center;\n}\n.spinner {\n  border-color: #D3D3D3;\n}\n.progressbar {\n  border-width: 1px;\n  border-style: solid;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n  overflow: hidden;\n  position: relative;\n}\n.progressbar-text {\n  text-align: center;\n  position: absolute;\n}\n.progressbar-value {\n  position: relative;\n  overflow: hidden;\n  width: 0;\n  -moz-border-radius: 5px 0 0 5px;\n  -webkit-border-radius: 5px 0 0 5px;\n  border-radius: 5px 0 0 5px;\n}\n.progressbar {\n  border-color: #D3D3D3;\n}\n.progressbar-text {\n  color: #000000;\n  font-size: 12px;\n}\n.progressbar-value .progressbar-text {\n  background-color: #0092DC;\n  color: #fff;\n}\n.searchbox {\n  display: inline-block;\n  white-space: nowrap;\n  margin: 0;\n  padding: 0;\n  border-width: 1px;\n  border-style: solid;\n  overflow: hidden;\n  vertical-align: middle;\n}\n.searchbox .searchbox-text {\n  font-size: 12px;\n  border: 0;\n  margin: 0;\n  padding: 0 2px;\n  vertical-align: top;\n}\n.searchbox .searchbox-prompt {\n  font-size: 12px;\n  color: #ccc;\n}\n.searchbox-button {\n  width: 18px;\n  height: 20px;\n  overflow: hidden;\n  display: inline-block;\n  vertical-align: top;\n  cursor: pointer;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n}\n.searchbox-button-hover {\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n}\n.searchbox .l-btn-plain {\n  border: 0;\n  padding: 0;\n  vertical-align: top;\n  opacity: 0.6;\n  filter: alpha(opacity=60);\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.searchbox .l-btn-plain:hover {\n  border: 0;\n  padding: 0;\n  opacity: 1.0;\n  filter: alpha(opacity=100);\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.searchbox a.m-btn-plain-active {\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.searchbox .m-btn-active {\n  border-width: 0 1px 0 0;\n  -moz-border-radius: 0 0 0 0;\n  -webkit-border-radius: 0 0 0 0;\n  border-radius: 0 0 0 0;\n}\n.searchbox .textbox-button-right {\n  border-width: 0 0 0 1px;\n}\n.searchbox .textbox-button-left {\n  border-width: 0 1px 0 0;\n}\n.searchbox-button {\n  background: url(" + __webpack_require__(90) + ") no-repeat center center;\n}\n.searchbox {\n  border-color: #D3D3D3;\n  background-color: #fff;\n}\n.searchbox .l-btn-plain {\n  background: #f3f3f3;\n}\n.searchbox .l-btn-plain-disabled,\n.searchbox .l-btn-plain-disabled:hover {\n  opacity: 0.5;\n  filter: alpha(opacity=50);\n}\n.textbox-invalid {\n  border-color: #ffa8a8;\n  background-color: #fff3f3;\n}\n.slider-disabled {\n  opacity: 0.5;\n  filter: alpha(opacity=50);\n}\n.slider-h {\n  height: 22px;\n}\n.slider-v {\n  width: 22px;\n}\n.slider-inner {\n  position: relative;\n  height: 6px;\n  top: 7px;\n  border-width: 1px;\n  border-style: solid;\n  border-radius: 5px;\n}\n.slider-handle {\n  position: absolute;\n  display: block;\n  outline: none;\n  width: 20px;\n  height: 20px;\n  top: 50%;\n  margin-top: -10px;\n  margin-left: -10px;\n}\n.slider-tip {\n  position: absolute;\n  display: inline-block;\n  line-height: 12px;\n  font-size: 12px;\n  white-space: nowrap;\n  top: -22px;\n}\n.slider-rule {\n  position: relative;\n  top: 15px;\n}\n.slider-rule span {\n  position: absolute;\n  display: inline-block;\n  font-size: 0;\n  height: 5px;\n  border-width: 0 0 0 1px;\n  border-style: solid;\n}\n.slider-rulelabel {\n  position: relative;\n  top: 20px;\n}\n.slider-rulelabel span {\n  position: absolute;\n  display: inline-block;\n  font-size: 12px;\n}\n.slider-v .slider-inner {\n  width: 6px;\n  left: 7px;\n  top: 0;\n  float: left;\n}\n.slider-v .slider-handle {\n  left: 50%;\n  margin-top: -10px;\n}\n.slider-v .slider-tip {\n  left: -10px;\n  margin-top: -6px;\n}\n.slider-v .slider-rule {\n  float: left;\n  top: 0;\n  left: 16px;\n}\n.slider-v .slider-rule span {\n  width: 5px;\n  height: 'auto';\n  border-left: 0;\n  border-width: 1px 0 0 0;\n  border-style: solid;\n}\n.slider-v .slider-rulelabel {\n  float: left;\n  top: 0;\n  left: 23px;\n}\n.slider-handle {\n  background: url(" + __webpack_require__(91) + ") no-repeat;\n}\n.slider-inner {\n  border-color: #D3D3D3;\n  background: #f3f3f3;\n}\n.slider-rule span {\n  border-color: #D3D3D3;\n}\n.slider-rulelabel span {\n  color: #000000;\n}\n.menu {\n  position: absolute;\n  margin: 0;\n  padding: 2px;\n  border-width: 1px;\n  border-style: solid;\n  overflow: hidden;\n}\n.menu-item {\n  position: relative;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  white-space: nowrap;\n  cursor: pointer;\n  border-width: 1px;\n  border-style: solid;\n}\n.menu-text {\n  height: 20px;\n  line-height: 20px;\n  float: left;\n  padding-left: 28px;\n}\n.menu-icon {\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  left: 2px;\n  top: 50%;\n  margin-top: -8px;\n}\n.menu-rightarrow {\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  right: 0;\n  top: 50%;\n  margin-top: -8px;\n}\n.menu-line {\n  position: absolute;\n  left: 26px;\n  top: 0;\n  height: 2000px;\n  font-size: 1px;\n}\n.menu-sep {\n  margin: 3px 0px 3px 25px;\n  font-size: 1px;\n}\n.menu-active {\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.menu-item-disabled {\n  opacity: 0.5;\n  filter: alpha(opacity=50);\n  cursor: default;\n}\n.menu-text,\n.menu-text span {\n  font-size: 12px;\n}\n.menu-shadow {\n  position: absolute;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n  background: #ccc;\n  -moz-box-shadow: 2px 2px 3px #cccccc;\n  -webkit-box-shadow: 2px 2px 3px #cccccc;\n  box-shadow: 2px 2px 3px #cccccc;\n  filter: progid:DXImageTransform.Microsoft.Blur(pixelRadius=2,MakeShadow=false,ShadowOpacity=0.2);\n}\n.menu-rightarrow {\n  background: url(" + __webpack_require__(14) + ") no-repeat -32px center;\n}\n.menu-line {\n  border-left: 1px solid #ccc;\n  border-right: 1px solid #fff;\n}\n.menu-sep {\n  border-top: 1px solid #ccc;\n  border-bottom: 1px solid #fff;\n}\n.menu {\n  background-color: #f3f3f3;\n  border-color: #D3D3D3;\n  color: #444;\n}\n.menu-content {\n  background: #ffffff;\n}\n.menu-item {\n  border-color: transparent;\n  _border-color: #f3f3f3;\n}\n.menu-active {\n  border-color: #ccc;\n  color: #000000;\n  background: #e2e2e2;\n}\n.menu-active-disabled {\n  border-color: transparent;\n  background: transparent;\n  color: #444;\n}\n.m-btn-downarrow,\n.s-btn-downarrow {\n  display: inline-block;\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  font-size: 1px;\n  right: 0;\n  top: 50%;\n  margin-top: -8px;\n}\n.m-btn-active,\n.s-btn-active {\n  background: #e2e2e2;\n  color: #000000;\n  border: 1px solid #ccc;\n  filter: none;\n}\n.m-btn-plain-active,\n.s-btn-plain-active {\n  background: transparent;\n  padding: 0;\n  border-width: 1px;\n  border-style: solid;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.m-btn .l-btn-left .l-btn-text {\n  margin-right: 20px;\n}\n.m-btn .l-btn-icon-right .l-btn-text {\n  margin-right: 40px;\n}\n.m-btn .l-btn-icon-right .l-btn-icon {\n  right: 20px;\n}\n.m-btn .l-btn-icon-top .l-btn-text {\n  margin-right: 4px;\n  margin-bottom: 14px;\n}\n.m-btn .l-btn-icon-bottom .l-btn-text {\n  margin-right: 4px;\n  margin-bottom: 34px;\n}\n.m-btn .l-btn-icon-bottom .l-btn-icon {\n  top: auto;\n  bottom: 20px;\n}\n.m-btn .l-btn-icon-top .m-btn-downarrow,\n.m-btn .l-btn-icon-bottom .m-btn-downarrow {\n  top: auto;\n  bottom: 0px;\n  left: 50%;\n  margin-left: -8px;\n}\n.m-btn-line {\n  display: inline-block;\n  position: absolute;\n  font-size: 1px;\n  display: none;\n}\n.m-btn .l-btn-left .m-btn-line {\n  right: 0;\n  width: 16px;\n  height: 500px;\n  border-style: solid;\n  border-color: #bfbfbf;\n  border-width: 0 0 0 1px;\n}\n.m-btn .l-btn-icon-top .m-btn-line,\n.m-btn .l-btn-icon-bottom .m-btn-line {\n  left: 0;\n  bottom: 0;\n  width: 500px;\n  height: 16px;\n  border-width: 1px 0 0 0;\n}\n.m-btn-large .l-btn-icon-right .l-btn-text {\n  margin-right: 56px;\n}\n.m-btn-large .l-btn-icon-bottom .l-btn-text {\n  margin-bottom: 50px;\n}\n.m-btn-downarrow,\n.s-btn-downarrow {\n  background: url(" + __webpack_require__(14) + ") no-repeat 0 center;\n}\n.m-btn-plain-active,\n.s-btn-plain-active {\n  border-color: #ccc;\n  background-color: #e2e2e2;\n  color: #000000;\n}\n.s-btn:hover .m-btn-line,\n.s-btn-active .m-btn-line,\n.s-btn-plain-active .m-btn-line {\n  display: inline-block;\n}\n.l-btn:hover .s-btn-downarrow,\n.s-btn-active .s-btn-downarrow,\n.s-btn-plain-active .s-btn-downarrow {\n  border-style: solid;\n  border-color: #bfbfbf;\n  border-width: 0 0 0 1px;\n}\n.messager-body {\n  padding: 10px;\n  overflow: hidden;\n}\n.messager-button {\n  text-align: center;\n  padding-top: 10px;\n}\n.messager-button .l-btn {\n  width: 70px;\n}\n.messager-icon {\n  float: left;\n  width: 32px;\n  height: 32px;\n  margin: 0 10px 10px 0;\n}\n.messager-error {\n  background: url(" + __webpack_require__(9) + ") no-repeat scroll -64px 0;\n}\n.messager-info {\n  background: url(" + __webpack_require__(9) + ") no-repeat scroll 0 0;\n}\n.messager-question {\n  background: url(" + __webpack_require__(9) + ") no-repeat scroll -32px 0;\n}\n.messager-warning {\n  background: url(" + __webpack_require__(9) + ") no-repeat scroll -96px 0;\n}\n.messager-progress {\n  padding: 10px;\n}\n.messager-p-msg {\n  margin-bottom: 5px;\n}\n.messager-body .messager-input {\n  width: 100%;\n  padding: 1px 0;\n  border: 1px solid #D3D3D3;\n}\n.tree {\n  margin: 0;\n  padding: 0;\n  list-style-type: none;\n}\n.tree li {\n  white-space: nowrap;\n}\n.tree li ul {\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n.tree-node {\n  height: 18px;\n  white-space: nowrap;\n  cursor: pointer;\n}\n.tree-hit {\n  cursor: pointer;\n}\n.tree-expanded,\n.tree-collapsed,\n.tree-folder,\n.tree-file,\n.tree-checkbox,\n.tree-indent {\n  display: inline-block;\n  width: 16px;\n  height: 18px;\n  vertical-align: top;\n  overflow: hidden;\n}\n.tree-expanded {\n  background: url(" + __webpack_require__(0) + ") no-repeat -18px 0px;\n}\n.tree-expanded-hover {\n  background: url(" + __webpack_require__(0) + ") no-repeat -50px 0px;\n}\n.tree-collapsed {\n  background: url(" + __webpack_require__(0) + ") no-repeat 0px 0px;\n}\n.tree-collapsed-hover {\n  background: url(" + __webpack_require__(0) + ") no-repeat -32px 0px;\n}\n.tree-lines .tree-expanded,\n.tree-lines .tree-root-first .tree-expanded {\n  background: url(" + __webpack_require__(0) + ") no-repeat -144px 0;\n}\n.tree-lines .tree-collapsed,\n.tree-lines .tree-root-first .tree-collapsed {\n  background: url(" + __webpack_require__(0) + ") no-repeat -128px 0;\n}\n.tree-lines .tree-node-last .tree-expanded,\n.tree-lines .tree-root-one .tree-expanded {\n  background: url(" + __webpack_require__(0) + ") no-repeat -80px 0;\n}\n.tree-lines .tree-node-last .tree-collapsed,\n.tree-lines .tree-root-one .tree-collapsed {\n  background: url(" + __webpack_require__(0) + ") no-repeat -64px 0;\n}\n.tree-line {\n  background: url(" + __webpack_require__(0) + ") no-repeat -176px 0;\n}\n.tree-join {\n  background: url(" + __webpack_require__(0) + ") no-repeat -192px 0;\n}\n.tree-joinbottom {\n  background: url(" + __webpack_require__(0) + ") no-repeat -160px 0;\n}\n.tree-folder {\n  background: url(" + __webpack_require__(0) + ") no-repeat -208px 0;\n}\n.tree-folder-open {\n  background: url(" + __webpack_require__(0) + ") no-repeat -224px 0;\n}\n.tree-file {\n  background: url(" + __webpack_require__(0) + ") no-repeat -240px 0;\n}\n.tree-loading {\n  background: url(" + __webpack_require__(8) + ") no-repeat center center;\n}\n.tree-checkbox0 {\n  background: url(" + __webpack_require__(0) + ") no-repeat -208px -18px;\n}\n.tree-checkbox1 {\n  background: url(" + __webpack_require__(0) + ") no-repeat -224px -18px;\n}\n.tree-checkbox2 {\n  background: url(" + __webpack_require__(0) + ") no-repeat -240px -18px;\n}\n.tree-title {\n  font-size: 12px;\n  display: inline-block;\n  text-decoration: none;\n  vertical-align: top;\n  white-space: nowrap;\n  padding: 0 2px;\n  height: 18px;\n  line-height: 18px;\n}\n.tree-node-proxy {\n  font-size: 12px;\n  line-height: 20px;\n  padding: 0 2px 0 20px;\n  border-width: 1px;\n  border-style: solid;\n  z-index: 9900000;\n}\n.tree-dnd-icon {\n  display: inline-block;\n  position: absolute;\n  width: 16px;\n  height: 18px;\n  left: 2px;\n  top: 50%;\n  margin-top: -9px;\n}\n.tree-dnd-yes {\n  background: url(" + __webpack_require__(0) + ") no-repeat -256px 0;\n}\n.tree-dnd-no {\n  background: url(" + __webpack_require__(0) + ") no-repeat -256px -18px;\n}\n.tree-node-top {\n  border-top: 1px dotted red;\n}\n.tree-node-bottom {\n  border-bottom: 1px dotted red;\n}\n.tree-node-append .tree-title {\n  border: 1px dotted red;\n}\n.tree-editor {\n  border: 1px solid #ccc;\n  font-size: 12px;\n  height: 14px !important;\n  height: 18px;\n  line-height: 14px;\n  padding: 1px 2px;\n  width: 80px;\n  position: absolute;\n  top: 0;\n}\n.tree-node-proxy {\n  background-color: #ffffff;\n  color: #000000;\n  border-color: #D3D3D3;\n}\n.tree-node-hover {\n  background: #e2e2e2;\n  color: #000000;\n}\n.tree-node-selected {\n  background: #0092DC;\n  color: #fff;\n}\n.validatebox-invalid {\n  border-color: #ffa8a8;\n  background-color: #fff3f3;\n  color: #000;\n}\n.tooltip {\n  position: absolute;\n  display: none;\n  z-index: 9900000;\n  outline: none;\n  opacity: 1;\n  filter: alpha(opacity=100);\n  padding: 5px;\n  border-width: 1px;\n  border-style: solid;\n  border-radius: 5px;\n  -moz-border-radius: 5px 5px 5px 5px;\n  -webkit-border-radius: 5px 5px 5px 5px;\n  border-radius: 5px 5px 5px 5px;\n}\n.tooltip-content {\n  font-size: 12px;\n}\n.tooltip-arrow-outer,\n.tooltip-arrow {\n  position: absolute;\n  width: 0;\n  height: 0;\n  line-height: 0;\n  font-size: 0;\n  border-style: solid;\n  border-width: 6px;\n  border-color: transparent;\n  _border-color: tomato;\n  _filter: chroma(color=tomato);\n}\n.tooltip-right .tooltip-arrow-outer {\n  left: 0;\n  top: 50%;\n  margin: -6px 0 0 -13px;\n}\n.tooltip-right .tooltip-arrow {\n  left: 0;\n  top: 50%;\n  margin: -6px 0 0 -12px;\n}\n.tooltip-left .tooltip-arrow-outer {\n  right: 0;\n  top: 50%;\n  margin: -6px -13px 0 0;\n}\n.tooltip-left .tooltip-arrow {\n  right: 0;\n  top: 50%;\n  margin: -6px -12px 0 0;\n}\n.tooltip-top .tooltip-arrow-outer {\n  bottom: 0;\n  left: 50%;\n  margin: 0 0 -13px -6px;\n}\n.tooltip-top .tooltip-arrow {\n  bottom: 0;\n  left: 50%;\n  margin: 0 0 -12px -6px;\n}\n.tooltip-bottom .tooltip-arrow-outer {\n  top: 0;\n  left: 50%;\n  margin: -13px 0 0 -6px;\n}\n.tooltip-bottom .tooltip-arrow {\n  top: 0;\n  left: 50%;\n  margin: -12px 0 0 -6px;\n}\n.tooltip {\n  background-color: #ffffff;\n  border-color: #D3D3D3;\n  color: #000000;\n}\n.tooltip-right .tooltip-arrow-outer {\n  border-right-color: #D3D3D3;\n}\n.tooltip-right .tooltip-arrow {\n  border-right-color: #ffffff;\n}\n.tooltip-left .tooltip-arrow-outer {\n  border-left-color: #D3D3D3;\n}\n.tooltip-left .tooltip-arrow {\n  border-left-color: #ffffff;\n}\n.tooltip-top .tooltip-arrow-outer {\n  border-top-color: #D3D3D3;\n}\n.tooltip-top .tooltip-arrow {\n  border-top-color: #ffffff;\n}\n.tooltip-bottom .tooltip-arrow-outer {\n  border-bottom-color: #D3D3D3;\n}\n.tooltip-bottom .tooltip-arrow {\n  border-bottom-color: #ffffff;\n}\n", ""]);

// exports


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".icon-blank{\n\tbackground:url(" + __webpack_require__(93) + ") no-repeat center center;\n}\n.icon-add{\n\tbackground:url(" + __webpack_require__(97) + ") no-repeat center center;\n}\n.icon-edit{\n\tbackground:url(" + __webpack_require__(114) + ") no-repeat center center;\n}\n.icon-clear{\n\tbackground:url(" + __webpack_require__(95) + ") no-repeat center center;\n}\n.icon-remove{\n\tbackground:url(" + __webpack_require__(98) + ") no-repeat center center;\n}\n.icon-save{\n\tbackground:url(" + __webpack_require__(99) + ") no-repeat center center;\n}\n.icon-cut{\n\tbackground:url(" + __webpack_require__(96) + ") no-repeat center center;\n}\n.icon-ok{\n\tbackground:url(" + __webpack_require__(113) + ") no-repeat center center;\n}\n.icon-no{\n\tbackground:url(" + __webpack_require__(112) + ") no-repeat center center;\n}\n.icon-cancel{\n\tbackground:url(" + __webpack_require__(94) + ") no-repeat center center;\n}\n.icon-reload{\n\tbackground:url(" + __webpack_require__(117) + ") no-repeat center center;\n}\n.icon-search{\n\tbackground:url(" + __webpack_require__(118) + ") no-repeat center center;\n}\n.icon-print{\n\tbackground:url(" + __webpack_require__(115) + ") no-repeat center center;\n}\n.icon-help{\n\tbackground:url(" + __webpack_require__(101) + ") no-repeat center center;\n}\n.icon-undo{\n\tbackground:url(" + __webpack_require__(121) + ") no-repeat center center;\n}\n.icon-redo{\n\tbackground:url(" + __webpack_require__(116) + ") no-repeat center center;\n}\n.icon-back{\n\tbackground:url(" + __webpack_require__(92) + ") no-repeat center center;\n}\n.icon-sum{\n\tbackground:url(" + __webpack_require__(119) + ") no-repeat center center;\n}\n.icon-tip{\n\tbackground:url(" + __webpack_require__(120) + ") no-repeat center center;\n}\n.icon-filter{\n\tbackground:url(" + __webpack_require__(100) + ") no-repeat center center;\n}\n.icon-man{\n\tbackground:url(" + __webpack_require__(108) + ") no-repeat center center;\n}\n.icon-lock{\n\tbackground:url(" + __webpack_require__(107) + ") no-repeat center center;\n}\n\n\n.icon-mini-add{\n\tbackground:url(" + __webpack_require__(109) + ") no-repeat center center;\n}\n.icon-mini-edit{\n\tbackground:url(" + __webpack_require__(110) + ") no-repeat center center;\n}\n.icon-mini-refresh{\n\tbackground:url(" + __webpack_require__(111) + ") no-repeat center center;\n}\n\n.icon-large-picture{\n\tbackground:url(" + __webpack_require__(104) + ") no-repeat center center;\n}\n.icon-large-clipart{\n\tbackground:url(" + __webpack_require__(103) + ") no-repeat center center;\n}\n.icon-large-shapes{\n\tbackground:url(" + __webpack_require__(105) + ") no-repeat center center;\n}\n.icon-large-smartart{\n\tbackground:url(" + __webpack_require__(106) + ") no-repeat center center;\n}\n.icon-large-chart{\n\tbackground:url(" + __webpack_require__(102) + ") no-repeat center center;\n}\n", ""]);

// exports


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, "/*!\n * jQuery contextMenu - Plugin for simple contextMenu handling\n *\n * Version: 1.5.24\n *\n * Authors: Rodney Rehm, Addy Osmani (patches for FF)\n * Web: http://medialize.github.com/jQuery-contextMenu/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *   GPL v3 http://opensource.org/licenses/GPL-3.0\n *\n */\n\n.context-menu-list {\n    margin:0; \n    padding:0;\n    \n    min-width: 120px;\n    max-width: 250px;\n    display: inline-block;\n    position: absolute;\n    list-style-type: none;\n    \n    border: 1px solid #DDD;\n    background: #EEE;\n    \n    -webkit-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n       -moz-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n        -ms-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n         -o-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n    \n    font-family: Verdana, Arial, Helvetica, sans-serif;\n    font-size: 11px;\n}\n\n.context-menu-item {\n    padding: 2px 2px 2px 24px;\n    background-color: #EEE;\n    position: relative;\n    -webkit-user-select: none;\n       -moz-user-select: -moz-none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n.context-menu-separator {\n    padding-bottom:0;\n    border-bottom: 1px solid #DDD;\n}\n\n.context-menu-item > label > input,\n.context-menu-item > label > textarea {\n    -webkit-user-select: text;\n       -moz-user-select: text;\n        -ms-user-select: text;\n            user-select: text;\n}\n\n.context-menu-item.hover {\n    cursor: pointer;\n    background-color: #39F;\n}\n\n.context-menu-item.disabled {\n    color: #666;\n}\n\n.context-menu-input.hover,\n.context-menu-item.disabled.hover {\n    cursor: default;\n    background-color: #EEE;\n}\n\n.context-menu-submenu:after {\n    content: \">\";\n    color: #666;\n    position: absolute;\n    top: 0;\n    right: 3px;\n    z-index: 1;\n}\n\n/* icons\n    #protip:\n    In case you want to use sprites for icons (which I would suggest you do) have a look at\n    http://css-tricks.com/13224-pseudo-spriting/ to get an idea of how to implement \n    .context-menu-item.icon:before {}\n */\n.context-menu-item.icon { min-height: 18px; background-repeat: no-repeat; background-position: 4px 2px; }\n.context-menu-item.icon-edit { background-image: url(" + __webpack_require__(127) + "); }\n.context-menu-item.icon-cut { background-image: url(" + __webpack_require__(122) + "); }\n.context-menu-item.icon-copy { background-image: url(" + __webpack_require__(125) + "); }\n.context-menu-item.icon-paste { background-image: url(" + __webpack_require__(128) + "); }\n.context-menu-item.icon-delete { background-image: url(" + __webpack_require__(126) + "); }\n.context-menu-item.icon-add { background-image: url(" + __webpack_require__(124) + "); }\n.context-menu-item.icon-quit { background-image: url(" + __webpack_require__(123) + "); }\n\n/* vertically align inside labels */\n.context-menu-input > label > * { vertical-align: top; }\n\n/* position checkboxes and radios as icons */\n.context-menu-input > label > input[type=\"checkbox\"],\n.context-menu-input > label > input[type=\"radio\"] {\n    margin-left: -17px;\n}\n.context-menu-input > label > span {\n    margin-left: 5px;\n}\n\n.context-menu-input > label,\n.context-menu-input > label > input[type=\"text\"],\n.context-menu-input > label > textarea,\n.context-menu-input > label > select {\n    display: block;\n    width: 100%;\n    \n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n        -ms-box-sizing: border-box;\n         -o-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n.context-menu-input > label > textarea {\n    height: 100px;\n}\n.context-menu-item > .context-menu-list {\n    display: none;\n    /* re-positioned by js */\n    right: -5px;\n    top: 5px;\n}\n\n.context-menu-item.hover > .context-menu-list {\n    display: block;\n}\n\n.context-menu-accesskey {\n    text-decoration: underline;\n}\n", ""]);

// exports


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, "/* This is a compiled file, you should be editing the file in the templates directory */\n.pace {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -ms-box-sizing: border-box;\n  -o-box-sizing: border-box;\n  box-sizing: border-box;\n\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n  border-radius: 10px;\n\n  -moz-background-clip: padding;\n  -webkit-background-clip: padding-box;\n  background-clip: padding-box;\n\n  -webkit-pointer-events: none;\n  pointer-events: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n\n  z-index: 2000;\n  position: fixed;\n  margin: auto;\n  top: 12px;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: 200px;\n  height: 25px;\n  border: 2px solid #29d;\n  background-color: #fff;\n}\n\n.pace .pace-progress {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -ms-box-sizing: border-box;\n  -o-box-sizing: border-box;\n  box-sizing: border-box;\n\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n\n  -webkit-background-clip: padding-box;\n  -moz-background-clip: padding;\n  background-clip: padding-box;\n\n  -webkit-transition: width 1s ease-in-out 1s linear;\n  -moz-transition: width 1s ease-in-out 1s linear;\n  -ms-transition: width 1s ease-in-out 1s linear;\n  -o-transition: width 1s ease-in-out 1s linear;\n  transition: width 1s ease-in-out 1s linear;\n\n  -webkit-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n\n  max-width: 190px;\n  position: fixed;\n  z-index: 2000;\n  display: block;\n  position: absolute;\n  left: 3px;\n  top: 3px;\n  height: 15px;\n  font-size: 12px;\n  background: #29d;\n  color: #29d;\n  line-height: 60px;\n  font-weight: bold;\n  font-family:  Helvetica, Arial, \"Lucida Grande\", sans-serif;\n}\n\n.pace .pace-progress:after {\n  content: attr(data-progress-text);\n  display: inline-block;\n}\n\n.pace.pace-inactive {\n  display: none;\n}", ""]);

// exports


/***/ }),
/* 64 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 65 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 66 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 67 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAANlJREFUeNrs0z1KQ1EUBODv3jwMKgQVfxBSCpbZhAtwCW7DBQgWLkCyC7dg4y6sVDBqUOFFIsZr4SlShJcEWwdOdc7MnGIGVnCGe5Q584ALbKAFCef4xBXeYpHMxi6Ow/QUo4QnHOEVY3xpxh6u0cOwwjZGQX7GJN6dhRRGW1hFu4pFDud57mXqJiPnKeVlkZCyP+Jf4FfgBZtLcHaCU1Ba2MchbjFsCJG4PcEdblCLYvQxWKBMj7jEAbpYS1GedXQinrkhWAXf+MA76iqyX0dE2wsKjGMmPwMA5pRCdd5txKQAAAAASUVORK5CYII="

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAtRJREFUeNpck01oU1kYhp97c5PcO829mmptG4sVC7qzdiypLuwkKWSgUrGMInXnUrS4EFqpFKauCmpFQTSMYNEwTRYz4MhMwB+sG5nOiEXUqMUiSpBYS2yvP7cmNzluTiX4weHwLb7nvN/hfT1Ula7rPxmGcdd13ZAQYj+wG9gCOMAcIPiu1OqmXC7/Go1GG03T3Au8BV4Ba4ErwG0J8wHK8oxH3gZwt7GxcYVpmofD4XBdNpt1K5XKJJAB0sACcBJ4CrwBytWPX1UUZaK/v//07OzstUgkEquvr78D5IEXQB+wDtgh+xOAtSygDXjk9/vPp9Pps0KISrFYfDAyMnJI1/XLwH7gPjACNGiadi0YDNrAJiAAcBpI9vX1JW3bzubz+StCCLG4uDgYj8dTmqYdlLs/9/l8/TU1Ne+9Xq8j1dSpQFhVVW9zc7ORTCZT4XC4dW5uLmFZ1mhvb++Yruu7AFtV1TumaQ62tLSsLJVKAHWABvCsra1tamJiwjUM4zMwGolELuVyuVPBYNAaGBg4oqrqxUAgcGN4eFh0d3fPAPPAAWCtCpRCoVA4lUo5juOUgempqSl/IpF4OT8//8S27esdHR0b0un0j/F4fCmTyfwHmMA7QMHn892zLKukquoYcA64CexoaGi4GY1GWyuVSq5QKIy5rmsnEonb0hPP5B+EqK2tfa0oig3sAbYBV4H/NU37s6ur6++hoaHNQoilmZmZ801NTRekL0aBrcAqtVAo/COE+B34BSgAR4EzrusuTU5ObnccpzWfzx8fHx9/kcvlDGAN8BewKC1OE7AR+A2YBn4G6oH1Ho9nX2dnZ6anp2dne3v7PSALdAOtwOplI2nSEKuBXuAx8An4F7hlGMaHWCzmGobxEIgB7UBIZuJbKBRJ+wFYKRVsBgKKony0LOuY4zjXi8XiH8Brmcwv1QCqQH4J0gGvBBvyLMggfV4e+DoADLn+utF+Xn8AAAAASUVORK5CYII="

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAHKSURBVHjapJKxSxtRHMc/OaHL4RBUKBUEFzkl0m5HoV3yFxQXO0ipKMWry0GHEto4JNQbekKn6JBgcKkOERdT6NKpQ0fj8M4SuCUWS4ZC6PGKqbwOd0nvxLSWfuH48X2/3+/z7r33SxHJcZwSYEV288HXAyK/Of3m01OukFLqt3EcR0kplZRS1XMPlbBNpTonStimErZZGgTQ4gvtdpvW23UmpY+xWoCTj2EEaxAkAfj+rsTPxnuMJy/hrAk/JJw1Qz8A0gfc7hyREh8wHj+DloDhMbzaDgyPQUuE61dANABhm6VJ6WPMr4B/HDZXN/h28w5edSOE+Mdh/hJEi4xlzC1y4TdgZBxvbwsyWe4+D6O3twUj41z4DYy5xQREAyxjeY3z0yZDoxN4+9t0p+5jLK0DhDGTxdvfZmh0gvPTJsbyWu+J0TqyW/XKBW5M38Or70Imy6z1OnFRfUh9N6wrF+jIbrWX1w8XZmrCNpUo59SfJMo5JWxTHS7M1AA9Pki667qJ4kql0v/icl1XAfrlQQrS6TTXUVQX9F9BKZWc6Wso3qPxn0oBUwD5fP6FruuP/tYQBMFOsVh8Ff3J51Qsd+sfNv7SO8qvAQAhhwxt3MdVpwAAAABJRU5ErkJggg=="

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KTMInWQAAAPtJREFUOBFjZMABfCYn/7/19imDvrQyw+rUqYw4lDFglQienv6f8f8XBnFhHgZOdi6G5+/+MSxNmohVLRM2k599eM2gJiTA8P33HwZdMVGGF1/eYFMGFsNqgKygBMP1t+8ZuFhZGS68eMUgzSeG0wCszgKpRoSBEjAMpuFUh9NkkER+Wct/vAqAkigmE6NhYlcNih4UCwgZgE0eayCimEqAA3bO4uUb/585fxmu1MRQlyE20h/uVELyYI1bdx78D3IiiIabhMTAJc8CUzP91iKGW1xPGZ49eg4TQqFxyYOdSSjp4pMHByKhpItPHmwAoaSLTx4e0oSSLi55AGBem/snqMlgAAAAAElFTkSuQmCC"

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAodJREFUeNqEkz1oU2EUhp/ckkRvru2N5ocWLFiCDrZNM0SlQZRQNFmyiIIoKFXo4iA6OGVTdFBxUSoOpXSR2qntUAOCDaYEUWlKpYLiJWgr+bnJTa7G0DSNyxcognjgg4/D+XnPed9j4d/WBxwDvgLvgS2gxX9sLzAOlIAsMAusiMSXgB+wAZZ2QseO5MPAPJAEbgMfhH8WuANsAveBbeBjG5FlR+fXwNVIJBKz2Ww38/n85vr6eiUQCHTW63VrIpGIAyngHjAFvAB+tQs8Br7HYrEDXq/3bKvV+qTr+jOXyzXscDh6SqWSR1VV78TExJRpmovAE+AU8EMCdgPngDdOp/NSs9lc0jTtQSKR+Gy1WrdVVV20Wq3ja2tru8Lh8DWgLvYTBRQJCIpNDxcKhZJhGPOZTCYfDAaLiqL0zc3NvXI4HNnu7u5x0zRNICxYOQLIEuABysB+TdOasixLxWIx32g0qslk8pvb7b5YqVTKQNfy8nIV6BHx+wC7BJhAJ2AMDg522Gy2PT6fj1QqpafT6esLCwuPAoGAS1GU2sjIiB0wxNLLgCQBGeAQ8FaWZbXVaoWj0ejBeDzuGhgY2JyZmfEC0sbGxqiu607gnaB8FdjuAGpirlKtVqv39/cHcrncSbvdrvf29h43DGNodXX1htvtzk5PT68AaWAMeAgYbRpDwFNgzOPxXPH7/WfK5bKezWb1UCjUpWmaM5PJzALPgQtAAZgE9HYBOzAKXAbuAk3gBOADvgjYFeA8oAK3hDJz7QIWwAFEhNLyQspVof0hMfekeA1xLxXLjluQABlwAqeBo+K/JRAsCcZqgoEqsGX56xol0VERiOzC1xJda8BP4LcYkz8DAGCD8CaB5mAsAAAAAElFTkSuQmCC"

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = "data:image/gif;base64,R0lGODlhEAAQAMQAAP//////AP8A//8AAAD//wD/AAAA/wAAAP/7t/z1q/frlfLgffrz2e7YlM2qR+TEdOjLgu/Rh9+4YPvmufvirf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABUALAAAAAAQABAAAAVLYCWOZGme5RSt7IRCSCw3zAnLcQLtOyU+iaBwGHz8iMiEsfJQOJ9Q51ISrSokIqoViq04FuCwGOwQfcfoshedFkEc8LgcDkHZ76YQADs="

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = "data:image/gif;base64,R0lGODlhEAAQAMQAAP//////AP8A//8AAAD//wD/AAAA/wAAAPz8+//7t/z1q/frlenZcfLgffnuw/rxzvrz2e7YlPLt3M2qR+TEdOjLgu/Rh9+4YPvmufvirf///wAAAAAAAAAAAAAAAAAAACH5BAEAABoALAAAAAAQABAAAAVYoCaOZGmeJmatLIZWSSxH0AnLsVLteyZSiqBwGKT8iEgF5RFhOZ2RBSWiwFljlsXFQU0KF5YLgrIom8/ly0XTRLspE43k0qjb7w1GXHOZ+P+AfkYohIUkIQA7"

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAKCAIAAAAy3EnLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjRBRkIxNEZCMDJERTExRTA4MEY1QUYzRTVCMUJENTJEIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjRBRkIxNEZDMDJERTExRTA4MEY1QUYzRTVCMUJENTJEIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NEFGQjE0RjkwMkRFMTFFMDgwRjVBRjNFNUIxQkQ1MkQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NEFGQjE0RkEwMkRFMTFFMDgwRjVBRjNFNUIxQkQ1MkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4kPXMMAAAArUlEQVR42pyP0QrCMAxFky4dw1effPXVTxP0VxT8MfcbIsxNdK5LYtrpQBDBhVt6C03ODcCfhXZ2+wMzq+rvr9777WZN5sryqMA+Lxzio70j4sc8HAwSEUyo2D6GsdmjtyskdQxtiAKC5Qwj5XSuXPbCNdfbpW5EgDWJoRcIbELni6mROlGXNiPEVrWqgxEkESJKoB8IRKsFftnBHpLEEHv6dw/lMM/w70hPAQYAZZVe/HST/lcAAAAASUVORK5CYII="

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkVFNjA4MzBCMDEwRjExRTA5NkREOTE0NUNEQTJEQTVEIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkVFNjA4MzBDMDEwRjExRTA5NkREOTE0NUNEQTJEQTVEIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RUU2MDgzMDkwMTBGMTFFMDk2REQ5MTQ1Q0RBMkRBNUQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RUU2MDgzMEEwMTBGMTFFMDk2REQ5MTQ1Q0RBMkRBNUQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7zpIf5AAAC8UlEQVR42nST30tTYRjHv+/ZcXNTZ5s4f6QyIa/6AYE/ssw0iai86jKsm7zQILCLbiK0m8CF5nBYROumiEIL6aKgnwrVnMpE6g+wcnO52uZ+Km47b897NkP68cKH856H7/O83+c552X4ezUQ54wlJYfKd+6sFIFVn88fCQY/0vYBMYv/LB1hP9jWlno4Ps6/zM/z2Owsj83N8a8eD39EsZb29jRpHIR+K4nlniLwZMBmO3nl1ClIExNILHiQSa6DGQzQVlSgoL4eqaNHMTg5if7Ll1+S/jSR1OQKDF2z2c5e6+hA+OJFxD5/giJq6/VgxUbwwiJshMNQ3G4cO3MGeVbrrnevX5so74VwsL+ptXXe5XRqQt3dSCWTkESiVguJTpdMJmgqKyFZLMj4fJB+/EDRQD9azncrrunpA8LB1aHh4abdb94gsrgIiRIZ59neJAlMQxLGwDc2wBMJpKiAIZ6AqbOTjT9+DMloNh9uqa1FZGYGTJxsNIKZdpD1YrDCQtUJMmk1GZubavGoy4VmqxWm0tJmuaK6uty8vo4EVUZREUwjI5CrqnIjZlknLDvrDGnWLvVhMxDADnJUWVNjkVRRJoO8eEwV8RzZFw5FoCgqnHScXCBNjihOuUz2Ly+vhvR6S4negFQ4hFBf3+9vy8TJW4glisTj0FF70fx8rHz7FpCi9Ie5aLr5ra3I+74KmWwKkUo0Ch6JgK+tZYnF1FkYGxvh9noRDgTcEtV1jjgcCu/pgUyVtcGf0FE7krAoy+AEcvCMArmgAJquLtwcHRWenOIz+r1LS2XaurqGDiqSfv4cCAUhp1KQqFeJbIN6RyIOWadF6YgdNz58wL2xsbuUe3trXAXEq+t2O08veDjv7eXJvXt5tLpKJblvD+cXeniG7sSgw8FpNm9JX/jnZTIQt44cP65MTE5yn9vNk1NTKiu0f/rsGW8/cYLs4M72ZPaPW3lIXGdzeXkz/SNlIvDd6w0E/X43be8T77eLfwkwACoGVM5z6EZtAAAAAElFTkSuQmCC"

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAdtJREFUeNqUk99LU3EYxh+qK8GL6A9wRDgy2KQy+sOKftyF1kWC1m5ipTXrIigjHKQLXSdLadJ0bWfzxzAvFtSUsTwr6ridnY8XZxtIrdwD36vv+zzvr+eV2iMoicbzqUMEJDGT2mBifqUp0tMROZXO8BNYA8bmPhxaJCiJrGkCUHHgiw2rLjx8s/RfkYAk0pkMTVRd+F6DogNbQHi2fSX9kkibWQAkcWd0pCW0nFtDEomKw9148o/BBiSx/MnL7ADJ3CaSuB8OU9zeQRK3R0bZqsGcDTenD1bCbHIdCyjvgVX1sm4WvjWDiEQiABRsSFrwogI3XnvbOSJJZauibVv67Uh1GizcVn/1el2S1HVU6j4m+bqkE8e7vc94PO6XxL2XBvlfUHYgkdlAEuPjY5RKJa+F4WGqQAWYTqaRxNVr1y9IkhYXFk5L4kH0PcXGEEOhUGuI+XweSTi1GivZVSQxODh08cAaDMPolcSj6Fu+urBThV0b9hxwXU/INE2PPHRr4K9GiMVipyTxdOYdxRp8LkNhF34AH811JHHp8pWBf1pxaip6UhKTsXmsRs+LqRyS6PX7zx/qGJ49n+yRxCsjwZLpeaKv78zZjs5x4vETX9MHwWD/uXZx+wMAwkGPHkP2mlQAAAAASUVORK5CYII="

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAUxJREFUeNqUUrtOw0AQNBI9NIgKwg9AOvg7GmpainQ0iCYdoJAgkoKEp2XHD4KNsISEeIQGhWAMwRl2LzlHJlh2Rhqd7nwzO7drRUnGChFDLioTYpmFJb2F7dqFNFnIKhaV1aaBdwAtYqFSz5xEiC3TBCMgPvcBi1g4Ok1NkucLhmFAQvbgtQfYZLJVbiQmEZWNYeWwHzfgrecD59/AZulszCQv3/wX0oBBetyFwOEHsLEfJVliA1SuXNGwbjgSJVH/BIodYP1AFftpdvC/espToCizU+kjmiFFjtien4vOOAZ2jjXcULxOwhMY3Is3YvXald/WpEmOD3arOjyK+OL/b8Cw3dsxcSxJsabhnn6AdjAy+AkHYsdxE8WxJHt1HY80sofuIA0tUO2o8mpan0SSckMT/eDpXFpuZnEsyYlqoul4E4tjJmniXwEGAEptXgM0kfyWAAAAAElFTkSuQmCC"

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAjZJREFUeNq0k81LVGEcRs973/femblzZxRSpkVJXxgUFqiLFkqQQrUwsAhmnxhGCK2MaBF9bFq4iCjaFK0Gaif2FzQ5tGhSayGVoLWy0XAcHce5751fi2xvSGd/zup5lIjwPxn2fX8lkUhMAPF/ERVws6OjQ0qlkrS1tQnQtlN5wBiz0NffL9ZaGRwcFNd1X+xUvnXoSLtMfSiKiMjgxUsCFIB2YD9wADgB9AABgNkWm4DRYyc7706+zbMnlaAawZmz51lcXOyMbDgrIiilVBAErtZaFQqFp2EYXgN4lEgGK129fVL8ZeVLVeTbmsiPDZGKiGyJyFotlM26lb8Ui0UBVoHT6vqTifHj3aduHD7Yig94QFxDTEM6DnMzszx+eB9rQyIbEY/HSKVS+L5PLpdbU8/m5bJjeeUCKQ+aY5B0tyMO+C44YQ2DkIx7eFpRrZTJ5/Nks9nvZnODZQDXgUggjKDm/Yml41BeXuX5+AM+vn+HArR28IyhXC5TrVYnjRuj1IiIGgpdE2hYCBuwGcJGHZJeM0Nj9wiMoMXiKsHXwsjwENPT0y1m8dPserplL1FkMcajqbUFNwFbDXANzEwVeHl3FKMdHEcR81x+Li2xMP/1DTCmlOP0GuPlRMQ6WseaMvsy50Zuq6NdPbRmMsSNJk2dQNWxtXXq1RXGrl5h7vP0ADCpAGd7utH2LrqBrDbmQiyZTiaSQUxr40gjath6zVbKqxVb33oN3AGqardvdHZ7198DAPFZ9Jqz2sl5AAAAAElFTkSuQmCC"

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAcBJREFUeNrEkz1oU3EUxX//92VqtCmG0kEQEUTslCJRqItUBzeLDurq4iI4iXYQB3edpIM4W3RQRCxIcWsFE7WitCJqtShEREvMS957eR/H4VXTPYIXLvdOh8P53Wsk0U9Z9FkG6MuC82e5NDXFhctXCRKbtV8QxRCl+eym0E0gM1AowOOZG1y7cu6viBZXfQE6NHFYCy+X9KUjPf8szX+QnryVZt9Ic++l+7XvOjp5SoBuzjUEyALYNlTkY1NMHDvD+Ngot29NM7gVLAskGCrB0tNHTFaHGdm1n3uvRXl4pOfg05q03JBWmtKDhRUBOnHytOaXf6i2muns+YsCdH2mrtl30t26dKeungPXytNstWDP7p0sfhWl7RUO7i1T3WHx7WeXh69CRiv7CFrr+KwNFBq+8IP14GIRRAn2JpcXz2q0W00q40foBAm2sUllSDIwFhwfMzkF1wbPhk6Y4Acxxjg4CVQPVMmAdgcMoh2GuI6H49hkGzG6NgRRjDJRHhwgySBKIOpCnEEq8DwXjIsfdFEiNhecnkA7SCkWbIoDFmEMxJDZOYE85rw9B0pbPIIoJQiTf3OJ5r8/U98CvwcAj+jiE/fy+GEAAAAASUVORK5CYII="

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI1MjUwNDE2MDJERjExRTBCRTYyODU5NTAzMUEzQkM2IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI1MjUwNDE3MDJERjExRTBCRTYyODU5NTAzMUEzQkM2Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MjUyNTA0MTQwMkRGMTFFMEJFNjI4NTk1MDMxQTNCQzYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MjUyNTA0MTUwMkRGMTFFMEJFNjI4NTk1MDMxQTNCQzYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6CiUrXAAAB5klEQVR42pxTO0scURg9O84qUZzFTQg+UgiKJIUW6wop7AIprG1TWAkWShoru2CnIBaGWNgqKKyo+QEJIkJGg1pIfOuqODtxddgdd3fWmZvvzsyVQTQ+Dpz7+OZ+557v3rmAB5k4TWRPpewLfCF2atoZwnLYi4RCuI2cAxQprm7uoLO9jYc+8uY9V7o0DPYY8FX+7v1CmE1NTrKT09MH7f7Z3WeLa5ti7lrlPlkymYSiKEin014AdyMSiSAajfLhKLHvxkEikWCPha+/EBT+xIMcv9c2/lvCsaazVc0Q82ZRgkI0VFVFY0MDsqZJX0PuCocFLoQ2LyktQ+H1KwwPjmBs4LPId9EtXHAU/NM+83lBPCce2IytXDE2c5QRLmJCoIoHUrrOtrZ37i2BC8xeeqx928Jj34J/y0Qs3ta1tPgTuVzeywhch01jm3oLEpYcBSvr2xj60AQ5ILC/qv4Ck2QYOdtNEGdwTX2Wsi+KQJom+UqGspe1N2/AhSSHe1rjceipFOrf1OE+fN3Lkw0Lfw93IYVLM6KEDuL3rHmFivIXMPOWa19UUKA3kL0GMuTi3JGwZcvornZTeyVq3vHkufl5yCUSTKo/5N+Pf3uwHK8E3QK0oi2SfxDH8ZwnTFwm1vDkfwIMALaYcE4nvzwUAAAAAElFTkSuQmCC"

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjkzMEI4RjE2MDJFMTExRTBBNjZFODY5ODhFNTc1QTlFIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjkzMEI4RjE3MDJFMTExRTBBNjZFODY5ODhFNTc1QTlFIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTMwQjhGMTQwMkUxMTFFMEE2NkU4Njk4OEU1NzVBOUUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTMwQjhGMTUwMkUxMTFFMEE2NkU4Njk4OEU1NzVBOUUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6eAL5rAAAB+ElEQVR42sSTXUiTYRTHf+/H3Lsp22zl5iw3cBcpdiX2IaRgm8WKpIuQboRoBEFEIF1JF33dBLsIuqgUgqCIqHSsXZQKeiF9mCGxhsSa0FW4K2lbe1nb2+MCX+8XdOA8cOA8v/M/zzmPZBgG9ZhMnSYJr0uCunmsfE7h83q4d3+CzNp3fL42NHsTaoOG1WrHamvEqtn5jQWHs5mjfUGMchGP1/cXkEjE+bi0zI2bt3j0+ClPnifYuasVr28PTU43DTYHVcVO38FeIkd6uH51nOGRqKkg+y1LfPolhXyec+cv0N29jwcPn5FezeBy/6R1t5+zZwbpaN/B2KWLvJ6Zp7MnbAJsNq0WzM6+YXMqx06c5MrlKCupNTaKZUIDBygXc9y5fZcX8ST2RgcV0cIWYPubzs3NsLT8icnJCYYG9wugVOt3bPwaH94t4nS3iawqZf2XCTBXwWBvZxeqohCLxUQrXbibnaTSXynpOr2H+kmnvog6MrpeMAGVSqUW+AMB2v0BLKpC8lWC928Xt7QNnzqNxaqhl3Qy2Syl4jaAxaLSEQwSDoeZnpoiny/Q0uIRhVThUi1xYWEeh8vF6GiUZDKBJEkmoFqtEokcJ7e+zuH+ATF7TVyURZKMLNpRhMuyIpQa5HI/GAqFhJL8v9lE6b9/proBfwQYAP9UpOZqynn9AAAAAElFTkSuQmCC"

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkRGMTM2RkY1MDJEQzExRTBCQ0JGRTZDM0M5NDQ5MEM2IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkRGMTM2RkY2MDJEQzExRTBCQ0JGRTZDM0M5NDQ5MEM2Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6REYxMzZGRjMwMkRDMTFFMEJDQkZFNkMzQzk0NDkwQzYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6REYxMzZGRjQwMkRDMTFFMEJDQkZFNkMzQzk0NDkwQzYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6m+0j/AAACG0lEQVR42mxST4gScRT+uQhitHtI0FORh+rqwYOHkKK6KIIgeHBhE+wggdDZk4IetqsXIYztqoIg/qFNUUSw3RJKdtkWnYMmmM3Y2Dqz5Wzu7Df+TDe2B/Pj+35v3pvvvfmIfCW8Xi+ZRyAQuJolSxQKhdLpNIDZbC4Uiu/39gwGA2g2m0WxJEmrAkEQyN+oVCo4a7Vat9tTq9XFYhG0VCrhHI1Gi4J+vw++u/uOZVkAt9v9nWWls7Otraegvd7Xk5MJQKfTWUkKh8MajYbjlB6j0Q/6teFwCDqdToGr1Sp9c61cLicSCavVioRWq93ZeaPT3XA4HE6nEzNsb79UuhIiimI8Hk8mk0vxJJPJsCwHgOlps0gkAtputzsMQy7HRDhdbIAQm802m80oBfB4PLiklE6yhmf9+jWVSnV8/AUY4HIvSsfjnwAbG+vBYHBR7ff79/c/jHkeaSyAXkajUbqcg4NDu90+GAwUFd1u17O5qeyEn4C/SrwGxsQulwsAY8x/lAipOp2u2WySVquFxB9Z/saLjY+fBUl+W21QPQzDnJ/L9Xq9UChMJsoAqVRKkaQom4fFYsHbKOZFaSz8Qurho8cmk8loNCLr8/lW1oAqmEKv1x8xPf50SuvHwu9PrUPqqHw+Dx/8Yz4sEV949vzF/QdPAGKx2M1bt4/azJ279ziO+49bUZDL5WjvRqPBzzdGnbe0KuJCgAEAqOrA8TUmXNAAAAAASUVORK5CYII="

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjA5M0UyNTM3MDExMDExRTA4OERCQzBDNzAxOEE2MDUzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjA5M0UyNTM4MDExMDExRTA4OERCQzBDNzAxOEE2MDUzIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDkzRTI1MzUwMTEwMTFFMDg4REJDMEM3MDE4QTYwNTMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDkzRTI1MzYwMTEwMTFFMDg4REJDMEM3MDE4QTYwNTMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5gZDsIAAADP0lEQVR42mRTW0wUVxj+5szMLuzsAsKCLLtIUk1rU9vygFpakApK05A2aKopMdonA6SmD018UPSJPphAceM2XLxWm+IlJiaWXmiFeKmUh0L6RELaZBsWGWCR5bI7MDM7c/pPUWP0nPnmcv7//+b7//8cAS+PrYSD/nX5FcFAMCCLTHg8O63qibmh7trd33309lvDhmkibRj/OwvPBboJp6ora440f94kBd8sguHSIAkMnrQX6piKa5cu2/7JaM/JHZVHfZKUMizrGUEG4Wb7V+11VYcrEBk7g+G/78BILcMrKCjOKkHFxl2o33wAg9/fw+89kYHO6p31XpcrKT4haGtrbT9U9sUW1N2uw8jEKNy2Aa+oIMedA6+chflkAkPRQezf2wDIxa/cuHE1/+Ng8AdHQWlV+ft/ftN/Wqz5+T0sJTXk2CI8lgteKMh15aHQU4Ki7E1YXI5jaiGKtvoLaD10ArtnJsodBS0dX3e805vRjT8e/QWvBEiUmSSIkAWJ4ILEJKQtA5qeJIIY5o049pUdxP6ODrC87LzKUNl63J3+Bb5MqipRcoLNbJiCCY1rSOhzUJf/xUxqEibNgfF++F/zoyg/UC6FAsWFukfDYnoJkkyBHLC4TbBgcGqVBZjchGiJsEwOnZQsrCaxQDMU2lBAagW6OCQn0EUJ0dO2KYhu3E7DIkbDSpOR0Tq92xZWiJysTijY5FRsxq0p8Gf6QKrBSAWlDosYDdGGwdJYEQysQIdGSHEdGYpCBc7GRGwizh4vzj18NBJH1YZamPQjRwkjJYK8RqITiS5aWGVrWKKUKl+tRmI8ATWuDjMSfSESjthNgeNY58sAJxKZwNiaGjh1eaJohT4zFRnHtreAYpz9c95poxqNRQs2KW9sa/q0ET+qt5DU0pBNUkFEThGdmiR12q6SC9f3Xcf41X8Q7gqfJ2vn03PgIfSHT0X46NJD3jj2CX/9p2ye3wueexG85Nss3vDbHj6k3udd4W7OBDZI/t4XD5ND0v7Bzg+bmo80CoWlfqTcy9QJQFn1IT42j7OdZ9H3a9858vuSkHyR4Ol4l/BZwB8oDwWL11OTManGZqdmp4Zp/QrhwfPO/wkwAAOQXgA2fuS2AAAAAElFTkSuQmCC"

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAUFJREFUeNqkk01Lw0AURc+bSacf6sKtIEXsqqv+Bv8/rixYXNiFG+miBU3S0sw8F5OkSRlQ7IOBlyHvzM29E1FVLqkMQET+RVFVyToPeMD+MlQCB+BW5KQA4AvIS3AGnIWxBSunwaBQBtgeoRid9k3TeKBrhxW4u58ym82iQiDUIK8JgAAifbnWGIyJrwSgUjjWq2di0wwdTCy4BtoBDARcBurh4BOACXHYnMuIKbX9c65kLgFoarFYtAMvyyVGhPl8TlBQFPVQdBSIqiIiugvKtfRjnD48MnYZr6sVFbAFPgrYWXgaCaoqrYmlh03edziEQKijySso99EDZxIpDC2UR/j8hkPVfHtMp4nR1zGqJDxwEiFBYVPEy/S2fkeAvYcqdGIMCcAVIDfxpPOqbLzjVmOUMkgAJBHfX0ou/Z1/BgC8yH9gCqSiYwAAAABJRU5ErkJggg=="

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAcVJREFUeNrEk89LVHEUxT/f933pOKPOLEIsWuTKKKnQwNf0AyUsAosWbdr0F7SIaNXCP6eFUAS6iBAiLKmkiFq0KBAGG8bwx9Q4jt/3nfdOixcYtZJZdOBsLpfDvefcayTRCQI6hSTOTk41Ae2XkgjHovL6/OulfJxCnIJPwQM+Tnj57AXHx8coDRRRAoasp2Xh8/InTp4efQqghqTtVKq3pY1Yakq692BGBL2KLt/QqpcqTqrsSist6Utbml36IEABQJDCAUHRQjGEPDBxrszhoaNcuniewRBKFvot9Idw0EIpNHsmStBw2fg2q3OhPM79u3fIdXdTrdbos1Cw0GehBBSCvfS0nUjfm1KtIXlJsXM6NjwssIKcbt66rb+x/O69AIWQmRMY8IJNB5Wvq2zV69jQ0lXo5fe0/6QHkAmYjNZkYj92YgYGj5CkwnvPxJVpHODjbOd8Fzif/Ckm7aRS3UubsfTtp9erjys6NXpGk1NXteakWktaa0nrTnKSFt+8FSBzYmSk+nD28aG4ndBOIEkBE2Csxe06cj09eO8xiMCADQyFfI7F5wvMPXm0gSSiKFrY7xVOX7velIT578/UscCvAQBQoh/ghOapvAAAAABJRU5ErkJggg=="

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALklEQVR42mNgGAXUBcbGxv9BmFx5uAJsivDJEVRItGZsGkjWjMsQmgTqKKASAADJyyyhLrHD5wAAAABJRU5ErkJggg=="

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIESURBVDjLlVJtaxpBEH7uvNSL50skFBqCiDVYpCWiIAjtx4Ih4I/zs78jkD9QioVAUBGNWigqRfpBxSO+3LnbmY13mNQWOvAwuzszz7zsQEoJBomWzWY/V6vVb5lM5oruBr/tYBQKhU+1Wu0r+/CbF6cOA02Tv9jr5gbn+TyGd3cQlQpe40nYFry9xZvLS/y8v8fm+lrZ0lJqukbCTlYwCCsWw3a7RTgex3EggLiuK5jkYkYiynYcjcLcEXOsvjvDNAx0BgPl1O31IIjEPjmBHQ5ja5rodLvK1nl48Ang9dgHRIyyN87O0LNtXFD2FLWmU4B0HKxdF99JDwhvhUCB9CPZLwDd2K/gw+kp3lsW5GYDl5wEg8heEdG7oyNkSGuE4GKBRyL1q6jX69J13b/CcRy5XC4VWPiNYzjWwAFZr9dot9tIp9Po9/uq9/l8jnK57H25L/ohAg4ejUaI0ORzuRxSqRRCoRAosw+P6BmB95inXfAWhdFqtVQ1Dg+UqqNW/Jg/WnhZ4mw2g6DJc/BkMlFnhud3cAb7ZNwOrbaaQzKZ5OXBcDiEQb/GA9XljoqU2A+u0CqzqVgswqKv5awcPB6PfSJ/Bgv6V5uEjoIN+wjQHrDmCjhzIpHAarVSLfktdGlNyTHKZf1LvAqYrNlsolQqPRFMp9MvjUbjI/5D6Dd+sP4NLTpNB1cxufkAAAAASUVORK5CYII="

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAK/SURBVHjaYvz//z8DJQAggFhARElJMQMLCyuDsJCgp7y8QpmgsIgZIyMDy6ePH2+8f/dm2tdvP2bevHmTYdq0aQyenp4Me/fuZfj16xcDyHKAAAIbAGKIi4nk6hhZ9kooqLHKiPAyMDExMjx9+1Xvyf27M17cv2r66dOndKDSv1ZWVgyMQNN37doFdgFAAIEN4OXhdlXVM5/IoWDOyCXEwvAPKAryGBc/OwOvihDDbyb25D/bt90ACvUAAQMbGxsDMzMz2ACAAGICEbJy8jU/BTUZfzCyMLz/wsDwEorffmVg+P6HgeGnoBaDubVjARsrK8/Hjx8ZXr9+zfDz50+wAQABBDaAW0DM+P0/PoaP34GagPg1UOOrrxD2h28MDO//sDAISKlIi4oIqbGjBSJAALFAqP9MrEAXvQNq+PaLgYEd4jqGX38ZGH4AXcDKysDAzASOLfa5QCIFiH9ADQAIILALPr99cVGc7QuDABcDw+9/DAyffkLwLyCbl5OBQYrrL8Pbx7feP33z7p4UUH0XEHNADQAIILAB27Zu7fj99CKDHB8Dg5IIMEwEGBhkgFhRGIL/v7jMsGXjhnnWv3+//A1ULwrEVVADAAIIbMCGTZs3Tp/Q0frxxlEGQcavDNL8QAOAWJjlB8PbaycZvnx+xeBrbagzU5jJDeQRoK8YBKAGAAQQIygNgOIVBLS1NOO8fXzzVNQ1NZiYmVkeP7j3bMf2bQtCRXiVIhvd43nfbfl7NvlC9KPHn1a+A6ovAOoFCCAGLEmZmZ2NVZmTg10LZlEoE4PSjTiW5/9PmP3/fMzv91pZ3vA+aAIECCAGYvOCEgOD4ZUQ9mf/j5v+/3DE5/c8dcEEkF6AAGIgJTPJMjLonw5ie/j/qOn/Nbla90B6AQKIgdTcKMfEYNRmyLZdnYc5AqQXIIAYKc3OAAEGABLI/zfRn+acAAAAAElFTkSuQmCC"

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAANbY1E9YMgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAALxSURBVHjalFTfS5NRGD7ffn1zvxy4aFghIf6qkSF05Qz0IuzCy6QRgX+CoDeuKIjwXxBqV7vxWpToTgh2FRT+qBGUJLK50HBTN+d0Oz7P4Tsx1wb1wsP5vnPe9znv+5z3HEO0Nlsikbjb1tYW9fv91zhxfHycqVQqqampqc/4rTULMpoRzc/PPxwcHHzZ3d19LxQKCZfLpRZAJvb29sTW1tbHtbW1V/F4/F0rYm3OxcXFN7u7u/Ls7ExWq1U1gkiB3+fn52rMZrMymUwmGNOSbGFhIYGyZLFYlPl8Xh4eHsqjo6NL4FyhUFA+9EXM23pSux5jsdjk9PT0aymlODk5EbVaTQFZ/gVkKcrlsgrs6+sbyuVy39bX17/iV2oNfcvLyz+j0WjHwcGBsNvtwmazCcMwBDe4JLo1pzdsb28XqVRqf2Ji4ibPzcHsxsbGJvv7+zsoODMgIQNpDNaknKufpy8PCrGh0dHRR6urq0kb1sze3t5x0zQF9BGlUkmBZRMsrR56XvtBV9UFKP0BuZihGQgEOtFvgqQ4QQVmoLNpNL3GSkjm8XhEOBzuwZLbYZ2QyUmfz6fIKLoem5XscDiE0+n8MzIZ+JDHQUKBgyhxJxJSE01IUCeKrzoeB8WsSNKITCaT554krG1sbPyAFveDwaDSqZ5Qk6reakLmdruV9mib73BRjgGU+wRtU5OW8YbwZkB01cSoQEE39Onpqbox2lZWVqper/cpuUhoArdGRkY+kKiZoWSFZsYYxpLD4hJsnSso5/Hs7Oy+/E+bmZnZR2yMHBaX0Fn2oG1ezM3NFf6VjL6Iec5YnV39M+YH7kDoZ8PDw+mlpSWlYaNRQ67hmqbpyxgr1mh8D23WwnWUcBttND4wMDAUiUSudnV1eemwvb1d3Nzc/JVOpz/h0N5Dvy+Y3uEd1u9i41UgqRvoAMLou07gBr6D1noeh7MDZPGdA34D5fpH1mjxitstYmbmAVzWWgUoAUWLiH136Tm6EGAA9KaN+oVolfYAAAAASUVORK5CYII="

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAMiSURBVHjaYvz//z8DJQAggFhABCNjD5D8A8T/gBygECszA8OvvwwMTP8txJUFZv3lYuF4++GnOyMTw/3///4x/Aep42dj+H8xgwEggJiwGvvrryiQ7PYL1Ty6YYW/rp2ppPT/t9+E/v34zfD/z18UpQABxIKh+f9fJxFR3gmdXXa6ibE6DIzMTAy/fv39wfDzz1cGLhaQc4FqEMoBAgjJgP9AmX/Fzi6qTTMmO3PyKIowLLn+nyFI5Q8D86+/PGwsTC1MHMwfGFiYWBhYGFh/MTHeBWqqAwggRlAgMjJ2gdzdm5FuWjR1kiPD+fdsDG2HGRgEWX4xzPH5x3Dj1nuGZ6+/M7CxAe0Aop9Au1rnXWTYN9ufESCAoC74W5qXa140cZILw6qbjAxLLvxn+An0LzvLd4apB38zcHGwA73CwvDt408GdsY/DNH2ogzKktzgwAAIILABpsZS9e3tdgwrbjEyLDj7n4Hj/y8G1t8/GF58+M4w5+53hh9ffzD8+Pyd4dPHrwwCbH8YrFU4GP7+/Qe2GiAASWSUAgAIg1CJdf+71tYWLUrKb32gPoDUIsLrdAJOM04gnSENjGaY9iHWlTU2cuUfk7oCCGzAyVNPuhsbj9W0ttoxfH3/h2HR0a8M/37+YhAAhoGXJisDO9D5//9wMHz5zMHAyfyPQUyAjYEZop8BIIDABvz7x9TY1n5ECphGktrbrBik2H8xVK14x8DP+4+hMUCW4eWbnwyvP/5gYGbiAcbgf4a7z78xPH79nRmkFyCAoIHI9Ifh/7+0jo4jr+7ce1c8baId67JsKYbFu54zfPzxn6Gi7czvnVvuHmQU5fwMjELm/8wMbD9YGR+AdAIEEFI6YAKG6v/KNauunT975mVbf7+tcneiHMP3n/8Yvv/++/nrtz85DN9+32QA2csCdD8PRCtAAGFJysyr7t/74BoYun1uWt4RhqcvvzOwc7KwAz3Nw/D3PzgdQMMPDAACCJqQuiEZCZxGgbKsQNNBaf7/f28FXZGpP9mZGF+8/OrMyMR45z/Qyv8sQHXcwIA9n8EAEECMlGZngAADALCEL2yqmxZQAAAAAElFTkSuQmCC"

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAP/SURBVHjaYiyXlGT4/vu3vIag4BKh//8NL3/7lvL/378VbP/+MbD+/8/ABKQZgfjv378MzAwM3hri4st//vt39+G9e1GcTEzXAQKI2YKHR16Oh2dJpLm5jZmmJtu3O3e8n/7794Dx///LLAwMDECa4T8I//vnoy8ktMw7NZVPXl9f4vWdOxYfP3w4ChBAzDGKirtiTEwshfPzGRhCQxmUnjxh/XfxoudTJqZ7TAwMV0AGAK33MmZnX+YUFcXHmpfHwK6uziDPyyv1/sULB4AAYhHm4NAVEhZmYODmZmD49ImBJSuLwe7LF86/q1fPPs/N/Quo+ZPunz8rbIKDednj4hgY3r0DGcjAIy/PICQmpgYQQMzq///f//nhg4fykydsjBISQDczMrAYGTFIPX/O9uvixSChX78iHNzcuHiBBoM0Mnz4wPD/1CmGM0uW/Lx06FAhQAAx27CzX3706dN9ptevveRevWJlAhkCVMhiYMAg/PQpk4y4OIsAUDMjVPO/M2cYLmzc+OfE0aNF///8mQYQQMx2PDwM/3//vvLkx48Hf1688JJ79oyFWUQEHHgcGhoMXPr6DEygQHz7luHvyZMMZ7Zv/3PqwoWCf3//TmUBuhYggJhtgX5nBIY2w58/l1/8/Hn15+vXQZJv3zKzgQxhYmJg/POH4f/HjwzfgZrP7t//9/ydO0n//v2bwwyKIaABAAHEwv/1KwNQgOEfUPF/NrYP/7i4/n0GOvPLixcMYO8AwV+gGlAA/2Vh+Qe07AMbUAyEQekEIICYXVlZGf6CbOHg8DGWlV1j9fEj91egcz++fs3w9v59ho9A/BvodyY2NgY5GRlmFkHBgNevXj1ggKYTgABiAiYQhv/s7F4WampL7T594v0FtPk/SAKI+YFOFABqZObgYPgPdOFPoCv05OQ4jaytZzMyM0eC1AEEEAsjO7ufiabmEru3b3m/P3rE8JsBAniALnvEyvrvDyPjPyVmZpY/QOf+BeJfwHSgq6LCCfTu7JsHD7ICBBCLhpbWEvfv33l/3r7N8AtqMw8XF8MdTs6fF79/zwDG0EeWv38Xq3BwcP8FuugPUP73s2cMJiYm3MBwmwkQQEw/v3599AXoTCagjaDY4BIQYHgoJPTn3LdvxX///VsAdOb6q+/fpz76+vU7JzDGQFEKCo8fv34xfH///gVAADGbffp08BUPj7mCmJgULzMzw2V+/j9nXr0qAAbsVGYgHxzFf/9eef3p0wNWLi5PGTk51v/AKD5+9OiNJ+fPxwIEELMnG9vrD2/eHP7CyWn5hotL+PLjx/l/gCmMCZQGgE5mAEUVMKBBof7p/fsHf5iYPB49ePDg4fXr8cyMjCcBAgwAkC29pEiNXvgAAAAASUVORK5CYII="

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0klEQVQ4jaWSWU8TURTHT/fS0tZiiUg7QGLRIKAYY4xbNC4vChEpBR8EytKVTtvpPl2ldKdslkIhool+FE3ql8DER/0IhHY802KbPnuSf+7M/Of+zrnnXIDzkEgk0N2tQnU3JRAIGp5UAqq615JAwIdmqNW9sLhkAKvNDCbzCsoIZosR9DPTMDQ8BAvLc2CxGcFoQc+6gs8m0L+dbiaA4ZHr4PFREI7Q4PZSnUHazwmFA+CiHLC4YgB/0AvhGA2U1ymlw34OjR4LYatqAtxeFzic9rl0NnnmD3i/B4I+RSgcxM0+iMZDQLpWjZlc6tQX8PygQ36u2WpsB1AeJ3j97oPCVp7ZLW4xuLkSjtKKZDoBDoo0FUu71dxGmslkk6eU19VpwuO0AXAzW6omsR4/YQH75T0mEg1VHC67r3xYqm7vFpji3k4V362RWKj9CNpBLdjsFghFghCgvQRmPdkvF5mPnw6Z489HtdLBB+agvFd1UqQtGg/Xe2JYnq9PpxlPnj0GG4mQaJAFEdiL32xWtpryUalGOu302nocsAewuGyoT6cZbCkLS/P1PoQiASCdq7aNQraaSq8x6UyCKWzlGGxshW0sC7CTNpjSvWmNUaNRI3WhPgmswra5na9mckkG19paIvYHV2Z7p4AQTwWPoVglrfB6cgIvX0cDIJVK4fmLpzBveDebx8zp7Dpmzdf0szrq4aMHA5j958ZmlmGFd+ObfkbHGbt1E7hcbgMg7hBD/0C/cEo3ecyOKptL1e7dvxtDS8lKrpCPudyOX9l8inmfiJ71qnsJ/J/XAohFoFKpRHK57Pb4xKsvI6PDTjQvYYkSoUgo5gv4CplMdmd84uXX0RujLh6Pd7Hncg+Xw+E0ACxJjX24em2QS/QRfILQ8Pr6CJB2SuteV5cSNISGi+KzvlZ7BZTKC9AWSAURViIUCs8lgH8ZWEjrO0okbHr/HX8BbiwHJG2/82cAAAAASUVORK5CYII="

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAOSSURBVHjaYtRQU2P4//s3A9/fvwzMrKwMLxkZGRiAbBj4C2R///6dx9bWtk9NTS157969kT9+/FjFxMTEwAhUCxBATAwEAFAxl6Oj46IFCxakysvLP3/37t1loBhYjoeHhwEggFAN+P+fgYmZmeHfv38wmxmAthZ2dnYGfvr0iWHNmjVbf//+fR2k8efPn2AtAAGE4QJGoNP+Aw0CGQB0okJcXFwR0GaGTZs2/Xrw4ME2UVFRBkFBQbAlIHUAAcSC1d1AV/z984dBR1s7z93dXQiokeEcEAAN3Qh0FScHB4cI0BXynJycqgABxAIMMobfQJM+/fkjzszIyA4Mvkd8QP7HP39EHZ2cvEC27d+/n+HZs2dPXV1dk96+feulq6trpaWlJblr166nAAHE8hPoFDEOjuQEScnsf3/+sM35/r2C5devLQL8/MVAA1S/AcPh7t27DA4ODgEaGhrBIC8AbWbYs2fP9xs3buQDBBCLDCdnZqmc3KSHz559dXj3jv8zE9PEvczMEWHm5mGfvn5lOnr0KDhwjYyMmP8AvXXx4kWGgwcPAqmLhdzc3PsBAoglU1m5kp2Z+W/OpUuO1Wxs02p4eS1cBQWVvpiYMHzi52e4deYMw5tXr/4/ff785U2glY8fP57Dx8e3HBjA/5iBYQUQQCxCLCxCcuLizO6Kion2v36pvXjxgqH527eNmteumVXLyEgeuHr17ZazZ2sZfv/ex8bOfpMVmNhgiQgEAAKI+Ssjo4QzD49loqCg+ZM3bzg7mJnznggIvC7j5XU6umzZlzm3bwcxCgisZWNiegvSCMLs7OzgNMLGxsYAEEAsF79+LSs4evSGKBeX3vnfv+fxcXGZzPLwqNf//5/90blzv/j+/ZP5+eEDOM4ZeHkZ/oMTCyM8xgECiFlUSOgPw69fp58xMGz5zcys2unkNJ/r58+/U48eveTBxCQq8+GDzRE2tl2c//69YgUmYVC+4QDGwrdfv8AuAQggJpBZf4DOegVMeerCwg7W0tLcS8+fv9D69WvO/v//3/EzMvIzMwBTOMg2IOYEavz6+DHDf6D6X0ADAQIInJC+AQ0AOevtly+PngFTXaGgoJnr06ebBD99EmsREOj7yM5+5Rssu4B8AMoDQIO+AfMDQAAxCwkLM/wHRgcrEH/89+/mrVev5OU/f9Znev+eezIv76zLvLzl7P/+/WaEaYTSIAtBMQEQYABvYX3JH1439gAAAABJRU5ErkJggg=="

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAPSSURBVHjaYmRIYWJg+M3MwPCXjYGB4R+Q/hurLKI0WVtCk/vfX4b/ICFmRlbGey8e/7ly/1bjfybmTgYmxv8Mv4D6/jAzAAQQI8QARiBmAer/K6YqrnxnY9kmXk0pNQZk8Pz9K4aQljiGY5ePGzMwsZxj+MsOVM/MABBAQF1Azf+B1vz7CbSdQVhDUoMbpLnmQDXDmednGJhZmRlk+GUZprhOZjDXtGQ4du6QHMN/xnMMTP/BWgECiAVs/L//0kCnqjH8ZFD68v3Lv9//fjMdfniE4dDdQwwMQIuURJUYvv79wvD9x3cGhu/fdRjY2T8AvfqUgYX5NkAAsQAZUapSarMN5Yw4//z4/d9UwYyJlYmFgYeNh4GZg5mBjY2NgZedF+hKRgYLNSOGV65RTWwcfAw3Ht75e/HujRqAAGKQL5J/ee3ptf8g8Ov/bzD97vu7/66LXP+ztLL85+zm/K8/X///rXe3gDL//v8FYhB4+ublf+NUt18AAcSiJKrMpymlydCwu4Fh7429DCycQEcx/WW4+/EuAzcbNzC8mBhef3vNkLE7g4GTnZPhGxAaiOsz9Fn0M2jIaTICBKCIjHEABKEoVolKwr//jZiY2N2NJ2Agfr7P9gbtHkuzRL879apganNuWDHykUly+qQ9DVRsxCDS4tf9jU8AlsggBwAYBGFS9/8vMzSGC4Fb+3yapCCNUaF47wDW7k6mA0sdc988VV8AsTAzMTODFKoKqTLoS+oxMHOzAKP3H8Pzb88ZfgKjFqSRg4mDQUFAgYGVjZXh279vDMr8ykC7mBlYWFgYAQIAQQC+/wAkdCPu3+zg//7//v/z+/L/8/ry/+Px4/9CokL/BYUF/wqLCv8uny7/0uvS//P88v/1//T//P/6//D08v84aEv7Aojl7tt7lf79AZPMlC3Z/vz6w2Akq8+Q65XNwMHCAfYn2AtA78kJyDJsO3qQYdvJXQzsHFwMV+9e/3f61oUOgABi+c/EOPPSgwu7Lt2+oMfwnUHhgZFzb4ZHGvO3318Z/v78CxT6zvD111ewYfsuHWJYuHZyGwM77wmG/2z3GJjZrgIEECQlMjHcB2MOBg1eLp5eViZWBiMJI4bff/8wMLEyMsgD/c/FwsXAwwlMUJycJ4FmbWYABR3QZQABxAIKTWDQAw0BMf9+vPvizq+Hbx5z9rr1MfwBQlCIMwPhx6+fGc7eOg2MStYXDEyg3MsIzrwAAcTIkMyIkp0Z//7N0pbW7daT1WcDZef//xgZWBhZGO48u8dw+uaFvn//GKuA2fkfwy9GcHYGCDAAV016+26QlyMAAAAASUVORK5CYII="

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIDSURBVHjaYvz//z8DJQAggJgYKAQAAUSxAQABxMiQyGAhwCqwVElYRYrhP8Pf//+AXvrLyMAA8tk/ZiANZP8DYSYwZmRgYmD6z8T88Pmzb68/fUkFCCAGvnS+M3MPzfv/49fP/79+//n/4+ev/99/QPH330D8C4K/gfDv/z++/fn/88ff/9tP7f8vFaT/FCCAWLSkdbQTrOMZLr28xPDw/UMGdhY2BgYmoI0gBPIgIyMQATFIAMj/C4TCnEIMHqYODGZaphIAAcTCycLxj4mJiaF7XzfDuvPrGFi4WRgYgGYwAF3PyMLIwMzMzMDEDHQ2CwR/+/+NwUbGmmGr9zYGTjbOvwABqCJjFABgGARKKPn/cwMh2pqto+DgnYea/bHVKBVSiZhXjmUFxU+as1dYEjm4AogJKTghzoY5GcnpjP+hNBKEAYAALJJBEgAwDAGD/v/FqammPbqwg0VwFNI00v4F2kxG3JUVWJ/Gj6jdyfc8QFQdAcTy8+9vJpAfCu0LGHx1fRk4WNnBAQdUDdYIcwkkUBkZ/vz/wyDKKcYAitCff34wAQQQg1Cm0JU1Z9f/xwn+IeG/UAwEx6+d/S8favwGIIBACclVlEt8saakJv9/UEIChQ800YATENDZkMSE4LMwsTLdffTg9+NXL4oAAoiR0swEEEAU5wWAAKLYAIAAAwBc7vIKtZwbEwAAAABJRU5ErkJggg=="

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAMUSURBVHjaYvz//z8Dj9T81VqOmgGSXH9+MTEwMPwDiv37z8DwHwgZgTQEQBh///5hevSDm+X+iXsHvj6McgUIIAaQARbpF/4vf/j//+df3/+DwC8g/grEn/78///tH4T/9z8EvPv68X/R5uf/lRIvg7gMAAEoHIMUgEEYCA5Vqyf9/zdbKsTE0HgddpbJ57Xc2eXVa3eF0bAFtkENxCHFqkRaq8E/ZT4SLPlxfwEENuD/v7////5jZGBgYgQ79D8jxNEg6jdQ4DfQwN9MEIHfQAFePkEGLg6wfgaAAGJhgANGBkagAYxARWzMQB5Inhmq6Q8DOExArgKGCjiMQM4HAYAAAhsA1AeWYGRigggyQ2xnYIIYBDL0N1DzH6ij/zMyMTAyQ6wFCCC4C5iAqtiYQab+BfOZgQo4gbr/ATX9AXkFGB3//4G89xNoLicDE1QfQABBAhHI+/qbkeHYA2aGP///AG0DRiNQ59+/f4H0f4a/IC8AIQvzX4Y/P/4zfPrDycACjV+AAAIbwM7yn+HFdwaGM1dZGf58+wV285+/QMOAgfD3LyQF/ABa8O4TMwOHADMDOz8wRlggBgAEENgAZqAfvwFjkPPnN4YMy68M4uJMDF+/MTL8/AUJCxYORobbD34z5EziYBAz5mVg5mdmgAYXA0AAQQIR6N+fQGeysvxlkBL5xzB37V8GB1MmBnN9NobvQJdxcjIyANMYg6wUMAZYGMGxwgaNaoAAYoHF919QNAHj+MXr7wzTVnEycLH/YtBQ+gd0NgMDNzsjw8dPvxjERHkYXgEt+wo0gB1qAEAAQbwANPUX0At/gcnu08fvDBoKfxlYgQH2+hULw+fvjAzfWf8zfP3yl0FUiJHh1S9GsKsEmSAmAAQQxAWMjMxsfAwM39mYGJiZ/jC0ZYPji+HLd5DrgNEHdB4zMNCUVbkY7j5hZPgLDBsWVkhMAgQQ2IAL2y8dNuXjsPz/8fP/fa+eM/BwswJdBIxGaCJiAkbZV6DN74AWcHxhZpD7x8h4b++lqwwNygwAAcQIS5LkAoAAAwBDND5TZ7iMJQAAAABJRU5ErkJggg=="

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA+ElEQVR42mNgGD6gsKbpf8/UOf/PX7vz/+HLN/+fvX7//83HL/+fvXnz/+6jp/+Pn7nwf8Xazf87+qf+z8gt/I/VkJL61v/tk2b8X7d9z/+Tl67///jzz/+f////f/zqw//1W3b9b++Z9F/L0Pw/XpcUVTf875k+9//GXfv/n7l88/+jlx//r9mw838v0GAtfeP/RHmnuKbxf9fkWf8Pnrr4/9DpK//rW7r+G+vq/ycpTEoqGv/3Tl3wv7Z7yn89I9P/ZAVsRV3Pf1uv4P9kx0xtY+9/R48g8g2oqmv/7+TuS4EBTS3/nT18KPBCc/1/e2e3/wzDGwAATyyLJOn11NsAAAAASUVORK5CYII="

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAQ1SURBVHjaYmTQncwABv8YGRi+/+JkYGZ05BMRzJGRF7cUFOTl/vv3P8O7N1++P7/37PLnF6+mMvz5t5WRifnT/x+/GBgYGRkAAogFrBnIYPj5W45TkK/f1csoyNlejYGLh5vh89d/DN9/MDD8/sfE+uLVV+sLZ+5YXz54cu/Xpy9ygJpugLQCBBAzg6gXyGY5EVnxtbn5ns4hPioM3778ZXj58BmDDBdQ9/ePDLfuvmJgZGFlkJSXZuCVUVZ6++y19483b/cxMDO/AggAQQC+/wMAEUcICQ4MkGxvSUg+NBcA3eH2APfs6QBbPhEA+Pr6ACodCQA4JwcAws7pAOvu9wAGCQkABholEe3g3i387/KwAgBBAL7/AgABAjZBRjBcOjEXAO7vAADl5/QAMyQLABEPBgChvvEAiq/vABsXDQBbQxMA7PD2AO7q6gACBAIAFTE8PAAEBVICAEEAvv8EBwwLaisxJQD//AAA8vX8AAYHCADB1e4Ay9r0AAkMDwDq8PoA1eD1ADMmDwAJBusA6/H7APv96gAGFBQABxEQawKIRVRa1O78S16Gn39/MmiK/gOGJyPDy+/cDK+f/mR4/+U3AyfTdwZVGTGGd1/+MHz49BcYqCwMHz8Dncr5lYFDREgNIIBYePm4+V5++M9w5OwHhggLNgY5IUYGEGRn+c3gZ8zC4GksxSAhxM4wb/kjhpcfGBj+/vnO8Ob9OwaufzwMLJxcbAABAEEAvv8E//3/AAQC/QD49/oAosL3ADEcAgAQCQAALBsBAGNIFQDy9v0AhKfjAJey7QDz9vkA9ffyAP78+AAA/QoA//0AAAKI5dvHz1/4/v/mZmD6x/Dv3y+Gs3eAgfHtF4OIHRfD5+9/GWyKrjLcefiVgZH1L1DDT2CC+wvGTECv/vn05Q9AADG9f/rqOMuvzwzcHEwg9zEwsAAVABVeAmpacPAjw51HXxkYmH8z/AcaDrSBgeHPb2DEAZMRUNmv16/vAAQQ05d3n6Z9enCPQVqUDZjkgIp+AW1h+cfgbynI4K7PxRDmLA5MTL8hhv8Fyv/5ycDOzcvw980nht8f3s8ACCCm/3//Hr1/4vw6/n9fGMTEuIGKfzKw/v/HYK3Dw6CnwMlgpsHHwABK90CbGX4D5Ti5GNgYuRi+37h5juHfr1UAAQBBAL7/AwANRfv78vTM9ensRh0kHRUDDAsA9fHyAM7a8wDR3/gAoLPdAPT28wACBQEACA4RAAcFDwD4ztHm/OzoWgAABN0CiJmB3QnoR6b3P9992vHp0TMlfm4ONT4JIYYXH/8znLjygeHPf0YGTgEBoEZuBsa3wGR+/uLJ32+eRgI1nweGBANAADEyiLZBMiQDE8P/7z+5GYHe5xAUyGcXFdZmBMYzKJp/ffr6+9erN/f+fngz8/+/v8sYGP6/YwCqB2GAAAMAS8yiWnSbjn8AAAAASUVORK5CYII="

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGTElEQVR42tWXC1BNeRzHz1qK9BJ5bKL3QypF3ovYmFBcEWkpLVpSIq9kq6HITuTRbqikyEUR1Y1IpbRsRQ+Ji5tHRnluHrOGZb77P/9znOTc1oxlZ/bOfOb7OzPnzud7/v8z557LMP/Hz826bFzK7q6U6vJYZBRU9CNofxF5nSKrVfkbhQPydjPILqyMYUt8fvmNj8tpgTNVBVkFFaM+e4GmGlfgYbiYp2mC/IsWeHLBnF7ph6Ax8L8p8KjcHK+uD8CrawPwmqYDXpMZjQGiAopTuaiYaKaUi+mHPu1GfXDeDC+v2OPlVZb+HFf6kwILWxSozjjcqvzZgjHIHaD1aTdqQ4kJXtTYU57X2FHYGfcWUHFuPIOiCL2Pyo+zBT5lm+qLjdFU1Q9Nlf2ak4B7c6k8ZxeDpiAJkLhOTH6aIM+x02y9QGj6DQwNLVTKrXwjPCq3IdjSfFjG5ds7c6g8O5bBXU8HeqUfgq1Bglxmr6G8wHKpvFW5d5IC13MN0HjOGg3n+nKcZ2drvL7lTeUZ2xjc9uiPJl9HEYgJbJbbqYsLBKRc/Ue5se9BXMnphfqiPqgvtuKyyIry8oYXladtZnDL3R6P547E43kj8IRNygi83eQvyI/ZdhQX8Nt3E3FnnxGet0Amf0PlLJcy9VGXb4Gbpy1RJ2CBF1dmU7k0ioFiqg0ezBmG+z7DSRL4/CvaT5Af7acmLjBlSyW50joehTBH5T0VClxI04P8hBnBnE+OpkuzqHxvBAO5xAoNs4dQ7tEcTHIwXkUtEOQZVh3EBSSbSzE7Xk64SpnFzglXsSH3IZUb+Ujxu7QHajJNUJNlSlaDZKYp5VGlJ5UnhjKodbXAnZkOuENuRjbrZ3L5Z6SvIE/rq6SA688l8Py1miPuEqGaEiFroHJDrxScTemGi4eNUXHYiOMINzeWe1D5jtXkITTeFHXT7VriTp4Za+cK8oNW7cUFJkTmY8a2Mo6tPGRed6yeynvP2oXCRF2UHjAgK2GAUpYDXN4970HlscsYXBhniGtTrCEnXHPjUk6yKdxHkEstVcQFnEOPY1p0MeEsTzGmEtZmKKi8t8d2nIzrTFahF0pS9Enq83Mv3C6eTuUxgQxKR+vjsqslpZZPlsc/eQnyVEslK+AUnAFJ5ClI1r8jj2bYoVoq13PbhJztOihI6Mmjx2WiHhT57lS+cSGDkpE9UDneBFVkKyqduawieX/1LEG+z0xVXMAx6ABcwrMEXFnCMhGyv5LKe7hE4tgmbbIK3yA3rgfJZuSnplF55HwGZ4bpotzJAGVjCU6GPAZoWOkhyPeaK9mCkYuTMD74EJwJ7+fq5FIq7+78E9LWa0G2tRvHtu4CtbnTqDzch8HpgTr4zbEnzrVAH/VB7oI82bSduMDwBXFwCkrG2Hcs5XJlQjGV645ZDmmEBo5G6zazqSvJrqiWuVF56GwGJ/promh4dxR9y9KNS3J8K3CqIN9t8rW4wGCfzXBctAOjKTvh6M/NK3bkUbnuSH/sDVNDelRnpEV1QfqGztxMsuKohMqDPRnIbNSQP6QzTg/pgvzBPGRWBEwW5InGSgo4fL8BI+bHELbwxFCCYmVU3mnIPCSFdIB0nQ6hE586OEAoS59E5StmMDhmpYqTDp3ITy+5X1gctOksX+QiyBOM2ogL2E0PxVDvKJ4NAoExR6lce5AX4le0J6ugjX2Eve9x/qArlS9zZ5Bu2Zb86qlDZqdBM4ekjGTtjxMEebzhV+ICtm6rMGhmOIcnm2EYSHJxdBqVa9nPQNxSVewJ0SRokdXgkqVEOonKWQ6ZtkGmTQcOaxY1Mqvhsq+zIN9pqGQFrF2XYMC0YMIqPgnuwfDfuJ/K1W3c8MsSFSSs1EAiIWEViyY9Lk51EQqkGpP3gj4q5LGrQvNIH1WSqqieN06Qp/j9IC7Qx9kPdpKlsJu8lKa9JIhkEPwi9lD5OO812BbQDruWqWPn+yxXR+GeiVQetz0EyaTAYYu2SP+ACp/vqDxp8ihkFVX9kVVUndTipdTCaT5sXfx5AoT0DY/HuDlr6Je2+LUj29BRRP7uCVTOnpNoRLbBrI2IC95jkLpyyTt5RmZBxeQWr+VsG/ZVmV0aZbCNs85UhbP5b88RyfkC2mwJdl+Uwf+RMPhM5wjyvwG2FpAnNb4o4wAAAABJRU5ErkJggg=="

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGhklEQVR42u2WW0xc1xWG89iHVspDW6Wp1KhR5bZ20hK3TRulVU1aVXXzUFV9itw2le24ihK3MVYIZgBDjdUYDBiC4zozA64r2dwa21xjIBmwY2OYMdjFMcM9gLmYm8fAwAznzPm69h4IMwVBZPWtOdLSPmefs9b+97/WXv956KHProjraEElYasmy1FBRmGlWDlZzvDcEWc1mYU1ZNrL9fM5V1uM2MPax1FFRkGNzJeT6awI+zhr9L2Ko/yOOi9E+a0CkCEvGbwGswPgHxMbxdJjJwTbsMQItDJ7r5l9h51UNtzIUcHU4pYJlmURsoJYIQiFQvpZJjD1BDIaUX5rAKhh4fh3MYqexLy0HfPadvhoO1bvD2BgKww9Bf1bmRzIl0AOKhtvuipcbduyZNeyjixsMD4+Tm19Hceyc0lP/ys2m41GVwOGKUAERKTfKgCKrsDxGBbPbMGsjMFoeh7r1i+xer6HNRCDNRgDfU8x8XEefzlkXwEgdFsquoBQi78en0Bc3Gvs37+f+Ph4UlNT8c/Oa5Yi/dasgeBJ2X3xk1jnNxGs/yF0/QK6fyS7l7nh7xCUcWIoh71pJz8JpPKqGFBUHzqUxr59+0lNScOWnEhVVRX5+XlM3ZvGFBYi/dasAf/bTzBXsIXJ01to2vs4HRk/IdCyDaNjK8H+zcyPPsH4yFu8cnAlUFZhlWZANsirr7zMS7t243Zfp6W5FZerkYSERCYnfASNxSi/VQAUlYH8zfgdm7lr/zZN8Ztwxz3OYOFPmW19Fv/I95ma/BUjQ5W8nPL2CgNShCEWdeE1NF7hxV17qKu7yPv1tRQ4CnnDlojP58MwjCi/NVJQzUzat5jL/SbGqW9A9deh8REs9ybMoecIDj+HbzSWuz3v8qek41EpUDlQLCyaBu2tLcTt3sGBvS+S/YenKcs7jO/+JAuGFeW3JgDvbx6la8cjDO35MlMJX2RWTkXw/DYWXdswm2MxWmKZuOXkJVt+RBHWYGDpOmhzJuHa+RgXX3iMid4b3P7brzn7zOdoLc4mEAxF+a2uAWkYFQd+z/DZNOY/+AdBz3sYrXWYN+ugo1aKsRarq4pp72V2H8j7JFB2QZUuQCO0SP0LX6L/zd8y+s5u6p7/PE1//BoD6bGcif2CBhDpt2YRJif8mcmuy9KHvMyMdHJ/xMv94U58Q158g7eZ7mtnuP0yuxJyI1JQLhVuIuxTu+OreG1P48v+Ga7ffYWPbD+mJ/3n2Lc/KgCsKL81UxAnneq1dIc+r+rIvHrw71I4J3Tu9iS+pXew841cdsYfWwEgKXgQv1UAVHtUbVJ98KlsqaU+qN9aAB5WLxS6T2PLovKgfmu0YqVoooRCqRpVZ8wSBVSNRtF85FS5nlPfqXE5kPpmWfWUnihtUD0l21EdjuOoWopXvb4aZotToqeIFHcx3i47d4ZPYgXqCfoz6Oy0k+ouweYuIvl6SbQaStBSEdHOYenYo6JX4yYDdy26R0Pcn4X5ICwswNyCub4aqkAp7lIOekpIknGgzy7yW4IxJ6rmKSO5uVTenyXJUxythsLQe80hyptMegVA310xUfEepeSBELMBS4/+hQ3UUNGaLAslec5qFtRC3p48ARSe08+dTs1ApKopv4oWKL5qUe2x6JGd946tMLAMYm5hAzVUuU1qLVkCUKpBKLN5SjUjsxPvMDfh0AD+Ww3PSQrKxf7ZKN37FnjvmHiHYMxn6IVnFgRMYAM1zCmoCC/aUqap7uw6pXOudn7j37mSyGqpiVqmxrKiVE0xUHYViq6amgV7PTTJT1T7IDol0375yZoP27pqeGQJgNptw7UK/PfsNLSU6+JTrNzpz2ZqJFO/j1Q11YqLLsGZDwXEpRCnXWgQnh6Ltj5hYwQmpoUBv7WBGspRU8GbPRcIzDikfC8yMXyCxubKpXSUcrvbTkpzUZSqZckP52m1sIBwuixOvG+Rcy7A6QZo7Te4KSBufCzWy8ZqeEWonx5zYM2XYvovCIhcRu+c0Ewkuct0/hXISFVTzB2rMsmpDJB5foGMc/Ocd4O7TzEQ4nqvpU09r6+G+hiGq1+de/xH6fA65BSE60DZ8vtIVVON6813/RwunaGwMZx/Tw9c6wnh7obm7vBzi9i6aqioVKdAUa0WmRvP1Pf6aC7N21qEgev/ilI1xUBOpUF1O1zxinVafNgBl9XYhbZL3pAe11VD1T4fRNVUy/1MDf8navh/ef0HSoEj+dmWU94AAAAASUVORK5CYII="

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGSklEQVR42s2XaVNTVxzG/Uj9Ph07baftdNppVaoyVh0rojIioKCAEFlkU3Yw7HsMS2QxshmWsCQkZCFAIBHITfL0/5xcb+mLvupIy8wzZ3Lumf/vd5Z7Qs6d+z/8PavrQ1WrBWzPMi1D775QAsW1vTjrPzLNw/Y8JVBY042kdO5+TPzrhE7ln8aQRaZ55P2QEnha1aU6Q9E46ga3PmvIIItMQ6CgsgMJ6QxSYMCNUR/+lrEAMC6ZCAKTO8CM5H0ImNsFFnaT+LAbx9JeHMv7jKZafmY/n3Mcx7M2GWSRaQg8rjAjLp2BSBw1/Zt4I1Cr5FM76v9L4q1ITImAXTIrhecFsCggx14KuiQCCi5hP5/PCtwuYW0yyCLTEMgra4cmnf7DOKp7N2DZFrhEtbrImD8lYBOBaYG/k8yFklgICUhge+sOxCfagc5yxEdbsbe2qPr5fFbGUZi1ySCLTEMgx9SKmHRuH2qo6lnDsICZET0UseqrYJNMB04J7KbgWBoEIktSZR84lHa+F3vOBSXAcRzP2mSQRaYhkF3SjBPp9B5oqOxawaAHGPRCtcNeXULfignJJAVkJd7vJDAvAI0zV/CoHtmb8Aw0S5N6bpdxHM/aZJBFpiGQVdyIY+ncCmso71hC3xaM9HtSIkOfJHwpiSmRmAkkREJTy65mjkPJDitJRKitGLNBTeAJtWqs7RYGWWQaAvcKX+FIOt37MZS9/oBuF1R63ECvOyXBDHlTZ4MSNiXBmckKjLbIjOe5iZINyaIU64c2XK+eT8s4jmdtlzDIItMQyHxSpxZucy8GU9s8OgTesSkTYyjjTsn06RIWyRhXwpeU7YgjuLwgx9wsr9EoELNLIblZbbUIOuZEMg6bjON41t7YjSkWmYbA7cc1iEjnujwsaZlFu0yCadNbs4hQqktfEW4JJazbSYz7ZHa+OAIC0ywNatk584BjFm+lf2I7gVEZx/Gs7QzFFItMQ+BWXpXaPWfoBMWN79C8BpUWSet6Ku2bKZFOfWsGeEAlb7xJASQwvi0wX1zJsOVn9vM5DzK3kLVXdk4Ui0xD4EZOBcLSuSoPC+un0OQEGplVoInRZVo+rYh+RnhI5XbFiIdJCkyAngSs0lrk85B+gDmO41mbAmSRaQj8nl2mzvBy8BhPXtrwSqCnY5qKILt1CZk10ygbWEbrRmpFOnURdVAFMqALse3Xt6tHP0+vJaxNBllkGgLpWSbsSacjcIz82nFUL8NIyWQE98uH4d+NYj0URe+oE88HVtDsTKD51Dl5zTMiyW1fwU9ZZtwotaNm4USJtkmaZRtZmwyyyDQELt97hhBfHv8xHlVbUSUX2wtJ0fgB/jBZseY7RCSWhFfu+fBJEndqZlEytIl6WZ0GKdwo22MWiRulYzANOjHjisHqjCH9mQ0l9hO1hQ0S1iaDLDINgbTMInV9zPuOkPvCgkqB51tCuFdmgSsYRUSg68EYKvp9KO3alvfZqyRMtn3Urcg2rSRwJX8Qps4tbEUTmFrTYOoJo2E8iktFVpTOxlArsqxNBllkGgIXbj+F3JQYcR4ip2IYD7s9Cr60HUUgnEA4msT+UQLtE2GY5DIolvUskmlfLxlHwdgeLma0o3bqAGvyvTC1ouFB6z4yXgZxrdaHq7U7OJ8ziSfvTlRtMsgi0xD45VYB5KKCRR5mlw3g7vMRzKzuYyWkqfgPRUIE3jiiMJndSiBfXoncegeuFlpQYT3Egj8Oi0NDsVnOTGMIt0TgZo0PV0q9+KZoHd/nWFVtMsgi0xD4+eYjyEWF0fUIHpj6YF87wpxHg8OdEvAcyG0XSWB1S0N1tx8FjRvIb15Fdt0isqoXkf50BE2y3MVdKXiGDk+v8OK351v4tdiFC4VbqjYZZJFpCPx4PVfd4m9dUWSV9mJy46PK3KaGBdcx1kRmQ268vvkIyls9SiCv2YmsV05kVs4ho8yGS3lDSK/1406TzL4uJXC13IO0UjfSSty4WOhWtckgi0xD4IdrDyGXFeyej7hf0v1ZQwZZZBoC36U/gFxY+CCvyFmELDINgW+vZKlv8HX5LjiLkEWmIfD15ftw8z8i+WfhLEIWmYbAV2l34dJ/F5xFyCLTEDh/MVN1nmXINAS+vJCB/yKGAH+l8ociO840wvwTUo7nC5F9l70AAAAASUVORK5CYII="

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAE7UlEQVR42u2XaVNaZxTH8xHyUfoR+hH6ss30RWaaSTpN3GKsTbXWPcYlmNRicItG64IL7tXi3hgFEdC4oGJEDe4bbhhF/j3nudwoFWwEX/aZ+Q+X4XL+v3Oecx4uN278v4JcXQYrijV9SM2txsNkFe49fo6IRBWScqpQUN0F7aAFmm7TF6Sb126er+5ERl496jvNMM6sY27jBIvbwOz6CfSWdVRrTUhR1iCntBWN3aav/EJEZ7yGT6WXCP1IinpajEdpr8Q1v/L7yCdFeJhaKGR3AIs7wDwBzG0SxAZATBhdOERpkw7x2eX+Idhsxwk4jiTx9c4hsO3R1gGwSdrYl7S2ByzvAktkaifTB/G5+ECvC2Ru25LMrWQ+tQaMrwDmJVA1RhGnKPMNIQMsOyTZZVFQLqkcmDOzUvBpCjxBgUcp8IgduB+nFPfM0z3vPdlPy+bLgGEB0NmAIs0gMgs0FyG4zJyxL2MOKmc148lqclUyNpOMH84A5rYkQL5vYlUCHF4EBsn871k3eqeP8IuiAjV/DXlD8L5yqdlUNg4GwMt8ns1P0TV9Cq3FhaJGAzLzNWjqG33F0yEAuKl4nxfOlZuNrWsu6Kc3oR1aQEnbGNJLtIhRVCKKm5D0+Fk50orakFvVg4GpLYwtOjG7KQEYF6Wyv2HzGTKfcqFt4hhtwyt4lJKP5t6R7qZu05efALi5bOey7R9fQ07NIMq0kxiwbGFp8whHx6c4v9xuN7YPXJi0H0BrWkFxixnZf/Sif3Ibunk3+t+70UOZd1gk85axI7Sbt/BdVNZFgPU9qXzyHmaU9WFh/RBXXVO2DTGWwpwy75g6EebNZN44cij0TUiKNwB/YXVP6lyWhRSrbKUvn4qGdH70b0hFEA3ME/J2DlDrNskgFb1WF2XO5h9F5k1k3GB2ovWdE7cjM/8FkFIo5pqbizVGoxOeXEjULto/t2goBjkls8NjqT/ekFmbxQ2N6RBVuh3SNmoMu5ShE7fC0gn+GO1k3jrmFFlrjPuoGd5Hg86OUDo3LgDw+LExiw3DkgrRMuFC7ywuANj8ANQZDwj6RABI5lLm9aZ91Br2UaXfhbJ6AAkvKn0AkMG7ZUk8YqFJBfhz0v0fALgAwNC3Qp+KzNlcYzqgyuwJ84bhPUSmvoaqssMbICK5QIyfWZ5tUkhigADjJ/g65ImUOZW9lkzVegd97kB2eR9in5XRGTCy7XUOhCflCQCjx5wPl88DcPsFqBeZc9klc5XGgDDae4+5xuskDEtSiV8xNmbx2R1sBbjsnHmdwQEFZe7XnFdo4ksR1LAoSR8MAPUAA2gG7MhRDyAiuQSxWaX+zWWA72N/w72YF58U8BZ4AELifkf88wqoqjouN+fFzdDcY1ZwZ8oKtgJsSnFMotup4S59IuIPGILHQlawAB7zcI4V0DPhNQCczXkg60FCvvdJ6PA+it/azgCkOfeegqAB7sfn+QX4nDEMGuCHX1Ui2OUA3lPA19cG8HNGGQq1c+ixngGcnF5egVr6tSvpmsednxTBA3DnJinViMqqwMs6A/TWXew6XVhzHNPTrvSwoTHuobjTBoV6CAl57bgTo0Q4/Su6cNYHCHCTZ5cDcTYZKjWi0/Jxl7LjB45vw9JwN1qBqFQV0pSVV5v7q0DI50Nj3+htGcaXhCnfE+jcXwXGlwI1/QfiAaF+5LlX9AAAAABJRU5ErkJggg=="

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAE/0lEQVR42u2X+1JTVxTGfQQepY9Q2+nUGf9Q61RrB7kWhCpIuCiBQEI0AYy5EVHACwhoiUJpUbxVDQYSEIGTnASISkAuCbcREB/g69rnnERCDAaYTv9oz8xv1l77nOzvW3vtk0n27Pn/+revC53F+KfotHFfEQlbGlC0yqC3VaDDX4/OyavofteEJ9O3YAtY0Rts3zHPZ24j/3IyumzcwS1NMJcn63+Cvk+Fa6OVaPBocZWvxA1eh5tuPZrdhh1xbbgSNU4lUrXfb22C3WAPpFv2w+AsQx1/HrWcGrVDFbAMlKOmv4woh1lAHIdxRuZmp4g4LoPJqYD2qQyJqr3xmUip2QcDiVxxqXFpWIWaAVqkXwGTQyEsZnKUwugsFcdSbpYie4aNhfuOSJTd2TheHqeJVMs+1LxSwTKihPklLd5fCoNDDkOfnNokxo3oe4uj59kcsXFO8Wc6klTfxNmOK/tRO6KGeVBBO8KEz+Ki/YyAzl4UQWg+il7p2d5Pn5P/nopUdZxnIvPaQViGlGSgGBf7aKEXhbjQUyDGEJSzGL7H8k2wuWppXNWTh6LfEpFZeTA+Ezktx2B8KceFvkJU2/NRZTuNqud5YSpteVH5xjkhf35601wO8mndPGOaYGKr1zOBHUrV42xonuVAu0s0EmysfJiB43Qe7tn5xi2/pHJafsT5pydhutsi0Qoz8Slv2ZBvjpsJzTcjt/4IFJfkuP/CbYspnt6wHxVPsqD+KwumO814s+TF60WJBS98EmOMeQ9Ggx4aS7BcmOPhDeMRyK1SI+vcUarevRpzB5It36H8wS9QPs4QMFqb4Vv0kKAnHMfmeYkNQgE3PIR3Yx6UCPAY8Y/gWF5uSLzzs2cg0bQXJV1JUD5Ko16J6K03SZgnYR7jC0zULTAaimFxFzxzLkGMF8Zu8JS7CdcMB6e7F6dURrb1XJedT4l6C5LM36Kw42eqPgXlD1OkmAp9W6MgHBJPKa4kNCTshtzQLlCka4NM04psVSPSSupxvKAWR3NMOJSlAzfjgsPdh7HJGcjOXRZ6f8/GfR0hnll3AHnWIyjrTkLZg+QI9G03Iqpmwt6gi6p2iVUHOKqUg3tWggRZdDGocgffB+61D/7ACvI1V6INnG3Nhsx6VBR8lILzzzKh6cmSOAHDnSb46BD6ljwYZyyIsIMW6reHIZ0B16yLqubATY+gf3QAg14O/rkVTM6tRhvQ3auGrI3Eu5NR7TgF03BhFOaOVkysjOPNe5HUkipCC9/yKEqM7QJnLloh097CrxVNSC9pQCK14MgpIw5kVOPtzHtMzK6QiVUUaOsiDZzQHcaJqh+QqT4UE01dAzjfMDEkMDw+hKExkcHRV1QhRe+rMAMexiD6Cd+7xXD1k58zwH6Q3O9xGdlkLBqsNswurAnMSEzPr2I6uIop6utUIBRFmKB/jqpmUPV+STyWgQRmgk3E4nqHHYHldcwtfSATH5AuNxEGTJMRheEPgWJdOwo0bThZ0YqMkhtILqzHsdxLOJxtJFNrAhOCgfrPvwVbXdfbexFc/ojA0kcysU4m1qVdWMO7ICEJTNJOMKZIyC8xMbsq9J+J78KAPbaB+S8bCO/A7A4NXG1nLfgotmCRxBnUiun5D8IOTIUIGZlbE8WJt6x6En5DkbEzA3dfQG25LXyYUbhLtm0gnjdlW9BabM3tGPjim7Id4vrH9J+5/gYMGUwOV4OuOAAAAABJRU5ErkJggg=="

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA/klEQVQ4jcWSu0rEUBCGvxEfYbEV1kKwshZsBEFJbZdSUCGCeQBrywgJGLDcMpVFmq19ArET3H4L2SbmTAIZCxXc3eMFL/h3Zy7f/MwZ+G/Je4k4jpeADeABuE6SpPsyIIqiLRG5AsZAD7gxs+0sy9xs7YIPoKoXqnqWpulK27bLqtpT1X1f7RwgDMO+qvabpjkHyPN84py7dM7t+gCLswHn3JqI3BdF8fgaq+v61syOfYCpHQRBsC4iB8COmZ2+Sa2KyImZHQHDsizHXgej0WgPOHx5DjwDB8Amz8udB1RV5XP5oaYAXef96r8FeO/g2w7M7A4YftIz+enQ39UTrjBiph1IvW4AAAAASUVORK5CYII="

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAu0lEQVQ4jcXSMWpCQRDG8R9GRFJYiUgKIcHSA6TxFmLtAcQT5AI5S0qxSJXaE1h5AhHTPkW0kAV57uq+yg+mmZnvvzO7y7P1cqfWRA/v2OJYBdzBEjsc8IdxFcAEp1LMY421BOA1kmtUAQwjuT66uYC3SK6NVqL/Rh8uNx/2P2KUaw4aXwEWEtOmVijX/nNP7WKGH5c/ECYo8IsvDFLmT2zcvn85CkxjgO8Mc4hVMNWvAHOsM1fdZ/Y91hme0DMm6lP25QAAAABJRU5ErkJggg=="

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEVQTFRFOHbHOHbHOHbHPnvKPnzKR4PPSIPOSIPPSITPUozUUo3UXZXYXZbYXpXZXpbYZp3dZ57dbaPgeKPahq/hh6/hlLvn////hW2cDgAAAAJ0Uk5TAGbSQglVAAAAN0lEQVQIHQXBiQGAIAwEwT2iQUWB+KT/Up0BRYRAY3xzirNf2XpjfzLzPfBtTfeKzG5bBCqliB87IwHNkQ+ziwAAAABJRU5ErkJggg=="

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAENJREFUeNpiYMAE/UD8H4rr0SXnQyXuIynCkIwHYn4kRRiSDFD6P9Q6nJLzYbpBnPdQB2FIMiA55j02SWQFWCUBAgwA8GAf5/4iTMwAAAAASUVORK5CYII="

/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHCAYAAAArkDztAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEJJREFUeNpiYMAE54GYnwFK7Afi/0h4PgNUEKTKH4jtkXX8hwrCAD+MgS4BYv9nhBolAMQNUAkQ/QGb5SA2P0CAAQDQwBKWLht5PwAAAABJRU5ErkJggg=="

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAMsSURBVHjaYmRAA2kMDPKCwsIFSrq6BiIqKgZcTEwMj65cuXDv2rUL7z98mDCLgeEhsnqAAEJBleLi9XvKy/9/vXbt//8PH/7/f/fu//83b/7/f/36/9eTJ//vSUn5XykgUI+sByCAmGGMFnX1+SlTphQYeHoysP79y8Dw4QMDw/v3DAxv3zIwvHnDwPr7N4OSjg6DmoqKA8vx4wrHfv3aCNIHEEBgAyolJOpTursLZBUVGRg+foRgkOZ378CaGV6/ZmB48YKB4flzBj6g4SqSkgYc584xHGVgOAgQQMxAP/N7REauMNbW5mD48oXhwqFDDC8EBBiu7tjBoMQMNP/VK4a9QMW/LS2Byg8ycN25w8B+/jzD11evDIB2zwEIIBYgkWBnaCjAcOwYAwMbGwOntTWDupsbwzcHB4a9WVkMDEAbLWfOZOACGnrs5k0Gi6Iihj///jFoMDAICDIwxAAEEIumvr4DF9AWsLMZGRm4tm1j+GZmBtZgOW0aOHxA7McXLjBwtbYy/AVq/gMU4wFiaQYGZ4AAYuLi4BBgePkSHmiyQL++BdryDcgHaYRpfuvtzaAPFANpBuHfQPyfgUEKIICYGIAmMnz+DDEAim+BDEQCwgoKDG8lJRn+AmPiJ5D/C2EAA0AAMb1+9eoBw8+fkFAHat77/z+D5dKlcJthLrHcs4fhqL4+ww+gJhAGGQS09g5AADE9evjwwONfv+C2cwKdCne2jw/DWw8PuCFMAQFwA15A8BGAAAI7cbm19f3/6ur//0tK/n8kJPT/aFHR//Pi4v//sbP//8PI+P+Ovv7/Hfn5/08AXX0ViE8BcTMDw1NQWAIEECz9+x+Vlf3/n4Pj/3+gpn8sLGCNQJv+A+PmPzBE/j8A4mtAfBqIFwBxEANDEkgvQACBU+JZBoabPz59eiv254+XGDDefwEDFuTMb0D8HUqD8FcgBhrCsImBoWwdA8MMUDgCBBA8L1xmYDgFVHzqMQODHZDLz4Wm+SYQH2ZgeLaXgSEFaMA8IPcvSB9AADFiyZRsAQwMZsCEEiDEwKAGiipgdroLzA3bdzMwAJMrwxdkxQABBgDVplUNe0+hFAAAAABJRU5ErkJggg=="

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAMFSURBVHjaYvz//z8DJQAgAINxcAQgCANA8MgQlRkefrUDLZM6LBQSAd3XxlxOZofYNtQTWhMWOqYVxHjVsdWY0gj/x+Iw7NqP/KByfwKIiSTrQI79/TtBXVlqV6S1hZUAK98/gAAi2gCgV0X/MTHMdrfQm1/r6Shz8drzfw/uvEoECCCW/wz/FYHB8A2o5iUOnQz//vwz4xbjnJ/soqUVoKHM0LH7PMOx0w8yGbmZNgEEEIuQCO/VX7//3fz8+I8PGwPDUxS9//6z/vj7J1VOTbCnwseY00ZcgKF853mGXQcf1DOxs8xiYPzHABBATHzM3J99HBQNuAXZVv7+808IrJMRGE5//2v85WBY5uaoNHVqmAenlbgkQ+Oeawy79j7vZ/vP0sTABIk9gABienbn+0wJBjGG7EAra0YuhnX//jEw/vn9z5VXnGVXarBBSIOrO4M4Dw9D78FLDNu2v1zF/pu5nAEp5AACAEEAvv8DBjAZ5u70+2RxSUoEBw3+H8fX4mUiKg1hdlc6FEoiMwD4/vMAn8nQAK6t6bgA+v1dAAf89/wE+gD9BvkA/wf8AAIAQQC+/wMQMCHw7e73HRUcCDNXMDwBCBn3DlM2LgUqDyMA7vzpALHU0wCxquzRAfIBWQUFAuwD/QQABf0GAAb7CQAG+QoAAgBBAL7/AxAvIv/99AX78gHvWy8nFwEwFiQAA/8DAO/96gC/3dYArqXx4P/tAU0GBwHgBfwGAAb8CAAI+QwACPYPAAn0EAACiFlIQ5uB9Q/H4y+f/1nxq35V4mFnYfj0/xXD6Sf3GLYu/f7m91OWACaO31f+M/+DeJoRGPEgzPQPjAECiInjFzsD5z+2n4zP+LaePv2e4TnjHYaLr+4z7Fz668uv21wxzMwMp/ElMIAAYmL+y84Awhz/2Be9PsP98MTt5wxHVzH/+n5ZIBuoeSehFAoQQMwSakbAKGVmYGJk/M70jUPszW0eix/XeesYmP9M+8/2h+Ef82+G/yzADAT2AiOGAQABxEhpdgYIMABQrSEzlY7wIwAAAABJRU5ErkJggg=="

/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJbSURBVHjaYvz//z8DJQAggFhABCMjI6YMNxsDg6EiA8NvoJI/rAwMP4GY7X82m+z3ll+POFoZ/jP2/D9/mgEggJiwGssH1GwijeD/A1rA9C/VMfp5n3bhEwEGu1edDP8ZYkBSAAHEgqFZAGiThTgDwy+gpr9QzSx/851TnkwwcH7N8P+PNgNjECvT+SdfJwFllwAEEKoLxIGa7YQh7P8QzYzsf8vd0h5O0ANq5vmrzhCjWMzgxqbCwPzsyx2QMoAAQhggCXSMHR+qZo7fDbbxjzu0bD4yCPzTYPBVKGfYfm0Pw5T8o3v+HH/uCVIKEEBQLwCd6cANDKj/CM2cvzt0/V+Xq5p+ZxBl0GDwUChj2HJpO0Nb9r5tP8++Dwcq+gLSCRBAEANMgTb/hUbnPyDm+j1B2uVdvrTOTwYFNk0GL/kShrXnNjJ05u5f9/v8Z2Dg/f8OczhAAEEMUAca9gvogv/A+OT8PZ3L6lO6oNJvBh0eHQZfxQKGFafWMHTnHVz29+L3BKCi38jBBhBADOCEFAVkhQFdEcU9i6Gb+b/gcob/SUf1/5/9Oud/yT7n/4y67HOAKpjRIwykFyCAEAaE85iINQn9Z5jH8N9/j9H/ox/n/M/fbfufQYt5Mq5UCNILEEBwA5TyZefuOtH+33On3f9Nr6f9T9xi8R8Ydt34kjFIL0AAQYgYBgWPGueP/789+L/91rL/JhM1QJobCeUDkF6AAIIQacwzWf0U/1vmWd8QtBbqZ+BmsCYmI4H0AgQQhLBm7GCQZggEivHAZRmJMwAggBgpzc4AAQYABEbgQL928iEAAAAASUVORK5CYII="

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAOzSURBVHjaYuzrW8wAA79//2HQ1VU7r6+vpv///7//DP8ZGBiZGBiYmJgZ/v1jYMzNzd2ybt1yPwYkABBALJ8+fWb4/x/C+fHjBwMbG5OAlJQII5ALwgxAYxj+AvH/v3+AAn9VGdAAQACxnDy5nUFcXI5BSEiK4e9fBobv37//hUn+/POX4dfvfwx/gAawMv4DuuLvb5A4KysLAzMzC9DFvxkAAojp69cPDC9f3mW4cGEPw/Pn9xl+/vz5B+wdoLUgzRD6P9Dw/ww/f/36zc7OxqCjo80gKioKNPAfA0AAMUH895/h69cvDDdvnjT9/v2jGMyAP0Dx30BX/P75E+jN/wycnBwSPLw8qqDA+fXrF9iVAAHEAsTiwsLCkywtrW0FBARFRIWFWT9//c3w9ddfhh+/fjP8AeK/QMV/vzMwBPoHSllb21x+9uTJs+07t619+fJlNUAAsSgoKM4tK6vyVlZWYXj16iXDmRuPGa69/MHADIqC/0D/A0Pkz182hl9ffzHwSyoyODt7sH9nZFC0sLYvyc5K5gAIIBZTUxMrVVUVhu/fvjJ8BMbIV2FphmdsvAxvv/5jePuTgeELMET+/GNk+ArEUv+/MMi9fMLwnOEvg66eAYO+noE/QACxiItLcLMAPcL87zfDmx8MDBse8zBcucLA8OATE1AZJH4ZgREK9AmDITsvQ4gCM4O5kBDDfyYWBnFJSR6AAGJ5/vwj0/XrjxlE+ZgZvjEIMpy5ysvw+gsw8QA1Mf4HJwVglDEwcP0DRp+AEMNPZiaGb9++MLx6+5vh548/jAABxPL9+7e/z569Z3n08DvDl68/GEqkgTHAxAr0NzPQ6ZDkxAo0gIXxNwMP02+Gu1eZGTjYuYCGsgKj/Mc/gABi+f//9zcZGQn2CxfPMCycP5lBQ0UeqICNAZR2IWkRkhqZgc64/Potw/ffTAx5eZUMHBycwKj//AsggFju37/zSFZWTPD/fw2GqOg4BltbG2DaZwLG/29w+vj39x+YZgIa8O7tG4Zbt24zaGkpMzx79ozh8eMHrwECiPnNm9ef/v797fHnzz9WR0c3RmlpMaDpXAxcnDxgzMnJDcRcDCws7MAkLwl0DxPDqVPH/i9duujnvn17JwEEEFAxO8iVqgkJmUf/owGgzf9///7//8ePf/+/fPkNFrt8+fp/QUHhHUA9ViDTAAKIBZQhdHWNb6upaZ/q6urVBoqB1AGT7j9wWgflAWAmArOBKQuUgZiB/r8P5BwD2QwQYACMMqi1XtDgUAAAAABJRU5ErkJggg=="

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJWSURBVHjaYmYgADyNjef7WmtO4OEUOnDv+fOX6PIAAcRMyAAtKamCBUvaDBgYeCK+vP34AmjIRWR5gADCa4CDsbE/BwNDRESEo4C+rTuHuqJ4wNfnTxT4hCUPPH7+/CdIDUAAMWLT6GJsHO9opjDB1cVGwNTaiIGBkQmKmRleP3/G0N0x98LRmy8Sjp09exEggDAMiLQzmJ+fYJ1gbqnDwMDEAsRARzJCaSj/67ffDIvmb/+wYuelYIAAQvFCpL1+f1uKbIaOmhADw68PDAy/PwJpIP7zCcj+DKQ/g8XY2D4ziKrzcVy8+EwIIIBYYJodjY3to43eFCiwARW/fMrAwMrDwMDCzsDAzAbEIBqoFOReKWmG/VeZGCb2H128cf/JQoAAghugxP9rgbc+0NY/QMXSygwMigYM115wM1w7+5whRO0RA8NfBoav8oYM85Y+/DxvyZnyC7duLQBq+w4QQGDNVkDb95VK/P+/gP///zvp/zctzfkfZG+2SU9TM8nbyOjS/xNB/189bPtfEOt+Q1VR0RM59gACCIy8jI37v0zj+v//dsr/KU1Rn3SVlWOAwmwgOT9j4/0n9lf+DwAaKCUurowe6AABBEZNQSrn/+8y+b90Ztp/DTk5f2QbgFGqb6aungZkcmLTCxBAYDQzXvb/q5uV/+20tacSkzqRAUAAsQD9L88nxcywYuXDz7devZrIAA4u4gFAAAGTF4OCsqUBw4G9dw68eP36LgOJACCAQAYwPHzOwPDgxcctpNoOAgABBDLgwfLll06++PBhLwMZACDAAGyQxmsDWqtQAAAAAElFTkSuQmCC"

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAOnSURBVHjaYvz//z8DYzYjAxz8B7L/MTEw/GUGYiaQCC8jA9P8/19/LWBg4N7C8IeTgeEPE0TpxqcMAAHExIAOgAYy/P0LVPQLiH8zMHz58ddOycq01L96M+t/5iaG3z+ZkZUDBBALiubfDMLMTKxREgLSNvysgjz//zL/+/b9B4uOpJFIQ1Qug66CRm3uxGq1j18+pzCwsH4BaQEIIEa4F34x2JgrWSzId8tRFpXjZvjJ9JUBJAcCbEwcDA+YLjLwc/IxsF/WYojrLJv3+fPH5P87njAABBAL1GYlVw23ZTURpbJHGDYyfP4vxsD5h4fhPwPEAOa/LAw3Pt1m4ORkZ/Dmt2bgYeGT/PznE1gOIIDABnBxcOfE2kXLznrRz+DGGcBw9eyTX7eenXvLzMD67+ev30y2ylZiCW5FzJdu32VInFF9/vmLR9kMbBxgAwACCGyAgYSRpwAfH4P1b3eG44evf5+xtT+IgZV1J8MfFjaGr3/4v33+dJqbnVuuadmENa/ePU9jYON6D44lIAAIIHAYyBQr3XdUcpRk+svCsv3SrsOvv7xyYWBj4GX4zf6R4QsXNxsz58G/P36u+fvv5xSGn3/YGP4wczCw8Pz5f/DeS4AAggRiApsYw/ffrAz/mX4xMLJ8Z2FlSmJh58348f2XNcNXnvcMP5kFGf7/fi/EL7Ax3DrYh5mF9ffOE0df3Fq8UwEggCCByMT8ioGTFRiY33mEeISn9Mb0xO84tf39yh1LOBlYGL4BbfzA8PWnfbBbol1mvgsT+z9u9nv3Xv0CaQUIIGg6AEbj3x+SCmLqqyektlsbaWoyfP/8h//XD7YzHCyc//7+YWBUFlcQcvBQ59jwZhGD9YcohuMXL+4H6QQIIIgX4tgZBLlFV6zOWxS+k20xw8svrxjM+GyBLgNF5D+g8UzAdPGF4c2/5wzubJEME7q3vd6wb7vT/ws3rgAEEMQFf1kZvn///eLB0ycMzOJcDP+/sTCwMXMz/Pj7A549BBjkGPie6jDUrF725MjZ40kMHJxXQHIAAQRxQaQQ0JDf7NyMvFNL/AuSA6ydGRZv2PF79bEd+7hYeH4z/mNm+vLl57cXb14d//Pj11JgGngJNvjkeQaAAELkBWbWn19/fk9tWdp/++HjV233nj74+vjprXAGFs6PwPQAtACkFBjQ7OwM0AQKBgABhHABCIAU/gDibwxOjIzcBf//McUDA+A9OFuDszcQ/2OE+AnqAoAAAwCqtWnPz1QoaQAAAABJRU5ErkJggg=="

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAK/SURBVHjaYvz//z8DJQAggFhARElJMQMLCyuDsJCgp7y8QpmgsIgZIyMDy6ePH2+8f/dm2tdvP2bevHmTYdq0aQyenp4Me/fuZfj16xcDyHKAAAIbAGKIi4nk6hhZ9kooqLHKiPAyMDExMjx9+1Xvyf27M17cv2r66dOndKDSv1ZWVgyMQNN37doFdgFAAIEN4OXhdlXVM5/IoWDOyCXEwvAPKAryGBc/OwOvihDDbyb25D/bt90ACvUAAQMbGxsDMzMz2ACAAGICEbJy8jU/BTUZfzCyMLz/wsDwEorffmVg+P6HgeGnoBaDubVjARsrK8/Hjx8ZXr9+zfDz50+wAQABBDaAW0DM+P0/PoaP34GagPg1UOOrrxD2h28MDO//sDAISKlIi4oIqbGjBSJAALFAqP9MrEAXvQNq+PaLgYEd4jqGX38ZGH4AXcDKysDAzASOLfa5QCIFiH9ADQAIILALPr99cVGc7QuDABcDw+9/DAyffkLwLyCbl5OBQYrrL8Pbx7feP33z7p4UUH0XEHNADQAIILAB27Zu7fj99CKDHB8Dg5IIMEwEGBhkgFhRGIL/v7jMsGXjhnnWv3+//A1ULwrEVVADAAIIbMCGTZs3Tp/Q0frxxlEGQcavDNL8QAOAWJjlB8PbaycZvnx+xeBrbagzU5jJDeQRoK8YBKAGAAQQIygNgOIVBLS1NOO8fXzzVNQ1NZiYmVkeP7j3bMf2bQtCRXiVIhvd43nfbfl7NvlC9KPHn1a+A6ovAOoFCCAGLEmZmZ2NVZmTg10LZlEoE4PSjTiW5/9PmP3/fMzv91pZ3vA+aAIECCAGYvOCEgOD4ZUQ9mf/j5v+/3DE5/c8dcEEkF6AAGIgJTPJMjLonw5ie/j/qOn/Nbla90B6AQKIgdTcKMfEYNRmyLZdnYc5AqQXIIAYKc3OAAEGABLI/zfRn+acAAAAAElFTkSuQmCC"

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAACzSURBVCjPY/jPgB8yEKmg0aHxf93/6jPlR4vP5P/I+p9yFMOEuvP7/pedKerJ7cmYnNwTOx9DQaVB9/8J/3McILyw/VjcUFA//3/a/QQBPI5MOT/7f2QBHgWxCRHvg2bhVBAjEHY/8DaecAhd73/GswfCNvmPoSA4we+8x2kQywLoTP33aAqCDHzeu79xrLepN+83uq/3Xwvdm94Jrvsd9lvtN91vuF93v+Z+tX5S44ICBQA4egHkwuNCKQAAAABJRU5ErkJggg=="

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAolJREFUeNp8U81PE1EQn7df3XZbQE2tlAQaKJWiiegBJH6EoyboSePJk4me/Dh68Wb8B0zUE4kXLiYSSRo5oDbQkBATCrVGcbVAAwixlO2H7e727a6zYCvoxkl+mdl58/vNm7fvEcuywLbYHXbHE4IAOIHhSVw5hMsEfR59khqQNHbL4cpTY8dzsN+QCxe9bT2nwxdu9UsdoYCmrlvF5UxuafJlpLi21I7r4wirTmDqgYkp7HLK29Z7ZuDuyPXm8LEIENOt6t95vWm1s+/m/Wvetu5zhgn9NeNPx30CuL2ByKXbg4ZZYUxTrxHCAcuKQKlCt5VZODp8ox/HOI8iDWuMQHeTgeaO7nZKSypqW5QWTE3bBNOsERQ0WkJdQewetMBJYHdbrKbljJ+VL5QQZodcLn/lWFZgeL6FgMVSFOD+J7CxOj+9JIXYaLm8WLU7M4yLcbmCRJI6hbWF5IpukHXLcjgDewTEm9TYqCyJxzVB8POi2MpKUhcjSWFWYDu0xOiTrEYhpjsdom2o/KmsKFMzI89mA4Fht88XZTyeEOPz9bomHj9aUPL5t1iT2stpCBRVAiWNAHYYW/6QzGbn0t8E4TDPcV5Onn2/nEnNZXUKo9UaQEV3EFBrDVDc4sTH6cl1JNsCfHpqcgNzr/AA7UMEx3vwOm1BFZVtqDqkMul5kRCW4F0gmfSCG0nzdfLzGfPfv/Dus4kAuHo2AH6/vzC9SGJ9CfdlWZbh4bi2MthpKXZdQjb33f2/3wK8SGzC0FAUoy2IRntA1wVwIjr9BTsWEQfi8fgRO5HL5aBQ+FFfb0UcRHj28kj9OeOw9nv2/S5qwm8v+geIINbcQ59HlBDbiALmqM37JcAABIc4sUmmya4AAAAASUVORK5CYII="

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJVSURBVHjaYmTAAqyMjeXtWFk3fPz48dn069e9GfAAgABiQhdwVVOzD1NSulC7bZuBBCenOAMBABBAKMhLXr5+W3Pz//9v3/7//+bN/0YdnaceSkrxQBfx49IDEEAwJ/PnGhntf7Rq1f//N278/3/t2v//V678/3/x4v9Hy5b9nxUZ+R5kODa9AAHECLRB31pW9kBRVZUAFy8vA8OfPwwMf/9i0I+vXGGoWrjwwD1e3oBjZ89+hBkAEEBMLL9/OwTHxgpwgXgvXzIwvH4NoV+8YGB49gyCHz9mkOXmZuj383NQevlyGbILAAKI+danTyfvnzv3mY2V1V1bTo6B4eZNBoa3bxkY3r2DGPbqFcTAJ08YuIC09p8/qjc4OT/fe//+OMgAgABiBhG3P306/vr58+0PHz0KNfPy4mAFafjwgeEwUO69uDgDn64uA+vv3wwMjx4xiLCyMnz59Mnqmbj4rBevX38HCCBmmFMefPz49AM7+5ybJ09a6rq4yPNzcTHMW7fuZtfp04k7V6/+/ltCwsggJISB4epVBomfP9m3f/jwGKjnFEAAYY0VD3n5pm2Vlf8b/f3PwMTM9PWNay0tL32dM+f/f1vb/1lSUntA4gABhBPZKSm52UhIJKGn0Al+fu//t7T8n6Ko+B8oxAkQQAykAlDCujZ58v+d2tr/dTU0bAACiJlUA+68f39R6v//BEt1dYF1z56tBwggJgYywPGrVye8FRNjYP32TQwggMgy4J2Y2IHTFy4wCH//rgUQQMzkGPD4+fOXApycZo9//94GEGAA2rH5UKps700AAAAASUVORK5CYII="

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIaSURBVDjLY/j//z8DLqyaNVPLrnr5PMnESay41DDgM8Cuellm+7rTT0RiJ3Aii4snTGIiygDnupV5c/dc/QF0AT9MTCl9hq5P67qtRBng3ri6ZN2Je/9lU6bKgfgSCZPVJ2+7+CR9+u5tRBng07K2+sCVZ//lUqepCMX0y87cefnO9B2XH4rGTZQgyoCA9vUt5+69/a+QNj25f/O504evPf+jkDbNmuhADOna1Hn50cf/fZvPf7vz8ut/87JFOUTFAq9tHDiUI/u3dd8Fatxy9tH/xCk7FxCMRiGXNCmjzLmrneo2XtLJmLckffqesxcefPgfP3HbUcHgRha8Bgg5p0kANd5OWHXnf8i8C59TN7/6P3PXjf8PX//4H965bg+vZbgjXgOMsuasiVt67a+Ub4GdhHeef8LaJ/9n773zf+nZ9//Tt7//H7vsxn9Zz7QUnAZ4de375Fi3Ahy/RnnTpqdteP6/ZNGpf+kbn/7XjZty0Ld3x2XrgvVfuA08ObAa4NK09XnUkmsvHJvWHU3b9ua/Wd7yG+Y5a14HTj3yGSSvHlZW5lCx/b+QRZA0VgPkgsvDAqcffxO17MY/s5xlp7lMAyVMM1Y8DF9w8RenlqOcWVbfHPvSLX94jX0FcMaCiGu6hJhHlgKMrx83/1jypuf//Sftf5q0+u5/o6RFN0jKjTyGXuyGiQuu25dt+26SuuQBj5G3CLoaAMk4ntedg7qJAAAAAElFTkSuQmCC"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAEuSURBVDjLpZM9SgRBFIRr/EHXwGVFAxUPYmTgMTyEoblX2NwjGG9i5B0EMTIQFWTBaHTeqyqDHmdX0FlhHzSvO6n+qvp1ZRvL1AqWrLX5w93VuSXBJkhCKovMrpOJk4vr6lcBidg7PgVMWIYkWATEbv9wc/03AZkwiY/3J7i93STcEmxu7yOz6ReQCDFhFTExIRJWgox+gcwot2UUAmY5kzADzkBEL0Er0PUZReUGIhcRNAU5muI/E1JiZzjF4cEbHp+HyIx+C2otdPgqfTodoP5c/w9BgNn8sPD6sgFzFVu76ieIaGYhMtrwWiGVPRkLCLJkYJX0vyms8rQLMigWBqMj2IKZsFSWCbGM83xVtjGZTFzXNeL2spv3+fmf/QnCJu5HZwCA8XhcVct+5y9H3H2zjxE/HwAAAABJRU5ErkJggg=="

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAAB90RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgOLVo0ngAAAExSURBVDiNvZM9SgRBEIW/6p7AYNhE0ETFAxgIop5AzTyCIBjueBGDRScTwWMIXmARE4+wKCYbmaizTPc8g/1xZ13dRcEHTdNF16v3qrtMEma2AiwDnp/RBR4lVaOIJICtoiheyrKMIQRNW0VRKM/zc2AdcJKQhA0U7JRl2e71es7MRuQhBBqNBvvXn7HD1/wiy7LWw9Vex4pnEhtkmJnz3uOco6r6Cp1zXzw0m81TgM2TrNU+O+jUbgwThnuaplMbMSBZShfXSCYJhhamVZ/ExvElBhiwHUK4A/De1zzPQq2M97NecQbBb1Cz8J2CcUu3xyLGSJIku8D9nxX8P0EIoXYe/wei348aYozcHIXJcAUgSYkkmVkVY3wHFuZQVcUY34AIjIZplf44z2spAl1JTx9MRpCdM880HAAAAABJRU5ErkJggg=="

/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAADHSURBVCjPdZFNbsIwFAa/5B5FuQPCOQ9HQuqCq3SHUAtrrgFCSKQk8Y80XTjYJqiajRfj55GftNBKJtGoRiXSytlAZORzM1ckExjouHEm0LPdqHkTRnruXAgEPGpVq1JVCJ6RB3dOfHFEa7W5RzLx3kjPDse8ZxKisue9JwkByzevPQGZQnD8kHuunEvB43EcyD0dt/kEzzGdLD2/k9Ckb261zs9ZhiggVRO12jzN4Z5C+tQq90T+ETK20/J1tU2xeCOjpT7+APfbTaDnTb/mAAAAAElFTkSuQmCC"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAGqSURBVDjLlZM7S0JhGMfVox+gqYZuQkMETYZNQmi2+QGKligiCBoalFragoqGzDM41NRQQy4VKDhUSyC0NLR1EeKIt7wePV7/vc/BI97NF36cA+f9/97neQ6vCoCKrVGGgWHswyRDQxkFVU1gkCQpWSqVKuVyGZ1g3+Fyuc5aJYrASOFsNgtRFOukUikkEgmEw2FZEgqFwPN8k4SWmgS0IZ/Po1AoyE8ik8kgmUwiEonIglwuBzrE7XbLkjYBhRVIQIF0Oo1oNNrWUm0m6iYBa6O+gd6pb6WVWCwmVyIIQndBK40SqoTmEY/H/y9olFA7NBMSDSQgisWiPBeSEAMLqIrvWyde1mbgt+jwtDIBfl7D9xRQSCHoOceb3YT8wymq716I17sIbM9WfGbtTl8Blf+8OoUcC8NpAxxDwKEe0eMF+Ba5z75/gaCyq68eNK7EwQj8Zm21UVDtNoPH5XFkL9YBFpLsKvwyglscfFbuR7kLc2zKItvc8TJ93ZwgsDkNwaFHZE+Hjw01/DZtxWvl9hXBGEl6XeXLpWH+zsIJVPa9hQtfmbgjyv4BPlWugike25IAAAAASUVORK5CYII="

/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAH8SURBVDjLjZPfS1NhGMdXf0VEQhDUhdCN4X0IYT8ghIJQM0KoC4vushZddLELKyRhQQkSFIKEGEkUCI2oxVhepG5zi1xbc0u3cDs7Z+ec/ezT+x62scmmHvhwDrzP93Pe57znsQE2cR0SdAm6d+GwYL/M1LBVBV35fF4plUqVcrlMK8Q6TqdzYrukJuiW4Vwuh67rdbLZLJlMhmQyaUnigVlC05f4+dbB0tQplp92DsnwPimQBaZpUigUrLtE0zQURSGVSqHF37DhGkVZeQdagszKLJ7HvZtNAhmuIQWGYaCqKps/ZkivPqCwPs/Gp0cYvjnKUTe+F9fMJoFoo96zfJZ9K+sLpP33qRhujPANtr7dJPhqmO/PBxX3+PljTYLtqImPpH13qZge9LUrmLEB1FU7sZd9jJw5MljNthYk/KLnxdFqeAjzdz9Z/z3Ck2fRE36qx9pakAjME1y4Lbb9GTMyTD52GUXsZO3ZadTkL6umrSD4ZZrAezvLH54Q915EjwywtXSH8FQf+t+I9V12FLwe6wE1SmjyAi77Qb6Kt3rGe9H+hKzwrgLH9eMUPE4K3gm8jpPMjRwlHfNTLBbr7Cjo7znA2NVOXA/PsThzi2wyah1pI+0E/9rNQQsqMtM4CyfE36fLhb2ERa0mB7BR0CElexjnGnL0O2T2PyFunSz8jchwAAAAAElFTkSuQmCC"

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAH+SURBVDjLdZI7aFRREIa/k3u5cclGwiXEF9GInSCIoF0qa1/BynJdyBYhtaRJSrsFK4XtBCGFQRALm4BYKQg2ti5JQEh2hay66ObMmbG49+4jSwYOc4rzfzP/nHFmBsCL6uWrwDfGo7PcaM5wQrjnjxduABvAnXJ6hkdr63TbnwGYmr3Fy/Un/O3+AngFbC03mq+HATGwdfv+g4ul8jT++1fMjNDrAmBmLF6bZ+LcFczs4fs3b+8CY4BLpfJpjn4fICo0N+tgBhht+4Ka4ff3ODV7ITFInHPOCt85ADRgIkzMnEWDYKb8aHf52fmHAbp/iNsTdlo9gJvOuQNg18w0BjBVVAT1PdT3wIxW65B7a++I4qTf7hKwIfKp0Wg8W1lZqTvndnOAoMFjprn37ERxgvceEUFE8N6TpimVSmU1jmNqtVp9IgMEVDwmHg0BDYppBnPOEUURURThnAMgSRKq1eoqMBcXAMRjQTFRVA2VDBBFUT9PTk7S6XQIIZCm6WCIpllVFUUlYGpYCCMdFHfnHCIy8o3ZEH3ARDEJqIKKDbYthxQWitwHZNUzgOYWig6GIcdBgz0IhnrNZ1BY0PG9z4WFpQLw0R8dLU6dn8+EqphCybf6j4YWb6R6AXj6YXt7GrjeFwA7rR5LJ4gAQgh/gOCG6cfaXQDmODkCcPAfs2Qwc59hLO4AAAAASUVORK5CYII="

/***/ }),
/* 129 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })
/******/ ]);